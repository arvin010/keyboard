; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\segger_rtt_printf.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\segger_rtt_printf.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\FTLib\CMSIS\inc -I..\FTLib\Inc -I..\FTLib\Lib -I..\usb\inc -I..\user -I..\RTT -I.\RTE\_Keyboard -IC:\Users\Reidgjiao\AppData\Local\Arm\Packs\FMD\FT32F0xx_DFP\1.0.6\Drivers\CMSIS\FT32F0xx\Include -IC:\Keil_v5-MDK\ARM\CMSIS\Include -D__UVISION_VERSION=529 -DFT32F072x8 -DFT32F072x8 --omf_browse=.\objects\segger_rtt_printf.crf ..\RTT\SEGGER_RTT_printf.c]
                          THUMB

                          AREA ||i.SEGGER_RTT_printf||, CODE, READONLY, ALIGN=1

                  SEGGER_RTT_printf PROC
;;;495    */
;;;496    int SEGGER_RTT_printf(unsigned BufferIndex, const char * sFormat, ...) {
000000  b40f              PUSH     {r0-r3}
000002  b538              PUSH     {r3-r5,lr}
000004  4604              MOV      r4,r0
;;;497      int r;
;;;498      va_list ParamList;
;;;499    
;;;500      va_start(ParamList, sFormat);
000006  a806              ADD      r0,sp,#0x18
000008  9000              STR      r0,[sp,#0]
;;;501      r = SEGGER_RTT_vprintf(BufferIndex, sFormat, &ParamList);
00000a  466a              MOV      r2,sp
00000c  4620              MOV      r0,r4
00000e  9905              LDR      r1,[sp,#0x14]
000010  f7fffffe          BL       SEGGER_RTT_vprintf
000014  4605              MOV      r5,r0
;;;502      va_end(ParamList);
000016  2000              MOVS     r0,#0
000018  9000              STR      r0,[sp,#0]
;;;503      return r;
00001a  4628              MOV      r0,r5
;;;504    }
00001c  bc38              POP      {r3-r5}
00001e  bc08              POP      {r3}
000020  b004              ADD      sp,sp,#0x10
000022  4718              BX       r3
;;;505    /*************************** End of file ****************************/
                          ENDP


                          AREA ||i.SEGGER_RTT_vprintf||, CODE, READONLY, ALIGN=1

                  SEGGER_RTT_vprintf PROC
;;;321    */
;;;322    int SEGGER_RTT_vprintf(unsigned BufferIndex, const char * sFormat, va_list * pParamList) {
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
000002  b09a              SUB      sp,sp,#0x68
000004  460d              MOV      r5,r1
000006  4614              MOV      r4,r2
;;;323      char c;
;;;324      SEGGER_RTT_PRINTF_DESC BufferDesc;
;;;325      int v;
;;;326      unsigned NumDigits;
;;;327      unsigned FormatFlags;
;;;328      unsigned FieldWidth;
;;;329      char acBuffer[SEGGER_RTT_PRINTF_BUFFER_SIZE];
;;;330    
;;;331      BufferDesc.pBuffer        = acBuffer;
000008  a802              ADD      r0,sp,#8
00000a  9015              STR      r0,[sp,#0x54]
;;;332      BufferDesc.BufferSize     = SEGGER_RTT_PRINTF_BUFFER_SIZE;
00000c  2040              MOVS     r0,#0x40
00000e  9016              STR      r0,[sp,#0x58]
;;;333      BufferDesc.Cnt            = 0u;
000010  2000              MOVS     r0,#0
000012  9017              STR      r0,[sp,#0x5c]
;;;334      BufferDesc.RTTBufferIndex = BufferIndex;
000014  981a              LDR      r0,[sp,#0x68]
000016  9019              STR      r0,[sp,#0x64]
;;;335      BufferDesc.ReturnValue    = 0;
000018  2000              MOVS     r0,#0
00001a  9018              STR      r0,[sp,#0x60]
;;;336    
;;;337      do {
00001c  bf00              NOP      
                  |L2.30|
;;;338        c = *sFormat;
00001e  782e              LDRB     r6,[r5,#0]
;;;339        sFormat++;
000020  1c6d              ADDS     r5,r5,#1
;;;340        if (c == 0u) {
000022  2e00              CMP      r6,#0
000024  d100              BNE      |L2.40|
;;;341          break;
000026  e0e4              B        |L2.498|
                  |L2.40|
;;;342        }
;;;343        if (c == '%') {
000028  2e25              CMP      r6,#0x25
00002a  d179              BNE      |L2.288|
;;;344          //
;;;345          // Filter out flags
;;;346          //
;;;347          FormatFlags = 0u;
00002c  2700              MOVS     r7,#0
;;;348          v = 1;
00002e  2001              MOVS     r0,#1
000030  9014              STR      r0,[sp,#0x50]
;;;349          do {
000032  bf00              NOP      
                  |L2.52|
;;;350            c = *sFormat;
000034  782e              LDRB     r6,[r5,#0]
;;;351            switch (c) {
000036  2e23              CMP      r6,#0x23
000038  d012              BEQ      |L2.96|
00003a  2e2b              CMP      r6,#0x2b
00003c  d00c              BEQ      |L2.88|
00003e  2e2d              CMP      r6,#0x2d
000040  d002              BEQ      |L2.72|
000042  2e30              CMP      r6,#0x30
000044  d110              BNE      |L2.104|
000046  e003              B        |L2.80|
                  |L2.72|
;;;352            case '-': FormatFlags |= FORMAT_FLAG_LEFT_JUSTIFY; sFormat++; break;
000048  2001              MOVS     r0,#1
00004a  4307              ORRS     r7,r7,r0
00004c  1c6d              ADDS     r5,r5,#1
00004e  e00e              B        |L2.110|
                  |L2.80|
;;;353            case '0': FormatFlags |= FORMAT_FLAG_PAD_ZERO;     sFormat++; break;
000050  2002              MOVS     r0,#2
000052  4307              ORRS     r7,r7,r0
000054  1c6d              ADDS     r5,r5,#1
000056  e00a              B        |L2.110|
                  |L2.88|
;;;354            case '+': FormatFlags |= FORMAT_FLAG_PRINT_SIGN;   sFormat++; break;
000058  2004              MOVS     r0,#4
00005a  4307              ORRS     r7,r7,r0
00005c  1c6d              ADDS     r5,r5,#1
00005e  e006              B        |L2.110|
                  |L2.96|
;;;355            case '#': FormatFlags |= FORMAT_FLAG_ALTERNATE;    sFormat++; break;
000060  2008              MOVS     r0,#8
000062  4307              ORRS     r7,r7,r0
000064  1c6d              ADDS     r5,r5,#1
000066  e002              B        |L2.110|
                  |L2.104|
;;;356            default:  v = 0; break;
000068  2000              MOVS     r0,#0
00006a  9014              STR      r0,[sp,#0x50]
00006c  bf00              NOP      
                  |L2.110|
00006e  bf00              NOP                            ;352
;;;357            }
;;;358          } while (v);
000070  9814              LDR      r0,[sp,#0x50]
000072  2800              CMP      r0,#0
000074  d1de              BNE      |L2.52|
;;;359          //
;;;360          // filter out field with
;;;361          //
;;;362          FieldWidth = 0u;
000076  9012              STR      r0,[sp,#0x48]
;;;363          do {
000078  bf00              NOP      
                  |L2.122|
;;;364            c = *sFormat;
00007a  782e              LDRB     r6,[r5,#0]
;;;365            if ((c < '0') || (c > '9')) {
00007c  2e30              CMP      r6,#0x30
00007e  db01              BLT      |L2.132|
000080  2e39              CMP      r6,#0x39
000082  dd00              BLE      |L2.134|
                  |L2.132|
;;;366              break;
000084  e008              B        |L2.152|
                  |L2.134|
;;;367            }
;;;368            sFormat++;
000086  1c6d              ADDS     r5,r5,#1
;;;369            FieldWidth = (FieldWidth * 10u) + ((unsigned)c - '0');
000088  210a              MOVS     r1,#0xa
00008a  9812              LDR      r0,[sp,#0x48]
00008c  4348              MULS     r0,r1,r0
00008e  4631              MOV      r1,r6
000090  3930              SUBS     r1,r1,#0x30
000092  1840              ADDS     r0,r0,r1
000094  9012              STR      r0,[sp,#0x48]
;;;370          } while (1);
000096  e7f0              B        |L2.122|
                  |L2.152|
000098  bf00              NOP                            ;366
;;;371    
;;;372          //
;;;373          // Filter out precision (number of digits to display)
;;;374          //
;;;375          NumDigits = 0u;
00009a  2000              MOVS     r0,#0
00009c  9013              STR      r0,[sp,#0x4c]
;;;376          c = *sFormat;
00009e  782e              LDRB     r6,[r5,#0]
;;;377          if (c == '.') {
0000a0  2e2e              CMP      r6,#0x2e
0000a2  d111              BNE      |L2.200|
;;;378            sFormat++;
0000a4  1c6d              ADDS     r5,r5,#1
;;;379            do {
0000a6  bf00              NOP      
                  |L2.168|
;;;380              c = *sFormat;
0000a8  782e              LDRB     r6,[r5,#0]
;;;381              if ((c < '0') || (c > '9')) {
0000aa  2e30              CMP      r6,#0x30
0000ac  db01              BLT      |L2.178|
0000ae  2e39              CMP      r6,#0x39
0000b0  dd00              BLE      |L2.180|
                  |L2.178|
;;;382                break;
0000b2  e008              B        |L2.198|
                  |L2.180|
;;;383              }
;;;384              sFormat++;
0000b4  1c6d              ADDS     r5,r5,#1
;;;385              NumDigits = NumDigits * 10u + ((unsigned)c - '0');
0000b6  210a              MOVS     r1,#0xa
0000b8  9813              LDR      r0,[sp,#0x4c]
0000ba  4348              MULS     r0,r1,r0
0000bc  4631              MOV      r1,r6
0000be  3930              SUBS     r1,r1,#0x30
0000c0  1840              ADDS     r0,r0,r1
0000c2  9013              STR      r0,[sp,#0x4c]
;;;386            } while (1);
0000c4  e7f0              B        |L2.168|
                  |L2.198|
0000c6  bf00              NOP                            ;382
                  |L2.200|
;;;387          }
;;;388          //
;;;389          // Filter out length modifier
;;;390          //
;;;391          c = *sFormat;
0000c8  782e              LDRB     r6,[r5,#0]
;;;392          do {
0000ca  bf00              NOP      
                  |L2.204|
;;;393            if ((c == 'l') || (c == 'h')) {
0000cc  2e6c              CMP      r6,#0x6c
0000ce  d001              BEQ      |L2.212|
0000d0  2e68              CMP      r6,#0x68
0000d2  d102              BNE      |L2.218|
                  |L2.212|
;;;394              sFormat++;
0000d4  1c6d              ADDS     r5,r5,#1
;;;395              c = *sFormat;
0000d6  782e              LDRB     r6,[r5,#0]
0000d8  e000              B        |L2.220|
                  |L2.218|
;;;396            } else {
;;;397              break;
0000da  e000              B        |L2.222|
                  |L2.220|
;;;398            }
;;;399          } while (1);
0000dc  e7f6              B        |L2.204|
                  |L2.222|
0000de  bf00              NOP                            ;397
;;;400          //
;;;401          // Handle specifiers
;;;402          //
;;;403          switch (c) {
0000e0  2e70              CMP      r6,#0x70
0000e2  d063              BEQ      |L2.428|
0000e4  dc08              BGT      |L2.248|
0000e6  2e25              CMP      r6,#0x25
0000e8  d072              BEQ      |L2.464|
0000ea  2e58              CMP      r6,#0x58
0000ec  d038              BEQ      |L2.352|
0000ee  2e63              CMP      r6,#0x63
0000f0  d009              BEQ      |L2.262|
0000f2  2e64              CMP      r6,#0x64
0000f4  d171              BNE      |L2.474|
0000f6  e014              B        |L2.290|
                  |L2.248|
0000f8  2e73              CMP      r6,#0x73
0000fa  d040              BEQ      |L2.382|
0000fc  2e75              CMP      r6,#0x75
0000fe  d01f              BEQ      |L2.320|
000100  2e78              CMP      r6,#0x78
000102  d16a              BNE      |L2.474|
000104  e02b              B        |L2.350|
                  |L2.262|
;;;404          case 'c': {
;;;405            char c0;
;;;406            v = va_arg(*pParamList, int);
000106  6821              LDR      r1,[r4,#0]
000108  1d08              ADDS     r0,r1,#4
00010a  6020              STR      r0,[r4,#0]
00010c  6808              LDR      r0,[r1,#0]
00010e  9014              STR      r0,[sp,#0x50]
;;;407            c0 = (char)v;
000110  9814              LDR      r0,[sp,#0x50]
000112  b2c0              UXTB     r0,r0
000114  9001              STR      r0,[sp,#4]
;;;408            _StoreChar(&BufferDesc, c0);
000116  a815              ADD      r0,sp,#0x54
000118  9901              LDR      r1,[sp,#4]
00011a  f7fffffe          BL       _StoreChar
;;;409            break;
00011e  e05d              B        |L2.476|
                  |L2.288|
000120  e05f              B        |L2.482|
                  |L2.290|
;;;410          }
;;;411          case 'd':
;;;412            v = va_arg(*pParamList, int);
000122  6821              LDR      r1,[r4,#0]
000124  1d08              ADDS     r0,r1,#4
000126  6020              STR      r0,[r4,#0]
000128  6808              LDR      r0,[r1,#0]
00012a  9014              STR      r0,[sp,#0x50]
;;;413            _PrintInt(&BufferDesc, v, 10u, NumDigits, FieldWidth, FormatFlags);
00012c  9812              LDR      r0,[sp,#0x48]
00012e  9701              STR      r7,[sp,#4]
000130  9000              STR      r0,[sp,#0]
000132  220a              MOVS     r2,#0xa
000134  a815              ADD      r0,sp,#0x54
000136  9b13              LDR      r3,[sp,#0x4c]
000138  9914              LDR      r1,[sp,#0x50]
00013a  f7fffffe          BL       _PrintInt
;;;414            break;
00013e  e04d              B        |L2.476|
                  |L2.320|
;;;415          case 'u':
;;;416            v = va_arg(*pParamList, int);
000140  6821              LDR      r1,[r4,#0]
000142  1d08              ADDS     r0,r1,#4
000144  6020              STR      r0,[r4,#0]
000146  6808              LDR      r0,[r1,#0]
000148  9014              STR      r0,[sp,#0x50]
;;;417            _PrintUnsigned(&BufferDesc, (unsigned)v, 10u, NumDigits, FieldWidth, FormatFlags);
00014a  9812              LDR      r0,[sp,#0x48]
00014c  9701              STR      r7,[sp,#4]
00014e  9000              STR      r0,[sp,#0]
000150  220a              MOVS     r2,#0xa
000152  a815              ADD      r0,sp,#0x54
000154  9b13              LDR      r3,[sp,#0x4c]
000156  9914              LDR      r1,[sp,#0x50]
000158  f7fffffe          BL       _PrintUnsigned
;;;418            break;
00015c  e03e              B        |L2.476|
                  |L2.350|
;;;419          case 'x':
;;;420          case 'X':
00015e  bf00              NOP      
                  |L2.352|
;;;421            v = va_arg(*pParamList, int);
000160  6821              LDR      r1,[r4,#0]
000162  1d08              ADDS     r0,r1,#4
000164  6020              STR      r0,[r4,#0]
000166  6808              LDR      r0,[r1,#0]
000168  9014              STR      r0,[sp,#0x50]
;;;422            _PrintUnsigned(&BufferDesc, (unsigned)v, 16u, NumDigits, FieldWidth, FormatFlags);
00016a  9812              LDR      r0,[sp,#0x48]
00016c  9701              STR      r7,[sp,#4]
00016e  9000              STR      r0,[sp,#0]
000170  2210              MOVS     r2,#0x10
000172  a815              ADD      r0,sp,#0x54
000174  9b13              LDR      r3,[sp,#0x4c]
000176  9914              LDR      r1,[sp,#0x50]
000178  f7fffffe          BL       _PrintUnsigned
;;;423            break;
00017c  e02e              B        |L2.476|
                  |L2.382|
;;;424          case 's':
;;;425            {
;;;426              const char * s = va_arg(*pParamList, const char *);
00017e  6821              LDR      r1,[r4,#0]
000180  1d08              ADDS     r0,r1,#4
000182  6020              STR      r0,[r4,#0]
000184  6808              LDR      r0,[r1,#0]
000186  9001              STR      r0,[sp,#4]
;;;427              do {
000188  bf00              NOP      
                  |L2.394|
;;;428                c = *s;
00018a  9801              LDR      r0,[sp,#4]
00018c  7806              LDRB     r6,[r0,#0]
;;;429                s++;
00018e  9801              LDR      r0,[sp,#4]
000190  1c40              ADDS     r0,r0,#1
000192  9001              STR      r0,[sp,#4]
;;;430                if (c == '\0') {
000194  2e00              CMP      r6,#0
000196  d100              BNE      |L2.410|
;;;431                  break;
000198  e006              B        |L2.424|
                  |L2.410|
;;;432                }
;;;433               _StoreChar(&BufferDesc, c);
00019a  4631              MOV      r1,r6
00019c  a815              ADD      r0,sp,#0x54
00019e  f7fffffe          BL       _StoreChar
;;;434              } while (BufferDesc.ReturnValue >= 0);
0001a2  9818              LDR      r0,[sp,#0x60]
0001a4  2800              CMP      r0,#0
0001a6  daf0              BGE      |L2.394|
                  |L2.424|
0001a8  bf00              NOP                            ;431
;;;435            }
;;;436            break;
0001aa  e017              B        |L2.476|
                  |L2.428|
;;;437          case 'p':
;;;438            v = va_arg(*pParamList, int);
0001ac  6821              LDR      r1,[r4,#0]
0001ae  1d08              ADDS     r0,r1,#4
0001b0  6020              STR      r0,[r4,#0]
0001b2  6808              LDR      r0,[r1,#0]
0001b4  9014              STR      r0,[sp,#0x50]
;;;439            _PrintUnsigned(&BufferDesc, (unsigned)v, 16u, 8u, 8u, 0u);
0001b6  2000              MOVS     r0,#0
0001b8  2108              MOVS     r1,#8
0001ba  460b              MOV      r3,r1
0001bc  2210              MOVS     r2,#0x10
0001be  9100              STR      r1,[sp,#0]
0001c0  9001              STR      r0,[sp,#4]
0001c2  a815              ADD      r0,sp,#0x54
0001c4  9914              LDR      r1,[sp,#0x50]
0001c6  f7fffffe          BL       _PrintUnsigned
;;;440            break;
0001ca  e007              B        |L2.476|
0001cc  e000              B        |L2.464|
0001ce  e004              B        |L2.474|
                  |L2.464|
;;;441          case '%':
;;;442            _StoreChar(&BufferDesc, '%');
0001d0  2125              MOVS     r1,#0x25
0001d2  a815              ADD      r0,sp,#0x54
0001d4  f7fffffe          BL       _StoreChar
;;;443            break;
0001d8  e000              B        |L2.476|
                  |L2.474|
;;;444          default:
;;;445            break;
0001da  bf00              NOP      
                  |L2.476|
0001dc  bf00              NOP                            ;409
;;;446          }
;;;447          sFormat++;
0001de  1c6d              ADDS     r5,r5,#1
0001e0  e003              B        |L2.490|
                  |L2.482|
;;;448        } else {
;;;449          _StoreChar(&BufferDesc, c);
0001e2  4631              MOV      r1,r6
0001e4  a815              ADD      r0,sp,#0x54
0001e6  f7fffffe          BL       _StoreChar
                  |L2.490|
;;;450        }
;;;451      } while (BufferDesc.ReturnValue >= 0);
0001ea  9818              LDR      r0,[sp,#0x60]
0001ec  2800              CMP      r0,#0
0001ee  db00              BLT      |L2.498|
0001f0  e715              B        |L2.30|
                  |L2.498|
0001f2  bf00              NOP                            ;341
;;;452    
;;;453      if (BufferDesc.ReturnValue > 0) {
0001f4  9818              LDR      r0,[sp,#0x60]
0001f6  2800              CMP      r0,#0
0001f8  dd0b              BLE      |L2.530|
;;;454        //
;;;455        // Write remaining data, if any
;;;456        //
;;;457        if (BufferDesc.Cnt != 0u) {
0001fa  9817              LDR      r0,[sp,#0x5c]
0001fc  2800              CMP      r0,#0
0001fe  d004              BEQ      |L2.522|
;;;458          SEGGER_RTT_Write(BufferIndex, acBuffer, BufferDesc.Cnt);
000200  a902              ADD      r1,sp,#8
000202  9a17              LDR      r2,[sp,#0x5c]
000204  981a              LDR      r0,[sp,#0x68]
000206  f7fffffe          BL       SEGGER_RTT_Write
                  |L2.522|
;;;459        }
;;;460        BufferDesc.ReturnValue += (int)BufferDesc.Cnt;
00020a  9917              LDR      r1,[sp,#0x5c]
00020c  9818              LDR      r0,[sp,#0x60]
00020e  1840              ADDS     r0,r0,r1
000210  9018              STR      r0,[sp,#0x60]
                  |L2.530|
;;;461      }
;;;462      return BufferDesc.ReturnValue;
000212  9818              LDR      r0,[sp,#0x60]
;;;463    }
000214  b01d              ADD      sp,sp,#0x74
000216  bdf0              POP      {r4-r7,pc}
;;;464    
                          ENDP


                          AREA ||i._PrintInt||, CODE, READONLY, ALIGN=1

                  _PrintInt PROC
;;;226    */
;;;227    static void _PrintInt(SEGGER_RTT_PRINTF_DESC * pBufferDesc, int v, unsigned Base, unsigned NumDigits, unsigned FieldWidth, unsigned FormatFlags) {
000000  b5ff              PUSH     {r0-r7,lr}
000002  b085              SUB      sp,sp,#0x14
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  9d0f              LDR      r5,[sp,#0x3c]
00000a  9c0e              LDR      r4,[sp,#0x38]
;;;228      unsigned Width;
;;;229      int Number;
;;;230    
;;;231      Number = (v < 0) ? -v : v;
00000c  2f00              CMP      r7,#0
00000e  da01              BGE      |L3.20|
000010  4278              RSBS     r0,r7,#0
000012  e000              B        |L3.22|
                  |L3.20|
000014  4638              MOV      r0,r7
                  |L3.22|
000016  9003              STR      r0,[sp,#0xc]
;;;232    
;;;233      //
;;;234      // Get actual field width
;;;235      //
;;;236      Width = 1u;
000018  2001              MOVS     r0,#1
00001a  9004              STR      r0,[sp,#0x10]
;;;237      while (Number >= (int)Base) {
00001c  e007              B        |L3.46|
                  |L3.30|
;;;238        Number = (Number / (int)Base);
00001e  9907              LDR      r1,[sp,#0x1c]
000020  9803              LDR      r0,[sp,#0xc]
000022  f7fffffe          BL       __aeabi_idivmod
000026  9003              STR      r0,[sp,#0xc]
;;;239        Width++;
000028  9804              LDR      r0,[sp,#0x10]
00002a  1c40              ADDS     r0,r0,#1
00002c  9004              STR      r0,[sp,#0x10]
                  |L3.46|
00002e  9907              LDR      r1,[sp,#0x1c]         ;237
000030  9803              LDR      r0,[sp,#0xc]          ;237
000032  4288              CMP      r0,r1                 ;237
000034  daf3              BGE      |L3.30|
;;;240      }
;;;241      if (NumDigits > Width) {
000036  9904              LDR      r1,[sp,#0x10]
000038  9808              LDR      r0,[sp,#0x20]
00003a  4288              CMP      r0,r1
00003c  d901              BLS      |L3.66|
;;;242        Width = NumDigits;
00003e  9808              LDR      r0,[sp,#0x20]
000040  9004              STR      r0,[sp,#0x10]
                  |L3.66|
;;;243      }
;;;244      if ((FieldWidth > 0u) && ((v < 0) || ((FormatFlags & FORMAT_FLAG_PRINT_SIGN) == FORMAT_FLAG_PRINT_SIGN))) {
000042  2c00              CMP      r4,#0
000044  d006              BEQ      |L3.84|
000046  2f00              CMP      r7,#0
000048  db03              BLT      |L3.82|
00004a  2004              MOVS     r0,#4
00004c  4028              ANDS     r0,r0,r5
00004e  2804              CMP      r0,#4
000050  d100              BNE      |L3.84|
                  |L3.82|
;;;245        FieldWidth--;
000052  1e64              SUBS     r4,r4,#1
                  |L3.84|
;;;246      }
;;;247    
;;;248      //
;;;249      // Print leading spaces if necessary
;;;250      //
;;;251      if ((((FormatFlags & FORMAT_FLAG_PAD_ZERO) == 0u) || (NumDigits != 0u)) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u)) {
000054  2002              MOVS     r0,#2
000056  4028              ANDS     r0,r0,r5
000058  2800              CMP      r0,#0
00005a  d002              BEQ      |L3.98|
00005c  9808              LDR      r0,[sp,#0x20]
00005e  2800              CMP      r0,#0
000060  d015              BEQ      |L3.142|
                  |L3.98|
000062  07e8              LSLS     r0,r5,#31
000064  0fc0              LSRS     r0,r0,#31
000066  2800              CMP      r0,#0
000068  d111              BNE      |L3.142|
;;;252        if (FieldWidth != 0u) {
00006a  2c00              CMP      r4,#0
00006c  d00f              BEQ      |L3.142|
;;;253          while ((FieldWidth != 0u) && (Width < FieldWidth)) {
00006e  e008              B        |L3.130|
                  |L3.112|
;;;254            FieldWidth--;
000070  1e64              SUBS     r4,r4,#1
;;;255            _StoreChar(pBufferDesc, ' ');
000072  2120              MOVS     r1,#0x20
000074  4630              MOV      r0,r6
000076  f7fffffe          BL       _StoreChar
;;;256            if (pBufferDesc->ReturnValue < 0) {
00007a  68f0              LDR      r0,[r6,#0xc]
00007c  2800              CMP      r0,#0
00007e  da00              BGE      |L3.130|
;;;257              break;
000080  e004              B        |L3.140|
                  |L3.130|
000082  2c00              CMP      r4,#0                 ;253
000084  d002              BEQ      |L3.140|
000086  9804              LDR      r0,[sp,#0x10]         ;253
000088  42a0              CMP      r0,r4                 ;253
00008a  d3f1              BCC      |L3.112|
                  |L3.140|
00008c  bf00              NOP      
                  |L3.142|
;;;258            }
;;;259          }
;;;260        }
;;;261      }
;;;262      //
;;;263      // Print sign if necessary
;;;264      //
;;;265      if (pBufferDesc->ReturnValue >= 0) {
00008e  68f0              LDR      r0,[r6,#0xc]
000090  2800              CMP      r0,#0
000092  db3a              BLT      |L3.266|
;;;266        if (v < 0) {
000094  2f00              CMP      r7,#0
000096  da05              BGE      |L3.164|
;;;267          v = -v;
000098  427f              RSBS     r7,r7,#0
;;;268          _StoreChar(pBufferDesc, '-');
00009a  212d              MOVS     r1,#0x2d
00009c  4630              MOV      r0,r6
00009e  f7fffffe          BL       _StoreChar
0000a2  e007              B        |L3.180|
                  |L3.164|
;;;269        } else if ((FormatFlags & FORMAT_FLAG_PRINT_SIGN) == FORMAT_FLAG_PRINT_SIGN) {
0000a4  2004              MOVS     r0,#4
0000a6  4028              ANDS     r0,r0,r5
0000a8  2804              CMP      r0,#4
0000aa  d103              BNE      |L3.180|
;;;270          _StoreChar(pBufferDesc, '+');
0000ac  212b              MOVS     r1,#0x2b
0000ae  4630              MOV      r0,r6
0000b0  f7fffffe          BL       _StoreChar
                  |L3.180|
;;;271        } else {
;;;272    
;;;273        }
;;;274        if (pBufferDesc->ReturnValue >= 0) {
0000b4  68f0              LDR      r0,[r6,#0xc]
0000b6  2800              CMP      r0,#0
0000b8  db27              BLT      |L3.266|
;;;275          //
;;;276          // Print leading zeros if necessary
;;;277          //
;;;278          if (((FormatFlags & FORMAT_FLAG_PAD_ZERO) == FORMAT_FLAG_PAD_ZERO) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u) && (NumDigits == 0u)) {
0000ba  2002              MOVS     r0,#2
0000bc  4028              ANDS     r0,r0,r5
0000be  2802              CMP      r0,#2
0000c0  d118              BNE      |L3.244|
0000c2  07e8              LSLS     r0,r5,#31
0000c4  0fc0              LSRS     r0,r0,#31
0000c6  2800              CMP      r0,#0
0000c8  d114              BNE      |L3.244|
0000ca  9808              LDR      r0,[sp,#0x20]
0000cc  2800              CMP      r0,#0
0000ce  d111              BNE      |L3.244|
;;;279            if (FieldWidth != 0u) {
0000d0  2c00              CMP      r4,#0
0000d2  d00f              BEQ      |L3.244|
;;;280              while ((FieldWidth != 0u) && (Width < FieldWidth)) {
0000d4  e008              B        |L3.232|
                  |L3.214|
;;;281                FieldWidth--;
0000d6  1e64              SUBS     r4,r4,#1
;;;282                _StoreChar(pBufferDesc, '0');
0000d8  2130              MOVS     r1,#0x30
0000da  4630              MOV      r0,r6
0000dc  f7fffffe          BL       _StoreChar
;;;283                if (pBufferDesc->ReturnValue < 0) {
0000e0  68f0              LDR      r0,[r6,#0xc]
0000e2  2800              CMP      r0,#0
0000e4  da00              BGE      |L3.232|
;;;284                  break;
0000e6  e004              B        |L3.242|
                  |L3.232|
0000e8  2c00              CMP      r4,#0                 ;280
0000ea  d002              BEQ      |L3.242|
0000ec  9804              LDR      r0,[sp,#0x10]         ;280
0000ee  42a0              CMP      r0,r4                 ;280
0000f0  d3f1              BCC      |L3.214|
                  |L3.242|
0000f2  bf00              NOP      
                  |L3.244|
;;;285                }
;;;286              }
;;;287            }
;;;288          }
;;;289          if (pBufferDesc->ReturnValue >= 0) {
0000f4  68f0              LDR      r0,[r6,#0xc]
0000f6  2800              CMP      r0,#0
0000f8  db07              BLT      |L3.266|
;;;290            //
;;;291            // Print number without sign
;;;292            //
;;;293            _PrintUnsigned(pBufferDesc, (unsigned)v, Base, NumDigits, FieldWidth, FormatFlags);
0000fa  9501              STR      r5,[sp,#4]
0000fc  9400              STR      r4,[sp,#0]
0000fe  4639              MOV      r1,r7
000100  4630              MOV      r0,r6
000102  9b08              LDR      r3,[sp,#0x20]
000104  9a07              LDR      r2,[sp,#0x1c]
000106  f7fffffe          BL       _PrintUnsigned
                  |L3.266|
;;;294          }
;;;295        }
;;;296      }
;;;297    }
00010a  b009              ADD      sp,sp,#0x24
00010c  bdf0              POP      {r4-r7,pc}
;;;298    
                          ENDP


                          AREA ||i._PrintUnsigned||, CODE, READONLY, ALIGN=2

                  _PrintUnsigned PROC
;;;136    */
;;;137    static void _PrintUnsigned(SEGGER_RTT_PRINTF_DESC * pBufferDesc, unsigned v, unsigned Base, unsigned NumDigits, unsigned FieldWidth, unsigned FormatFlags) {
000000  b5ff              PUSH     {r0-r7,lr}
000002  b085              SUB      sp,sp,#0x14
000004  4606              MOV      r6,r0
000006  4617              MOV      r7,r2
000008  461d              MOV      r5,r3
00000a  9c0e              LDR      r4,[sp,#0x38]
;;;138      static const char _aV2C[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
;;;139      unsigned Div;
;;;140      unsigned Digit;
;;;141      unsigned Number;
;;;142      unsigned Width;
;;;143      char c;
;;;144    
;;;145      Number = v;
00000c  9806              LDR      r0,[sp,#0x18]
00000e  9002              STR      r0,[sp,#8]
;;;146      Digit = 1u;
000010  2001              MOVS     r0,#1
000012  9003              STR      r0,[sp,#0xc]
;;;147      //
;;;148      // Get actual field width
;;;149      //
;;;150      Width = 1u;
000014  9001              STR      r0,[sp,#4]
;;;151      while (Number >= Base) {
000016  e007              B        |L4.40|
                  |L4.24|
;;;152        Number = (Number / Base);
000018  4639              MOV      r1,r7
00001a  9802              LDR      r0,[sp,#8]
00001c  f7fffffe          BL       __aeabi_uidivmod
000020  9002              STR      r0,[sp,#8]
;;;153        Width++;
000022  9801              LDR      r0,[sp,#4]
000024  1c40              ADDS     r0,r0,#1
000026  9001              STR      r0,[sp,#4]
                  |L4.40|
000028  9802              LDR      r0,[sp,#8]            ;151
00002a  42b8              CMP      r0,r7                 ;151
00002c  d2f4              BCS      |L4.24|
;;;154      }
;;;155      if (NumDigits > Width) {
00002e  9801              LDR      r0,[sp,#4]
000030  4285              CMP      r5,r0
000032  d900              BLS      |L4.54|
;;;156        Width = NumDigits;
000034  9501              STR      r5,[sp,#4]
                  |L4.54|
;;;157      }
;;;158      //
;;;159      // Print leading chars if necessary
;;;160      //
;;;161      if ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u) {
000036  980f              LDR      r0,[sp,#0x3c]
000038  07c0              LSLS     r0,r0,#31
00003a  0fc0              LSRS     r0,r0,#31
00003c  2800              CMP      r0,#0
00003e  d11d              BNE      |L4.124|
;;;162        if (FieldWidth != 0u) {
000040  2c00              CMP      r4,#0
000042  d01b              BEQ      |L4.124|
;;;163          if (((FormatFlags & FORMAT_FLAG_PAD_ZERO) == FORMAT_FLAG_PAD_ZERO) && (NumDigits == 0u)) {
000044  2102              MOVS     r1,#2
000046  980f              LDR      r0,[sp,#0x3c]
000048  4008              ANDS     r0,r0,r1
00004a  2802              CMP      r0,#2
00004c  d104              BNE      |L4.88|
00004e  2d00              CMP      r5,#0
000050  d102              BNE      |L4.88|
;;;164            c = '0';
000052  2030              MOVS     r0,#0x30
000054  9000              STR      r0,[sp,#0]
000056  e001              B        |L4.92|
                  |L4.88|
;;;165          } else {
;;;166            c = ' ';
000058  2020              MOVS     r0,#0x20
00005a  9000              STR      r0,[sp,#0]
                  |L4.92|
;;;167          }
;;;168          while ((FieldWidth != 0u) && (Width < FieldWidth)) {
00005c  e008              B        |L4.112|
                  |L4.94|
;;;169            FieldWidth--;
00005e  1e64              SUBS     r4,r4,#1
;;;170            _StoreChar(pBufferDesc, c);
000060  4630              MOV      r0,r6
000062  9900              LDR      r1,[sp,#0]
000064  f7fffffe          BL       _StoreChar
;;;171            if (pBufferDesc->ReturnValue < 0) {
000068  68f0              LDR      r0,[r6,#0xc]
00006a  2800              CMP      r0,#0
00006c  da00              BGE      |L4.112|
;;;172              break;
00006e  e004              B        |L4.122|
                  |L4.112|
000070  2c00              CMP      r4,#0                 ;168
000072  d002              BEQ      |L4.122|
000074  9801              LDR      r0,[sp,#4]            ;168
000076  42a0              CMP      r0,r4                 ;168
000078  d3f1              BCC      |L4.94|
                  |L4.122|
00007a  bf00              NOP      
                  |L4.124|
;;;173            }
;;;174          }
;;;175        }
;;;176      }
;;;177      if (pBufferDesc->ReturnValue >= 0) {
00007c  68f0              LDR      r0,[r6,#0xc]
00007e  2800              CMP      r0,#0
000080  db48              BLT      |L4.276|
;;;178        //
;;;179        // Compute Digit.
;;;180        // Loop until Digit has the value of the highest digit required.
;;;181        // Example: If the output is 345 (Base 10), loop 2 times until Digit is 100.
;;;182        //
;;;183        while (1) {
000082  e00f              B        |L4.164|
                  |L4.132|
;;;184          if (NumDigits > 1u) {       // User specified a min number of digits to print? => Make sure we loop at least that often, before checking anything else (> 1 check avoids problems with NumDigits being signed / unsigned)
000084  2d01              CMP      r5,#1
000086  d901              BLS      |L4.140|
;;;185            NumDigits--;
000088  1e6d              SUBS     r5,r5,#1
00008a  e008              B        |L4.158|
                  |L4.140|
;;;186          } else {
;;;187            Div = v / Digit;
00008c  9903              LDR      r1,[sp,#0xc]
00008e  9806              LDR      r0,[sp,#0x18]
000090  f7fffffe          BL       __aeabi_uidivmod
000094  9004              STR      r0,[sp,#0x10]
;;;188            if (Div < Base) {        // Is our divider big enough to extract the highest digit from value? => Done
000096  9804              LDR      r0,[sp,#0x10]
000098  42b8              CMP      r0,r7
00009a  d200              BCS      |L4.158|
;;;189              break;
00009c  e003              B        |L4.166|
                  |L4.158|
;;;190            }
;;;191          }
;;;192          Digit *= Base;
00009e  9803              LDR      r0,[sp,#0xc]
0000a0  4378              MULS     r0,r7,r0
0000a2  9003              STR      r0,[sp,#0xc]
                  |L4.164|
0000a4  e7ee              B        |L4.132|
                  |L4.166|
0000a6  bf00              NOP                            ;189
;;;193        }
;;;194        //
;;;195        // Output digits
;;;196        //
;;;197        do {
0000a8  bf00              NOP      
                  |L4.170|
;;;198          Div = v / Digit;
0000aa  9903              LDR      r1,[sp,#0xc]
0000ac  9806              LDR      r0,[sp,#0x18]
0000ae  f7fffffe          BL       __aeabi_uidivmod
0000b2  9004              STR      r0,[sp,#0x10]
;;;199          v -= Div * Digit;
0000b4  9903              LDR      r1,[sp,#0xc]
0000b6  9804              LDR      r0,[sp,#0x10]
0000b8  4348              MULS     r0,r1,r0
0000ba  9906              LDR      r1,[sp,#0x18]
0000bc  1a08              SUBS     r0,r1,r0
0000be  9006              STR      r0,[sp,#0x18]
;;;200          _StoreChar(pBufferDesc, _aV2C[Div]);
0000c0  4a15              LDR      r2,|L4.280|
0000c2  9804              LDR      r0,[sp,#0x10]
0000c4  5c11              LDRB     r1,[r2,r0]
0000c6  4630              MOV      r0,r6
0000c8  f7fffffe          BL       _StoreChar
;;;201          if (pBufferDesc->ReturnValue < 0) {
0000cc  68f0              LDR      r0,[r6,#0xc]
0000ce  2800              CMP      r0,#0
0000d0  da00              BGE      |L4.212|
;;;202            break;
0000d2  e007              B        |L4.228|
                  |L4.212|
;;;203          }
;;;204          Digit /= Base;
0000d4  4639              MOV      r1,r7
0000d6  9803              LDR      r0,[sp,#0xc]
0000d8  f7fffffe          BL       __aeabi_uidivmod
0000dc  9003              STR      r0,[sp,#0xc]
;;;205        } while (Digit);
0000de  9803              LDR      r0,[sp,#0xc]
0000e0  2800              CMP      r0,#0
0000e2  d1e2              BNE      |L4.170|
                  |L4.228|
0000e4  bf00              NOP                            ;202
;;;206        //
;;;207        // Print trailing spaces if necessary
;;;208        //
;;;209        if ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == FORMAT_FLAG_LEFT_JUSTIFY) {
0000e6  980f              LDR      r0,[sp,#0x3c]
0000e8  07c0              LSLS     r0,r0,#31
0000ea  0fc0              LSRS     r0,r0,#31
0000ec  2800              CMP      r0,#0
0000ee  d011              BEQ      |L4.276|
;;;210          if (FieldWidth != 0u) {
0000f0  2c00              CMP      r4,#0
0000f2  d00f              BEQ      |L4.276|
;;;211            while ((FieldWidth != 0u) && (Width < FieldWidth)) {
0000f4  e008              B        |L4.264|
                  |L4.246|
;;;212              FieldWidth--;
0000f6  1e64              SUBS     r4,r4,#1
;;;213              _StoreChar(pBufferDesc, ' ');
0000f8  2120              MOVS     r1,#0x20
0000fa  4630              MOV      r0,r6
0000fc  f7fffffe          BL       _StoreChar
;;;214              if (pBufferDesc->ReturnValue < 0) {
000100  68f0              LDR      r0,[r6,#0xc]
000102  2800              CMP      r0,#0
000104  da00              BGE      |L4.264|
;;;215                break;
000106  e004              B        |L4.274|
                  |L4.264|
000108  2c00              CMP      r4,#0                 ;211
00010a  d002              BEQ      |L4.274|
00010c  9801              LDR      r0,[sp,#4]            ;211
00010e  42a0              CMP      r0,r4                 ;211
000110  d3f1              BCC      |L4.246|
                  |L4.274|
000112  bf00              NOP      
                  |L4.276|
;;;216              }
;;;217            }
;;;218          }
;;;219        }
;;;220      }
;;;221    }
000114  b009              ADD      sp,sp,#0x24
000116  bdf0              POP      {r4-r7,pc}
;;;222    
                          ENDP

                  |L4.280|
                          DCD      _aV2C

                          AREA ||i._StoreChar||, CODE, READONLY, ALIGN=1

                  _StoreChar PROC
;;;111    */
;;;112    static void _StoreChar(SEGGER_RTT_PRINTF_DESC * p, char c) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;113      unsigned Cnt;
;;;114    
;;;115      Cnt = p->Cnt;
000006  68a5              LDR      r5,[r4,#8]
;;;116      if ((Cnt + 1u) <= p->BufferSize) {
000008  1c68              ADDS     r0,r5,#1
00000a  6861              LDR      r1,[r4,#4]
00000c  4281              CMP      r1,r0
00000e  d306              BCC      |L5.30|
;;;117        *(p->pBuffer + Cnt) = c;
000010  6820              LDR      r0,[r4,#0]
000012  5546              STRB     r6,[r0,r5]
;;;118        p->Cnt = Cnt + 1u;
000014  1c68              ADDS     r0,r5,#1
000016  60a0              STR      r0,[r4,#8]
;;;119        p->ReturnValue++;
000018  68e0              LDR      r0,[r4,#0xc]
00001a  1c40              ADDS     r0,r0,#1
00001c  60e0              STR      r0,[r4,#0xc]
                  |L5.30|
;;;120      }
;;;121      //
;;;122      // Write part of string, when the buffer is full
;;;123      //
;;;124      if (p->Cnt == p->BufferSize) {
00001e  6861              LDR      r1,[r4,#4]
000020  68a0              LDR      r0,[r4,#8]
000022  4288              CMP      r0,r1
000024  d10d              BNE      |L5.66|
;;;125        if (SEGGER_RTT_Write(p->RTTBufferIndex, p->pBuffer, p->Cnt) != p->Cnt) {
000026  68a2              LDR      r2,[r4,#8]
000028  6821              LDR      r1,[r4,#0]
00002a  6920              LDR      r0,[r4,#0x10]
00002c  f7fffffe          BL       SEGGER_RTT_Write
000030  68a1              LDR      r1,[r4,#8]
000032  4288              CMP      r0,r1
000034  d003              BEQ      |L5.62|
;;;126          p->ReturnValue = -1;
000036  2000              MOVS     r0,#0
000038  43c0              MVNS     r0,r0
00003a  60e0              STR      r0,[r4,#0xc]
00003c  e001              B        |L5.66|
                  |L5.62|
;;;127        } else {
;;;128          p->Cnt = 0u;
00003e  2000              MOVS     r0,#0
000040  60a0              STR      r0,[r4,#8]
                  |L5.66|
;;;129        }
;;;130      }
;;;131    }
000042  bd70              POP      {r4-r6,pc}
;;;132    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  _aV2C
000000  30313233          DCB      0x30,0x31,0x32,0x33
000004  34353637          DCB      0x34,0x35,0x36,0x37
000008  38394142          DCB      0x38,0x39,0x41,0x42
00000c  43444546          DCB      0x43,0x44,0x45,0x46
