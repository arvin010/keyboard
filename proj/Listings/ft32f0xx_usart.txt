; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\ft32f0xx_usart.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\ft32f0xx_usart.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\FTLib\CMSIS\inc -I..\FTLib\Inc -I..\FTLib\Lib -I..\usb\inc -I..\user -I..\RTT -I..\iap2 -IC:\Users\dell1\AppData\Local\Arm\Packs\FMD\FT32F0xx_DFP\1.0.6\Drivers\CMSIS\FT32F0xx\Include -D__UVISION_VERSION=534 -DFT32F072x8 -DFT32F072x8 --omf_browse=.\objects\ft32f0xx_usart.crf ..\FTLib\Src\ft32f0xx_usart.c]
                          THUMB

                          AREA ||i.USART_AddressDetectionConfig||, CODE, READONLY, ALIGN=1

                  USART_AddressDetectionConfig PROC
;;;679      */
;;;680    void USART_AddressDetectionConfig(USART_TypeDef* USARTx, uint32_t USART_AddressLength)
000000  6842              LDR      r2,[r0,#4]
;;;681    {
;;;682      /* Check the parameters */
;;;683      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;684      assert_param(IS_USART_ADDRESS_DETECTION(USART_AddressLength));
;;;685    
;;;686      USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_ADDM7);
000002  2310              MOVS     r3,#0x10
000004  439a              BICS     r2,r2,r3
000006  6042              STR      r2,[r0,#4]
;;;687      USARTx->CR2 |= USART_AddressLength;
000008  6842              LDR      r2,[r0,#4]
00000a  430a              ORRS     r2,r2,r1
00000c  6042              STR      r2,[r0,#4]
;;;688    }
00000e  4770              BX       lr
;;;689    
                          ENDP


                          AREA ||i.USART_AutoBaudRateCmd||, CODE, READONLY, ALIGN=1

                  USART_AutoBaudRateCmd PROC
;;;533      */
;;;534    void USART_AutoBaudRateCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;535    {
;;;536      /* Check the parameters */
;;;537      assert_param(IS_USART_123_PERIPH(USARTx));
;;;538      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;539    
;;;540      if (NewState != DISABLE)
000002  d005              BEQ      |L2.16|
;;;541      {
;;;542        /* Enable the auto baud rate feature by setting the ABREN bit in the CR2 
;;;543           register */
;;;544        USARTx->CR2 |= USART_CR2_ABREN;
000004  6842              LDR      r2,[r0,#4]
000006  2301              MOVS     r3,#1
000008  051b              LSLS     r3,r3,#20
00000a  431a              ORRS     r2,r2,r3
00000c  6042              STR      r2,[r0,#4]
00000e  e004              B        |L2.26|
                  |L2.16|
;;;545      }
;;;546      else
;;;547      {
;;;548        /* Disable the auto baud rate feature by clearing the ABREN bit in the CR2 
;;;549           register */
;;;550        USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_ABREN);
000010  6842              LDR      r2,[r0,#4]
000012  2301              MOVS     r3,#1
000014  051b              LSLS     r3,r3,#20
000016  439a              BICS     r2,r2,r3
000018  6042              STR      r2,[r0,#4]
                  |L2.26|
;;;551      }
;;;552    }
00001a  4770              BX       lr
;;;553    
                          ENDP


                          AREA ||i.USART_AutoBaudRateConfig||, CODE, READONLY, ALIGN=1

                  USART_AutoBaudRateConfig PROC
;;;563      */
;;;564    void USART_AutoBaudRateConfig(USART_TypeDef* USARTx, uint32_t USART_AutoBaudRate)
000000  6842              LDR      r2,[r0,#4]
;;;565    {
;;;566      /* Check the parameters */
;;;567      assert_param(IS_USART_123_PERIPH(USARTx));
;;;568      assert_param(IS_USART_AUTOBAUDRATE_MODE(USART_AutoBaudRate));
;;;569    
;;;570      USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_ABRMODE);
000002  2303              MOVS     r3,#3
000004  055b              LSLS     r3,r3,#21
000006  439a              BICS     r2,r2,r3
000008  6042              STR      r2,[r0,#4]
;;;571      USARTx->CR2 |= USART_AutoBaudRate;
00000a  6842              LDR      r2,[r0,#4]
00000c  430a              ORRS     r2,r2,r1
00000e  6042              STR      r2,[r0,#4]
;;;572    }
000010  4770              BX       lr
;;;573    
                          ENDP


                          AREA ||i.USART_ClearFlag||, CODE, READONLY, ALIGN=1

                  USART_ClearFlag PROC
;;;1058     */
;;;1059   void USART_ClearFlag(USART_TypeDef* USARTx, uint32_t USART_FLAG)
000000  6201              STR      r1,[r0,#0x20]
;;;1060   {
;;;1061     /* Check the parameters */
;;;1062     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1063     assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
;;;1064        
;;;1065     USARTx->ICR = USART_FLAG;
;;;1066   }
000002  4770              BX       lr
;;;1067   
                          ENDP


                          AREA ||i.USART_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  USART_ClearITPendingBit PROC
;;;1159     */
;;;1160   void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint32_t USART_IT)
000000  b510              PUSH     {r4,lr}
;;;1161   {
;;;1162     uint32_t bitpos = 0, itmask = 0;
000002  2300              MOVS     r3,#0
000004  2200              MOVS     r2,#0
;;;1163     /* Check the parameters */
;;;1164     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1165     assert_param(IS_USART_CLEAR_IT(USART_IT)); 
;;;1166     
;;;1167     bitpos = USART_IT >> 0x10;
000006  0c0b              LSRS     r3,r1,#16
;;;1168     itmask = ((uint32_t)0x01 << (uint32_t)bitpos);
000008  2401              MOVS     r4,#1
00000a  409c              LSLS     r4,r4,r3
00000c  4622              MOV      r2,r4
;;;1169     USARTx->ICR = (uint32_t)itmask;
00000e  6202              STR      r2,[r0,#0x20]
;;;1170   }
000010  bd10              POP      {r4,pc}
;;;1171   
                          ENDP


                          AREA ||i.USART_ClockInit||, CODE, READONLY, ALIGN=1

                  USART_ClockInit PROC
;;;203      */
;;;204    void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
000000  b510              PUSH     {r4,lr}
;;;205    {
;;;206      uint32_t tmpreg = 0;
000002  2200              MOVS     r2,#0
;;;207      /* Check the parameters */
;;;208      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;209      assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
;;;210      assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
;;;211      assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
;;;212      assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
;;;213    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;214      tmpreg = USARTx->CR2;
000004  6842              LDR      r2,[r0,#4]
;;;215      /* Clear CLKEN, CPOL, CPHA, LBCL and SSM bits */
;;;216      tmpreg &= (uint32_t)~((uint32_t)CR2_CLOCK_CLEAR_MASK);
000006  240f              MOVS     r4,#0xf
000008  0224              LSLS     r4,r4,#8
00000a  4613              MOV      r3,r2
00000c  43a3              BICS     r3,r3,r4
00000e  461a              MOV      r2,r3
;;;217      /* Configure the USART Clock, CPOL, CPHA, LastBit and SSM ------------*/
;;;218      /* Set CLKEN bit according to USART_Clock value */
;;;219      /* Set CPOL bit according to USART_CPOL value */
;;;220      /* Set CPHA bit according to USART_CPHA value */
;;;221      /* Set LBCL bit according to USART_LastBit value */
;;;222      tmpreg |= (uint32_t)(USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
000010  684c              LDR      r4,[r1,#4]
000012  680b              LDR      r3,[r1,#0]
000014  4323              ORRS     r3,r3,r4
000016  688c              LDR      r4,[r1,#8]
000018  4323              ORRS     r3,r3,r4
00001a  68cc              LDR      r4,[r1,#0xc]
00001c  4323              ORRS     r3,r3,r4
00001e  431a              ORRS     r2,r2,r3
;;;223                           USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit);
;;;224      /* Write to USART CR2 */
;;;225      USARTx->CR2 = tmpreg;
000020  6042              STR      r2,[r0,#4]
;;;226    }
000022  bd10              POP      {r4,pc}
;;;227    
                          ENDP


                          AREA ||i.USART_ClockStructInit||, CODE, READONLY, ALIGN=1

                  USART_ClockStructInit PROC
;;;233      */
;;;234    void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
000000  2100              MOVS     r1,#0
;;;235    {
;;;236      /* USART_ClockInitStruct members default value */
;;;237      USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
000002  6001              STR      r1,[r0,#0]
;;;238      USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
000004  6041              STR      r1,[r0,#4]
;;;239      USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
000006  6081              STR      r1,[r0,#8]
;;;240      USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
000008  60c1              STR      r1,[r0,#0xc]
;;;241    }
00000a  4770              BX       lr
;;;242    
                          ENDP


                          AREA ||i.USART_Cmd||, CODE, READONLY, ALIGN=1

                  USART_Cmd PROC
;;;249      */
;;;250    void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;251    {
;;;252      /* Check the parameters */
;;;253      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;254      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;255      
;;;256      if (NewState != DISABLE)
000002  d004              BEQ      |L8.14|
;;;257      {
;;;258        /* Enable the selected USART by setting the UE bit in the CR1 register */
;;;259        USARTx->CR1 |= USART_CR1_UE;
000004  6802              LDR      r2,[r0,#0]
000006  2301              MOVS     r3,#1
000008  431a              ORRS     r2,r2,r3
00000a  6002              STR      r2,[r0,#0]
00000c  e003              B        |L8.22|
                  |L8.14|
;;;260      }
;;;261      else
;;;262      {
;;;263        /* Disable the selected USART by clearing the UE bit in the CR1 register */
;;;264        USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_UE);
00000e  6802              LDR      r2,[r0,#0]
000010  0852              LSRS     r2,r2,#1
000012  0052              LSLS     r2,r2,#1
000014  6002              STR      r2,[r0,#0]
                  |L8.22|
;;;265      }
;;;266    }
000016  4770              BX       lr
;;;267    
                          ENDP


                          AREA ||i.USART_DECmd||, CODE, READONLY, ALIGN=1

                  USART_DECmd PROC
;;;727      */
;;;728    void USART_DECmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;729    {
;;;730      /* Check the parameters */
;;;731      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;732      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;733      if (NewState != DISABLE)
000002  d005              BEQ      |L9.16|
;;;734      {
;;;735        /* Enable the DE functionality by setting the DEM bit in the CR3 register */
;;;736        USARTx->CR3 |= USART_CR3_DEM;
000004  6882              LDR      r2,[r0,#8]
000006  2301              MOVS     r3,#1
000008  039b              LSLS     r3,r3,#14
00000a  431a              ORRS     r2,r2,r3
00000c  6082              STR      r2,[r0,#8]
00000e  e004              B        |L9.26|
                  |L9.16|
;;;737      }
;;;738      else
;;;739      {
;;;740        /* Disable the DE functionality by clearing the DEM bit in the CR3 register */
;;;741        USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DEM);
000010  6882              LDR      r2,[r0,#8]
000012  2301              MOVS     r3,#1
000014  039b              LSLS     r3,r3,#14
000016  439a              BICS     r2,r2,r3
000018  6082              STR      r2,[r0,#8]
                  |L9.26|
;;;742      }
;;;743    }
00001a  4770              BX       lr
;;;744    
                          ENDP


                          AREA ||i.USART_DEPolarityConfig||, CODE, READONLY, ALIGN=1

                  USART_DEPolarityConfig PROC
;;;753      */
;;;754    void USART_DEPolarityConfig(USART_TypeDef* USARTx, uint32_t USART_DEPolarity)
000000  6882              LDR      r2,[r0,#8]
;;;755    {
;;;756      /* Check the parameters */
;;;757      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;758      assert_param(IS_USART_DE_POLARITY(USART_DEPolarity));
;;;759    
;;;760      USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DEP);
000002  2301              MOVS     r3,#1
000004  03db              LSLS     r3,r3,#15
000006  439a              BICS     r2,r2,r3
000008  6082              STR      r2,[r0,#8]
;;;761      USARTx->CR3 |= USART_DEPolarity;
00000a  6882              LDR      r2,[r0,#8]
00000c  430a              ORRS     r2,r2,r1
00000e  6082              STR      r2,[r0,#8]
;;;762    }
000010  4770              BX       lr
;;;763    
                          ENDP


                          AREA ||i.USART_DMACmd||, CODE, READONLY, ALIGN=1

                  USART_DMACmd PROC
;;;816      */
;;;817    void USART_DMACmd(USART_TypeDef* USARTx, uint32_t USART_DMAReq, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;818    {
;;;819      /* Check the parameters */
;;;820      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;821      assert_param(IS_USART_DMAREQ(USART_DMAReq));  
;;;822      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;823    
;;;824      if (NewState != DISABLE)
000002  d003              BEQ      |L11.12|
;;;825      {
;;;826        /* Enable the DMA transfer for selected requests by setting the DMAT and/or
;;;827           DMAR bits in the USART CR3 register */
;;;828        USARTx->CR3 |= USART_DMAReq;
000004  6883              LDR      r3,[r0,#8]
000006  430b              ORRS     r3,r3,r1
000008  6083              STR      r3,[r0,#8]
00000a  e002              B        |L11.18|
                  |L11.12|
;;;829      }
;;;830      else
;;;831      {
;;;832        /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
;;;833           DMAR bits in the USART CR3 register */
;;;834        USARTx->CR3 &= (uint32_t)~USART_DMAReq;
00000c  6883              LDR      r3,[r0,#8]
00000e  438b              BICS     r3,r3,r1
000010  6083              STR      r3,[r0,#8]
                  |L11.18|
;;;835      }
;;;836    }
000012  4770              BX       lr
;;;837    
                          ENDP


                          AREA ||i.USART_DMAReceptionErrorConfig||, CODE, READONLY, ALIGN=1

                  USART_DMAReceptionErrorConfig PROC
;;;848      */
;;;849    void USART_DMAReceptionErrorConfig(USART_TypeDef* USARTx, uint32_t USART_DMAOnError)
000000  6882              LDR      r2,[r0,#8]
;;;850    {
;;;851      /* Check the parameters */
;;;852      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;853      assert_param(IS_USART_DMAONERROR(USART_DMAOnError)); 
;;;854      
;;;855      /* Clear the DMA Reception error detection bit */
;;;856      USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DDRE);
000002  2301              MOVS     r3,#1
000004  035b              LSLS     r3,r3,#13
000006  439a              BICS     r2,r2,r3
000008  6082              STR      r2,[r0,#8]
;;;857      /* Set the new value for the DMA Reception error detection bit */
;;;858      USARTx->CR3 |= USART_DMAOnError;
00000a  6882              LDR      r2,[r0,#8]
00000c  430a              ORRS     r2,r2,r1
00000e  6082              STR      r2,[r0,#8]
;;;859    }
000010  4770              BX       lr
;;;860    
                          ENDP


                          AREA ||i.USART_DataInvCmd||, CODE, READONLY, ALIGN=1

                  USART_DataInvCmd PROC
;;;394      */
;;;395    void USART_DataInvCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;396    {
;;;397      /* Check the parameters */
;;;398      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;399      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;400    
;;;401      if (NewState != DISABLE)
000002  d005              BEQ      |L13.16|
;;;402      {
;;;403        /* Enable the binary data inversion feature by setting the DATAINV bit in 
;;;404           the CR2 register */
;;;405        USARTx->CR2 |= USART_CR2_DATAINV;
000004  6842              LDR      r2,[r0,#4]
000006  2301              MOVS     r3,#1
000008  049b              LSLS     r3,r3,#18
00000a  431a              ORRS     r2,r2,r3
00000c  6042              STR      r2,[r0,#4]
00000e  e004              B        |L13.26|
                  |L13.16|
;;;406      }
;;;407      else
;;;408      {
;;;409        /* Disable the binary data inversion feature by clearing the DATAINV bit in 
;;;410           the CR2 register */
;;;411        USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_DATAINV);
000010  6842              LDR      r2,[r0,#4]
000012  2301              MOVS     r3,#1
000014  049b              LSLS     r3,r3,#18
000016  439a              BICS     r2,r2,r3
000018  6042              STR      r2,[r0,#4]
                  |L13.26|
;;;412      }
;;;413    }
00001a  4770              BX       lr
;;;414    
                          ENDP


                          AREA ||i.USART_DeInit||, CODE, READONLY, ALIGN=2

                  USART_DeInit PROC
;;;49       */
;;;50     void USART_DeInit(USART_TypeDef* USARTx)
000000  b510              PUSH     {r4,lr}
;;;51     {
000002  4604              MOV      r4,r0
;;;52       /* Check the parameters */
;;;53       assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;54     
;;;55       if (USARTx == USART1)
000004  480c              LDR      r0,|L14.56|
000006  4284              CMP      r4,r0
000008  d109              BNE      |L14.30|
;;;56       {
;;;57         RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  0388              LSLS     r0,r1,#14
00000e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;58         RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
000012  2100              MOVS     r1,#0
000014  2001              MOVS     r0,#1
000016  0380              LSLS     r0,r0,#14
000018  f7fffffe          BL       RCC_APB2PeriphResetCmd
00001c  e00b              B        |L14.54|
                  |L14.30|
;;;59       }
;;;60       else if (USARTx == USART2)
00001e  4807              LDR      r0,|L14.60|
000020  4284              CMP      r4,r0
000022  d108              BNE      |L14.54|
;;;61       {
;;;62         RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
000024  2101              MOVS     r1,#1
000026  0448              LSLS     r0,r1,#17
000028  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;63         RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
00002c  2100              MOVS     r1,#0
00002e  2001              MOVS     r0,#1
000030  0440              LSLS     r0,r0,#17
000032  f7fffffe          BL       RCC_APB1PeriphResetCmd
                  |L14.54|
;;;64       }
;;;65     }
000036  bd10              POP      {r4,pc}
;;;66     
                          ENDP

                  |L14.56|
                          DCD      0x40013800
                  |L14.60|
                          DCD      0x40004400

                          AREA ||i.USART_DirectionModeCmd||, CODE, READONLY, ALIGN=1

                  USART_DirectionModeCmd PROC
;;;278      */
;;;279    void USART_DirectionModeCmd(USART_TypeDef* USARTx, uint32_t USART_DirectionMode, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;280    {
;;;281      /* Check the parameters */
;;;282      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;283      assert_param(IS_USART_MODE(USART_DirectionMode));
;;;284      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;285    
;;;286      if (NewState != DISABLE)
000002  d003              BEQ      |L15.12|
;;;287      {
;;;288        /* Enable the USART's transfer interface by setting the TE and/or RE bits 
;;;289           in the USART CR1 register */
;;;290        USARTx->CR1 |= USART_DirectionMode;
000004  6803              LDR      r3,[r0,#0]
000006  430b              ORRS     r3,r3,r1
000008  6003              STR      r3,[r0,#0]
00000a  e002              B        |L15.18|
                  |L15.12|
;;;291      }
;;;292      else
;;;293      {
;;;294        /* Disable the USART's transfer interface by clearing the TE and/or RE bits
;;;295           in the USART CR3 register */
;;;296        USARTx->CR1 &= (uint32_t)~USART_DirectionMode;
00000c  6803              LDR      r3,[r0,#0]
00000e  438b              BICS     r3,r3,r1
000010  6003              STR      r3,[r0,#0]
                  |L15.18|
;;;297      }
;;;298    }
000012  4770              BX       lr
;;;299    
                          ENDP


                          AREA ||i.USART_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  USART_GetFlagStatus PROC
;;;1010     */
;;;1011   FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint32_t USART_FLAG)
000000  4602              MOV      r2,r0
;;;1012   {
;;;1013     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1014     /* Check the parameters */
;;;1015     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1016     assert_param(IS_USART_FLAG(USART_FLAG));
;;;1017     
;;;1018     if ((USARTx->ISR & USART_FLAG) != (uint16_t)RESET)
000004  69d3              LDR      r3,[r2,#0x1c]
000006  400b              ANDS     r3,r3,r1
000008  2b00              CMP      r3,#0
00000a  d001              BEQ      |L16.16|
;;;1019     {
;;;1020       bitstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L16.18|
                  |L16.16|
;;;1021     }
;;;1022     else
;;;1023     {
;;;1024       bitstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L16.18|
;;;1025     }
;;;1026     return bitstatus;
;;;1027   }
000012  4770              BX       lr
;;;1028   
                          ENDP


                          AREA ||i.USART_GetITStatus||, CODE, READONLY, ALIGN=1

                  USART_GetITStatus PROC
;;;1088     */
;;;1089   ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint32_t USART_IT)
000000  b570              PUSH     {r4-r6,lr}
;;;1090   {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;1091     uint32_t bitpos = 0, itmask = 0, usartreg = 0;
000006  2400              MOVS     r4,#0
000008  2100              MOVS     r1,#0
00000a  2500              MOVS     r5,#0
;;;1092     ITStatus bitstatus = RESET;
00000c  2000              MOVS     r0,#0
;;;1093     /* Check the parameters */
;;;1094     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1095     assert_param(IS_USART_GET_IT(USART_IT)); 
;;;1096     
;;;1097     /* Get the USART register index */
;;;1098     usartreg = (((uint16_t)USART_IT) >> 0x08);
00000e  041e              LSLS     r6,r3,#16
000010  0e35              LSRS     r5,r6,#24
;;;1099     /* Get the interrupt position */
;;;1100     itmask = USART_IT & IT_MASK;
000012  b2d9              UXTB     r1,r3
;;;1101     itmask = (uint32_t)0x01 << itmask;
000014  2601              MOVS     r6,#1
000016  408e              LSLS     r6,r6,r1
000018  4631              MOV      r1,r6
;;;1102     
;;;1103     if (usartreg == 0x01) /* The IT  is in CR1 register */
00001a  2d01              CMP      r5,#1
00001c  d102              BNE      |L17.36|
;;;1104     {
;;;1105       itmask &= USARTx->CR1;
00001e  6816              LDR      r6,[r2,#0]
000020  4031              ANDS     r1,r1,r6
000022  e006              B        |L17.50|
                  |L17.36|
;;;1106     }
;;;1107     else if (usartreg == 0x02) /* The IT  is in CR2 register */
000024  2d02              CMP      r5,#2
000026  d102              BNE      |L17.46|
;;;1108     {
;;;1109       itmask &= USARTx->CR2;
000028  6856              LDR      r6,[r2,#4]
00002a  4031              ANDS     r1,r1,r6
00002c  e001              B        |L17.50|
                  |L17.46|
;;;1110     }
;;;1111     else /* The IT  is in CR3 register */
;;;1112     {
;;;1113       itmask &= USARTx->CR3;
00002e  6896              LDR      r6,[r2,#8]
000030  4031              ANDS     r1,r1,r6
                  |L17.50|
;;;1114     }
;;;1115     
;;;1116     bitpos = USART_IT >> 0x10;
000032  0c1c              LSRS     r4,r3,#16
;;;1117     bitpos = (uint32_t)0x01 << bitpos;
000034  2601              MOVS     r6,#1
000036  40a6              LSLS     r6,r6,r4
000038  4634              MOV      r4,r6
;;;1118     bitpos &= USARTx->ISR;
00003a  69d6              LDR      r6,[r2,#0x1c]
00003c  4034              ANDS     r4,r4,r6
;;;1119     if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
00003e  2900              CMP      r1,#0
000040  d003              BEQ      |L17.74|
000042  2c00              CMP      r4,#0
000044  d001              BEQ      |L17.74|
;;;1120     {
;;;1121       bitstatus = SET;
000046  2001              MOVS     r0,#1
000048  e000              B        |L17.76|
                  |L17.74|
;;;1122     }
;;;1123     else
;;;1124     {
;;;1125       bitstatus = RESET;
00004a  2000              MOVS     r0,#0
                  |L17.76|
;;;1126     }
;;;1127     
;;;1128     return bitstatus;  
;;;1129   }
00004c  bd70              POP      {r4-r6,pc}
;;;1130   
                          ENDP


                          AREA ||i.USART_HalfDuplexCmd||, CODE, READONLY, ALIGN=1

                  USART_HalfDuplexCmd PROC
;;;699      */
;;;700    void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;701    {
;;;702      /* Check the parameters */
;;;703      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;704      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;705      
;;;706      if (NewState != DISABLE)
000002  d004              BEQ      |L18.14|
;;;707      {
;;;708        /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;709        USARTx->CR3 |= USART_CR3_HDSEL;
000004  6882              LDR      r2,[r0,#8]
000006  2308              MOVS     r3,#8
000008  431a              ORRS     r2,r2,r3
00000a  6082              STR      r2,[r0,#8]
00000c  e003              B        |L18.22|
                  |L18.14|
;;;710      }
;;;711      else
;;;712      {
;;;713        /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
;;;714        USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_HDSEL);
00000e  6882              LDR      r2,[r0,#8]
000010  2308              MOVS     r3,#8
000012  439a              BICS     r2,r2,r3
000014  6082              STR      r2,[r0,#8]
                  |L18.22|
;;;715      }
;;;716    }
000016  4770              BX       lr
;;;717    
                          ENDP


                          AREA ||i.USART_ITConfig||, CODE, READONLY, ALIGN=1

                  USART_ITConfig PROC
;;;884      */
;;;885    void USART_ITConfig(USART_TypeDef* USARTx, uint32_t USART_IT, FunctionalState NewState)
000000  b5f8              PUSH     {r3-r7,lr}
;;;886    {
000002  4603              MOV      r3,r0
;;;887      uint32_t usartreg = 0, itpos = 0, itmask = 0;
000004  2400              MOVS     r4,#0
000006  2600              MOVS     r6,#0
000008  9600              STR      r6,[sp,#0]
00000a  2500              MOVS     r5,#0
;;;888      uint32_t usartxbase = 0;
00000c  2000              MOVS     r0,#0
;;;889      /* Check the parameters */
;;;890      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;891      assert_param(IS_USART_CONFIG_IT(USART_IT));
;;;892      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;893      
;;;894      usartxbase = (uint32_t)USARTx;
00000e  4618              MOV      r0,r3
;;;895      
;;;896      /* Get the USART register index */
;;;897      usartreg = (((uint16_t)USART_IT) >> 0x08);
000010  040e              LSLS     r6,r1,#16
000012  0e34              LSRS     r4,r6,#24
;;;898      
;;;899      /* Get the interrupt position */
;;;900      itpos = USART_IT & IT_MASK;
000014  b2ce              UXTB     r6,r1
000016  9600              STR      r6,[sp,#0]
;;;901      itmask = (((uint32_t)0x01) << itpos);
000018  2701              MOVS     r7,#1
00001a  9e00              LDR      r6,[sp,#0]
00001c  40b7              LSLS     r7,r7,r6
00001e  463d              MOV      r5,r7
;;;902      
;;;903      if (usartreg == 0x02) /* The IT is in CR2 register */
000020  2c02              CMP      r4,#2
000022  d101              BNE      |L19.40|
;;;904      {
;;;905        usartxbase += 0x04;
000024  1d00              ADDS     r0,r0,#4
000026  e002              B        |L19.46|
                  |L19.40|
;;;906      }
;;;907      else if (usartreg == 0x03) /* The IT is in CR3 register */
000028  2c03              CMP      r4,#3
00002a  d100              BNE      |L19.46|
;;;908      {
;;;909        usartxbase += 0x08;
00002c  3008              ADDS     r0,r0,#8
                  |L19.46|
;;;910      }
;;;911      else /* The IT is in CR1 register */
;;;912      {
;;;913      }
;;;914      if (NewState != DISABLE)
00002e  2a00              CMP      r2,#0
000030  d003              BEQ      |L19.58|
;;;915      {
;;;916        *(__IO uint32_t*)usartxbase  |= itmask;
000032  6806              LDR      r6,[r0,#0]
000034  432e              ORRS     r6,r6,r5
000036  6006              STR      r6,[r0,#0]
000038  e002              B        |L19.64|
                  |L19.58|
;;;917      }
;;;918      else
;;;919      {
;;;920        *(__IO uint32_t*)usartxbase &= ~itmask;
00003a  6806              LDR      r6,[r0,#0]
00003c  43ae              BICS     r6,r6,r5
00003e  6006              STR      r6,[r0,#0]
                  |L19.64|
;;;921      }
;;;922    }
000040  bdf8              POP      {r3-r7,pc}
;;;923    
                          ENDP


                          AREA ||i.USART_Init||, CODE, READONLY, ALIGN=2

                  USART_Init PROC
;;;74       */
;;;75     void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
000000  b5f0              PUSH     {r4-r7,lr}
;;;76     {
000002  b08b              SUB      sp,sp,#0x2c
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;77       uint32_t divider = 0, apbclock = 0, tmpreg = 0;
000008  2700              MOVS     r7,#0
00000a  2000              MOVS     r0,#0
00000c  900a              STR      r0,[sp,#0x28]
00000e  2600              MOVS     r6,#0
;;;78       RCC_ClocksTypeDef RCC_ClocksStatus;
;;;79       
;;;80       /* Check the parameters */
;;;81       assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;82       assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));  
;;;83       assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
;;;84       assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
;;;85       assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
;;;86       assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
;;;87       assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
;;;88       
;;;89       /* Disable USART */
;;;90       USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_UE);
000010  6820              LDR      r0,[r4,#0]
000012  0840              LSRS     r0,r0,#1
000014  0040              LSLS     r0,r0,#1
000016  6020              STR      r0,[r4,#0]
;;;91       
;;;92       /*---------------------------- USART CR2 Configuration -----------------------*/
;;;93       tmpreg = USARTx->CR2;
000018  6866              LDR      r6,[r4,#4]
;;;94       /* Clear STOP[13:12] bits */
;;;95       tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
00001a  2103              MOVS     r1,#3
00001c  0309              LSLS     r1,r1,#12
00001e  4630              MOV      r0,r6
000020  4388              BICS     r0,r0,r1
000022  4606              MOV      r6,r0
;;;96       
;;;97       /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
;;;98       /* Set STOP[13:12] bits according to USART_StopBits value */
;;;99       tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
000024  68a8              LDR      r0,[r5,#8]
000026  4306              ORRS     r6,r6,r0
;;;100      
;;;101      /* Write to USART CR2 */
;;;102      USARTx->CR2 = tmpreg;
000028  6066              STR      r6,[r4,#4]
;;;103      
;;;104      /*---------------------------- USART CR1 Configuration -----------------------*/
;;;105      tmpreg = USARTx->CR1;
00002a  6826              LDR      r6,[r4,#0]
;;;106      /* Clear M, PCE, PS, TE and RE bits */
;;;107      tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
00002c  4828              LDR      r0,|L20.208|
00002e  4006              ANDS     r6,r6,r0
;;;108      
;;;109      /* Configure the USART Word Length, Parity and mode ----------------------- */
;;;110      /* Set the M bits according to USART_WordLength value */
;;;111      /* Set PCE and PS bits according to USART_Parity value */
;;;112      /* Set TE and RE bits according to USART_Mode value */
;;;113      tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
000030  68e9              LDR      r1,[r5,#0xc]
000032  6868              LDR      r0,[r5,#4]
000034  4308              ORRS     r0,r0,r1
000036  6929              LDR      r1,[r5,#0x10]
000038  4308              ORRS     r0,r0,r1
00003a  4306              ORRS     r6,r6,r0
;;;114        USART_InitStruct->USART_Mode;
;;;115      
;;;116      /* Write to USART CR1 */
;;;117      USARTx->CR1 = tmpreg;
00003c  6026              STR      r6,[r4,#0]
;;;118      
;;;119      /*---------------------------- USART CR3 Configuration -----------------------*/  
;;;120      tmpreg = USARTx->CR3;
00003e  68a6              LDR      r6,[r4,#8]
;;;121      /* Clear CTSE and RTSE bits */
;;;122      tmpreg &= (uint32_t)~((uint32_t)CR3_CLEAR_MASK);
000040  2103              MOVS     r1,#3
000042  0209              LSLS     r1,r1,#8
000044  4630              MOV      r0,r6
000046  4388              BICS     r0,r0,r1
000048  4606              MOV      r6,r0
;;;123      
;;;124      /* Configure the USART HFC -------------------------------------------------*/
;;;125      /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
;;;126      tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
00004a  6968              LDR      r0,[r5,#0x14]
00004c  4306              ORRS     r6,r6,r0
;;;127      
;;;128      /* Write to USART CR3 */
;;;129      USARTx->CR3 = tmpreg;
00004e  60a6              STR      r6,[r4,#8]
;;;130      
;;;131      /*---------------------------- USART BRR Configuration -----------------------*/
;;;132      /* Configure the USART Baud Rate -------------------------------------------*/
;;;133      RCC_GetClocksFreq(&RCC_ClocksStatus);
000050  4668              MOV      r0,sp
000052  f7fffffe          BL       RCC_GetClocksFreq
;;;134      
;;;135      if (USARTx == USART1)
000056  481f              LDR      r0,|L20.212|
000058  4284              CMP      r4,r0
00005a  d102              BNE      |L20.98|
;;;136      {
;;;137        apbclock = RCC_ClocksStatus.USART1CLK_Frequency;
00005c  9806              LDR      r0,[sp,#0x18]
00005e  900a              STR      r0,[sp,#0x28]
000060  e004              B        |L20.108|
                  |L20.98|
;;;138      }
;;;139      else if (USARTx == USART2)
000062  481d              LDR      r0,|L20.216|
000064  4284              CMP      r4,r0
000066  d101              BNE      |L20.108|
;;;140      {
;;;141        apbclock = RCC_ClocksStatus.USART2CLK_Frequency;
000068  9807              LDR      r0,[sp,#0x1c]
00006a  900a              STR      r0,[sp,#0x28]
                  |L20.108|
;;;142      }
;;;143      
;;;144      /* Determine the integer part */
;;;145      if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
00006c  6820              LDR      r0,[r4,#0]
00006e  2101              MOVS     r1,#1
000070  03c9              LSLS     r1,r1,#15
000072  4008              ANDS     r0,r0,r1
000074  2800              CMP      r0,#0
000076  d00c              BEQ      |L20.146|
;;;146      {
;;;147        /* (divider * 10) computing in case Oversampling mode is 8 Samples */
;;;148        divider = (uint32_t)((2 * apbclock) / (USART_InitStruct->USART_BaudRate));
000078  6829              LDR      r1,[r5,#0]
00007a  9a0a              LDR      r2,[sp,#0x28]
00007c  0050              LSLS     r0,r2,#1
00007e  f7fffffe          BL       __aeabi_uidivmod
000082  4607              MOV      r7,r0
;;;149        tmpreg  = (uint32_t)((2 * apbclock) % (USART_InitStruct->USART_BaudRate));
000084  6829              LDR      r1,[r5,#0]
000086  9a0a              LDR      r2,[sp,#0x28]
000088  0050              LSLS     r0,r2,#1
00008a  f7fffffe          BL       __aeabi_uidivmod
00008e  460e              MOV      r6,r1
000090  e009              B        |L20.166|
                  |L20.146|
;;;150      }
;;;151      else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
;;;152      {
;;;153        /* (divider * 10) computing in case Oversampling mode is 16 Samples */
;;;154        divider = (uint32_t)((apbclock) / (USART_InitStruct->USART_BaudRate));
000092  6829              LDR      r1,[r5,#0]
000094  980a              LDR      r0,[sp,#0x28]
000096  f7fffffe          BL       __aeabi_uidivmod
00009a  4607              MOV      r7,r0
;;;155        tmpreg  = (uint32_t)((apbclock) % (USART_InitStruct->USART_BaudRate));
00009c  6829              LDR      r1,[r5,#0]
00009e  980a              LDR      r0,[sp,#0x28]
0000a0  f7fffffe          BL       __aeabi_uidivmod
0000a4  460e              MOV      r6,r1
                  |L20.166|
;;;156      }
;;;157      
;;;158      /* round the divider : if fractional part i greater than 0.5 increment divider */
;;;159      if (tmpreg >=  (USART_InitStruct->USART_BaudRate) / 2)
0000a6  6828              LDR      r0,[r5,#0]
0000a8  0840              LSRS     r0,r0,#1
0000aa  42b0              CMP      r0,r6
0000ac  d800              BHI      |L20.176|
;;;160      {
;;;161        divider++;
0000ae  1c7f              ADDS     r7,r7,#1
                  |L20.176|
;;;162      } 
;;;163      
;;;164      /* Implement the divider in case Oversampling mode is 8 Samples */
;;;165      if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
0000b0  6820              LDR      r0,[r4,#0]
0000b2  2101              MOVS     r1,#1
0000b4  03c9              LSLS     r1,r1,#15
0000b6  4008              ANDS     r0,r0,r1
0000b8  2800              CMP      r0,#0
0000ba  d006              BEQ      |L20.202|
;;;166      {
;;;167        /* get the LSB of divider and shift it to the right by 1 bit */
;;;168        tmpreg = (divider & (uint16_t)0x000F) >> 1;
0000bc  0738              LSLS     r0,r7,#28
0000be  0f46              LSRS     r6,r0,#29
;;;169        
;;;170        /* update the divider value */
;;;171        divider = (divider & (uint16_t)0xFFF0) | tmpreg;
0000c0  4638              MOV      r0,r7
0000c2  4906              LDR      r1,|L20.220|
0000c4  4008              ANDS     r0,r0,r1
0000c6  4330              ORRS     r0,r0,r6
0000c8  4607              MOV      r7,r0
                  |L20.202|
;;;172      }
;;;173      
;;;174      /* Write to USART BRR */
;;;175      USARTx->BRR = (uint16_t)divider;
0000ca  81a7              STRH     r7,[r4,#0xc]
;;;176    }
0000cc  b00b              ADD      sp,sp,#0x2c
0000ce  bdf0              POP      {r4-r7,pc}
;;;177    
                          ENDP

                  |L20.208|
                          DCD      0xffffe9f3
                  |L20.212|
                          DCD      0x40013800
                  |L20.216|
                          DCD      0x40004400
                  |L20.220|
                          DCD      0x0000fff0

                          AREA ||i.USART_InvPinCmd||, CODE, READONLY, ALIGN=1

                  USART_InvPinCmd PROC
;;;428      */
;;;429    void USART_InvPinCmd(USART_TypeDef* USARTx, uint32_t USART_InvPin, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;430    {
;;;431      /* Check the parameters */
;;;432      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;433      assert_param(IS_USART_INVERSTION_PIN(USART_InvPin));  
;;;434      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;435    
;;;436      if (NewState != DISABLE)
000002  d003              BEQ      |L21.12|
;;;437      {
;;;438        /* Enable the active level inversion for selected pins by setting the TXINV 
;;;439           and/or RXINV bits in the USART CR2 register */
;;;440        USARTx->CR2 |= USART_InvPin;
000004  6843              LDR      r3,[r0,#4]
000006  430b              ORRS     r3,r3,r1
000008  6043              STR      r3,[r0,#4]
00000a  e002              B        |L21.18|
                  |L21.12|
;;;441      }
;;;442      else
;;;443      {
;;;444        /* Disable the active level inversion for selected requests by clearing the 
;;;445           TXINV and/or RXINV bits in the USART CR2 register */
;;;446        USARTx->CR2 &= (uint32_t)~USART_InvPin;
00000c  6843              LDR      r3,[r0,#4]
00000e  438b              BICS     r3,r3,r1
000010  6043              STR      r3,[r0,#4]
                  |L21.18|
;;;447      }
;;;448    }
000012  4770              BX       lr
;;;449    
                          ENDP


                          AREA ||i.USART_MSBFirstCmd||, CODE, READONLY, ALIGN=1

                  USART_MSBFirstCmd PROC
;;;362      */
;;;363    void USART_MSBFirstCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;364    {
;;;365      /* Check the parameters */
;;;366      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;367      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;368      
;;;369      if (NewState != DISABLE)
000002  d005              BEQ      |L22.16|
;;;370      {
;;;371        /* Enable the most significant bit first transmitted/received following the 
;;;372           start bit by setting the MSBFIRST bit in the CR2 register */
;;;373        USARTx->CR2 |= USART_CR2_MSBFIRST;
000004  6842              LDR      r2,[r0,#4]
000006  2301              MOVS     r3,#1
000008  04db              LSLS     r3,r3,#19
00000a  431a              ORRS     r2,r2,r3
00000c  6042              STR      r2,[r0,#4]
00000e  e004              B        |L22.26|
                  |L22.16|
;;;374      }
;;;375      else
;;;376      {
;;;377        /* Disable the most significant bit first transmitted/received following the 
;;;378           start bit by clearing the MSBFIRST bit in the CR2 register */
;;;379        USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_MSBFIRST);
000010  6842              LDR      r2,[r0,#4]
000012  2301              MOVS     r3,#1
000014  04db              LSLS     r3,r3,#19
000016  439a              BICS     r2,r2,r3
000018  6042              STR      r2,[r0,#4]
                  |L22.26|
;;;380      }
;;;381    }
00001a  4770              BX       lr
;;;382    
                          ENDP


                          AREA ||i.USART_MuteModeCmd||, CODE, READONLY, ALIGN=1

                  USART_MuteModeCmd PROC
;;;633      */
;;;634    void USART_MuteModeCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;635    {
;;;636      /* Check the parameters */
;;;637      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;638      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;639      
;;;640      if (NewState != DISABLE)
000002  d005              BEQ      |L23.16|
;;;641      {
;;;642        /* Enable the USART mute mode by setting the MME bit in the CR1 register */
;;;643        USARTx->CR1 |= USART_CR1_MME;
000004  6802              LDR      r2,[r0,#0]
000006  2301              MOVS     r3,#1
000008  035b              LSLS     r3,r3,#13
00000a  431a              ORRS     r2,r2,r3
00000c  6002              STR      r2,[r0,#0]
00000e  e004              B        |L23.26|
                  |L23.16|
;;;644      }
;;;645      else
;;;646      {
;;;647        /* Disable the USART mute mode by clearing the MME bit in the CR1 register */
;;;648        USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_MME);
000010  6802              LDR      r2,[r0,#0]
000012  2301              MOVS     r3,#1
000014  035b              LSLS     r3,r3,#13
000016  439a              BICS     r2,r2,r3
000018  6002              STR      r2,[r0,#0]
                  |L23.26|
;;;649      }
;;;650    }
00001a  4770              BX       lr
;;;651    
                          ENDP


                          AREA ||i.USART_MuteModeWakeUpConfig||, CODE, READONLY, ALIGN=1

                  USART_MuteModeWakeUpConfig PROC
;;;660      */
;;;661    void USART_MuteModeWakeUpConfig(USART_TypeDef* USARTx, uint32_t USART_WakeUp)
000000  6802              LDR      r2,[r0,#0]
;;;662    {
;;;663      /* Check the parameters */
;;;664      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;665      assert_param(IS_USART_MUTEMODE_WAKEUP(USART_WakeUp));
;;;666    
;;;667      USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_WAKE);
000002  2301              MOVS     r3,#1
000004  02db              LSLS     r3,r3,#11
000006  439a              BICS     r2,r2,r3
000008  6002              STR      r2,[r0,#0]
;;;668      USARTx->CR1 |= USART_WakeUp;
00000a  6802              LDR      r2,[r0,#0]
00000c  430a              ORRS     r2,r2,r1
00000e  6002              STR      r2,[r0,#0]
;;;669    }
000010  4770              BX       lr
;;;670    
                          ENDP


                          AREA ||i.USART_OneBitMethodCmd||, CODE, READONLY, ALIGN=1

                  USART_OneBitMethodCmd PROC
;;;334      */
;;;335    void USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;336    {
;;;337      /* Check the parameters */
;;;338      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;339      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;340      
;;;341      if (NewState != DISABLE)
000002  d005              BEQ      |L25.16|
;;;342      {
;;;343        /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
;;;344        USARTx->CR3 |= USART_CR3_ONEBIT;
000004  6882              LDR      r2,[r0,#8]
000006  2301              MOVS     r3,#1
000008  02db              LSLS     r3,r3,#11
00000a  431a              ORRS     r2,r2,r3
00000c  6082              STR      r2,[r0,#8]
00000e  e004              B        |L25.26|
                  |L25.16|
;;;345      }
;;;346      else
;;;347      {
;;;348        /* Disable the one bit method by clearing the ONEBITE bit in the CR3 register */
;;;349        USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_ONEBIT);
000010  6882              LDR      r2,[r0,#8]
000012  2301              MOVS     r3,#1
000014  02db              LSLS     r3,r3,#11
000016  439a              BICS     r2,r2,r3
000018  6082              STR      r2,[r0,#8]
                  |L25.26|
;;;350      }
;;;351    }
00001a  4770              BX       lr
;;;352    
                          ENDP


                          AREA ||i.USART_OverSampling8Cmd||, CODE, READONLY, ALIGN=1

                  USART_OverSampling8Cmd PROC
;;;308      */
;;;309    void USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;310    {
;;;311      /* Check the parameters */
;;;312      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;313      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;314      
;;;315      if (NewState != DISABLE)
000002  d005              BEQ      |L26.16|
;;;316      {
;;;317        /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
;;;318        USARTx->CR1 |= USART_CR1_OVER8;
000004  6802              LDR      r2,[r0,#0]
000006  2301              MOVS     r3,#1
000008  03db              LSLS     r3,r3,#15
00000a  431a              ORRS     r2,r2,r3
00000c  6002              STR      r2,[r0,#0]
00000e  e004              B        |L26.26|
                  |L26.16|
;;;319      }
;;;320      else
;;;321      {
;;;322        /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */
;;;323        USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_OVER8);
000010  6802              LDR      r2,[r0,#0]
000012  2301              MOVS     r3,#1
000014  03db              LSLS     r3,r3,#15
000016  439a              BICS     r2,r2,r3
000018  6002              STR      r2,[r0,#0]
                  |L26.26|
;;;324      }
;;;325    }  
00001a  4770              BX       lr
;;;326    
                          ENDP


                          AREA ||i.USART_OverrunDetectionConfig||, CODE, READONLY, ALIGN=1

                  USART_OverrunDetectionConfig PROC
;;;969      */
;;;970    void USART_OverrunDetectionConfig(USART_TypeDef* USARTx, uint32_t USART_OVRDetection)
000000  6882              LDR      r2,[r0,#8]
;;;971    {
;;;972      /* Check the parameters */
;;;973      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;974      assert_param(IS_USART_OVRDETECTION(USART_OVRDetection));
;;;975      
;;;976      /* Clear the OVR detection bit */
;;;977      USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_OVRDIS);
000002  2301              MOVS     r3,#1
000004  031b              LSLS     r3,r3,#12
000006  439a              BICS     r2,r2,r3
000008  6082              STR      r2,[r0,#8]
;;;978      /* Set the new value for the OVR detection bit */
;;;979      USARTx->CR3 |= USART_OVRDetection;
00000a  6882              LDR      r2,[r0,#8]
00000c  430a              ORRS     r2,r2,r1
00000e  6082              STR      r2,[r0,#8]
;;;980    }
000010  4770              BX       lr
;;;981    
                          ENDP


                          AREA ||i.USART_ReceiveData||, CODE, READONLY, ALIGN=1

                  USART_ReceiveData PROC
;;;597      */
;;;598    uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
000000  4601              MOV      r1,r0
;;;599    {
;;;600      /* Check the parameters */
;;;601      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;602      
;;;603      /* Receive Data */
;;;604      return (uint16_t)(USARTx->RDR & (uint16_t)0x01FF);
000002  8c88              LDRH     r0,[r1,#0x24]
000004  05c0              LSLS     r0,r0,#23
000006  0dc0              LSRS     r0,r0,#23
;;;605    }
000008  4770              BX       lr
;;;606    
                          ENDP


                          AREA ||i.USART_ReceiverTimeOutCmd||, CODE, READONLY, ALIGN=1

                  USART_ReceiverTimeOutCmd PROC
;;;484      */
;;;485    void USART_ReceiverTimeOutCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;486    {
;;;487      /* Check the parameters */
;;;488      assert_param(IS_USART_123_PERIPH(USARTx));
;;;489      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;490    
;;;491      if (NewState != DISABLE)
000002  d005              BEQ      |L29.16|
;;;492      {
;;;493        /* Enable the receiver time out feature by setting the RTOEN bit in the CR2 
;;;494           register */
;;;495        USARTx->CR2 |= USART_CR2_RTOEN;
000004  6842              LDR      r2,[r0,#4]
000006  2301              MOVS     r3,#1
000008  05db              LSLS     r3,r3,#23
00000a  431a              ORRS     r2,r2,r3
00000c  6042              STR      r2,[r0,#4]
00000e  e004              B        |L29.26|
                  |L29.16|
;;;496      }
;;;497      else
;;;498      {
;;;499        /* Disable the receiver time out feature by clearing the RTOEN bit in the CR2 
;;;500           register */
;;;501        USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_RTOEN);
000010  6842              LDR      r2,[r0,#4]
000012  2301              MOVS     r3,#1
000014  05db              LSLS     r3,r3,#23
000016  439a              BICS     r2,r2,r3
000018  6042              STR      r2,[r0,#4]
                  |L29.26|
;;;502      }
;;;503    }
00001a  4770              BX       lr
;;;504    
                          ENDP


                          AREA ||i.USART_RequestCmd||, CODE, READONLY, ALIGN=1

                  USART_RequestCmd PROC
;;;937      */
;;;938    void USART_RequestCmd(USART_TypeDef* USARTx, uint32_t USART_Request, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;939    {
;;;940      /* Check the parameters */
;;;941      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;942      assert_param(IS_USART_REQUEST(USART_Request));
;;;943      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;944    
;;;945      if (NewState != DISABLE)
000002  d003              BEQ      |L30.12|
;;;946      {
;;;947        /* Enable the USART ReQuest by setting the dedicated request bit in the RQR
;;;948           register.*/
;;;949          USARTx->RQR |= USART_Request;
000004  8b03              LDRH     r3,[r0,#0x18]
000006  430b              ORRS     r3,r3,r1
000008  8303              STRH     r3,[r0,#0x18]
00000a  e002              B        |L30.18|
                  |L30.12|
;;;950      }
;;;951      else
;;;952      {
;;;953        /* Disable the USART ReQuest by clearing the dedicated request bit in the RQR
;;;954           register.*/
;;;955        USARTx->RQR &= (uint32_t)~USART_Request;
00000c  8b03              LDRH     r3,[r0,#0x18]
00000e  438b              BICS     r3,r3,r1
000010  8303              STRH     r3,[r0,#0x18]
                  |L30.18|
;;;956      }
;;;957    }
000012  4770              BX       lr
;;;958    
                          ENDP


                          AREA ||i.USART_SWAPPinCmd||, CODE, READONLY, ALIGN=1

                  USART_SWAPPinCmd PROC
;;;459      */
;;;460    void USART_SWAPPinCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;461    {
;;;462      /* Check the parameters */
;;;463      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;464      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;465    
;;;466      if (NewState != DISABLE)
000002  d005              BEQ      |L31.16|
;;;467      {
;;;468        /* Enable the SWAP feature by setting the SWAP bit in the CR2 register */
;;;469        USARTx->CR2 |= USART_CR2_SWAP;
000004  6842              LDR      r2,[r0,#4]
000006  2301              MOVS     r3,#1
000008  03db              LSLS     r3,r3,#15
00000a  431a              ORRS     r2,r2,r3
00000c  6042              STR      r2,[r0,#4]
00000e  e004              B        |L31.26|
                  |L31.16|
;;;470      }
;;;471      else
;;;472      {
;;;473        /* Disable the SWAP feature by clearing the SWAP bit in the CR2 register */
;;;474        USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_SWAP);
000010  6842              LDR      r2,[r0,#4]
000012  2301              MOVS     r3,#1
000014  03db              LSLS     r3,r3,#15
000016  439a              BICS     r2,r2,r3
000018  6042              STR      r2,[r0,#4]
                  |L31.26|
;;;475      }
;;;476    }
00001a  4770              BX       lr
;;;477    
                          ENDP


                          AREA ||i.USART_SendData||, CODE, READONLY, ALIGN=1

                  USART_SendData PROC
;;;582      */
;;;583    void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
000000  05ca              LSLS     r2,r1,#23
;;;584    {
;;;585      /* Check the parameters */
;;;586      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;587      assert_param(IS_USART_DATA(Data)); 
;;;588        
;;;589      /* Transmit Data */
;;;590      USARTx->TDR = (Data & (uint16_t)0x01FF);
000002  0dd2              LSRS     r2,r2,#23
000004  8502              STRH     r2,[r0,#0x28]
;;;591    }
000006  4770              BX       lr
;;;592    
                          ENDP


                          AREA ||i.USART_SetAddress||, CODE, READONLY, ALIGN=1

                  USART_SetAddress PROC
;;;615      */
;;;616    void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address)
000000  6842              LDR      r2,[r0,#4]
;;;617    {
;;;618      /* Check the parameters */
;;;619      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;620      
;;;621      /* Clear the USART address */
;;;622      USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_ADD);
000002  0212              LSLS     r2,r2,#8
000004  0a12              LSRS     r2,r2,#8
000006  6042              STR      r2,[r0,#4]
;;;623      /* Set the USART address node */
;;;624      USARTx->CR2 |=((uint32_t)USART_Address << (uint32_t)0x18);
000008  6842              LDR      r2,[r0,#4]
00000a  060b              LSLS     r3,r1,#24
00000c  431a              ORRS     r2,r2,r3
00000e  6042              STR      r2,[r0,#4]
;;;625    }
000010  4770              BX       lr
;;;626    
                          ENDP


                          AREA ||i.USART_SetDEAssertionTime||, CODE, READONLY, ALIGN=1

                  USART_SetDEAssertionTime PROC
;;;770      */
;;;771    void USART_SetDEAssertionTime(USART_TypeDef* USARTx, uint32_t USART_DEAssertionTime)
000000  6802              LDR      r2,[r0,#0]
;;;772    {
;;;773      /* Check the parameters */
;;;774      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;775      assert_param(IS_USART_DE_ASSERTION_DEASSERTION_TIME(USART_DEAssertionTime)); 
;;;776    
;;;777      /* Clear the DE assertion time */
;;;778      USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_DEAT);
000002  231f              MOVS     r3,#0x1f
000004  055b              LSLS     r3,r3,#21
000006  439a              BICS     r2,r2,r3
000008  6002              STR      r2,[r0,#0]
;;;779      /* Set the new value for the DE assertion time */
;;;780      USARTx->CR1 |=((uint32_t)USART_DEAssertionTime << (uint32_t)0x15);
00000a  6802              LDR      r2,[r0,#0]
00000c  054b              LSLS     r3,r1,#21
00000e  431a              ORRS     r2,r2,r3
000010  6002              STR      r2,[r0,#0]
;;;781    }
000012  4770              BX       lr
;;;782    
                          ENDP


                          AREA ||i.USART_SetDEDeassertionTime||, CODE, READONLY, ALIGN=1

                  USART_SetDEDeassertionTime PROC
;;;789      */
;;;790    void USART_SetDEDeassertionTime(USART_TypeDef* USARTx, uint32_t USART_DEDeassertionTime)
000000  6802              LDR      r2,[r0,#0]
;;;791    {
;;;792      /* Check the parameters */
;;;793      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;794      assert_param(IS_USART_DE_ASSERTION_DEASSERTION_TIME(USART_DEDeassertionTime)); 
;;;795    
;;;796      /* Clear the DE deassertion time */
;;;797      USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_DEDT);
000002  231f              MOVS     r3,#0x1f
000004  041b              LSLS     r3,r3,#16
000006  439a              BICS     r2,r2,r3
000008  6002              STR      r2,[r0,#0]
;;;798      /* Set the new value for the DE deassertion time */
;;;799      USARTx->CR1 |=((uint32_t)USART_DEDeassertionTime << (uint32_t)0x10);
00000a  6802              LDR      r2,[r0,#0]
00000c  040b              LSLS     r3,r1,#16
00000e  431a              ORRS     r2,r2,r3
000010  6002              STR      r2,[r0,#0]
;;;800    }
000012  4770              BX       lr
;;;801    
                          ENDP


                          AREA ||i.USART_SetReceiverTimeOut||, CODE, READONLY, ALIGN=1

                  USART_SetReceiverTimeOut PROC
;;;510      */
;;;511    void USART_SetReceiverTimeOut(USART_TypeDef* USARTx, uint32_t USART_ReceiverTimeOut)
000000  6942              LDR      r2,[r0,#0x14]
;;;512    {    
;;;513      /* Check the parameters */
;;;514      assert_param(IS_USART_123_PERIPH(USARTx));
;;;515      assert_param(IS_USART_TIMEOUT(USART_ReceiverTimeOut));
;;;516    
;;;517      /* Clear the receiver Time Out value by clearing the RTO[23:0] bits in the RTOR
;;;518         register  */
;;;519      USARTx->RTOR &= (uint32_t)~((uint32_t)USART_RTOR_RTO);
000002  0e12              LSRS     r2,r2,#24
000004  0612              LSLS     r2,r2,#24
000006  6142              STR      r2,[r0,#0x14]
;;;520      /* Set the receiver Time Out value by setting the RTO[23:0] bits in the RTOR
;;;521         register  */
;;;522      USARTx->RTOR |= USART_ReceiverTimeOut;
000008  6942              LDR      r2,[r0,#0x14]
00000a  430a              ORRS     r2,r2,r1
00000c  6142              STR      r2,[r0,#0x14]
;;;523    }
00000e  4770              BX       lr
;;;524    /**
                          ENDP


                          AREA ||i.USART_StructInit||, CODE, READONLY, ALIGN=1

                  USART_StructInit PROC
;;;183      */
;;;184    void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
000000  214b              MOVS     r1,#0x4b
;;;185    {
;;;186      /* USART_InitStruct members default value */
;;;187      USART_InitStruct->USART_BaudRate = 9600;
000002  01c9              LSLS     r1,r1,#7
000004  6001              STR      r1,[r0,#0]
;;;188      USART_InitStruct->USART_WordLength = USART_WordLength_8b;
000006  2100              MOVS     r1,#0
000008  6041              STR      r1,[r0,#4]
;;;189      USART_InitStruct->USART_StopBits = USART_StopBits_1;
00000a  6081              STR      r1,[r0,#8]
;;;190      USART_InitStruct->USART_Parity = USART_Parity_No ;
00000c  60c1              STR      r1,[r0,#0xc]
;;;191      USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00000e  210c              MOVS     r1,#0xc
000010  6101              STR      r1,[r0,#0x10]
;;;192      USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
000012  2100              MOVS     r1,#0
000014  6141              STR      r1,[r0,#0x14]
;;;193    }
000016  4770              BX       lr
;;;194    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\FTLib\\Src\\ft32f0xx_usart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_ft32f0xx_usart_c_9565154b____REV16|
#line 129 "..\\FTLib\\CMSIS\\inc\\core_cmInstr.h"
|__asm___16_ft32f0xx_usart_c_9565154b____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_ft32f0xx_usart_c_9565154b____REVSH|
#line 144
|__asm___16_ft32f0xx_usart_c_9565154b____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
