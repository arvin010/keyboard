; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\ft32f0xx_rcc.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\ft32f0xx_rcc.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\FTLib\CMSIS\inc -I..\FTLib\Inc -I..\FTLib\Lib -I..\usb\inc -I..\user -I..\RTT -I.\RTE\_Keyboard -IC:\Users\Reidgjiao\AppData\Local\Arm\Packs\FMD\FT32F0xx_DFP\1.0.6\Drivers\CMSIS\FT32F0xx\Include -IC:\Keil_v5-MDK\ARM\CMSIS\Include -D__UVISION_VERSION=529 -DFT32F072x8 -DFT32F072x8 --omf_browse=.\objects\ft32f0xx_rcc.crf ..\FTLib\Src\ft32f0xx_rcc.c]
                          THUMB

                          AREA ||i.RCC_ADCCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_ADCCLKConfig PROC
;;;682      */
;;;683    void RCC_ADCCLKConfig(uint32_t RCC_ADCCLK)
000000  490c              LDR      r1,|L1.52|
;;;684    { 
;;;685      /* Check the parameters */
;;;686      assert_param(IS_RCC_ADCCLK(RCC_ADCCLK));
;;;687    
;;;688      /* Clear ADCPRE bit */
;;;689      RCC->CFGR &= ~RCC_CFGR_ADCPRE;
000002  6849              LDR      r1,[r1,#4]
000004  2201              MOVS     r2,#1
000006  0392              LSLS     r2,r2,#14
000008  4391              BICS     r1,r1,r2
00000a  4a0a              LDR      r2,|L1.52|
00000c  6051              STR      r1,[r2,#4]
;;;690      /* Set ADCPRE bits according to RCC_PCLK value */
;;;691      RCC->CFGR |= RCC_ADCCLK & 0xFFFF;
00000e  4611              MOV      r1,r2
000010  6849              LDR      r1,[r1,#4]
000012  b282              UXTH     r2,r0
000014  4311              ORRS     r1,r1,r2
000016  4a07              LDR      r2,|L1.52|
000018  6051              STR      r1,[r2,#4]
;;;692    
;;;693      /* Clear ADCSW bit */
;;;694      RCC->CFGR3 &= ~RCC_CFGR3_ADCSW; 
00001a  4611              MOV      r1,r2
00001c  6b09              LDR      r1,[r1,#0x30]
00001e  1592              ASRS     r2,r2,#22
000020  4391              BICS     r1,r1,r2
000022  4a04              LDR      r2,|L1.52|
000024  6311              STR      r1,[r2,#0x30]
;;;695      /* Set ADCSW bits according to RCC_ADCCLK value */
;;;696      RCC->CFGR3 |= RCC_ADCCLK >> 16;  
000026  4611              MOV      r1,r2
000028  6b09              LDR      r1,[r1,#0x30]
00002a  0c02              LSRS     r2,r0,#16
00002c  4311              ORRS     r1,r1,r2
00002e  4a01              LDR      r2,|L1.52|
000030  6311              STR      r1,[r2,#0x30]
;;;697    }
000032  4770              BX       lr
;;;698    
                          ENDP

                  |L1.52|
                          DCD      0x40021000

                          AREA ||i.RCC_AHBPeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHBPeriphClockCmd PROC
;;;1102     */
;;;1103   void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1104   {
;;;1105     /* Check the parameters */
;;;1106     assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
;;;1107     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1108     
;;;1109     if (NewState != DISABLE)
000002  d005              BEQ      |L2.16|
;;;1110     {
;;;1111       RCC->AHBENR |= RCC_AHBPeriph;
000004  4a05              LDR      r2,|L2.28|
000006  6952              LDR      r2,[r2,#0x14]
000008  4302              ORRS     r2,r2,r0
00000a  4b04              LDR      r3,|L2.28|
00000c  615a              STR      r2,[r3,#0x14]
00000e  e004              B        |L2.26|
                  |L2.16|
;;;1112     }
;;;1113     else
;;;1114     {
;;;1115       RCC->AHBENR &= ~RCC_AHBPeriph;
000010  4a02              LDR      r2,|L2.28|
000012  6952              LDR      r2,[r2,#0x14]
000014  4382              BICS     r2,r2,r0
000016  4b01              LDR      r3,|L2.28|
000018  615a              STR      r2,[r3,#0x14]
                  |L2.26|
;;;1116     }
;;;1117   }
00001a  4770              BX       lr
;;;1118   
                          ENDP

                  |L2.28|
                          DCD      0x40021000

                          AREA ||i.RCC_AHBPeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHBPeriphResetCmd PROC
;;;1218     */
;;;1219   void RCC_AHBPeriphResetCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1220   {
;;;1221     /* Check the parameters */
;;;1222     assert_param(IS_RCC_AHB_RST_PERIPH(RCC_AHBPeriph));
;;;1223     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1224   
;;;1225     if (NewState != DISABLE)
000002  d005              BEQ      |L3.16|
;;;1226     {
;;;1227       RCC->AHBRSTR |= RCC_AHBPeriph;
000004  4a05              LDR      r2,|L3.28|
000006  6a92              LDR      r2,[r2,#0x28]
000008  4302              ORRS     r2,r2,r0
00000a  4b04              LDR      r3,|L3.28|
00000c  629a              STR      r2,[r3,#0x28]
00000e  e004              B        |L3.26|
                  |L3.16|
;;;1228     }
;;;1229     else
;;;1230     {
;;;1231       RCC->AHBRSTR &= ~RCC_AHBPeriph;
000010  4a02              LDR      r2,|L3.28|
000012  6a92              LDR      r2,[r2,#0x28]
000014  4382              BICS     r2,r2,r0
000016  4b01              LDR      r3,|L3.28|
000018  629a              STR      r2,[r3,#0x28]
                  |L3.26|
;;;1232     }
;;;1233   }
00001a  4770              BX       lr
;;;1234   
                          ENDP

                  |L3.28|
                          DCD      0x40021000

                          AREA ||i.RCC_APB1PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphClockCmd PROC
;;;1187     */
;;;1188   void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1189   {
;;;1190     /* Check the parameters */
;;;1191     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;1192     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1193   
;;;1194     if (NewState != DISABLE)
000002  d005              BEQ      |L4.16|
;;;1195     {
;;;1196       RCC->APB1ENR |= RCC_APB1Periph;
000004  4a05              LDR      r2,|L4.28|
000006  69d2              LDR      r2,[r2,#0x1c]
000008  4302              ORRS     r2,r2,r0
00000a  4b04              LDR      r3,|L4.28|
00000c  61da              STR      r2,[r3,#0x1c]
00000e  e004              B        |L4.26|
                  |L4.16|
;;;1197     }
;;;1198     else
;;;1199     {
;;;1200       RCC->APB1ENR &= ~RCC_APB1Periph;
000010  4a02              LDR      r2,|L4.28|
000012  69d2              LDR      r2,[r2,#0x1c]
000014  4382              BICS     r2,r2,r0
000016  4b01              LDR      r3,|L4.28|
000018  61da              STR      r2,[r3,#0x1c]
                  |L4.26|
;;;1201     }
;;;1202   }
00001a  4770              BX       lr
;;;1203   
                          ENDP

                  |L4.28|
                          DCD      0x40021000

                          AREA ||i.RCC_APB1PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphResetCmd PROC
;;;1297     */
;;;1298   void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1299   {
;;;1300     /* Check the parameters */
;;;1301     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;1302     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1303   
;;;1304     if (NewState != DISABLE)
000002  d005              BEQ      |L5.16|
;;;1305     {
;;;1306       RCC->APB1RSTR |= RCC_APB1Periph;
000004  4a05              LDR      r2,|L5.28|
000006  6912              LDR      r2,[r2,#0x10]
000008  4302              ORRS     r2,r2,r0
00000a  4b04              LDR      r3,|L5.28|
00000c  611a              STR      r2,[r3,#0x10]
00000e  e004              B        |L5.26|
                  |L5.16|
;;;1307     }
;;;1308     else
;;;1309     {
;;;1310       RCC->APB1RSTR &= ~RCC_APB1Periph;
000010  4a02              LDR      r2,|L5.28|
000012  6912              LDR      r2,[r2,#0x10]
000014  4382              BICS     r2,r2,r0
000016  4b01              LDR      r3,|L5.28|
000018  611a              STR      r2,[r3,#0x10]
                  |L5.26|
;;;1311     }
;;;1312   }
00001a  4770              BX       lr
;;;1313   
                          ENDP

                  |L5.28|
                          DCD      0x40021000

                          AREA ||i.RCC_APB2PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphClockCmd PROC
;;;1141     */
;;;1142   void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1143   {
;;;1144     /* Check the parameters */
;;;1145     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;1146     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1147   
;;;1148     if (NewState != DISABLE)
000002  d005              BEQ      |L6.16|
;;;1149     {
;;;1150       RCC->APB2ENR |= RCC_APB2Periph;
000004  4a05              LDR      r2,|L6.28|
000006  6992              LDR      r2,[r2,#0x18]
000008  4302              ORRS     r2,r2,r0
00000a  4b04              LDR      r3,|L6.28|
00000c  619a              STR      r2,[r3,#0x18]
00000e  e004              B        |L6.26|
                  |L6.16|
;;;1151     }
;;;1152     else
;;;1153     {
;;;1154       RCC->APB2ENR &= ~RCC_APB2Periph;
000010  4a02              LDR      r2,|L6.28|
000012  6992              LDR      r2,[r2,#0x18]
000014  4382              BICS     r2,r2,r0
000016  4b01              LDR      r3,|L6.28|
000018  619a              STR      r2,[r3,#0x18]
                  |L6.26|
;;;1155     }
;;;1156   }
00001a  4770              BX       lr
;;;1157   
                          ENDP

                  |L6.28|
                          DCD      0x40021000

                          AREA ||i.RCC_APB2PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphResetCmd PROC
;;;1254     */
;;;1255   void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1256   {
;;;1257     /* Check the parameters */
;;;1258     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;1259     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1260   
;;;1261     if (NewState != DISABLE)
000002  d005              BEQ      |L7.16|
;;;1262     {
;;;1263       RCC->APB2RSTR |= RCC_APB2Periph;
000004  4a05              LDR      r2,|L7.28|
000006  68d2              LDR      r2,[r2,#0xc]
000008  4302              ORRS     r2,r2,r0
00000a  4b04              LDR      r3,|L7.28|
00000c  60da              STR      r2,[r3,#0xc]
00000e  e004              B        |L7.26|
                  |L7.16|
;;;1264     }
;;;1265     else
;;;1266     {
;;;1267       RCC->APB2RSTR &= ~RCC_APB2Periph;
000010  4a02              LDR      r2,|L7.28|
000012  68d2              LDR      r2,[r2,#0xc]
000014  4382              BICS     r2,r2,r0
000016  4b01              LDR      r3,|L7.28|
000018  60da              STR      r2,[r3,#0xc]
                  |L7.26|
;;;1268     }
;;;1269   }
00001a  4770              BX       lr
;;;1270   
                          ENDP

                  |L7.28|
                          DCD      0x40021000

                          AREA ||i.RCC_AdjustHSI14CalibrationValue||, CODE, READONLY, ALIGN=2

                  RCC_AdjustHSI14CalibrationValue PROC
;;;222      */
;;;223    void RCC_AdjustHSI14CalibrationValue(uint8_t HSI14CalibrationValue)
000000  4601              MOV      r1,r0
;;;224    {
;;;225      uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;226      
;;;227      /* Check the parameters */
;;;228      assert_param(IS_RCC_HSI14_CALIBRATION_VALUE(HSI14CalibrationValue));
;;;229      
;;;230      tmpreg = RCC->CR2;
000004  4a05              LDR      r2,|L8.28|
000006  6b50              LDR      r0,[r2,#0x34]
;;;231      
;;;232      /* Clear HSI14TRIM[4:0] bits */
;;;233      tmpreg &= ~RCC_CR2_HSI14TRIM;
000008  23f8              MOVS     r3,#0xf8
00000a  4602              MOV      r2,r0
00000c  439a              BICS     r2,r2,r3
00000e  4610              MOV      r0,r2
;;;234      
;;;235      /* Set the HSITRIM14[4:0] bits according to HSI14CalibrationValue value */
;;;236      tmpreg |= (uint32_t)HSI14CalibrationValue << 3;
000010  00ca              LSLS     r2,r1,#3
000012  4310              ORRS     r0,r0,r2
;;;237    
;;;238      /* Store the new value */
;;;239      RCC->CR2 = tmpreg;
000014  4a01              LDR      r2,|L8.28|
000016  6350              STR      r0,[r2,#0x34]
;;;240    }
000018  4770              BX       lr
;;;241    
                          ENDP

00001a  0000              DCW      0x0000
                  |L8.28|
                          DCD      0x40021000

                          AREA ||i.RCC_AdjustHSICalibrationValue||, CODE, READONLY, ALIGN=2

                  RCC_AdjustHSICalibrationValue PROC
;;;162      */
;;;163    void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
000000  4601              MOV      r1,r0
;;;164    {
;;;165      uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;166      
;;;167      /* Check the parameters */
;;;168      assert_param(IS_RCC_HSI_CALIBRATION_VALUE(HSICalibrationValue));
;;;169      
;;;170      tmpreg = RCC->CR;
000004  4a05              LDR      r2,|L9.28|
000006  6810              LDR      r0,[r2,#0]
;;;171      
;;;172      /* Clear HSITRIM[4:0] bits */
;;;173      tmpreg &= ~RCC_CR_HSITRIM;
000008  23f8              MOVS     r3,#0xf8
00000a  4602              MOV      r2,r0
00000c  439a              BICS     r2,r2,r3
00000e  4610              MOV      r0,r2
;;;174      
;;;175      /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
;;;176      tmpreg |= (uint32_t)HSICalibrationValue << 3;
000010  00ca              LSLS     r2,r1,#3
000012  4310              ORRS     r0,r0,r2
;;;177    
;;;178      /* Store the new value */
;;;179      RCC->CR = tmpreg;
000014  4a01              LDR      r2,|L9.28|
000016  6010              STR      r0,[r2,#0]
;;;180    }
000018  4770              BX       lr
;;;181    
                          ENDP

00001a  0000              DCW      0x0000
                  |L9.28|
                          DCD      0x40021000

                          AREA ||i.RCC_BackupResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_BackupResetCmd PROC
;;;1064     */
;;;1065   void RCC_BackupResetCmd(FunctionalState NewState)
000000  2800              CMP      r0,#0
;;;1066   {
;;;1067     /* Check the parameters */
;;;1068     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1069     
;;;1070     if (NewState != DISABLE)
000002  d007              BEQ      |L10.20|
;;;1071     {
;;;1072       RCC->BDCR |= RCC_BDCR_BDRST;
000004  4907              LDR      r1,|L10.36|
000006  6a09              LDR      r1,[r1,#0x20]
000008  2201              MOVS     r2,#1
00000a  0412              LSLS     r2,r2,#16
00000c  4311              ORRS     r1,r1,r2
00000e  4a05              LDR      r2,|L10.36|
000010  6211              STR      r1,[r2,#0x20]
000012  e006              B        |L10.34|
                  |L10.20|
;;;1073     }
;;;1074     else
;;;1075     {
;;;1076       RCC->BDCR &= ~RCC_BDCR_BDRST;
000014  4903              LDR      r1,|L10.36|
000016  6a09              LDR      r1,[r1,#0x20]
000018  2201              MOVS     r2,#1
00001a  0412              LSLS     r2,r2,#16
00001c  4391              BICS     r1,r1,r2
00001e  4a01              LDR      r2,|L10.36|
000020  6211              STR      r1,[r2,#0x20]
                  |L10.34|
;;;1077     }
;;;1078   }
000022  4770              BX       lr
;;;1079   
                          ENDP

                  |L10.36|
                          DCD      0x40021000

                          AREA ||i.RCC_ClearFlag||, CODE, READONLY, ALIGN=2

                  RCC_ClearFlag PROC
;;;1428     */
;;;1429   void RCC_ClearFlag(void)
000000  4803              LDR      r0,|L11.16|
;;;1430   {
;;;1431     /* Set RMVF bit to clear the reset flags */
;;;1432     RCC->CSR |= RCC_CSR_RMVF;
000002  6a40              LDR      r0,[r0,#0x24]
000004  2101              MOVS     r1,#1
000006  0609              LSLS     r1,r1,#24
000008  4308              ORRS     r0,r0,r1
00000a  4901              LDR      r1,|L11.16|
00000c  6248              STR      r0,[r1,#0x24]
;;;1433   }
00000e  4770              BX       lr
;;;1434   
                          ENDP

                  |L11.16|
                          DCD      0x40021000

                          AREA ||i.RCC_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  RCC_ClearITPendingBit PROC
;;;1482     */
;;;1483   void RCC_ClearITPendingBit(uint8_t RCC_IT)
000000  4901              LDR      r1,|L12.8|
;;;1484   {
;;;1485     /* Check the parameters */
;;;1486     assert_param(IS_RCC_CLEAR_IT(RCC_IT));
;;;1487     
;;;1488     /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
;;;1489        pending bits */
;;;1490     *(__IO uint8_t *) CIR_BYTE2_ADDRESS = RCC_IT;
000002  7288              STRB     r0,[r1,#0xa]
;;;1491   }
000004  4770              BX       lr
;;;1492   
                          ENDP

000006  0000              DCW      0x0000
                  |L12.8|
                          DCD      0x40021000

                          AREA ||i.RCC_ClockSecuritySystemCmd||, CODE, READONLY, ALIGN=2

                  RCC_ClockSecuritySystemCmd PROC
;;;487      */
;;;488    void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
000000  2800              CMP      r0,#0
;;;489    {
;;;490      /* Check the parameters */
;;;491      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;492      
;;;493      if (NewState != DISABLE)
000002  d007              BEQ      |L13.20|
;;;494      {
;;;495        RCC->CR |= RCC_CR_CSSON;
000004  4907              LDR      r1,|L13.36|
000006  6809              LDR      r1,[r1,#0]
000008  2201              MOVS     r2,#1
00000a  04d2              LSLS     r2,r2,#19
00000c  4311              ORRS     r1,r1,r2
00000e  4a05              LDR      r2,|L13.36|
000010  6011              STR      r1,[r2,#0]
000012  e006              B        |L13.34|
                  |L13.20|
;;;496      }
;;;497      else
;;;498      {
;;;499        RCC->CR &= ~RCC_CR_CSSON;
000014  4903              LDR      r1,|L13.36|
000016  6809              LDR      r1,[r1,#0]
000018  2201              MOVS     r2,#1
00001a  04d2              LSLS     r2,r2,#19
00001c  4391              BICS     r1,r1,r2
00001e  4a01              LDR      r2,|L13.36|
000020  6011              STR      r1,[r2,#0]
                  |L13.34|
;;;500      }
;;;501    }
000022  4770              BX       lr
;;;502    /**
                          ENDP

                  |L13.36|
                          DCD      0x40021000

                          AREA ||i.RCC_DeInit||, CODE, READONLY, ALIGN=2

                  RCC_DeInit PROC
;;;52       */
;;;53     void RCC_DeInit(void)
000000  4819              LDR      r0,|L14.104|
;;;54     {
;;;55       /* Set HSION bit */
;;;56       RCC->CR |= (uint32_t)0x00000001;
000002  6800              LDR      r0,[r0,#0]
000004  2101              MOVS     r1,#1
000006  4308              ORRS     r0,r0,r1
000008  4917              LDR      r1,|L14.104|
00000a  6008              STR      r0,[r1,#0]
;;;57     
;;;58       /* Reset SW[1:0], HPRE[3:0], PPRE[2:0], ADCPRE, MCOSEL[2:0], MCOPRE[2:0] and PLLNODIV bits */
;;;59       RCC->CFGR &= (uint32_t)0x08FFB80C;
00000c  4608              MOV      r0,r1
00000e  6840              LDR      r0,[r0,#4]
000010  4916              LDR      r1,|L14.108|
000012  4008              ANDS     r0,r0,r1
000014  4914              LDR      r1,|L14.104|
000016  6048              STR      r0,[r1,#4]
;;;60       
;;;61       /* Reset HSEON, CSSON and PLLON bits */
;;;62       RCC->CR &= (uint32_t)0xFEF6FFFF;
000018  4608              MOV      r0,r1
00001a  6800              LDR      r0,[r0,#0]
00001c  4914              LDR      r1,|L14.112|
00001e  4008              ANDS     r0,r0,r1
000020  4911              LDR      r1,|L14.104|
000022  6008              STR      r0,[r1,#0]
;;;63     
;;;64       /* Reset HSEBYP bit */
;;;65       RCC->CR &= (uint32_t)0xFFFBFFFF;
000024  4608              MOV      r0,r1
000026  6800              LDR      r0,[r0,#0]
000028  2101              MOVS     r1,#1
00002a  0489              LSLS     r1,r1,#18
00002c  4388              BICS     r0,r0,r1
00002e  490e              LDR      r1,|L14.104|
000030  6008              STR      r0,[r1,#0]
;;;66     
;;;67       /* Reset PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
;;;68       RCC->CFGR &= (uint32_t)0xFFC0FFFF;
000032  4608              MOV      r0,r1
000034  6840              LDR      r0,[r0,#4]
000036  213f              MOVS     r1,#0x3f
000038  0409              LSLS     r1,r1,#16
00003a  4388              BICS     r0,r0,r1
00003c  490a              LDR      r1,|L14.104|
00003e  6048              STR      r0,[r1,#4]
;;;69     
;;;70       /* Reset PREDIV1[3:0] bits */
;;;71       RCC->CFGR2 &= (uint32_t)0xFFFFFFF0;
000040  4608              MOV      r0,r1
000042  6ac0              LDR      r0,[r0,#0x2c]
000044  0900              LSRS     r0,r0,#4
000046  0100              LSLS     r0,r0,#4
000048  62c8              STR      r0,[r1,#0x2c]
;;;72     
;;;73       /* Reset USARTSW[1:0], I2CSW, CECSW and ADCSW bits */
;;;74       RCC->CFGR3 &= (uint32_t)0xFFF0FEAC;
00004a  4608              MOV      r0,r1
00004c  6b00              LDR      r0,[r0,#0x30]
00004e  4909              LDR      r1,|L14.116|
000050  4008              ANDS     r0,r0,r1
000052  4905              LDR      r1,|L14.104|
000054  6308              STR      r0,[r1,#0x30]
;;;75       
;;;76       /* Reset HSI14 bit */
;;;77       RCC->CR2 &= (uint32_t)0xFFFFFFFE;
000056  4608              MOV      r0,r1
000058  6b40              LDR      r0,[r0,#0x34]
00005a  0840              LSRS     r0,r0,#1
00005c  0040              LSLS     r0,r0,#1
00005e  6348              STR      r0,[r1,#0x34]
;;;78     
;;;79       /* Disable all interrupts */
;;;80       RCC->CIR = 0x00000000;
000060  2000              MOVS     r0,#0
000062  6088              STR      r0,[r1,#8]
;;;81     }
000064  4770              BX       lr
;;;82     
                          ENDP

000066  0000              DCW      0x0000
                  |L14.104|
                          DCD      0x40021000
                  |L14.108|
                          DCD      0x08ffb80c
                  |L14.112|
                          DCD      0xfef6ffff
                  |L14.116|
                          DCD      0xfff0feac

                          AREA ||i.RCC_GetClocksFreq||, CODE, READONLY, ALIGN=2

                  RCC_GetClocksFreq PROC
;;;841      */
;;;842    void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
000000  b5fe              PUSH     {r1-r7,lr}
;;;843    {
000002  4604              MOV      r4,r0
;;;844      uint32_t tmp = 0, pllmull = 0, pllsource = 0, prediv1factor = 0, presc = 0, pllclk = 0;
000004  2500              MOVS     r5,#0
000006  2600              MOVS     r6,#0
000008  2000              MOVS     r0,#0
00000a  9002              STR      r0,[sp,#8]
00000c  9001              STR      r0,[sp,#4]
00000e  9000              STR      r0,[sp,#0]
000010  2700              MOVS     r7,#0
;;;845    
;;;846      /* Get SYSCLK source -------------------------------------------------------*/
;;;847      tmp = RCC->CFGR & RCC_CFGR_SWS;
000012  4856              LDR      r0,|L15.364|
000014  6840              LDR      r0,[r0,#4]
000016  210c              MOVS     r1,#0xc
000018  4008              ANDS     r0,r0,r1
00001a  4605              MOV      r5,r0
;;;848      
;;;849      switch (tmp)
00001c  2d00              CMP      r5,#0
00001e  d006              BEQ      |L15.46|
000020  2d04              CMP      r5,#4
000022  d007              BEQ      |L15.52|
000024  2d08              CMP      r5,#8
000026  d008              BEQ      |L15.58|
000028  2d0c              CMP      r5,#0xc
00002a  d12c              BNE      |L15.134|
00002c  e028              B        |L15.128|
                  |L15.46|
;;;850      {
;;;851        case 0x00:  /* HSI used as system clock */
;;;852          RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
00002e  4850              LDR      r0,|L15.368|
000030  6020              STR      r0,[r4,#0]
;;;853          break;
000032  e02b              B        |L15.140|
                  |L15.52|
;;;854        case 0x04:  /* HSE used as system clock */
;;;855          RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
000034  484e              LDR      r0,|L15.368|
000036  6020              STR      r0,[r4,#0]
;;;856          break;
000038  e028              B        |L15.140|
                  |L15.58|
;;;857        case 0x08:  /* PLL used as system clock */
;;;858          /* Get PLL clock source and multiplication factor ----------------------*/
;;;859          pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
00003a  484c              LDR      r0,|L15.364|
00003c  6840              LDR      r0,[r0,#4]
00003e  210f              MOVS     r1,#0xf
000040  0489              LSLS     r1,r1,#18
000042  4008              ANDS     r0,r0,r1
000044  4606              MOV      r6,r0
;;;860          pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
000046  4849              LDR      r0,|L15.364|
000048  6840              LDR      r0,[r0,#4]
00004a  2103              MOVS     r1,#3
00004c  03c9              LSLS     r1,r1,#15
00004e  4008              ANDS     r0,r0,r1
000050  9002              STR      r0,[sp,#8]
;;;861          pllmull = ( pllmull >> 18) + 2;
000052  0cb0              LSRS     r0,r6,#18
000054  1c86              ADDS     r6,r0,#2
;;;862          
;;;863          if (pllsource == 0x00)
000056  9802              LDR      r0,[sp,#8]
000058  2800              CMP      r0,#0
00005a  d103              BNE      |L15.100|
;;;864          {
;;;865            /* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;866            pllclk = (HSI_VALUE >> 1) * pllmull;
00005c  4845              LDR      r0,|L15.372|
00005e  4637              MOV      r7,r6
000060  4347              MULS     r7,r0,r7
000062  e00b              B        |L15.124|
                  |L15.100|
;;;867          }
;;;868          else
;;;869          {
;;;870            prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
000064  4841              LDR      r0,|L15.364|
000066  6ac0              LDR      r0,[r0,#0x2c]
000068  0700              LSLS     r0,r0,#28
00006a  0f00              LSRS     r0,r0,#28
00006c  1c40              ADDS     r0,r0,#1
00006e  9001              STR      r0,[sp,#4]
;;;871            /* HSE oscillator clock selected as PREDIV1 clock entry */
;;;872            pllclk = (HSE_VALUE / prediv1factor) * pllmull; 
000070  483f              LDR      r0,|L15.368|
000072  9901              LDR      r1,[sp,#4]
000074  f7fffffe          BL       __aeabi_uidivmod
000078  4370              MULS     r0,r6,r0
00007a  4607              MOV      r7,r0
                  |L15.124|
;;;873          }
;;;874          RCC_Clocks->SYSCLK_Frequency = pllclk;      
00007c  6027              STR      r7,[r4,#0]
;;;875          break;
00007e  e005              B        |L15.140|
                  |L15.128|
;;;876        case 0x0C:  /* HSI48 used as system clock */
;;;877          RCC_Clocks->SYSCLK_Frequency = HSI48_VALUE;
000080  483d              LDR      r0,|L15.376|
000082  6020              STR      r0,[r4,#0]
;;;878          break;
000084  e002              B        |L15.140|
                  |L15.134|
;;;879        default: /* HSI used as system clock */
;;;880          RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
000086  483a              LDR      r0,|L15.368|
000088  6020              STR      r0,[r4,#0]
;;;881          break;
00008a  bf00              NOP      
                  |L15.140|
00008c  bf00              NOP                            ;853
;;;882      }
;;;883      /* Compute HCLK, PCLK clocks frequencies -----------------------------------*/
;;;884      /* Get HCLK prescaler */
;;;885      tmp = RCC->CFGR & RCC_CFGR_HPRE;
00008e  4837              LDR      r0,|L15.364|
000090  6840              LDR      r0,[r0,#4]
000092  21f0              MOVS     r1,#0xf0
000094  4008              ANDS     r0,r0,r1
000096  4605              MOV      r5,r0
;;;886      tmp = tmp >> 4;
000098  092d              LSRS     r5,r5,#4
;;;887      presc = APBAHBPrescTable[tmp]; 
00009a  4838              LDR      r0,|L15.380|
00009c  5d40              LDRB     r0,[r0,r5]
00009e  9000              STR      r0,[sp,#0]
;;;888      /* HCLK clock frequency */
;;;889      RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
0000a0  6820              LDR      r0,[r4,#0]
0000a2  9900              LDR      r1,[sp,#0]
0000a4  40c8              LSRS     r0,r0,r1
0000a6  6060              STR      r0,[r4,#4]
;;;890    
;;;891      /* Get PCLK prescaler */
;;;892      tmp = RCC->CFGR & RCC_CFGR_PPRE;
0000a8  4830              LDR      r0,|L15.364|
0000aa  6840              LDR      r0,[r0,#4]
0000ac  2107              MOVS     r1,#7
0000ae  0209              LSLS     r1,r1,#8
0000b0  4008              ANDS     r0,r0,r1
0000b2  4605              MOV      r5,r0
;;;893      tmp = tmp >> 8;
0000b4  0a2d              LSRS     r5,r5,#8
;;;894      presc = APBAHBPrescTable[tmp];
0000b6  4831              LDR      r0,|L15.380|
0000b8  5d40              LDRB     r0,[r0,r5]
0000ba  9000              STR      r0,[sp,#0]
;;;895      /* PCLK clock frequency */
;;;896      RCC_Clocks->PCLK_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
0000bc  6861              LDR      r1,[r4,#4]
0000be  9800              LDR      r0,[sp,#0]
0000c0  40c1              LSRS     r1,r1,r0
0000c2  60a1              STR      r1,[r4,#8]
;;;897    
;;;898      /* ADCCLK clock frequency */
;;;899      if((RCC->CFGR3 & RCC_CFGR3_ADCSW) != RCC_CFGR3_ADCSW)
0000c4  4829              LDR      r0,|L15.364|
0000c6  6b00              LDR      r0,[r0,#0x30]
0000c8  21ff              MOVS     r1,#0xff
0000ca  3101              ADDS     r1,#1
0000cc  4008              ANDS     r0,r0,r1
0000ce  4288              CMP      r0,r1
0000d0  d002              BEQ      |L15.216|
;;;900      {
;;;901        /* ADC Clock is HSI14 Osc. */
;;;902        RCC_Clocks->ADCCLK_Frequency = HSI14_VALUE;
0000d2  482b              LDR      r0,|L15.384|
0000d4  60e0              STR      r0,[r4,#0xc]
0000d6  e00d              B        |L15.244|
                  |L15.216|
;;;903      }
;;;904      else
;;;905      {
;;;906        if((RCC->CFGR & RCC_CFGR_ADCPRE) != RCC_CFGR_ADCPRE)
0000d8  4824              LDR      r0,|L15.364|
0000da  6840              LDR      r0,[r0,#4]
0000dc  2101              MOVS     r1,#1
0000de  0389              LSLS     r1,r1,#14
0000e0  4008              ANDS     r0,r0,r1
0000e2  4288              CMP      r0,r1
0000e4  d003              BEQ      |L15.238|
;;;907        {
;;;908          /* ADC Clock is derived from PCLK/2 */
;;;909          RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK_Frequency >> 1;
0000e6  68a0              LDR      r0,[r4,#8]
0000e8  0840              LSRS     r0,r0,#1
0000ea  60e0              STR      r0,[r4,#0xc]
0000ec  e002              B        |L15.244|
                  |L15.238|
;;;910        }
;;;911        else
;;;912        {
;;;913          /* ADC Clock is derived from PCLK/4 */
;;;914          RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK_Frequency >> 2;
0000ee  68a0              LDR      r0,[r4,#8]
0000f0  0880              LSRS     r0,r0,#2
0000f2  60e0              STR      r0,[r4,#0xc]
                  |L15.244|
;;;915        }
;;;916        
;;;917      }
;;;918    
;;;919      /* CECCLK clock frequency */
;;;920    
;;;921    
;;;922      /* I2C1CLK clock frequency */
;;;923      if((RCC->CFGR3 & RCC_CFGR3_I2C1SW) != RCC_CFGR3_I2C1SW)
0000f4  481d              LDR      r0,|L15.364|
0000f6  6b00              LDR      r0,[r0,#0x30]
0000f8  2110              MOVS     r1,#0x10
0000fa  4008              ANDS     r0,r0,r1
0000fc  2810              CMP      r0,#0x10
0000fe  d002              BEQ      |L15.262|
;;;924      {
;;;925        /* I2C1 Clock is HSI Osc. */
;;;926        RCC_Clocks->I2C1CLK_Frequency = HSI_VALUE;
000100  481b              LDR      r0,|L15.368|
000102  6160              STR      r0,[r4,#0x14]
000104  e001              B        |L15.266|
                  |L15.262|
;;;927      }
;;;928      else
;;;929      {
;;;930        /* I2C1 Clock is System Clock */
;;;931        RCC_Clocks->I2C1CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
000106  6820              LDR      r0,[r4,#0]
000108  6160              STR      r0,[r4,#0x14]
                  |L15.266|
;;;932      }
;;;933    
;;;934      /* USART1CLK clock frequency */
;;;935      if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == 0x0)
00010a  4818              LDR      r0,|L15.364|
00010c  6b00              LDR      r0,[r0,#0x30]
00010e  0780              LSLS     r0,r0,#30
000110  0f80              LSRS     r0,r0,#30
000112  2800              CMP      r0,#0
000114  d102              BNE      |L15.284|
;;;936      {
;;;937        /* USART1 Clock is PCLK */
;;;938        RCC_Clocks->USART1CLK_Frequency = RCC_Clocks->PCLK_Frequency;
000116  68a0              LDR      r0,[r4,#8]
000118  61a0              STR      r0,[r4,#0x18]
00011a  e019              B        |L15.336|
                  |L15.284|
;;;939      }
;;;940      else if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == RCC_CFGR3_USART1SW_0)
00011c  4813              LDR      r0,|L15.364|
00011e  6b00              LDR      r0,[r0,#0x30]
000120  0780              LSLS     r0,r0,#30
000122  0f80              LSRS     r0,r0,#30
000124  2801              CMP      r0,#1
000126  d102              BNE      |L15.302|
;;;941      {
;;;942        /* USART1 Clock is System Clock */
;;;943        RCC_Clocks->USART1CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
000128  6820              LDR      r0,[r4,#0]
00012a  61a0              STR      r0,[r4,#0x18]
00012c  e010              B        |L15.336|
                  |L15.302|
;;;944      }
;;;945      else if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == RCC_CFGR3_USART1SW_1)
00012e  480f              LDR      r0,|L15.364|
000130  6b00              LDR      r0,[r0,#0x30]
000132  0780              LSLS     r0,r0,#30
000134  0f80              LSRS     r0,r0,#30
000136  2802              CMP      r0,#2
000138  d102              BNE      |L15.320|
;;;946      {
;;;947        /* USART1 Clock is LSE Osc. */
;;;948        RCC_Clocks->USART1CLK_Frequency = LSE_VALUE;
00013a  0380              LSLS     r0,r0,#14
00013c  61a0              STR      r0,[r4,#0x18]
00013e  e007              B        |L15.336|
                  |L15.320|
;;;949      }
;;;950      else if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == RCC_CFGR3_USART1SW)
000140  480a              LDR      r0,|L15.364|
000142  6b00              LDR      r0,[r0,#0x30]
000144  0780              LSLS     r0,r0,#30
000146  0f80              LSRS     r0,r0,#30
000148  2803              CMP      r0,#3
00014a  d101              BNE      |L15.336|
;;;951      {
;;;952        /* USART1 Clock is HSI Osc. */
;;;953        RCC_Clocks->USART1CLK_Frequency = HSI_VALUE;
00014c  4808              LDR      r0,|L15.368|
00014e  61a0              STR      r0,[r4,#0x18]
                  |L15.336|
;;;954      }
;;;955      
;;;956      /* USART2CLK clock frequency */
;;;957      RCC_Clocks->USART2CLK_Frequency=RCC_Clocks->PCLK_Frequency;
000150  68a0              LDR      r0,[r4,#8]
000152  61e0              STR      r0,[r4,#0x1c]
;;;958        /* USART2CLK clock frequency */
;;;959    //  if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == 0x0)
;;;960    //  {
;;;961    //    /* USART Clock is PCLK */
;;;962    //    RCC_Clocks->USART2CLK_Frequency = RCC_Clocks->PCLK_Frequency;
;;;963    //  }
;;;964    //  else if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == RCC_CFGR3_USART2SW_0)
;;;965    //  {
;;;966    //    /* USART Clock is System Clock */
;;;967    //    RCC_Clocks->USART2CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
;;;968    //  }
;;;969    //  else if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == RCC_CFGR3_USART2SW_1)
;;;970    //  {
;;;971    //    /* USART Clock is LSE Osc. */
;;;972    //    RCC_Clocks->USART2CLK_Frequency = LSE_VALUE;
;;;973    //  }
;;;974    //  else if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == RCC_CFGR3_USART2SW)
;;;975    //  {
;;;976    //    /* USART Clock is HSI Osc. */
;;;977    //    RCC_Clocks->USART2CLK_Frequency = HSI_VALUE;
;;;978    //  }
;;;979    
;;;980    
;;;981      /* USART3CLK clock frequency */
;;;982    
;;;983      /* USBCLK clock frequency */
;;;984      if((RCC->CFGR3 & RCC_CFGR3_USBSW) != RCC_CFGR3_USBSW)
000154  4805              LDR      r0,|L15.364|
000156  6b00              LDR      r0,[r0,#0x30]
000158  2180              MOVS     r1,#0x80
00015a  4008              ANDS     r0,r0,r1
00015c  2880              CMP      r0,#0x80
00015e  d002              BEQ      |L15.358|
;;;985      {
;;;986        /* USB Clock is HSI48 */
;;;987        RCC_Clocks->USBCLK_Frequency = HSI48_VALUE;
000160  4805              LDR      r0,|L15.376|
000162  6260              STR      r0,[r4,#0x24]
000164  e000              B        |L15.360|
                  |L15.358|
;;;988      }
;;;989      else
;;;990      {
;;;991        /* USB Clock is PLL clock */
;;;992        RCC_Clocks->USBCLK_Frequency = pllclk;
000166  6267              STR      r7,[r4,#0x24]
                  |L15.360|
;;;993      }   
;;;994    }
000168  bdfe              POP      {r1-r7,pc}
;;;995    
                          ENDP

00016a  0000              DCW      0x0000
                  |L15.364|
                          DCD      0x40021000
                  |L15.368|
                          DCD      0x007a1200
                  |L15.372|
                          DCD      0x003d0900
                  |L15.376|
                          DCD      0x02dc6c00
                  |L15.380|
                          DCD      APBAHBPrescTable
                  |L15.384|
                          DCD      0x00d59f80

                          AREA ||i.RCC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetFlagStatus PROC
;;;1376     */
;;;1377   FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
000000  b510              PUSH     {r4,lr}
;;;1378   {
000002  4602              MOV      r2,r0
;;;1379     uint32_t tmp = 0;
000004  2100              MOVS     r1,#0
;;;1380     uint32_t statusreg = 0;
000006  2300              MOVS     r3,#0
;;;1381     FlagStatus bitstatus = RESET;
000008  2000              MOVS     r0,#0
;;;1382   
;;;1383     /* Check the parameters */
;;;1384     assert_param(IS_RCC_FLAG(RCC_FLAG));
;;;1385   
;;;1386     /* Get the RCC register index */
;;;1387     tmp = RCC_FLAG >> 5;
00000a  1151              ASRS     r1,r2,#5
;;;1388   
;;;1389     if (tmp == 0)               /* The flag to check is in CR register */
00000c  2900              CMP      r1,#0
00000e  d102              BNE      |L16.22|
;;;1390     {
;;;1391       statusreg = RCC->CR;
000010  4c0c              LDR      r4,|L16.68|
000012  6823              LDR      r3,[r4,#0]
000014  e00b              B        |L16.46|
                  |L16.22|
;;;1392     }
;;;1393     else if (tmp == 1)          /* The flag to check is in BDCR register */
000016  2901              CMP      r1,#1
000018  d102              BNE      |L16.32|
;;;1394     {
;;;1395       statusreg = RCC->BDCR;
00001a  4c0a              LDR      r4,|L16.68|
00001c  6a23              LDR      r3,[r4,#0x20]
00001e  e006              B        |L16.46|
                  |L16.32|
;;;1396     }
;;;1397     else if (tmp == 2)          /* The flag to check is in CSR register */
000020  2902              CMP      r1,#2
000022  d102              BNE      |L16.42|
;;;1398     {
;;;1399       statusreg = RCC->CSR;
000024  4c07              LDR      r4,|L16.68|
000026  6a63              LDR      r3,[r4,#0x24]
000028  e001              B        |L16.46|
                  |L16.42|
;;;1400     }
;;;1401     else                        /* The flag to check is in CR2 register */
;;;1402     {
;;;1403       statusreg = RCC->CR2;
00002a  4c06              LDR      r4,|L16.68|
00002c  6b63              LDR      r3,[r4,#0x34]
                  |L16.46|
;;;1404     }    
;;;1405   
;;;1406     /* Get the flag position */
;;;1407     tmp = RCC_FLAG & FLAG_MASK;
00002e  06d1              LSLS     r1,r2,#27
000030  0ec9              LSRS     r1,r1,#27
;;;1408   
;;;1409     if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
000032  2401              MOVS     r4,#1
000034  408c              LSLS     r4,r4,r1
000036  401c              ANDS     r4,r4,r3
000038  2c00              CMP      r4,#0
00003a  d001              BEQ      |L16.64|
;;;1410     {
;;;1411       bitstatus = SET;
00003c  2001              MOVS     r0,#1
00003e  e000              B        |L16.66|
                  |L16.64|
;;;1412     }
;;;1413     else
;;;1414     {
;;;1415       bitstatus = RESET;
000040  2000              MOVS     r0,#0
                  |L16.66|
;;;1416     }
;;;1417     /* Return the flag status */
;;;1418     return bitstatus;
;;;1419   }
000042  bd10              POP      {r4,pc}
;;;1420   
                          ENDP

                  |L16.68|
                          DCD      0x40021000

                          AREA ||i.RCC_GetITStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetITStatus PROC
;;;1448     */
;;;1449   ITStatus RCC_GetITStatus(uint8_t RCC_IT)
000000  4601              MOV      r1,r0
;;;1450   {
;;;1451     ITStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1452     
;;;1453     /* Check the parameters */
;;;1454     assert_param(IS_RCC_GET_IT(RCC_IT));
;;;1455     
;;;1456     /* Check the status of the specified RCC interrupt */
;;;1457     if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
000004  4a04              LDR      r2,|L17.24|
000006  6892              LDR      r2,[r2,#8]
000008  400a              ANDS     r2,r2,r1
00000a  2a00              CMP      r2,#0
00000c  d001              BEQ      |L17.18|
;;;1458     {
;;;1459       bitstatus = SET;
00000e  2001              MOVS     r0,#1
000010  e000              B        |L17.20|
                  |L17.18|
;;;1460     }
;;;1461     else
;;;1462     {
;;;1463       bitstatus = RESET;
000012  2000              MOVS     r0,#0
                  |L17.20|
;;;1464     }
;;;1465     /* Return the RCC_IT status */
;;;1466     return  bitstatus;
;;;1467   }
000014  4770              BX       lr
;;;1468   
                          ENDP

000016  0000              DCW      0x0000
                  |L17.24|
                          DCD      0x40021000

                          AREA ||i.RCC_GetSYSCLKSource||, CODE, READONLY, ALIGN=2

                  RCC_GetSYSCLKSource PROC
;;;599      */
;;;600    uint8_t RCC_GetSYSCLKSource(void)
000000  4802              LDR      r0,|L18.12|
;;;601    {
;;;602      return ((uint8_t)(RCC->CFGR & RCC_CFGR_SWS));
000002  6840              LDR      r0,[r0,#4]
000004  210c              MOVS     r1,#0xc
000006  4008              ANDS     r0,r0,r1
;;;603    }
000008  4770              BX       lr
;;;604    
                          ENDP

00000a  0000              DCW      0x0000
                  |L18.12|
                          DCD      0x40021000

                          AREA ||i.RCC_HCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_HCLKConfig PROC
;;;620      */
;;;621    void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
000000  4601              MOV      r1,r0
;;;622    {
;;;623      uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;624      
;;;625      /* Check the parameters */
;;;626      assert_param(IS_RCC_HCLK(RCC_SYSCLK));
;;;627      
;;;628      tmpreg = RCC->CFGR;
000004  4a05              LDR      r2,|L19.28|
000006  6850              LDR      r0,[r2,#4]
;;;629      
;;;630      /* Clear HPRE[3:0] bits */
;;;631      tmpreg &= ~RCC_CFGR_HPRE;
000008  23f0              MOVS     r3,#0xf0
00000a  4602              MOV      r2,r0
00000c  439a              BICS     r2,r2,r3
00000e  4610              MOV      r0,r2
;;;632      
;;;633      /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
;;;634      tmpreg |= RCC_SYSCLK;
000010  4602              MOV      r2,r0
000012  430a              ORRS     r2,r2,r1
000014  4610              MOV      r0,r2
;;;635      
;;;636      /* Store the new value */
;;;637      RCC->CFGR = tmpreg;
000016  4a01              LDR      r2,|L19.28|
000018  6050              STR      r0,[r2,#4]
;;;638    }
00001a  4770              BX       lr
;;;639    
                          ENDP

                  |L19.28|
                          DCD      0x40021000

                          AREA ||i.RCC_HSEConfig||, CODE, READONLY, ALIGN=2

                  RCC_HSEConfig PROC
;;;102      */
;;;103    void RCC_HSEConfig(uint8_t RCC_HSE)
000000  2100              MOVS     r1,#0
;;;104    {
;;;105      /* Check the parameters */
;;;106      assert_param(IS_RCC_HSE(RCC_HSE));
;;;107    
;;;108      /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
;;;109      *(__IO uint8_t *) CR_BYTE2_ADDRESS = RCC_HSE_OFF;
000002  4a02              LDR      r2,|L20.12|
000004  7091              STRB     r1,[r2,#2]
;;;110    
;;;111      /* Set the new HSE configuration -------------------------------------------*/
;;;112      *(__IO uint8_t *) CR_BYTE2_ADDRESS = RCC_HSE;
000006  4611              MOV      r1,r2
000008  7088              STRB     r0,[r1,#2]
;;;113    
;;;114    }
00000a  4770              BX       lr
;;;115    
                          ENDP

                  |L20.12|
                          DCD      0x40021000

                          AREA ||i.RCC_HSI14ADCRequestCmd||, CODE, READONLY, ALIGN=2

                  RCC_HSI14ADCRequestCmd PROC
;;;274      */
;;;275    void RCC_HSI14ADCRequestCmd(FunctionalState NewState)
000000  2800              CMP      r0,#0
;;;276    {
;;;277      /* Check the parameters */
;;;278      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;279      
;;;280      if (NewState != DISABLE)
000002  d006              BEQ      |L21.18|
;;;281      {
;;;282        RCC->CR2 &= ~RCC_CR2_HSI14DIS;
000004  4906              LDR      r1,|L21.32|
000006  6b49              LDR      r1,[r1,#0x34]
000008  2204              MOVS     r2,#4
00000a  4391              BICS     r1,r1,r2
00000c  4a04              LDR      r2,|L21.32|
00000e  6351              STR      r1,[r2,#0x34]
000010  e005              B        |L21.30|
                  |L21.18|
;;;283      }
;;;284      else
;;;285      {
;;;286        RCC->CR2 |= RCC_CR2_HSI14DIS;
000012  4903              LDR      r1,|L21.32|
000014  6b49              LDR      r1,[r1,#0x34]
000016  2204              MOVS     r2,#4
000018  4311              ORRS     r1,r1,r2
00001a  4a01              LDR      r2,|L21.32|
00001c  6351              STR      r1,[r2,#0x34]
                  |L21.30|
;;;287      }
;;;288    }
00001e  4770              BX       lr
;;;289    
                          ENDP

                  |L21.32|
                          DCD      0x40021000

                          AREA ||i.RCC_HSI14Cmd||, CODE, READONLY, ALIGN=2

                  RCC_HSI14Cmd PROC
;;;253      */
;;;254    void RCC_HSI14Cmd(FunctionalState NewState)
000000  2800              CMP      r0,#0
;;;255    {
;;;256      /* Check the parameters */
;;;257      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;258      
;;;259      if (NewState != DISABLE)
000002  d006              BEQ      |L22.18|
;;;260      {
;;;261        RCC->CR2 |= RCC_CR2_HSI14ON;
000004  4906              LDR      r1,|L22.32|
000006  6b49              LDR      r1,[r1,#0x34]
000008  2201              MOVS     r2,#1
00000a  4311              ORRS     r1,r1,r2
00000c  4a04              LDR      r2,|L22.32|
00000e  6351              STR      r1,[r2,#0x34]
000010  e005              B        |L22.30|
                  |L22.18|
;;;262      }
;;;263      else
;;;264      {
;;;265        RCC->CR2 &= ~RCC_CR2_HSI14ON;
000012  4903              LDR      r1,|L22.32|
000014  6b49              LDR      r1,[r1,#0x34]
000016  0849              LSRS     r1,r1,#1
000018  0049              LSLS     r1,r1,#1
00001a  4a01              LDR      r2,|L22.32|
00001c  6351              STR      r1,[r2,#0x34]
                  |L22.30|
;;;266      }
;;;267    }
00001e  4770              BX       lr
;;;268    
                          ENDP

                  |L22.32|
                          DCD      0x40021000

                          AREA ||i.RCC_HSI48Cmd||, CODE, READONLY, ALIGN=2

                  RCC_HSI48Cmd PROC
;;;438      */
;;;439    void RCC_HSI48Cmd(FunctionalState NewState)
000000  2800              CMP      r0,#0
;;;440    {
;;;441      /* Check the parameters */
;;;442      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;443      
;;;444      if (NewState != DISABLE)
000002  d007              BEQ      |L23.20|
;;;445      {
;;;446        RCC->CR2 |= RCC_CR2_HSI48ON;
000004  4907              LDR      r1,|L23.36|
000006  6b49              LDR      r1,[r1,#0x34]
000008  2201              MOVS     r2,#1
00000a  0412              LSLS     r2,r2,#16
00000c  4311              ORRS     r1,r1,r2
00000e  4a05              LDR      r2,|L23.36|
000010  6351              STR      r1,[r2,#0x34]
000012  e006              B        |L23.34|
                  |L23.20|
;;;447      }
;;;448      else
;;;449      {
;;;450        RCC->CR2 &= ~RCC_CR2_HSI48ON;
000014  4903              LDR      r1,|L23.36|
000016  6b49              LDR      r1,[r1,#0x34]
000018  2201              MOVS     r2,#1
00001a  0412              LSLS     r2,r2,#16
00001c  4391              BICS     r1,r1,r2
00001e  4a01              LDR      r2,|L23.36|
000020  6351              STR      r1,[r2,#0x34]
                  |L23.34|
;;;451      }
;;;452    }
000022  4770              BX       lr
;;;453    
                          ENDP

                  |L23.36|
                          DCD      0x40021000

                          AREA ||i.RCC_HSICmd||, CODE, READONLY, ALIGN=2

                  RCC_HSICmd PROC
;;;196      */
;;;197    void RCC_HSICmd(FunctionalState NewState)
000000  2800              CMP      r0,#0
;;;198    {
;;;199      /* Check the parameters */
;;;200      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;201      
;;;202      if (NewState != DISABLE)
000002  d006              BEQ      |L24.18|
;;;203      {
;;;204        RCC->CR |= RCC_CR_HSION;
000004  4906              LDR      r1,|L24.32|
000006  6809              LDR      r1,[r1,#0]
000008  2201              MOVS     r2,#1
00000a  4311              ORRS     r1,r1,r2
00000c  4a04              LDR      r2,|L24.32|
00000e  6011              STR      r1,[r2,#0]
000010  e005              B        |L24.30|
                  |L24.18|
;;;205      }
;;;206      else
;;;207      {
;;;208        RCC->CR &= ~RCC_CR_HSION;
000012  4903              LDR      r1,|L24.32|
000014  6809              LDR      r1,[r1,#0]
000016  0849              LSRS     r1,r1,#1
000018  0049              LSLS     r1,r1,#1
00001a  4a01              LDR      r2,|L24.32|
00001c  6011              STR      r1,[r2,#0]
                  |L24.30|
;;;209      }
;;;210    }
00001e  4770              BX       lr
;;;211    
                          ENDP

                  |L24.32|
                          DCD      0x40021000

                          AREA ||i.RCC_I2CCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_I2CCLKConfig PROC
;;;718      */
;;;719    void RCC_I2CCLKConfig(uint32_t RCC_I2CCLK)
000000  4905              LDR      r1,|L25.24|
;;;720    { 
;;;721      /* Check the parameters */
;;;722      assert_param(IS_RCC_I2CCLK(RCC_I2CCLK));
;;;723    
;;;724      /* Clear I2CSW bit */
;;;725      RCC->CFGR3 &= ~RCC_CFGR3_I2C1SW;
000002  6b09              LDR      r1,[r1,#0x30]
000004  2210              MOVS     r2,#0x10
000006  4391              BICS     r1,r1,r2
000008  4a03              LDR      r2,|L25.24|
00000a  6311              STR      r1,[r2,#0x30]
;;;726      /* Set I2CSW bits according to RCC_I2CCLK value */
;;;727      RCC->CFGR3 |= RCC_I2CCLK;
00000c  4611              MOV      r1,r2
00000e  6b09              LDR      r1,[r1,#0x30]
000010  4301              ORRS     r1,r1,r0
000012  6311              STR      r1,[r2,#0x30]
;;;728    }
000014  4770              BX       lr
;;;729    
                          ENDP

000016  0000              DCW      0x0000
                  |L25.24|
                          DCD      0x40021000

                          AREA ||i.RCC_ITConfig||, CODE, READONLY, ALIGN=2

                  RCC_ITConfig PROC
;;;1337     */
;;;1338   void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1339   {
;;;1340     /* Check the parameters */
;;;1341     assert_param(IS_RCC_IT(RCC_IT));
;;;1342     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1343     
;;;1344     if (NewState != DISABLE)
000002  d005              BEQ      |L26.16|
;;;1345     {
;;;1346       /* Perform Byte access to RCC_CIR[13:8] bits to enable the selected interrupts */
;;;1347       *(__IO uint8_t *) CIR_BYTE1_ADDRESS |= RCC_IT;
000004  4a05              LDR      r2,|L26.28|
000006  7a52              LDRB     r2,[r2,#9]
000008  4302              ORRS     r2,r2,r0
00000a  4b04              LDR      r3,|L26.28|
00000c  725a              STRB     r2,[r3,#9]
00000e  e004              B        |L26.26|
                  |L26.16|
;;;1348     }
;;;1349     else
;;;1350     {
;;;1351       /* Perform Byte access to RCC_CIR[13:8] bits to disable the selected interrupts */
;;;1352       *(__IO uint8_t *) CIR_BYTE1_ADDRESS &= (uint8_t)~RCC_IT;
000010  4a02              LDR      r2,|L26.28|
000012  7a52              LDRB     r2,[r2,#9]
000014  4382              BICS     r2,r2,r0
000016  4b01              LDR      r3,|L26.28|
000018  725a              STRB     r2,[r3,#9]
                  |L26.26|
;;;1353     }
;;;1354   }
00001a  4770              BX       lr
;;;1355   
                          ENDP

                  |L26.28|
                          DCD      0x40021000

                          AREA ||i.RCC_LSEConfig||, CODE, READONLY, ALIGN=2

                  RCC_LSEConfig PROC
;;;306      */
;;;307    void RCC_LSEConfig(uint32_t RCC_LSE)
000000  4908              LDR      r1,|L27.36|
;;;308    {
;;;309      /* Check the parameters */
;;;310      assert_param(IS_RCC_LSE(RCC_LSE));
;;;311    
;;;312      /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
;;;313      /* Reset LSEON bit */
;;;314      RCC->BDCR &= ~(RCC_BDCR_LSEON);
000002  6a09              LDR      r1,[r1,#0x20]
000004  0849              LSRS     r1,r1,#1
000006  0049              LSLS     r1,r1,#1
000008  4a06              LDR      r2,|L27.36|
00000a  6211              STR      r1,[r2,#0x20]
;;;315    
;;;316      /* Reset LSEBYP bit */
;;;317      RCC->BDCR &= ~(RCC_BDCR_LSEBYP);
00000c  4611              MOV      r1,r2
00000e  6a09              LDR      r1,[r1,#0x20]
000010  2204              MOVS     r2,#4
000012  4391              BICS     r1,r1,r2
000014  4a03              LDR      r2,|L27.36|
000016  6211              STR      r1,[r2,#0x20]
;;;318    
;;;319      /* Configure LSE */
;;;320      RCC->BDCR |= RCC_LSE;
000018  4611              MOV      r1,r2
00001a  6a09              LDR      r1,[r1,#0x20]
00001c  4301              ORRS     r1,r1,r0
00001e  6211              STR      r1,[r2,#0x20]
;;;321    }
000020  4770              BX       lr
;;;322    
                          ENDP

000022  0000              DCW      0x0000
                  |L27.36|
                          DCD      0x40021000

                          AREA ||i.RCC_LSEDriveConfig||, CODE, READONLY, ALIGN=2

                  RCC_LSEDriveConfig PROC
;;;332      */
;;;333    void RCC_LSEDriveConfig(uint32_t RCC_LSEDrive)
000000  4905              LDR      r1,|L28.24|
;;;334    {
;;;335      /* Check the parameters */
;;;336      assert_param(IS_RCC_LSE_DRIVE(RCC_LSEDrive));
;;;337      
;;;338      /* Clear LSEDRV[1:0] bits */
;;;339      RCC->BDCR &= ~(RCC_BDCR_LSEDRV);
000002  6a09              LDR      r1,[r1,#0x20]
000004  2238              MOVS     r2,#0x38
000006  4391              BICS     r1,r1,r2
000008  4a03              LDR      r2,|L28.24|
00000a  6211              STR      r1,[r2,#0x20]
;;;340    
;;;341      /* Set the LSE Drive */
;;;342      RCC->BDCR |= RCC_LSEDrive;
00000c  4611              MOV      r1,r2
00000e  6a09              LDR      r1,[r1,#0x20]
000010  4301              ORRS     r1,r1,r0
000012  6211              STR      r1,[r2,#0x20]
;;;343    }
000014  4770              BX       lr
;;;344    
                          ENDP

000016  0000              DCW      0x0000
                  |L28.24|
                          DCD      0x40021000

                          AREA ||i.RCC_LSICmd||, CODE, READONLY, ALIGN=2

                  RCC_LSICmd PROC
;;;356      */
;;;357    void RCC_LSICmd(FunctionalState NewState)
000000  2800              CMP      r0,#0
;;;358    {
;;;359      /* Check the parameters */
;;;360      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;361      
;;;362      if (NewState != DISABLE)
000002  d006              BEQ      |L29.18|
;;;363      {
;;;364        RCC->CSR |= RCC_CSR_LSION;
000004  4906              LDR      r1,|L29.32|
000006  6a49              LDR      r1,[r1,#0x24]
000008  2201              MOVS     r2,#1
00000a  4311              ORRS     r1,r1,r2
00000c  4a04              LDR      r2,|L29.32|
00000e  6251              STR      r1,[r2,#0x24]
000010  e005              B        |L29.30|
                  |L29.18|
;;;365      }
;;;366      else
;;;367      {
;;;368        RCC->CSR &= ~RCC_CSR_LSION;
000012  4903              LDR      r1,|L29.32|
000014  6a49              LDR      r1,[r1,#0x24]
000016  0849              LSRS     r1,r1,#1
000018  0049              LSLS     r1,r1,#1
00001a  4a01              LDR      r2,|L29.32|
00001c  6251              STR      r1,[r2,#0x24]
                  |L29.30|
;;;369      }
;;;370    }
00001e  4770              BX       lr
;;;371    
                          ENDP

                  |L29.32|
                          DCD      0x40021000

                          AREA ||i.RCC_MCOConfig||, CODE, READONLY, ALIGN=2

                  RCC_MCOConfig PROC
;;;529      */
;;;530    void RCC_MCOConfig(uint8_t RCC_MCOSource, uint32_t RCC_MCOPrescaler)
000000  4602              MOV      r2,r0
;;;531    {
;;;532      uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;533      
;;;534      /* Check the parameters */
;;;535      assert_param(IS_RCC_MCO_SOURCE(RCC_MCOSource));
;;;536      assert_param(IS_RCC_MCO_PRESCALER(RCC_MCOPrescaler));
;;;537        
;;;538      /* Get CFGR value */  
;;;539      tmpreg = RCC->CFGR;
000004  4b04              LDR      r3,|L30.24|
000006  6858              LDR      r0,[r3,#4]
;;;540      /* Clear MCOPRE[2:0] bits */
;;;541      tmpreg &= ~(RCC_CFGR_MCO_PRE | RCC_CFGR_MCO | RCC_CFGR_PLLNODIV);
000008  0200              LSLS     r0,r0,#8
00000a  0a00              LSRS     r0,r0,#8
;;;542      /* Set the RCC_MCOSource and RCC_MCOPrescaler */
;;;543      tmpreg |= (RCC_MCOPrescaler | ((uint32_t)RCC_MCOSource<<24));
00000c  0613              LSLS     r3,r2,#24
00000e  430b              ORRS     r3,r3,r1
000010  4318              ORRS     r0,r0,r3
;;;544      /* Store the new value */
;;;545      RCC->CFGR = tmpreg;
000012  4b01              LDR      r3,|L30.24|
000014  6058              STR      r0,[r3,#4]
;;;546    }
000016  4770              BX       lr
;;;547    
                          ENDP

                  |L30.24|
                          DCD      0x40021000

                          AREA ||i.RCC_PCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_PCLKConfig PROC
;;;651      */
;;;652    void RCC_PCLKConfig(uint32_t RCC_HCLK)
000000  4601              MOV      r1,r0
;;;653    {
;;;654      uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;655      
;;;656      /* Check the parameters */
;;;657      assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;658      
;;;659      tmpreg = RCC->CFGR;
000004  4a06              LDR      r2,|L31.32|
000006  6850              LDR      r0,[r2,#4]
;;;660      
;;;661      /* Clear PPRE[2:0] bits */
;;;662      tmpreg &= ~RCC_CFGR_PPRE;
000008  2307              MOVS     r3,#7
00000a  021b              LSLS     r3,r3,#8
00000c  4602              MOV      r2,r0
00000e  439a              BICS     r2,r2,r3
000010  4610              MOV      r0,r2
;;;663      
;;;664      /* Set PPRE[2:0] bits according to RCC_HCLK value */
;;;665      tmpreg |= RCC_HCLK;
000012  4602              MOV      r2,r0
000014  430a              ORRS     r2,r2,r1
000016  4610              MOV      r0,r2
;;;666      
;;;667      /* Store the new value */
;;;668      RCC->CFGR = tmpreg;
000018  4a01              LDR      r2,|L31.32|
00001a  6050              STR      r0,[r2,#4]
;;;669    }
00001c  4770              BX       lr
;;;670    
                          ENDP

00001e  0000              DCW      0x0000
                  |L31.32|
                          DCD      0x40021000

                          AREA ||i.RCC_PLLCmd||, CODE, READONLY, ALIGN=2

                  RCC_PLLCmd PROC
;;;413      */
;;;414    void RCC_PLLCmd(FunctionalState NewState)
000000  2800              CMP      r0,#0
;;;415    {
;;;416      /* Check the parameters */
;;;417      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;418      
;;;419      if (NewState != DISABLE)
000002  d007              BEQ      |L32.20|
;;;420      {
;;;421        RCC->CR |= RCC_CR_PLLON;
000004  4907              LDR      r1,|L32.36|
000006  6809              LDR      r1,[r1,#0]
000008  2201              MOVS     r2,#1
00000a  0612              LSLS     r2,r2,#24
00000c  4311              ORRS     r1,r1,r2
00000e  4a05              LDR      r2,|L32.36|
000010  6011              STR      r1,[r2,#0]
000012  e006              B        |L32.34|
                  |L32.20|
;;;422      }
;;;423      else
;;;424      {
;;;425        RCC->CR &= ~RCC_CR_PLLON;
000014  4903              LDR      r1,|L32.36|
000016  6809              LDR      r1,[r1,#0]
000018  2201              MOVS     r2,#1
00001a  0612              LSLS     r2,r2,#24
00001c  4391              BICS     r1,r1,r2
00001e  4a01              LDR      r2,|L32.36|
000020  6011              STR      r1,[r2,#0]
                  |L32.34|
;;;426      }
;;;427    }
000022  4770              BX       lr
;;;428    
                          ENDP

                  |L32.36|
                          DCD      0x40021000

                          AREA ||i.RCC_PLLConfig||, CODE, READONLY, ALIGN=2

                  RCC_PLLConfig PROC
;;;389      */
;;;390    void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t RCC_PLLMul)
000000  4a07              LDR      r2,|L33.32|
;;;391    {
;;;392      /* Check the parameters */
;;;393      assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
;;;394      assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));
;;;395    
;;;396      /* Clear PLL Source [16] and Multiplier [21:18] bits */
;;;397      RCC->CFGR &= ~(RCC_CFGR_PLLMULL | RCC_CFGR_PLLSRC);
000002  6852              LDR      r2,[r2,#4]
000004  237b              MOVS     r3,#0x7b
000006  03db              LSLS     r3,r3,#15
000008  439a              BICS     r2,r2,r3
00000a  4b05              LDR      r3,|L33.32|
00000c  605a              STR      r2,[r3,#4]
;;;398    
;;;399      /* Set the PLL Source and Multiplier */
;;;400      RCC->CFGR |= (uint32_t)(RCC_PLLSource | RCC_PLLMul);
00000e  461a              MOV      r2,r3
000010  6852              LDR      r2,[r2,#4]
000012  4603              MOV      r3,r0
000014  430b              ORRS     r3,r3,r1
000016  431a              ORRS     r2,r2,r3
000018  4b01              LDR      r3,|L33.32|
00001a  605a              STR      r2,[r3,#4]
;;;401    }
00001c  4770              BX       lr
;;;402    
                          ENDP

00001e  0000              DCW      0x0000
                  |L33.32|
                          DCD      0x40021000

                          AREA ||i.RCC_PREDIV1Config||, CODE, READONLY, ALIGN=2

                  RCC_PREDIV1Config PROC
;;;460      */
;;;461    void RCC_PREDIV1Config(uint32_t RCC_PREDIV1_Div)
000000  4601              MOV      r1,r0
;;;462    {
;;;463      uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;464      
;;;465      /* Check the parameters */
;;;466      assert_param(IS_RCC_PREDIV1(RCC_PREDIV1_Div));
;;;467    
;;;468      tmpreg = RCC->CFGR2;
000004  4a04              LDR      r2,|L34.24|
000006  6ad0              LDR      r0,[r2,#0x2c]
;;;469      /* Clear PREDIV1[3:0] bits */
;;;470      tmpreg &= ~(RCC_CFGR2_PREDIV1);
000008  0900              LSRS     r0,r0,#4
00000a  0100              LSLS     r0,r0,#4
;;;471      /* Set the PREDIV1 division factor */
;;;472      tmpreg |= RCC_PREDIV1_Div;
00000c  4602              MOV      r2,r0
00000e  430a              ORRS     r2,r2,r1
000010  4610              MOV      r0,r2
;;;473      /* Store the new value */
;;;474      RCC->CFGR2 = tmpreg;
000012  4a01              LDR      r2,|L34.24|
000014  62d0              STR      r0,[r2,#0x2c]
;;;475    }
000016  4770              BX       lr
;;;476    
                          ENDP

                  |L34.24|
                          DCD      0x40021000

                          AREA ||i.RCC_RTCCLKCmd||, CODE, READONLY, ALIGN=2

                  RCC_RTCCLKCmd PROC
;;;1041     */
;;;1042   void RCC_RTCCLKCmd(FunctionalState NewState)
000000  2800              CMP      r0,#0
;;;1043   {
;;;1044     /* Check the parameters */
;;;1045     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1046     
;;;1047     if (NewState != DISABLE)
000002  d007              BEQ      |L35.20|
;;;1048     {
;;;1049       RCC->BDCR |= RCC_BDCR_RTCEN;
000004  4907              LDR      r1,|L35.36|
000006  6a09              LDR      r1,[r1,#0x20]
000008  2201              MOVS     r2,#1
00000a  03d2              LSLS     r2,r2,#15
00000c  4311              ORRS     r1,r1,r2
00000e  4a05              LDR      r2,|L35.36|
000010  6211              STR      r1,[r2,#0x20]
000012  e006              B        |L35.34|
                  |L35.20|
;;;1050     }
;;;1051     else
;;;1052     {
;;;1053       RCC->BDCR &= ~RCC_BDCR_RTCEN;
000014  4903              LDR      r1,|L35.36|
000016  6a09              LDR      r1,[r1,#0x20]
000018  2201              MOVS     r2,#1
00001a  03d2              LSLS     r2,r2,#15
00001c  4391              BICS     r1,r1,r2
00001e  4a01              LDR      r2,|L35.36|
000020  6211              STR      r1,[r2,#0x20]
                  |L35.34|
;;;1054     }
;;;1055   }
000022  4770              BX       lr
;;;1056   
                          ENDP

                  |L35.36|
                          DCD      0x40021000

                          AREA ||i.RCC_RTCCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_RTCCLKConfig PROC
;;;1024     */
;;;1025   void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
000000  4902              LDR      r1,|L36.12|
;;;1026   {
;;;1027     /* Check the parameters */
;;;1028     assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
;;;1029     
;;;1030     /* Select the RTC clock source */
;;;1031     RCC->BDCR |= RCC_RTCCLKSource;
000002  6a09              LDR      r1,[r1,#0x20]
000004  4301              ORRS     r1,r1,r0
000006  4a01              LDR      r2,|L36.12|
000008  6211              STR      r1,[r2,#0x20]
;;;1032   }
00000a  4770              BX       lr
;;;1033   
                          ENDP

                  |L36.12|
                          DCD      0x40021000

                          AREA ||i.RCC_SYSCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_SYSCLKConfig PROC
;;;570      */
;;;571    void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
000000  4601              MOV      r1,r0
;;;572    {
;;;573      uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;574      
;;;575      /* Check the parameters */
;;;576      assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
;;;577      
;;;578      tmpreg = RCC->CFGR;
000004  4a04              LDR      r2,|L37.24|
000006  6850              LDR      r0,[r2,#4]
;;;579      
;;;580      /* Clear SW[1:0] bits */
;;;581      tmpreg &= ~RCC_CFGR_SW;
000008  0880              LSRS     r0,r0,#2
00000a  0080              LSLS     r0,r0,#2
;;;582      
;;;583      /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
;;;584      tmpreg |= RCC_SYSCLKSource;
00000c  4602              MOV      r2,r0
00000e  430a              ORRS     r2,r2,r1
000010  4610              MOV      r0,r2
;;;585      
;;;586      /* Store the new value */
;;;587      RCC->CFGR = tmpreg;
000012  4a01              LDR      r2,|L37.24|
000014  6050              STR      r0,[r2,#4]
;;;588    }
000016  4770              BX       lr
;;;589    
                          ENDP

                  |L37.24|
                          DCD      0x40021000

                          AREA ||i.RCC_USARTCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_USARTCLKConfig PROC
;;;748      */
;;;749    void RCC_USARTCLKConfig(uint32_t RCC_USARTCLK)
000000  2100              MOVS     r1,#0
;;;750    { 
;;;751      uint32_t tmp = 0;
;;;752      
;;;753      /* Check the parameters */
;;;754      assert_param(IS_RCC_USARTCLK(RCC_USARTCLK));
;;;755    
;;;756      /* Get USART index */
;;;757      tmp = (RCC_USARTCLK >> 28);
000002  0f01              LSRS     r1,r0,#28
;;;758    
;;;759      /* Clear USARTSW[1:0] bit */
;;;760      if (tmp == (uint32_t)0x00000001)
000004  2901              CMP      r1,#1
000006  d105              BNE      |L38.20|
;;;761      {
;;;762        /* Clear USART1SW[1:0] bit */  
;;;763        RCC->CFGR3 &= ~RCC_CFGR3_USART1SW;
000008  4a05              LDR      r2,|L38.32|
00000a  6b12              LDR      r2,[r2,#0x30]
00000c  0892              LSRS     r2,r2,#2
00000e  0092              LSLS     r2,r2,#2
000010  4b03              LDR      r3,|L38.32|
000012  631a              STR      r2,[r3,#0x30]
                  |L38.20|
;;;764      }
;;;765    //  else if (tmp == (uint32_t)0x00000002)
;;;766    //  {
;;;767    //    /* Clear USART2SW[1:0] bit */
;;;768    //    RCC->CFGR3 &= ~RCC_CFGR3_USART2SW;
;;;769    //  }
;;;770    //  else 
;;;771    //  {
;;;772    //    /* Clear USART3SW[1:0] bit */
;;;773    //    RCC->CFGR3 &= ~RCC_CFGR3_USART3SW;
;;;774    //  }
;;;775    
;;;776      /* Set USARTxSW bits according to RCC_USARTCLK value */
;;;777      RCC->CFGR3 |= RCC_USARTCLK;
000014  4a02              LDR      r2,|L38.32|
000016  6b12              LDR      r2,[r2,#0x30]
000018  4302              ORRS     r2,r2,r0
00001a  4b01              LDR      r3,|L38.32|
00001c  631a              STR      r2,[r3,#0x30]
;;;778    }
00001e  4770              BX       lr
;;;779    
                          ENDP

                  |L38.32|
                          DCD      0x40021000

                          AREA ||i.RCC_USBCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_USBCLKConfig PROC
;;;788      */
;;;789    void RCC_USBCLKConfig(uint32_t RCC_USBCLK)
000000  4905              LDR      r1,|L39.24|
;;;790    { 
;;;791      /* Check the parameters */
;;;792      assert_param(IS_RCC_USBCLK(RCC_USBCLK));
;;;793    
;;;794      /* Clear USBSW bit */
;;;795      RCC->CFGR3 &= ~RCC_CFGR3_USBSW;
000002  6b09              LDR      r1,[r1,#0x30]
000004  2280              MOVS     r2,#0x80
000006  4391              BICS     r1,r1,r2
000008  4a03              LDR      r2,|L39.24|
00000a  6311              STR      r1,[r2,#0x30]
;;;796      /* Set USBSW bits according to RCC_USBCLK value */
;;;797      RCC->CFGR3 |= RCC_USBCLK;
00000c  4611              MOV      r1,r2
00000e  6b09              LDR      r1,[r1,#0x30]
000010  4301              ORRS     r1,r1,r0
000012  6311              STR      r1,[r2,#0x30]
;;;798    }
000014  4770              BX       lr
;;;799    
                          ENDP

000016  0000              DCW      0x0000
                  |L39.24|
                          DCD      0x40021000

                          AREA ||i.RCC_WaitForHSEStartUp||, CODE, READONLY, ALIGN=1

                  RCC_WaitForHSEStartUp PROC
;;;128      */
;;;129    ErrorStatus RCC_WaitForHSEStartUp(void)
000000  b538              PUSH     {r3-r5,lr}
;;;130    {
;;;131      __IO uint32_t StartUpCounter = 0;
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
;;;132      ErrorStatus status = ERROR;
000006  2400              MOVS     r4,#0
;;;133      FlagStatus HSEStatus = RESET;
000008  2500              MOVS     r5,#0
;;;134      
;;;135      /* Wait till HSE is ready and if timeout is reached exit */
;;;136      do
00000a  bf00              NOP      
                  |L40.12|
;;;137      {
;;;138        HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
00000c  2011              MOVS     r0,#0x11
00000e  f7fffffe          BL       RCC_GetFlagStatus
000012  4605              MOV      r5,r0
;;;139        StartUpCounter++;  
000014  9800              LDR      r0,[sp,#0]
000016  1c40              ADDS     r0,r0,#1
000018  9000              STR      r0,[sp,#0]
;;;140      } while((StartUpCounter != HSE_STARTUP_TIMEOUT) && (HSEStatus == RESET));
00001a  2105              MOVS     r1,#5
00001c  0309              LSLS     r1,r1,#12
00001e  9800              LDR      r0,[sp,#0]
000020  4288              CMP      r0,r1
000022  d001              BEQ      |L40.40|
000024  2d00              CMP      r5,#0
000026  d0f1              BEQ      |L40.12|
                  |L40.40|
;;;141      
;;;142      if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
000028  2011              MOVS     r0,#0x11
00002a  f7fffffe          BL       RCC_GetFlagStatus
00002e  2800              CMP      r0,#0
000030  d001              BEQ      |L40.54|
;;;143      {
;;;144        status = SUCCESS;
000032  2401              MOVS     r4,#1
000034  e000              B        |L40.56|
                  |L40.54|
;;;145      }
;;;146      else
;;;147      {
;;;148        status = ERROR;
000036  2400              MOVS     r4,#0
                  |L40.56|
;;;149      }  
;;;150      return (status);
000038  4620              MOV      r0,r4
;;;151    }
00003a  bd38              POP      {r3-r5,pc}
;;;152    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  APBAHBPrescTable
000000  00000000          DCB      0x00,0x00,0x00,0x00
000004  01020304          DCB      0x01,0x02,0x03,0x04
000008  01020304          DCB      0x01,0x02,0x03,0x04
00000c  06070809          DCB      0x06,0x07,0x08,0x09

;*** Start embedded assembler ***

#line 1 "..\\FTLib\\Src\\ft32f0xx_rcc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_ft32f0xx_rcc_c_49e27980____REV16|
#line 129 "..\\FTLib\\CMSIS\\inc\\core_cmInstr.h"
|__asm___14_ft32f0xx_rcc_c_49e27980____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_ft32f0xx_rcc_c_49e27980____REVSH|
#line 144
|__asm___14_ft32f0xx_rcc_c_49e27980____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
