L 1 "..\user\eeprom.c"
N#include "eeprom.h"
L 1 "..\user\eeprom.h" 1
N#ifndef __EEPROM_H__
N#define __EEPROM_H__
N
N
N
N#include "main.h"
L 1 "..\user\main.h" 1
N/**
N  ******************************************************************************
N  * @file    	    main.h
N  * @author  	    FMD AE
N  * @brief   		This file contains all the functions prototypes for the main 
N  * @version 	    V1.0.0           
N  * @data		    2022-01-13
N  ******************************************************************************
N  * @attention
N  * COPYRIGHT (C) 2021 Fremont Micro Devices Corporation All rights reserved.
N  *    This software is provided by the copyright holders and contributors,and the
N  *software is believed to be accurate and reliable. However, Fremont Micro Devices
N  * Corporation assumes no responsibility for the consequences of use of such
N  *software or for any infringement of patents of other rights of third parties,
N  *which may result from its use. No license is granted by implication or otherwise
N  *under any patent rights of Fremont Micro Devices Corporation.
N  *  ******************************************************************************
N  */
N#ifndef __MAIN_H
N#define __MAIN_H
N
N/* Includes ---------------------------------------------------------------------*/
N#include <stdio.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5060044
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N
N#pragma __printf_args
Nextern _ARMABI int __ARM_snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int __ARM_vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int __ARM_vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
Nextern _ARMABI int __ARM_vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
N#pragma __printf_args
Nextern _ARMABI int asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N#endif
N#pragma __printf_args
Nextern _ARMABI int __ARM_asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int __ARM_vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N   /*
N    * dynamically allocates a buffer of the right size for the
N    * formatted string, and returns it in (*strp). Formal return value
N    * is the same as any other printf variant, except that it returns
N    * -1 if the buffer could not be allocated.
N    *
N    * (The functions with __ARM_ prefixed names are identical to the
N    * ones without, but are available in all compilation modes without
N    * violating user namespace.)
N    */
N
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S#if !defined(__STRICT_ANSI__)
S    using ::std::asprintf;
S    using ::std::vasprintf;
S#endif
S    using ::std::__ARM_asprintf;
S    using ::std::__ARM_vasprintf;
S    using ::std::__ARM_vsnprintf;
S    using ::std::__ARM_snprintf;
S    using ::std::__ARM_vsscanf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 24 "..\user\main.h" 2
N#include <stdlib.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998,2014 ARM Limited. All rights reserved.       */
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5060044
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X    #if 0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
X#elif !0L
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X   #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
X  #elif !0L
S    #define __wchar_t 1
S   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Ntypedef struct lldiv_t { __LONGLONG quot, rem; } lldiv_t;
Xtypedef struct lldiv_t { long long quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI __LONGLONG atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long long atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __LONGLONG strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long long strtoll(const char * __restrict  ,
N                                  char ** __restrict /*endptr*/, int /*base*/)
N                          __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __LONGLONG strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long long strtoull(const char * __restrict  ,
N                                            char ** __restrict /*endptr*/, int /*base*/)
N                                   __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__EDG__) && !defined(__GNUC__)
X#if 1L && !1L
S#define __LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE
N#endif
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE) 
X#if 0L && 0L 
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 0L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 0L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI_PURE __LONGLONG llabs(__LONGLONG /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long long llabs(long long  );
N   /*
N    * computes the absolute value of a long long integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __LONGLONG abs(__LONGLONG x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__LONGLONG /*numer*/, __LONGLONG /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) lldiv_t lldiv(long long  , long long  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__LONGLONG __numer, __LONGLONG __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N#endif
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S#endif
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#undef __LONGLONG
N
N#endif /* __stdlib_h */
N
N/* end of stdlib.h */
L 25 "..\user\main.h" 2
N#include <stdint.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060044
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 26 "..\user\main.h" 2
N#include <string.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060044
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
X#elif !0L
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 27 "..\user\main.h" 2
N#include "ft32f0xx.h"
L 1 "..\FTLib\CMSIS\inc\ft32f0xx.h" 1
N/**
N  ******************************************************************************
N  * @file    			ft32f0xx.h
N  * @author  			FMD AE
N  * @brief   			CMSIS FT32F0xx Device Peripheral Access Layer Header File.    	
N  * @version 			V1.0.0           
N  * @data		 			2021-07-01
N  ******************************************************************************
N  */
N
N#ifndef __FT32F0xx_H
N#define __FT32F0xx_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif /* __cplusplus */
N 
N
N#if !defined  (FT32F0)
X#if !0L
N#define FT32F0
N#endif /* FT32F0 */
N
N
N
N/**
N  * @brief CMSIS Device version number V2.3.3
N  */
N#define __FT32F0_DEVICE_VERSION_MAIN   (0x02) /*!< [31:24] main version */
N#define __FT32F0_DEVICE_VERSION_SUB1   (0x03) /*!< [23:16] sub1 version */
N#define __FT32F0_DEVICE_VERSION_SUB2   (0x03) /*!< [15:8]  sub2 version */
N#define __FT32F0_DEVICE_VERSION_RC     (0x00) /*!< [7:0]  release candidate */ 
N#define __FT32F0_DEVICE_VERSION        ((__FT32F0_DEVICE_VERSION_MAIN << 24)\
N                                        |(__FT32F0_DEVICE_VERSION_SUB1 << 16)\
N                                        |(__FT32F0_DEVICE_VERSION_SUB2 << 8 )\
N                                        |(__FT32F0_DEVICE_VERSION_RC))
X#define __FT32F0_DEVICE_VERSION        ((__FT32F0_DEVICE_VERSION_MAIN << 24)                                        |(__FT32F0_DEVICE_VERSION_SUB1 << 16)                                        |(__FT32F0_DEVICE_VERSION_SUB2 << 8 )                                        |(__FT32F0_DEVICE_VERSION_RC))
N                                             
N
N/* Exported macro ------------------------------------------------------------*/
N#ifdef  USE_FULL_ASSERT
S
S  #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
S/* Exported functions ------------------------------------------------------- */
S  void assert_failed(uint8_t* file, uint32_t line);
N#else
N  #define assert_param(expr) ((void)0)
N#endif /* USE_FULL_ASSERT */
N
N#if defined(FT32F030x6)
X#if 0L
S  #include "ft32f030x6.h"
S#elif defined(FT32F030x8)
X#elif 0L
S  #include "ft32f030x8.h"
N#elif defined(FT32F072x8)
X#elif 1L
N  #include "ft32f072x8.h" 
L 1 "..\FTLib\CMSIS\inc\ft32f072x8.h" 1
N/**
N  ******************************************************************************
N  * @file    			ft32f072x8.h
N  * @author  			FMD AE
N  * @brief   			CMSIS Cortex-M0 Device Peripheral Access Layer Header File. 
N  * @details 			This file contains all the peripheral register's definitions, bits 
N  *          			definitions and memory mapping for FT32F072X8 devices.  
N  * @version 			V1.0.0
N  * @date    			2021-07-01 
N  *******************************************************************************	
N  */
N
N/** @addtogroup CMSIS
N  * @{
N  */
N
N/** @addtogroup ft32f030x8
N  * @{
N  */
N    
N#ifndef __FT32F072X8_H
N#define __FT32F072X8_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif 
N  
N/** @addtogroup Library_configuration_section
N  * @{
N  */
N  
N/* Uncomment the line below according to the target FT32F0 device used in your 
N   application 
N  */
N
N#if !defined (FT32F072X8)
X#if !0L
N  #define FT32F072X8 
N#endif
N
N/*  Tip: To avoid modifying this file each time you need to switch between these
N        devices, you can define the device in your toolchain compiler preprocessor.
N  */
N
N
N#if !defined  USE_STDPERIPH_DRIVER
X#if !0L
N/**
N * @brief Comment the line below if you will not use the peripherals drivers.
N   In this case, these drivers will not be included and the application code will 
N   be based on direct access to peripherals registers 
N   */
N  /*#define USE_STDPERIPH_DRIVER*/
N#endif /* USE_STDPERIPH_DRIVER */
N
N/**
N * @brief In the following line adjust the value of External High Speed oscillator (HSE)
N   used in your application 
N   
N   Tip: To avoid modifying this file each time you need to use different HSE, you
N        can define the HSE value in your toolchain compiler preprocessor.
N  */
N#if !defined  (HSE_VALUE)     
X#if !0L     
N#define HSE_VALUE    ((uint32_t)8000000) /*!< Value of the External oscillator in Hz*/
N#endif /* HSE_VALUE */
N
N/**
N * @brief In the following line adjust the External High Speed oscillator (HSE) Startup 
N   Timeout value 
N   */
N#if !defined  (HSE_STARTUP_TIMEOUT)
X#if !0L
N#define HSE_STARTUP_TIMEOUT   ((uint16_t)0x5000) /*!< Time out for HSE start up */
N#endif /* HSE_STARTUP_TIMEOUT */
N
N/**
N * @brief In the following line adjust the Internal High Speed oscillator (HSI) Startup 
N   Timeout value 
N   */
N#if !defined  (HSI_STARTUP_TIMEOUT)
X#if !0L
N#define HSI_STARTUP_TIMEOUT   ((uint16_t)0x5000) /*!< Time out for HSI start up */
N#endif /* HSI_STARTUP_TIMEOUT */
N
N#if !defined  (HSI_VALUE) 
X#if !0L 
N#define HSI_VALUE  ((uint32_t)8000000) /*!< Value of the Internal High Speed oscillator in Hz.
N                                             The real value may vary depending on the variations
N                                             in voltage and temperature.  */
N#endif /* HSI_VALUE */
N
N#if !defined  (HSI14_VALUE) 
X#if !0L 
N#define HSI14_VALUE ((uint32_t)14000000) /*!< Value of the Internal High Speed oscillator for ADC in Hz.
N                                             The real value may vary depending on the variations
N                                             in voltage and temperature.  */
N#endif /* HSI14_VALUE */
N
N#if !defined  (HSI48_VALUE) 
X#if !0L 
N#define HSI48_VALUE ((uint32_t)48000000) /*!< Value of the Internal High Speed oscillator for USB in Hz.
N                                             The real value may vary depending on the variations
N                                             in voltage and temperature.  */
N#endif /* HSI48_VALUE */
N
N#if !defined  (LSI_VALUE) 
X#if !0L 
N#define LSI_VALUE  ((uint32_t)40000)    /*!< Value of the Internal Low Speed oscillator in Hz
N                                             The real value may vary depending on the variations
N                                             in voltage and temperature.  */
N#endif /* LSI_VALUE */
N
N#if !defined  (LSE_VALUE) 
X#if !0L 
N#define LSE_VALUE  ((uint32_t)32768)    /*!< Value of the External Low Speed oscillator in Hz */
N#endif /* LSE_VALUE */
N
N/**
N * @brief FT32F0XX Standard Peripheral Library version number V1.4.0
N   */
N#define __FT32F0XX_STDPERIPH_VERSION_MAIN   (0x01) /*!< [31:24] main version */
N#define __FT32F0XX_STDPERIPH_VERSION_SUB1   (0x05) /*!< [23:16] sub1 version */
N#define __FT32F0XX_STDPERIPH_VERSION_SUB2   (0x00) /*!< [15:8]  sub2 version */
N#define __FT32F0XX_STDPERIPH_VERSION_RC     (0x00) /*!< [7:0]  release candidate */ 
N#define __FT32F0XX_STDPERIPH_VERSION        ((__FT32F0XX_STDPERIPH_VERSION_MAIN << 24)\
N                                             |(__FT32F0XX_STDPERIPH_VERSION_SUB1 << 16)\
N                                             |(__FT32F0XX_STDPERIPH_VERSION_SUB2 << 8)\
N                                             |(__FT32F0XX_STDPERIPH_VERSION_RC))
X#define __FT32F0XX_STDPERIPH_VERSION        ((__FT32F0XX_STDPERIPH_VERSION_MAIN << 24)                                             |(__FT32F0XX_STDPERIPH_VERSION_SUB1 << 16)                                             |(__FT32F0XX_STDPERIPH_VERSION_SUB2 << 8)                                             |(__FT32F0XX_STDPERIPH_VERSION_RC))
N
N/**
N  * @}
N  */
N
N/** @addtogroup Configuration_section_for_CMSIS
N  * @{
N  */
N
N/**
N * @brief FT32F072X8 Interrupt Number Definition, according to the selected device 
N *        in @ref Library_configuration_section 
N */
N#define __CM0_REV                 0 /*!< Core Revision r0p0                            */
N#define __MPU_PRESENT             0 /*!< FT32F072X8 do not provide MPU                  */
N#define __NVIC_PRIO_BITS          2 /*!< FT32F072X8 uses 2 Bits for the Priority Levels */
N#define __Vendor_SysTickConfig    0 /*!< Set to 1 if different SysTick Config is used  */
N
N/*!< Interrupt Number Definition */
Ntypedef enum IRQn
N{
N/******  Cortex-M0 Processor Exceptions Numbers ******************************************************/
N  NonMaskableInt_IRQn         = -14,    /*!< 2 Non Maskable Interrupt                                */
N  HardFault_IRQn              = -13,    /*!< 3 Cortex-M0 Hard Fault Interrupt                        */
N  SVC_IRQn                    = -5,     /*!< 11 Cortex-M0 SV Call Interrupt                          */
N  PendSV_IRQn                 = -2,     /*!< 14 Cortex-M0 Pend SV Interrupt                          */
N  SysTick_IRQn                = -1,     /*!< 15 Cortex-M0 System Tick Interrupt                      */
N  
N/******  FT32F0 specific Interrupt Numbers ******************************************************************/
N  WWDG_IRQn                   = 0,      /*!< Window WatchDog Interrupt                                     */
N  PVD_VDDIO2_IRQn             = 1,      /*!< PVD and VDDIO2 supply comparator through EXTI Line detect Interrupt */
N  RTC_IRQn                    = 2,      /*!< RTC through EXTI Line Interrupt                               */
N  FLASH_IRQn                  = 3,      /*!< FLASH Interrupt                                               */
N  RCC_CRS_IRQn                = 4,      /*!< RCC and CRS Interrupts                                        */
N  EXTI0_1_IRQn                = 5,      /*!< EXTI Line 0 and 1 Interrupts                                  */
N  EXTI2_3_IRQn                = 6,      /*!< EXTI Line 2 and 3 Interrupts                                  */
N  EXTI4_15_IRQn               = 7,      /*!< EXTI Line 4 to 15 Interrupts                                  */
N  DMA1_Channel1_IRQn          = 9,      /*!< DMA1 Channel 1 Interrupt                                      */
N  DMA1_Channel2_3_IRQn        = 10,     /*!< DMA1 Channel 2 and Channel 3 Interrupts                       */
N  DMA1_Channel4_5_IRQn        = 11,     /*!< DMA1 Channel 4, Channel 5, Channel 6 and Channel 7 Interrupts */
N  ADC1_COMP_IRQn              = 12,     /*!< ADC1, COMP1 and COMP2 Interrupts                              */
N  TIM1_BRK_UP_TRG_COM_IRQn    = 13,     /*!< TIM1 Break, Update, Trigger and Commutation Interrupts        */
N  TIM1_CC_IRQn                = 14,     /*!< TIM1 Capture Compare Interrupt                                */
N  TIM3_IRQn                   = 16,     /*!< TIM3 Interrupt                                                */
N  TIM6_DAC_IRQn               = 17,     /*!< TIM6 and DAC Interrupts                                       */
N  TIM14_IRQn                  = 19,     /*!< TIM14 Interrupt                                               */
N  TIM15_IRQn                  = 20,     /*!< TIM15 Interrupt                                               */
N  TIM16_IRQn                  = 21,     /*!< TIM16 Interrupt                                               */
N  TIM17_IRQn                  = 22,     /*!< TIM17 Interrupt                                               */
N  I2C1_IRQn                   = 23,     /*!< I2C1 Interrupt                                                */
N  I2C2_IRQn                   = 24,     /*!< I2C2 Interrupt                                                */
N  SPI1_IRQn                   = 25,     /*!< SPI1 Interrupt                                                */
N  SPI2_IRQn                   = 26,     /*!< SPI2 Interrupt                                                */
N  USART1_IRQn                 = 27,     /*!< USART1 Interrupt                                              */
N  USART2_IRQn                 = 28,     /*!< USART2 Interrupt                                              */
N  USB_IRQn                    = 31      /*!< USB Low Priority global Interrupt                             */
N}IRQn_Type;
N
N/**
N  * @}
N  */
N
N#include "core_cm0.h"
L 1 "..\FTLib\CMSIS\inc\core_cm0.h" 1
N/**************************************************************************//**
N * @file     core_cm0.h
N * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File
N * @version  V3.30
N * @date     17. February 2014
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2009 - 2014 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if defined ( __ICCARM__ )
X#if 0L
S #pragma system_include  /* treat file as system include file for MISRA check */
N#endif
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N#ifndef __CORE_CM0_H_GENERIC
N#define __CORE_CM0_H_GENERIC
N
N/** \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/** \ingroup Cortex_M0
N  @{
N */
N
N/*  CMSIS CM0 definitions */
N#define __CM0_CMSIS_VERSION_MAIN  (0x03)                                   /*!< [31:16] CMSIS HAL main version   */
N#define __CM0_CMSIS_VERSION_SUB   (0x20)                                   /*!< [15:0]  CMSIS HAL sub version    */
N#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16) | \
N                                    __CM0_CMSIS_VERSION_SUB          )     /*!< CMSIS HAL version number         */
X#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16) |                                     __CM0_CMSIS_VERSION_SUB          )      
N
N#define __CORTEX_M                (0x00)                                   /*!< Cortex-M Core                    */
N
N
N#if   defined ( __CC_ARM )
X#if   1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
N  #define __STATIC_INLINE  static __inline
N
N#elif defined ( __GNUC__ )
X#elif 1L
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __ICCARM__ )
S  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TMS470__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TI CCS Compiler       */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __CSMC__ )		/* Cosmic */
S  #define __packed
S  #define __ASM            _asm                                      /*!< asm keyword for COSMIC Compiler      */
S  #define __INLINE         inline                                    /*use -pc99 on compile line !< inline keyword for COSMIC Compiler   */
S  #define __STATIC_INLINE  static inline
S
N#endif
N
N/** __FPU_USED indicates whether an FPU is used or not. This core does not support an FPU at all
N*/
N#define __FPU_USED       0
N
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 0L
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
N  #endif
N
N#elif defined ( __GNUC__ )
X#elif 1L
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TMS470__ )
S  #if defined __TI__VFP_SUPPORT____
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __CSMC__ )		/* Cosmic */
S  #if ( __CSMC__ & 0x400)		// FPU present for parser
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
N#endif
N
N#include <stdint.h>                      /* standard types definitions                      */
N#include <core_cmInstr.h>                /* Core Instruction Access                         */
L 1 "..\FTLib\CMSIS\inc\core_cmInstr.h" 1
N/**************************************************************************//**
N * @file     core_cmInstr.h
N * @brief    CMSIS Cortex-M Core Instruction Access Header File
N * @version  V3.30
N * @date     17. February 2014
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2009 - 2014 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#ifndef __CORE_CMINSTR_H
N#define __CORE_CMINSTR_H
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5060960 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N
N/** \brief  No Operation
N
N    No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/** \brief  Wait For Interrupt
N
N    Wait For Interrupt is a hint instruction that suspends execution
N    until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/** \brief  Wait For Event
N
N    Wait For Event is a hint instruction that permits the processor to enter
N    a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/** \brief  Send Event
N
N    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/** \brief  Instruction Synchronization Barrier
N
N    Instruction Synchronization Barrier flushes the pipeline in the processor,
N    so that all instructions following the ISB are fetched from cache or
N    memory, after the instruction has been completed.
N */
N#define __ISB()                           __isb(0xF)
N
N
N/** \brief  Data Synchronization Barrier
N
N    This function acts as a special kind of Data Memory Barrier.
N    It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB()                           __dsb(0xF)
N
N
N/** \brief  Data Memory Barrier
N
N    This function ensures the apparent order of the explicit memory operations before
N    and after the instruction, without ensuring their completion.
N */
N#define __DMB()                           __dmb(0xF)
N
N
N/** \brief  Reverse byte order (32 bit)
N
N    This function reverses the byte order in integer value.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/** \brief  Reverse byte order (16 bit)
N
N    This function reverses the byte order in two unsigned short values.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N/** \brief  Reverse byte order in signed short value
N
N    This function reverses the byte order in a signed short value with sign extension to integer.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/** \brief  Rotate Right in unsigned value (32 bit)
N
N    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N
N    \param [in]    value  Value to rotate
N    \param [in]    value  Number of Bits to rotate
N    \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N/** \brief  Breakpoint
N
N    This function causes the processor to enter Debug state.
N    Debug tools can use this to investigate system state when the instruction at a particular address is reached.
N
N    \param [in]    value  is ignored by the processor.
N                   If required, a debugger can use it to store additional information about the breakpoint.
N */
N#define __BKPT(value)                       __breakpoint(value)
N
N
N#if       (__CORTEX_M >= 0x03)
X#if       ((0x00) >= 0x03)
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S#define __RBIT                            __rbit
S
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function performs a exclusive LDR command for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S#define __LDREXB(ptr)                     ((uint8_t ) __ldrex(ptr))
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function performs a exclusive LDR command for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S#define __LDREXH(ptr)                     ((uint16_t) __ldrex(ptr))
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function performs a exclusive LDR command for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S#define __LDREXW(ptr)                     ((uint32_t ) __ldrex(ptr))
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function performs a exclusive STR command for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXB(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function performs a exclusive STR command for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXH(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function performs a exclusive STR command for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXW(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
S#define __CLREX                           __clrex
S
S
S/** \brief  Signed Saturate
S
S    This function saturates a signed value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (1..32)
S    \return             Saturated value
S */
S#define __SSAT                            __ssat
S
S
S/** \brief  Unsigned Saturate
S
S    This function saturates an unsigned value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (0..31)
S    \return             Saturated value
S */
S#define __USAT                            __usat
S
S
S/** \brief  Count leading zeros
S
S    This function counts the number of leading zeros of a data value.
S
S    \param [in]  value  Value to count the leading zeros
S    \return             number of leading zeros in value
S */
S#define __CLZ                             __clz
S
N#endif /* (__CORTEX_M >= 0x03) */
N
N
N#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
X#elif 1L  
S/* GNU gcc specific functions */
S
S/* Define macros for porting to both thumb1 and thumb2.
S * For thumb1, use low register (r0-r7), specified by constrant "l"
S * Otherwise, use general registers, specified by constrant "r" */
S#if defined (__thumb__) && !defined (__thumb2__)
S#define __CMSIS_GCC_OUT_REG(r) "=l" (r)
S#define __CMSIS_GCC_USE_REG(r) "l" (r)
S#else
S#define __CMSIS_GCC_OUT_REG(r) "=r" (r)
S#define __CMSIS_GCC_USE_REG(r) "r" (r)
S#endif
S
S/** \brief  No Operation
S
S    No Operation does nothing. This instruction can be used for code alignment purposes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __NOP(void)
S{
S  __ASM volatile ("nop");
S}
S
S
S/** \brief  Wait For Interrupt
S
S    Wait For Interrupt is a hint instruction that suspends execution
S    until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFI(void)
S{
S  __ASM volatile ("wfi");
S}
S
S
S/** \brief  Wait For Event
S
S    Wait For Event is a hint instruction that permits the processor to enter
S    a low-power state until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFE(void)
S{
S  __ASM volatile ("wfe");
S}
S
S
S/** \brief  Send Event
S
S    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __SEV(void)
S{
S  __ASM volatile ("sev");
S}
S
S
S/** \brief  Instruction Synchronization Barrier
S
S    Instruction Synchronization Barrier flushes the pipeline in the processor,
S    so that all instructions following the ISB are fetched from cache or
S    memory, after the instruction has been completed.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __ISB(void)
S{
S  __ASM volatile ("isb");
S}
S
S
S/** \brief  Data Synchronization Barrier
S
S    This function acts as a special kind of Data Memory Barrier.
S    It completes when all explicit memory accesses before this instruction complete.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __DSB(void)
S{
S  __ASM volatile ("dsb");
S}
S
S
S/** \brief  Data Memory Barrier
S
S    This function ensures the apparent order of the explicit memory operations before
S    and after the instruction, without ensuring their completion.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
S{
S  __ASM volatile ("dmb");
S}
S
S
S/** \brief  Reverse byte order (32 bit)
S
S    This function reverses the byte order in integer value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV(uint32_t value)
S{
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
S  return __builtin_bswap32(value);
S#else
S  uint32_t result;
S
S  __ASM volatile ("rev %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S#endif
S}
S
S
S/** \brief  Reverse byte order (16 bit)
S
S    This function reverses the byte order in two unsigned short values.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV16(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("rev16 %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S}
S
S
S/** \brief  Reverse byte order in signed short value
S
S    This function reverses the byte order in a signed short value with sign extension to integer.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE int32_t __REVSH(int32_t value)
S{
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S  return (short)__builtin_bswap16(value);
S#else
S  uint32_t result;
S
S  __ASM volatile ("revsh %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S#endif
S}
S
S
S/** \brief  Rotate Right in unsigned value (32 bit)
S
S    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
S
S    \param [in]    value  Value to rotate
S    \param [in]    value  Number of Bits to rotate
S    \return               Rotated value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
S{
S  return (op1 >> op2) | (op1 << (32 - op2)); 
S}
S
S
S/** \brief  Breakpoint
S
S    This function causes the processor to enter Debug state.
S    Debug tools can use this to investigate system state when the instruction at a particular address is reached.
S
S    \param [in]    value  is ignored by the processor.
S                   If required, a debugger can use it to store additional information about the breakpoint.
S */
S#define __BKPT(value)                       __ASM volatile ("bkpt "#value)
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S
S   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function performs a exclusive LDR command for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __LDREXB(volatile uint8_t *addr)
S{
S    uint32_t result;
S
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S   __ASM volatile ("ldrexb %0, %1" : "=r" (result) : "Q" (*addr) );
S#else
S    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
S       accepted by assembler. So has to use following less efficient pattern.
S    */
S   __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
S#endif
S   return ((uint8_t) result);    /* Add explicit type cast here */
S}
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function performs a exclusive LDR command for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint16_t __LDREXH(volatile uint16_t *addr)
S{
S    uint32_t result;
S
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S   __ASM volatile ("ldrexh %0, %1" : "=r" (result) : "Q" (*addr) );
S#else
S    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
S       accepted by assembler. So has to use following less efficient pattern.
S    */
S   __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
S#endif
S   return ((uint16_t) result);    /* Add explicit type cast here */
S}
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function performs a exclusive LDR command for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
S{
S    uint32_t result;
S
S   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function performs a exclusive STR command for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexb %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" ((uint32_t)value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function performs a exclusive STR command for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXH(uint16_t value, volatile uint16_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexh %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" ((uint32_t)value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function performs a exclusive STR command for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
S   return(result);
S}
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __CLREX(void)
S{
S  __ASM volatile ("clrex" ::: "memory");
S}
S
S
S/** \brief  Signed Saturate
S
S    This function saturates a signed value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (1..32)
S    \return             Saturated value
S */
S#define __SSAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __SSAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Unsigned Saturate
S
S    This function saturates an unsigned value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (0..31)
S    \return             Saturated value
S */
S#define __USAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __USAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Count leading zeros
S
S    This function counts the number of leading zeros of a data value.
S
S    \param [in]  value  Value to count the leading zeros
S    \return             number of leading zeros in value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
S   return ((uint8_t) result);    /* Add explicit type cast here */
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all intrinsics,
S * Including the CMSIS ones.
S */
S
S
S#elif defined ( __CSMC__ ) /*------------------ COSMIC Compiler -------------------*/
S/* Cosmic specific functions */
S#include <cmsis_csm.h>
S
N#endif
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N#endif /* __CORE_CMINSTR_H */
L 148 "..\FTLib\CMSIS\inc\core_cm0.h" 2
N#include <core_cmFunc.h>                 /* Core Function Access                            */
L 1 "..\FTLib\CMSIS\inc\core_cmFunc.h" 1
N/**************************************************************************//**
N * @file     core_cmFunc.h
N * @brief    CMSIS Cortex-M Core Function Access Header File
N * @version  V3.30
N * @date     17. February 2014
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2009 - 2014 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#ifndef __CORE_CMFUNC_H
N#define __CORE_CMFUNC_H
N
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5060960 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N/** \brief  Get Control Register
N
N    This function returns the content of the Control Register.
N
N    \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/** \brief  Set Control Register
N
N    This function writes the given value to the Control Register.
N
N    \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/** \brief  Get IPSR Register
N
N    This function returns the content of the IPSR Register.
N
N    \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/** \brief  Get APSR Register
N
N    This function returns the content of the APSR Register.
N
N    \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/** \brief  Get xPSR Register
N
N    This function returns the content of the xPSR Register.
N
N    \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/** \brief  Get Process Stack Pointer
N
N    This function returns the current value of the Process Stack Pointer (PSP).
N
N    \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/** \brief  Set Process Stack Pointer
N
N    This function assigns the given value to the Process Stack Pointer (PSP).
N
N    \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/** \brief  Get Main Stack Pointer
N
N    This function returns the current value of the Main Stack Pointer (MSP).
N
N    \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/** \brief  Set Main Stack Pointer
N
N    This function assigns the given value to the Main Stack Pointer (MSP).
N
N    \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/** \brief  Get Priority Mask
N
N    This function returns the current state of the priority mask bit from the Priority Mask Register.
N
N    \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/** \brief  Set Priority Mask
N
N    This function assigns the given value to the Priority Mask Register.
N
N    \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if       (__CORTEX_M >= 0x03)
X#if       ((0x00) >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S#define __enable_fault_irq                __enable_fiq
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S#define __disable_fault_irq               __disable_fiq
S
S
S/** \brief  Get Base Priority
S
S    This function returns the current value of the Base Priority register.
S
S    \return               Base Priority register value
S */
S__STATIC_INLINE uint32_t  __get_BASEPRI(void)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  return(__regBasePri);
S}
S
S
S/** \brief  Set Base Priority
S
S    This function assigns the given value to the Base Priority register.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  __regBasePri = (basePri & 0xff);
S}
S
S
S/** \brief  Get Fault Mask
S
S    This function returns the current value of the Fault Mask register.
S
S    \return               Fault Mask register value
S */
S__STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  return(__regFaultMask);
S}
S
S
S/** \brief  Set Fault Mask
S
S    This function assigns the given value to the Fault Mask register.
S
S    \param [in]    faultMask  Fault Mask value to set
S */
S__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  __regFaultMask = (faultMask & (uint32_t)1);
S}
S
N#endif /* (__CORTEX_M >= 0x03) */
N
N
N#if       (__CORTEX_M == 0x04)
X#if       ((0x00) == 0x04)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  return(__regfpscr);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  __regfpscr = (fpscr);
S#endif
S}
S
N#endif /* (__CORTEX_M == 0x04) */
N
N
N#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
X#elif 1L  
S/* GNU gcc specific functions */
S
S/** \brief  Enable IRQ Interrupts
S
S  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
S{
S  __ASM volatile ("cpsie i" : : : "memory");
S}
S
S
S/** \brief  Disable IRQ Interrupts
S
S  This function disables IRQ interrupts by setting the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
S{
S  __ASM volatile ("cpsid i" : : : "memory");
S}
S
S
S/** \brief  Get Control Register
S
S    This function returns the content of the Control Register.
S
S    \return               Control Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_CONTROL(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, control" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Control Register
S
S    This function writes the given value to the Control Register.
S
S    \param [in]    control  Control Register value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_CONTROL(uint32_t control)
S{
S  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
S}
S
S
S/** \brief  Get IPSR Register
S
S    This function returns the content of the IPSR Register.
S
S    \return               IPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get APSR Register
S
S    This function returns the content of the APSR Register.
S
S    \return               APSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_APSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, apsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get xPSR Register
S
S    This function returns the content of the xPSR Register.
S
S    \return               xPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_xPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get Process Stack Pointer
S
S    This function returns the current value of the Process Stack Pointer (PSP).
S
S    \return               PSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Process Stack Pointer
S
S    This function assigns the given value to the Process Stack Pointer (PSP).
S
S    \param [in]    topOfProcStack  Process Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
S{
S  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
S}
S
S
S/** \brief  Get Main Stack Pointer
S
S    This function returns the current value of the Main Stack Pointer (MSP).
S
S    \return               MSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_MSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Main Stack Pointer
S
S    This function assigns the given value to the Main Stack Pointer (MSP).
S
S    \param [in]    topOfMainStack  Main Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
S{
S  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
S}
S
S
S/** \brief  Get Priority Mask
S
S    This function returns the current state of the priority mask bit from the Priority Mask Register.
S
S    \return               Priority Mask value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, primask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Priority Mask
S
S    This function assigns the given value to the Priority Mask Register.
S
S    \param [in]    priMask  Priority Mask
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
S{
S  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
S}
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_fault_irq(void)
S{
S  __ASM volatile ("cpsie f" : : : "memory");
S}
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_fault_irq(void)
S{
S  __ASM volatile ("cpsid f" : : : "memory");
S}
S
S
S/** \brief  Get Base Priority
S
S    This function returns the current value of the Base Priority register.
S
S    \return               Base Priority register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Base Priority
S
S    This function assigns the given value to the Base Priority register.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
S{
S  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
S}
S
S
S/** \brief  Get Fault Mask
S
S    This function returns the current value of the Fault Mask register.
S
S    \return               Fault Mask register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Fault Mask
S
S    This function assigns the given value to the Fault Mask register.
S
S    \param [in]    faultMask  Fault Mask value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S#if       (__CORTEX_M == 0x04)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  uint32_t result;
S
S  /* Empty asm statement works as a scheduling barrier */
S  __ASM volatile ("");
S  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
S  __ASM volatile ("");
S  return(result);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  /* Empty asm statement works as a scheduling barrier */
S  __ASM volatile ("");
S  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc");
S  __ASM volatile ("");
S#endif
S}
S
S#endif /* (__CORTEX_M == 0x04) */
S
S
S#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all intrinsics,
S * Including the CMSIS ones.
S */
S
S
S#elif defined ( __CSMC__ ) /*------------------ COSMIC Compiler -------------------*/
S/* Cosmic specific functions */
S#include <cmsis_csm.h>
S
N#endif
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N#endif /* __CORE_CMFUNC_H */
L 149 "..\FTLib\CMSIS\inc\core_cm0.h" 2
N
N#endif /* __CORE_CM0_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM0_H_DEPENDANT
N#define __CORE_CM0_H_DEPENDANT
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM0_REV
S    #define __CM0_REV               0x0000
S    #warning "__CM0_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          2
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions                 */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions                 */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions                */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions              */
N
N/*@} end of group Cortex_M0 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N ******************************************************************************/
N/** \defgroup CMSIS_core_register Defines and Type Definitions
N    \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_CORE  Status and Control Registers
N    \brief  Core Register type definitions.
N  @{
N */
N
N/** \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N#if (__CORTEX_M != 0x04)
X#if ((0x00) != 0x04)
N    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved                           */
N#else
S    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved                           */
N#endif
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} APSR_Type;
N
N
N/** \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} IPSR_Type;
N
N
N/** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N#if (__CORTEX_M != 0x04)
X#if ((0x00) != 0x04)
N    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved                           */
N#else
S    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved                           */
N#endif
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
N    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0)          */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} xPSR_Type;
N
N
N/** \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
N    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag           */
N    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} CONTROL_Type;
N
N/*@} end of group CMSIS_CORE */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N    \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IO uint32_t ISER[1];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register           */
X  volatile uint32_t ISER[1];                  
N       uint32_t RESERVED0[31];
N  __IO uint32_t ICER[1];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register          */
X  volatile uint32_t ICER[1];                  
N       uint32_t RSERVED1[31];
N  __IO uint32_t ISPR[1];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register           */
X  volatile uint32_t ISPR[1];                  
N       uint32_t RESERVED2[31];
N  __IO uint32_t ICPR[1];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register         */
X  volatile uint32_t ICPR[1];                  
N       uint32_t RESERVED3[31];
N       uint32_t RESERVED4[64];
N  __IO uint32_t IP[8];                   /*!< Offset: 0x300 (R/W)  Interrupt Priority Register              */
X  volatile uint32_t IP[8];                    
N}  NVIC_Type;
N
N/*@} end of group CMSIS_NVIC */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SCB     System Control Block (SCB)
N    \brief      Type definitions for the System Control Block Registers
N  @{
N */
N
N/** \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPUID Base Register                                   */
X  volatile const  uint32_t CPUID;                    
N  __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register                  */
X  volatile uint32_t ICSR;                     
N       uint32_t RESERVED0;
N  __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register      */
X  volatile uint32_t AIRCR;                    
N  __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register                               */
X  volatile uint32_t SCR;                      
N  __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register                        */
X  volatile uint32_t CCR;                      
N       uint32_t RESERVED1;
N  __IO uint32_t SHP[2];                  /*!< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED   */
X  volatile uint32_t SHP[2];                   
N  __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State Register             */
X  volatile uint32_t SHCSR;                    
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N    \brief      Type definitions for the System Timer Registers.
N  @{
N */
N
N/** \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register       */
X  volatile uint32_t LOAD;                     
N  __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register      */
X  volatile uint32_t VAL;                      
N  __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register        */
X  volatile const  uint32_t CALIB;                    
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N    \brief      Cortex-M0 Core Debug Registers (DCB registers, SHCSR, and DFSR)
N                are only accessible over DAP and not via processor. Therefore
N                they are not covered by the Cortex-M0 header file.
N  @{
N */
N/*@} end of group CMSIS_CoreDebug */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_core_base     Core Definitions
N    \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Cortex-M0 Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address              */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address                 */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct           */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct       */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct          */
N
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/** \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N    \brief      Functions that manage interrupts and exceptions via the NVIC.
N    @{
N */
N
N/* Interrupt Priorities are WORD accessible only under ARMv6M                   */
N/* The following MACROS handle generation of the register offset and byte masks */
N#define _BIT_SHIFT(IRQn)         (  (((uint32_t)(IRQn)       )    &  0x03) * 8 )
N#define _SHP_IDX(IRQn)           ( ((((uint32_t)(IRQn) & 0x0F)-8) >>    2)     )
N#define _IP_IDX(IRQn)            (   ((uint32_t)(IRQn)            >>    2)     )
N
N
N/** \brief  Enable External Interrupt
N
N    The function enables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Disable External Interrupt
N
N    The function disables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Get Pending Interrupt
N
N    The function reads the pending register in the NVIC and returns the pending bit
N    for the specified interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N
N    \return             0  Interrupt status is not pending.
N    \return             1  Interrupt status is pending.
N */
N__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t) ((NVIC->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));
X  return((uint32_t) ((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));
N}
N
N
N/** \brief  Set Pending Interrupt
N
N    The function sets the pending bit of an external interrupt.
N
N    \param [in]      IRQn  Interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Clear Pending Interrupt
N
N    The function clears the pending bit of an external interrupt.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N
N/** \brief  Set Interrupt Priority
N
N    The function sets the priority of an interrupt.
N
N    \note The priority cannot be set for every core interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N    \param [in]  priority  Priority to set.
N */
N__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if(IRQn < 0) {
N    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] = (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] & ~(0xFF << ( (((uint32_t)(IRQn) ) & 0x03) * 8 ))) |
N        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
X        (((priority << (8 - 2)) & 0xFF) << ( (((uint32_t)(IRQn) ) & 0x03) * 8 )); }
N  else {
N    NVIC->IP[_IP_IDX(IRQn)] = (NVIC->IP[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( ((uint32_t)(IRQn) >> 2) )] = (((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( ((uint32_t)(IRQn) >> 2) )] & ~(0xFF << ( (((uint32_t)(IRQn) ) & 0x03) * 8 ))) |
N        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
X        (((priority << (8 - 2)) & 0xFF) << ( (((uint32_t)(IRQn) ) & 0x03) * 8 )); }
N}
N
N
N/** \brief  Get Interrupt Priority
N
N    The function reads the priority of an interrupt. The interrupt
N    number can be positive to specify an external (device specific)
N    interrupt, or negative to specify an internal (core) interrupt.
N
N
N    \param [in]   IRQn  Interrupt number.
N    \return             Interrupt Priority. Value is aligned automatically to the implemented
N                        priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if(IRQn < 0) {
N    return((uint32_t)(((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & 0xFF) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M0 system interrupts */
X    return((uint32_t)(((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] >> ( (((uint32_t)(IRQn) ) & 0x03) * 8 ) ) & 0xFF) >> (8 - 2)));  }  
N  else {
N    return((uint32_t)(((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & 0xFF) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[ ( ((uint32_t)(IRQn) >> 2) )] >> ( (((uint32_t)(IRQn) ) & 0x03) * 8 ) ) & 0xFF) >> (8 - 2)));  }  
N}
N
N
N/** \brief  System Reset
N
N    The function initiates a system reset request to reset the MCU.
N */
N__STATIC_INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  __DSB();                                                     /* Ensure all outstanding memory accesses included
X  __dsb(0xF);                                                     
N                                                                  buffered write are completed before reset */
N  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = ((0x5FA << 16)      |
N                 SCB_AIRCR_SYSRESETREQ_Msk);
X                 (1UL << 2));
N  __DSB();                                                     /* Ensure completion of memory access */
X  __dsb(0xF);                                                      
N  while(1);                                                    /* wait until reset */
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N    \brief      Functions that configure the System.
N  @{
N */
N
N#if (__Vendor_SysTickConfig == 0)
X#if (0 == 0)
N
N/** \brief  System Tick Configuration
N
N    The function initializes the System Timer and its interrupt, and starts the System Tick Timer.
N    Counter is in free running mode to generate periodic interrupts.
N
N    \param [in]  ticks  Number of ticks between two interrupts.
N
N    \return          0  Function succeeded.
N    \return          1  Function failed.
N
N    \note     When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N    must contain a vendor-specific implementation of this function.
N
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */
X  if ((ticks - 1) > (0xFFFFFFUL << 0))  return (1);       
N
N  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = ticks - 1;                                   
N  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
X  NVIC_SetPriority (SysTick_IRQn, (1<<2) - 1);   
N  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0;                                           
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1)   |
N                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL << 0);                     
N  return (0);                                                  /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N
N#endif /* __CORE_CM0_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
N
N#ifdef __cplusplus
S}
N#endif
L 183 "..\FTLib\CMSIS\inc\ft32f072x8.h" 2
N#include "ft32f0xx.h"
L 1 "..\FTLib\CMSIS\inc\ft32f0xx.h" 1
N/**
N  ******************************************************************************
N  * @file    			ft32f0xx.h
N  * @author  			FMD AE
N  * @brief   			CMSIS FT32F0xx Device Peripheral Access Layer Header File.    	
N  * @version 			V1.0.0           
N  * @data		 			2021-07-01
N  ******************************************************************************
N  */
N
N#ifndef __FT32F0xx_H
S#define __FT32F0xx_H
S
S#ifdef __cplusplus
S extern "C" {
S#endif /* __cplusplus */
S 
S
S#if !defined  (FT32F0)
S#define FT32F0
S#endif /* FT32F0 */
S
S
S
S/**
S  * @brief CMSIS Device version number V2.3.3
S  */
S#define __FT32F0_DEVICE_VERSION_MAIN   (0x02) /*!< [31:24] main version */
S#define __FT32F0_DEVICE_VERSION_SUB1   (0x03) /*!< [23:16] sub1 version */
S#define __FT32F0_DEVICE_VERSION_SUB2   (0x03) /*!< [15:8]  sub2 version */
S#define __FT32F0_DEVICE_VERSION_RC     (0x00) /*!< [7:0]  release candidate */ 
S#define __FT32F0_DEVICE_VERSION        ((__FT32F0_DEVICE_VERSION_MAIN << 24)\
S                                        |(__FT32F0_DEVICE_VERSION_SUB1 << 16)\
S                                        |(__FT32F0_DEVICE_VERSION_SUB2 << 8 )\
S                                        |(__FT32F0_DEVICE_VERSION_RC))
X#define __FT32F0_DEVICE_VERSION        ((__FT32F0_DEVICE_VERSION_MAIN << 24)                                        |(__FT32F0_DEVICE_VERSION_SUB1 << 16)                                        |(__FT32F0_DEVICE_VERSION_SUB2 << 8 )                                        |(__FT32F0_DEVICE_VERSION_RC))
S                                             
S
S/* Exported macro ------------------------------------------------------------*/
S#ifdef  USE_FULL_ASSERT
S
S  #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
S/* Exported functions ------------------------------------------------------- */
S  void assert_failed(uint8_t* file, uint32_t line);
S#else
S  #define assert_param(expr) ((void)0)
S#endif /* USE_FULL_ASSERT */
S
S#if defined(FT32F030x6)
S  #include "ft32f030x6.h"
S#elif defined(FT32F030x8)
S  #include "ft32f030x8.h"
S#elif defined(FT32F072x8)
S  #include "ft32f072x8.h" 
S#else
S #error "Please select first the target FT32F0xx device used in your application (in ft32f0xx.h file)"
S#endif
S
S/**
S  * @}
S  */
S
S
S
S/**
S  * @}
S  */
S
S
S/** @addtogroup Exported_macros
S  * @{
S  */
S#define SET_BIT(REG, BIT)     ((REG) |= (BIT))
S
S#define CLEAR_BIT(REG, BIT)   ((REG) &= ~(BIT))
S
S#define READ_BIT(REG, BIT)    ((REG) & (BIT))
S
S#define CLEAR_REG(REG)        ((REG) = (0x0))
S
S#define WRITE_REG(REG, VAL)   ((REG) = (VAL))
S
S#define READ_REG(REG)         ((REG))
S
S#define MODIFY_REG(REG, CLEARMASK, SETMASK)  WRITE_REG((REG), (((READ_REG(REG)) & (~(CLEARMASK))) | (SETMASK)))
S
S
S#ifdef __cplusplus
S}
S#endif /* __cplusplus */
S
N#endif /* __FT32F0xx_H */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N  
N
N
N
N/*****************************END OF FILE****/
L 184 "..\FTLib\CMSIS\inc\ft32f072x8.h" 2
N#include "system_ft32f0xx.h"
L 1 "..\FTLib\CMSIS\inc\system_ft32f0xx.h" 1
N/**
N  ******************************************************************************
N  * @file    			system_ft32f0xx.h
N  * @author  			FMD AE
N  * @brief   			CMSIS Cortex-M0 Device Peripheral Access Layer System Header File.
N  * @details 			        			  
N  * @version 			V1.0.0
N  * @date    			2021-07-01 
N  *******************************************************************************	
N  */
N  
N/**
N  * @brief Define to prevent recursive inclusion
N  */
N#ifndef __SYSTEM_FT32F0xx_H
N#define __SYSTEM_FT32F0xx_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif 
N
Nextern uint32_t SystemCoreClock;          /*!< System Clock Frequency (Core Clock) */
N
Nextern void SystemInit(void);
Nextern void SystemCoreClockUpdate(void);
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* */
N
N/**
N  * @}
N  */
N  
N/**
N  * @}
N  */  
N/************************ (C) COPYRIGHT FMD *****END OF FILE****/
L 185 "..\FTLib\CMSIS\inc\ft32f072x8.h" 2
N#include <stdint.h>
N
N/** @addtogroup Exported_types
N  * @{
N  */  
N/** @addtogroup Exported_types
N  * @{
N  */ 
Ntypedef enum 
N{
N  RESET = 0, 
N  SET = !RESET
N} FlagStatus, ITStatus;
N
Ntypedef enum 
N{
N  DISABLE = 0, 
N  ENABLE = !DISABLE
N} FunctionalState;
N#define IS_FUNCTIONAL_STATE(STATE) (((STATE) == DISABLE) || ((STATE) == ENABLE))
N
Ntypedef enum 
N{
N  ERROR = 0, 
N  SUCCESS = !ERROR
N} ErrorStatus;
N
N
N/** @addtogroup Peripheral_registers_structures
N  * @{
N  */   
N
N/** 
N  * @brief Analog to Digital Converter  
N  */
N
Ntypedef struct
N{
N  __IO uint32_t ISR;          /*!< ADC Interrupt and Status register,                          Address offset:0x00 */
X  volatile uint32_t ISR;           
N  __IO uint32_t IER;          /*!< ADC Interrupt Enable register,                              Address offset:0x04 */
X  volatile uint32_t IER;           
N  __IO uint32_t CR;           /*!< ADC Control register,                                       Address offset:0x08 */
X  volatile uint32_t CR;            
N  __IO uint32_t CFGR1;        /*!< ADC Configuration register 1,                               Address offset:0x0C */
X  volatile uint32_t CFGR1;         
N  __IO uint32_t CFGR2;        /*!< ADC Configuration register 2,                               Address offset:0x10 */
X  volatile uint32_t CFGR2;         
N  __IO uint32_t SMPR;         /*!< ADC Sampling time register,                                 Address offset:0x14 */
X  volatile uint32_t SMPR;          
N  uint32_t   RESERVED1;       /*!< Reserved,                                                                  0x18 */
N  uint32_t   RESERVED2;       /*!< Reserved,                                                                  0x1C */
N  __IO uint32_t TR;           /*!< ADC watchdog threshold register,                            Address offset:0x20 */
X  volatile uint32_t TR;            
N  uint32_t   RESERVED3;       /*!< Reserved,                                                                  0x24 */
N  __IO uint32_t CHSELR;       /*!< ADC channel selection register,                             Address offset:0x28 */
X  volatile uint32_t CHSELR;        
N  uint32_t   RESERVED4[5];    /*!< Reserved,                                                                  0x2C */
N   __IO uint32_t DR;          /*!< ADC data register,                                          Address offset:0x40 */
X   volatile uint32_t DR;           
N} ADC_TypeDef;
N
Ntypedef struct
N{
N  __IO uint32_t CCR;					/*Address offset:0x308 */
X  volatile uint32_t CCR;					 
N  __IO uint32_t CR2; 					/*Address offset:0x30C */
X  volatile uint32_t CR2; 					 
N} ADC_Common_TypeDef;
N
N/**
N  * @brief Comparator 
N  */
N
Ntypedef struct
N{
N	__IO uint32_t RESERVED[7];     /*!< Reserved,                               Address offset: 0x18-0x00 */
X	volatile uint32_t RESERVED[7];      
N  __IO uint32_t CSR;    				 /*!< COMP comparator control and status register, Address offset: 0x1C */
X  volatile uint32_t CSR;    				  
N} COMP_TypeDef;
N/**
N  * @brief OPA 
N  */
Ntypedef struct
N{
N	__IO uint32_t RESERVED[12];     /*!< Reserved,                               Address offset: 0x2C-0x00 */
X	volatile uint32_t RESERVED[12];      
N  __IO uint32_t CR;    				 /*!< COMP comparator control and status register, Address offset: 0x30 */
X  volatile uint32_t CR;    				  
N} OPA_TypeDef;
N
N/**
N  * @brief DAC Configuration
N  */
Ntypedef struct
N{
N	__IO uint32_t RESERVED[8];    /*!< Reserved,                                          Address offset: 0x1C-0x00 */
X	volatile uint32_t RESERVED[8];     
N  __IO uint32_t CTRL;           /*!< DAC configuration register                              Address offset: 0x20 */
X  volatile uint32_t CTRL;            
N  __IO uint32_t DATA1;          /*!< DAC1 Input  data                                        Address offset: 0x24 */
X  volatile uint32_t DATA1;           
N  __IO uint32_t DATA2;          /*!< DAC2 Input  data                                        Address offset: 0x28 */
X  volatile uint32_t DATA2;           
N}DAC_TypeDef;
N
N/** 
N  * @brief CRC calculation unit 
N  */
N
Ntypedef struct
N{
N  __IO uint32_t DR;          /*!< CRC Data register,                           Address offset: 0x00 */
X  volatile uint32_t DR;           
N	__IO uint32_t IDR;         /*!< CRC Independent data register,               Address offset: 0x04 */
X	volatile uint32_t IDR;          
N  __IO uint32_t CR;          /*!< CRC Control register,                        Address offset: 0x08 */ 
X  volatile uint32_t CR;            
N  uint32_t      RESERVED2;   /*!< Reserved,                                                    0x0C */
N  __IO uint32_t INIT;        /*!< Initial CRC value register,                  Address offset: 0x10 */
X  volatile uint32_t INIT;         
N  __IO uint32_t RESERVED3;   /*!< Reserved,                                                    0x14 */
X  volatile uint32_t RESERVED3;    
N} CRC_TypeDef;
N
N/**
N  * @brief Clock Recovery System 
N  */
Ntypedef struct 
N{
N__IO uint32_t CR;     /*!< CRS ccontrol register,              Address offset: 0x00 */
Xvolatile uint32_t CR;      
N__IO uint32_t CFGR;   /*!< CRS configuration register,         Address offset: 0x04 */
Xvolatile uint32_t CFGR;    
N__IO uint32_t ISR;    /*!< CRS interrupt and status register,  Address offset: 0x08 */
Xvolatile uint32_t ISR;     
N__IO uint32_t ICR;    /*!< CRS interrupt flag clear register,  Address offset: 0x0C */
Xvolatile uint32_t ICR;     
N} CRS_TypeDef;
N
N/** 
N  * @brief Debug MCU
N  */
N
Ntypedef struct
N{
N  __IO uint32_t IDCODE;       /*!< MCU device ID code,                          Address offset: 0x00 */
X  volatile uint32_t IDCODE;        
N  __IO uint32_t CR;           /*!< Debug MCU configuration register,            Address offset: 0x04 */
X  volatile uint32_t CR;            
N  __IO uint32_t APB1FZ;       /*!< Debug MCU APB1 freeze register,              Address offset: 0x08 */
X  volatile uint32_t APB1FZ;        
N  __IO uint32_t APB2FZ;       /*!< Debug MCU APB2 freeze register,              Address offset: 0x0C */
X  volatile uint32_t APB2FZ;        
N}DBGMCU_TypeDef;
N
N/** 
N  * @brief DMA Controller
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CCR;          /*!< DMA channel x configuration register                                           */
X  volatile uint32_t CCR;           
N  __IO uint32_t CNDTR;        /*!< DMA channel x number of data register                                          */
X  volatile uint32_t CNDTR;         
N  __IO uint32_t CPAR;         /*!< DMA channel x peripheral address register                                      */
X  volatile uint32_t CPAR;          
N  __IO uint32_t CMAR;         /*!< DMA channel x memory address register                                          */
X  volatile uint32_t CMAR;          
N} DMA_Channel_TypeDef;
N
Ntypedef struct
N{
N  __IO uint32_t ISR;          /*!< DMA interrupt status register,                            Address offset: 0x00 */
X  volatile uint32_t ISR;           
N  __IO uint32_t IFCR;         /*!< DMA interrupt flag clear register,                        Address offset: 0x04 */
X  volatile uint32_t IFCR;          
N}DMA_TypeDef;
N
N/** 
N  * @brief External Interrupt/Event Controller
N  */
N
Ntypedef struct
N{
N  __IO uint32_t IMR;          /*!<EXTI Interrupt mask register,                             Address offset: 0x00 */
X  volatile uint32_t IMR;           
N  __IO uint32_t EMR;          /*!<EXTI Event mask register,                                 Address offset: 0x04 */
X  volatile uint32_t EMR;           
N  __IO uint32_t RTSR;         /*!<EXTI Rising trigger selection register ,                  Address offset: 0x08 */
X  volatile uint32_t RTSR;          
N  __IO uint32_t FTSR;         /*!<EXTI Falling trigger selection register,                  Address offset: 0x0C */
X  volatile uint32_t FTSR;          
N  __IO uint32_t SWIER;        /*!<EXTI Software interrupt event register,                   Address offset: 0x10 */
X  volatile uint32_t SWIER;         
N  __IO uint32_t PR;           /*!<EXTI Pending register,                                    Address offset: 0x14 */
X  volatile uint32_t PR;            
N}EXTI_TypeDef;
N
N/** 
N  * @brief FLASH Registers
N  */
Ntypedef struct
N{
N  __IO uint32_t ACR;          /*!<FLASH access control register,                 Address offset: 0x00 */
X  volatile uint32_t ACR;           
N  __IO uint32_t KEYR;         /*!<FLASH key register,                            Address offset: 0x04 */
X  volatile uint32_t KEYR;          
N  __IO uint32_t OPTKEYR;      /*!<FLASH OPT key register,                        Address offset: 0x08 */
X  volatile uint32_t OPTKEYR;       
N  __IO uint32_t SR;           /*!<FLASH status register,                         Address offset: 0x0C */
X  volatile uint32_t SR;            
N  __IO uint32_t CR;           /*!<FLASH control register,                        Address offset: 0x10 */
X  volatile uint32_t CR;            
N  __IO uint32_t AR;           /*!<FLASH address register,                        Address offset: 0x14 */
X  volatile uint32_t AR;            
N  __IO uint32_t RESERVED;     /*!< Reserved,                                                     0x18 */
X  volatile uint32_t RESERVED;      
N  __IO uint32_t OBR;          /*!<FLASH option bytes register,                   Address offset: 0x1C */
X  volatile uint32_t OBR;           
N  __IO uint32_t WRPR;         /*!<FLASH option bytes register,                   Address offset: 0x20 */
X  volatile uint32_t WRPR;          
N} FLASH_TypeDef;
N
N
N/** 
N  * @brief Option Bytes Registers
N  */
Ntypedef struct
N{
N  __IO uint32_t USER_RDP;          /*!< FLASH option byte Read protection,             Address offset: 0x00-0x03 */
X  volatile uint32_t USER_RDP;           
N  __IO uint32_t DATA1_DATA0;       /*!< User data byte 0 (stored in FLASH_OBR[23:16]), Address offset: 0x04-0x07 */
X  volatile uint32_t DATA1_DATA0;        
N  __IO uint32_t WRP1_WRP0;         /*!< FLASH option byte write protection 0,1         Address offset: 0x08-0x0b */
X  volatile uint32_t WRP1_WRP0;          
N  __IO uint32_t WRP3_WRP2;         /*!< FLASH option byte write protection 2,          Address offset: 0x0C-0x0f */
X  volatile uint32_t WRP3_WRP2;          
N} OB_TypeDef;
N  
N
N/** 
N  * @brief General Purpose IO
N  */
N
Ntypedef struct
N{
N  __IO uint32_t MODER;        /*!< GPIO port mode register,                                  Address offset: 0x00 */
X  volatile uint32_t MODER;         
N  __IO uint16_t OTYPER;       /*!< GPIO port output type register,                           Address offset: 0x04 */
X  volatile uint16_t OTYPER;        
N  uint16_t RESERVED0;         /*!< Reserved,                                                                 0x06 */
N  __IO uint32_t OSPEEDR;      /*!< GPIO port output speed register,                          Address offset: 0x08 */
X  volatile uint32_t OSPEEDR;       
N  __IO uint32_t PUPDR;        /*!< GPIO port pull-up/pull-down register,                     Address offset: 0x0C */
X  volatile uint32_t PUPDR;         
N  __IO uint16_t IDR;          /*!< GPIO port input data register,                            Address offset: 0x10 */
X  volatile uint16_t IDR;           
N  uint16_t RESERVED1;         /*!< Reserved,                                                                 0x12 */
N  __IO uint16_t ODR;          /*!< GPIO port output data register,                           Address offset: 0x14 */
X  volatile uint16_t ODR;           
N  uint16_t RESERVED2;         /*!< Reserved,                                                                 0x16 */
N  __IO uint32_t BSRR;         /*!< GPIO port bit set/reset registerBSRR,                     Address offset: 0x18 */
X  volatile uint32_t BSRR;          
N  __IO uint32_t LCKR;         /*!< GPIO port configuration lock register,                    Address offset: 0x1C */
X  volatile uint32_t LCKR;          
N  __IO uint32_t AFR[2];       /*!< GPIO alternate function low register,                Address offset: 0x20-0x24 */
X  volatile uint32_t AFR[2];        
N  __IO uint16_t BRR;          /*!< GPIO bit reset register,                                  Address offset: 0x28 */
X  volatile uint16_t BRR;           
N  uint32_t RESERVED3;         /*!< Reserved,                                                                 0x2C */
N  __IO uint32_t LEDM;         /*!< GPIO LEDM register,                                       Address offset: 0x30 */
X  volatile uint32_t LEDM;          
N}GPIO_TypeDef;
N
N/** 
N  * @brief SysTem Configuration
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CFGR1;          /*!< SYSCFG configuration register 1,                        Address offset: 0x00 */
X  volatile uint32_t CFGR1;           
N       uint32_t RESERVED;       /*!< Reserved,                                                               0x04 */
N  __IO uint32_t EXTICR[4];      /*!< SYSCFG external interrupt configuration register,  Address offset: 0x14-0x08 */
X  volatile uint32_t EXTICR[4];       
N  __IO uint32_t CFGR2;          /*!< SYSCFG configuration register 2,                        Address offset: 0x18 */      
X  volatile uint32_t CFGR2;                 
N}SYSCFG_TypeDef;
N
N/** 
N  * @brief Inter-integrated Circuit Interface
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR1;      /*!< I2C Control register 1,            Address offset: 0x00 */
X  volatile uint32_t CR1;       
N  __IO uint32_t CR2;      /*!< I2C Control register 2,            Address offset: 0x04 */
X  volatile uint32_t CR2;       
N  __IO uint32_t OAR1;     /*!< I2C Own address 1 register,        Address offset: 0x08 */
X  volatile uint32_t OAR1;      
N  __IO uint32_t OAR2;     /*!< I2C Own address 2 register,        Address offset: 0x0C */
X  volatile uint32_t OAR2;      
N  __IO uint32_t TIMINGR;  /*!< I2C Timing register,               Address offset: 0x10 */
X  volatile uint32_t TIMINGR;   
N  __IO uint32_t TIMEOUTR; /*!< I2C Timeout register,              Address offset: 0x14 */
X  volatile uint32_t TIMEOUTR;  
N  __IO uint32_t ISR;      /*!< I2C Interrupt and status register, Address offset: 0x18 */
X  volatile uint32_t ISR;       
N  __IO uint32_t ICR;      /*!< I2C Interrupt clear register,      Address offset: 0x1C */
X  volatile uint32_t ICR;       
N  __IO uint32_t PECR;     /*!< I2C PEC register,                  Address offset: 0x20 */
X  volatile uint32_t PECR;      
N  __IO uint32_t RXDR;     /*!< I2C Receive data register,         Address offset: 0x24 */
X  volatile uint32_t RXDR;      
N  __IO uint32_t TXDR;     /*!< I2C Transmit data register,        Address offset: 0x28 */
X  volatile uint32_t TXDR;      
N}I2C_TypeDef;
N
N
N/** 
N  * @brief Independent WATCHDOG
N  */
Ntypedef struct
N{
N  __IO uint32_t KR;   /*!< IWDG Key register,       Address offset: 0x00 */
X  volatile uint32_t KR;    
N  __IO uint32_t PR;   /*!< IWDG Prescaler register, Address offset: 0x04 */
X  volatile uint32_t PR;    
N  __IO uint32_t RLR;  /*!< IWDG Reload register,    Address offset: 0x08 */
X  volatile uint32_t RLR;   
N  __IO uint32_t SR;   /*!< IWDG Status register,    Address offset: 0x0C */
X  volatile uint32_t SR;    
N  __IO uint32_t WINR; /*!< IWDG Window register,    Address offset: 0x10 */
X  volatile uint32_t WINR;  
N} IWDG_TypeDef;
N
N/**
N  * @brief USB
N  */
Ntypedef struct
N{ 
N	__IO uint8_t FADDR;      /*!<  function address register,                            Address offset: 0x00 */
X	volatile uint8_t FADDR;       
N	__IO uint8_t POWER;      /*!<  power management register,                            Address offset: 0x01 */
X	volatile uint8_t POWER;       
N	__IO uint8_t INTRIN;     /*!<  interrupt register endpint0 plus IN Endpoit 1 to 7,   Address offset: 0x02 */
X	volatile uint8_t INTRIN;      
N	__IO uint8_t RES1; 		 /*!<  RES1          									 	 Address offset: 0x03 */
X	volatile uint8_t RES1; 		  
N	__IO uint8_t INTROUT;    /*!<  interrupt register for OUT Endpoints 1 to 7,          Address offset: 0x04 */
X	volatile uint8_t INTROUT;     
N	__IO uint8_t RES2;		 /*!<  RES2          									 	 Address offset: 0x05 */
X	volatile uint8_t RES2;		  
N	__IO uint8_t INTRUSB;    /*!<  interrupt register for common USB interrrupts,        Address offset: 0x06 */
X	volatile uint8_t INTRUSB;     
N	__IO uint8_t INTRINE;    /*!<  inerrupt enable register for INTRIN,                  Address offset: 0x07 */
X	volatile uint8_t INTRINE;     
N	__IO uint8_t RES3; 		 /*!<  RES3          									 	 Address offset: 0x08 */
X	volatile uint8_t RES3; 		  
N	__IO uint8_t INTROUTE;   /*!<  inerrupt enable register for INTROUT,                 Address offset: 0x09 */
X	volatile uint8_t INTROUTE;    
N	__IO uint8_t RES4; 		 /*!<  RES4          									 	 Address offset: 0x0A */
X	volatile uint8_t RES4; 		  
N	__IO uint8_t INTRUSBE;   /*!<  inerrupt enable register for INTRUSB,                 Address offset: 0x0B */
X	volatile uint8_t INTRUSBE;    
N	__IO uint8_t FRAM1;      /*!<  frame number bits 0 to 7,                             Address offset: 0x0C */
X	volatile uint8_t FRAM1;       
N	__IO uint8_t FRAM2;      /*!<  frame number bits 8 to 15,                            Address offset: 0x0D */
X	volatile uint8_t FRAM2;       
N	__IO uint8_t INDEX;      /*!<  selecting then endpoint status and control register , Address offset: 0x0E */
X	volatile uint8_t INDEX;       
N	__IO uint8_t PDCTRL;     /*!<  pull down pull up control ,                           Address offset: 0x0F */
X	volatile uint8_t PDCTRL;      
N	__IO uint8_t INMAXP;	 /*!<  Maximum packet size for IN endpoint,                  Address offset: 0x10 */
X	volatile uint8_t INMAXP;	  
N	union 
N	{
N		__IO uint8_t INCSR0; /*!<  control status register fie endpoint 0,           	 Address offset: 0x11 */
X		volatile uint8_t INCSR0;  
N		__IO uint8_t INCSR1; /*!<  Control Status register 1 for IN Endpoint,        	 Address offset: 0x11 */
X		volatile uint8_t INCSR1;  
N	}INCSR;
N	//__IO uint8_t INCSR2;     /*!<  Control Status register 2 for IN Endpoint,            Address offset: 0x12 */
N	__IO uint8_t RES;        /*!<  Control Status register 2 for IN Endpoint,            Address offset: 0x12 */
X	volatile uint8_t RES;         
N	__IO uint8_t OUTMAXP;    /*!<  Maximum packet size for OUT endpoint,                 Address offset: 0x13 */
X	volatile uint8_t OUTMAXP;     
N	__IO uint8_t OUTCSR1;    /*!<  Control Status register 1 for OUT Endpoint,           Address offset: 0x14 */	
X	volatile uint8_t OUTCSR1;     	
N	__IO uint8_t OUTCSR2;    /*!<  Control Status register 2 for OUT Endpoint,           Address offset: 0x15 */ 
X	volatile uint8_t OUTCSR2;      
N	__IO uint8_t OUTCOUNTER; /*!<  number of bytes in OUT endpoint FIFO ,                Address offset: 0x16 */
X	volatile uint8_t OUTCOUNTER;  
N	__IO uint8_t RES5; 		 /*!<  RES5          									 	 Address offset: 0x17 */
X	volatile uint8_t RES5; 		  
N	__IO uint8_t RES6; 		 /*!<  RES6          									 	 Address offset: 0x18 */
X	volatile uint8_t RES6; 		  
N	__IO uint8_t RES7; 		 /*!<  RES7          									 	 Address offset: 0x19 */
X	volatile uint8_t RES7; 		  
N	__IO uint8_t FIFO0;      /*!<  FIFO for Endpoint 0,                                  Address offset: 0x20 */
X	volatile uint8_t FIFO0;       
N	__IO uint8_t RES8; 		 /*!<  RES8         									 	 Address offset: 0x21 */
X	volatile uint8_t RES8; 		  
N	__IO uint8_t RES9; 		 /*!<  RES9         									 	 Address offset: 0x22 */
X	volatile uint8_t RES9; 		  
N	__IO uint8_t RES10; 	 /*!<  RES10        									 	 Address offset: 0x23 */	
X	volatile uint8_t RES10; 	  	
N	__IO uint8_t FIFO1;      /*!<  FIFO for Endpoint 1,                              	 Address offset: 0x24 */
X	volatile uint8_t FIFO1;       
N	__IO uint8_t RES11; 	 /*!<  RES11          									 	 Address offset: 0x25 */
X	volatile uint8_t RES11; 	  
N	__IO uint8_t RES12; 	 /*!<  RES12          									 	 Address offset: 0x26 */
X	volatile uint8_t RES12; 	  
N	__IO uint8_t RES13; 	 /*!<  RES13          									 	 Address offset: 0x27 */	
X	volatile uint8_t RES13; 	  	
N	__IO uint8_t FIFO2;      /*!<  FIFO for Endpoint 2,                              	 Address offset: 0x28 */
X	volatile uint8_t FIFO2;       
N	__IO uint8_t RES14; 	 /*!<  RES14          									 	 Address offset: 0x29 */
X	volatile uint8_t RES14; 	  
N	__IO uint8_t RES15; 	 /*!<  RES15          									 	 Address offset: 0x2A */
X	volatile uint8_t RES15; 	  
N	__IO uint8_t RES16; 	 /*!<  RES16          									 	 Address offset: 0x2B */	
X	volatile uint8_t RES16; 	  	
N	__IO uint8_t FIFO3;      /*!<  FIFO for Endpoint 3,                              	 Address offset: 0x2C */
X	volatile uint8_t FIFO3;       
N	__IO uint8_t RES17; 	 /*!<  RES17          									 	 Address offset: 0x2D */
X	volatile uint8_t RES17; 	  
N	__IO uint8_t RES18; 	 /*!<  RES18          									 	 Address offset: 0x2E */
X	volatile uint8_t RES18; 	  
N	__IO uint8_t RES19; 	 /*!<  RES19          									 	 Address offset: 0x2F */	
X	volatile uint8_t RES19; 	  	
N	__IO uint8_t FIFO4;      /*!<  FIFO for Endpoint 4,                              	 Address offset: 0x30 */
X	volatile uint8_t FIFO4;       
N	__IO uint8_t RES20; 	 /*!<  RES20          									 	 Address offset: 0x31 */
X	volatile uint8_t RES20; 	  
N	__IO uint8_t RES21; 	 /*!<  RES21          									 	 Address offset: 0x32 */
X	volatile uint8_t RES21; 	  
N	__IO uint8_t RES22; 	 /*!<  RES22          									 	 Address offset: 0x33 */	
X	volatile uint8_t RES22; 	  	
N	__IO uint8_t FIFO5;      /*!<  FIFO for Endpoint 5,                              	 Address offset: 0x34 */
X	volatile uint8_t FIFO5;       
N	__IO uint8_t RES23; 	 /*!<  RES23         									 	 Address offset: 0x35 */
X	volatile uint8_t RES23; 	  
N	__IO uint8_t RES24; 	 /*!<  RES24         									 	 Address offset: 0x36 */
X	volatile uint8_t RES24; 	  
N	__IO uint8_t RES25; 	 /*!<  RES25         									 	 Address offset: 0x37 */	
X	volatile uint8_t RES25; 	  	
N	__IO uint8_t FIFO6;      /*!<  FIFO for Endpoint 6,                              	 Address offset: 0x38 */
X	volatile uint8_t FIFO6;       
N	__IO uint8_t RES26; 	 /*!<  RES26          									 	 Address offset: 0x39 */
X	volatile uint8_t RES26; 	  
N	__IO uint8_t RES27; 	 /*!<  RES27          									 	 Address offset: 0x3A */
X	volatile uint8_t RES27; 	  
N	__IO uint8_t RES28; 	 /*!<  RES28          									 	 Address offset: 0x3B */	
X	volatile uint8_t RES28; 	  	
N	__IO uint8_t FIFO7;      /*!<  FIFO for Endpoint 7,                                  Address offset: 0x3C */
X	volatile uint8_t FIFO7;       
N}USB_TypeDef;
N
N/** 
N  * @brief Power Control
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;   /*!< PWR power control register,        Address offset: 0x00 */
X  volatile uint32_t CR;    
N  __IO uint32_t CSR;  /*!< PWR power control/status register, Address offset: 0x04 */
X  volatile uint32_t CSR;   
N} PWR_TypeDef;
N
N
N/** 
N  * @brief Reset and Clock Control
N  */
Ntypedef struct
N{
N  __IO uint32_t CR;         /*!< RCC clock control register,                                  Address offset: 0x00 */
X  volatile uint32_t CR;          
N  __IO uint32_t CFGR;       /*!< RCC clock configuration register,                            Address offset: 0x04 */
X  volatile uint32_t CFGR;        
N  __IO uint32_t CIR;        /*!< RCC clock interrupt register,                                Address offset: 0x08 */
X  volatile uint32_t CIR;         
N  __IO uint32_t APB2RSTR;   /*!< RCC APB2 peripheral reset register,                          Address offset: 0x0C */
X  volatile uint32_t APB2RSTR;    
N  __IO uint32_t APB1RSTR;   /*!< RCC APB1 peripheral reset register,                          Address offset: 0x10 */
X  volatile uint32_t APB1RSTR;    
N  __IO uint32_t AHBENR;     /*!< RCC AHB peripheral clock register,                           Address offset: 0x14 */
X  volatile uint32_t AHBENR;      
N  __IO uint32_t APB2ENR;    /*!< RCC APB2 peripheral clock enable register,                   Address offset: 0x18 */
X  volatile uint32_t APB2ENR;     
N  __IO uint32_t APB1ENR;    /*!< RCC APB1 peripheral clock enable register,                   Address offset: 0x1C */
X  volatile uint32_t APB1ENR;     
N  __IO uint32_t BDCR;       /*!< RCC Backup domain control register,                          Address offset: 0x20 */ 
X  volatile uint32_t BDCR;         
N  __IO uint32_t CSR;        /*!< RCC clock control & status register,                         Address offset: 0x24 */
X  volatile uint32_t CSR;         
N  __IO uint32_t AHBRSTR;    /*!< RCC AHB peripheral reset register,                           Address offset: 0x28 */
X  volatile uint32_t AHBRSTR;     
N  __IO uint32_t CFGR2;      /*!< RCC clock configuration register 2,                          Address offset: 0x2C */
X  volatile uint32_t CFGR2;       
N  __IO uint32_t CFGR3;      /*!< RCC clock configuration register 3,                          Address offset: 0x30 */
X  volatile uint32_t CFGR3;       
N  __IO uint32_t CR2;        /*!< RCC clock control register 2,                                Address offset: 0x34 */
X  volatile uint32_t CR2;         
N  __IO uint32_t HSECFG;      /*!< RCC clock configuration register 2,                         Address offset: 0x38 New*/
X  volatile uint32_t HSECFG;       
N  __IO uint32_t CFGR4;      /*!< RCC clock configuration register 3,                          Address offset: 0x3C New*/
X  volatile uint32_t CFGR4;       
N  __IO uint32_t TRIM;        /*!< RCC clock control register 2,                               Address offset: 0x40 New*/
X  volatile uint32_t TRIM;         
N} RCC_TypeDef;
N
N/** 
N  * @brief Real-Time Clock
N  */
N
Ntypedef struct
N{
N  __IO uint32_t TR;         /*!< RTC time register,                                         Address offset: 0x00 */
X  volatile uint32_t TR;          
N  __IO uint32_t DR;         /*!< RTC date register,                                         Address offset: 0x04 */
X  volatile uint32_t DR;          
N  __IO uint32_t CR;         /*!< RTC control register,                                      Address offset: 0x08 */                                                                                            
X  volatile uint32_t CR;                                                                                                      
N  __IO uint32_t ISR;        /*!< RTC initialization and status register,                    Address offset: 0x0C */
X  volatile uint32_t ISR;         
N  __IO uint32_t PRER;       /*!< RTC prescaler register,                                    Address offset: 0x10 */
X  volatile uint32_t PRER;        
N       uint32_t RESERVED1;  /*!< Reserved,                                                  Address offset: 0x14 */
N       uint32_t RESERVED2;  /*!< Reserved,                                                  Address offset: 0x18 */
N  __IO uint32_t ALRMAR;     /*!< RTC alarm A register,                                      Address offset: 0x1C */
X  volatile uint32_t ALRMAR;      
N       uint32_t RESERVED3;  /*!< Reserved,                                                  Address offset: 0x20 */
N  __IO uint32_t WPR;        /*!< RTC write protection register,                             Address offset: 0x24 */
X  volatile uint32_t WPR;         
N  __IO uint32_t SSR;        /*!< RTC sub second register,                                   Address offset: 0x28 */
X  volatile uint32_t SSR;         
N  __IO uint32_t SHIFTR;     /*!< RTC shift control register,                                Address offset: 0x2C */
X  volatile uint32_t SHIFTR;      
N  __IO uint32_t TSTR;       /*!< RTC time stamp time register,                              Address offset: 0x30 */
X  volatile uint32_t TSTR;        
N  __IO uint32_t TSDR;       /*!< RTC time stamp date register,                              Address offset: 0x34 */
X  volatile uint32_t TSDR;        
N  __IO uint32_t TSSSR;      /*!< RTC time-stamp sub second register,                        Address offset: 0x38 */
X  volatile uint32_t TSSSR;       
N  __IO uint32_t CALR;       /*!< RTC calibration register,                                  Address offset: 0x3C */
X  volatile uint32_t CALR;        
N  __IO uint32_t TAFCR;      /*!< RTC tamper and alternate function configuration register,  Address offset: 0x40 */
X  volatile uint32_t TAFCR;       
N  __IO uint32_t ALRMASSR;   /*!< RTC alarm A sub second register,                           Address offset: 0x44 */
X  volatile uint32_t ALRMASSR;    
N} RTC_TypeDef;
N
N/* Old register name definition maintained for legacy purpose */
N#define CAL   CALR
N
N/** 
N  * @brief Serial Peripheral Interface
N  */
N  
Ntypedef struct
N{
N  __IO uint16_t CR1;      /*!< SPI Control register 1 (not used in I2S mode),       Address offset: 0x00 */
X  volatile uint16_t CR1;       
N  uint16_t  RESERVED0;    /*!< Reserved, 0x02                                                            */
N  __IO uint16_t CR2;      /*!< SPI Control register 2,                              Address offset: 0x04 */
X  volatile uint16_t CR2;       
N  uint16_t  RESERVED1;    /*!< Reserved, 0x06                                                            */
N  __IO uint16_t SR;       /*!< SPI Status register,                                 Address offset: 0x08 */
X  volatile uint16_t SR;        
N  uint16_t  RESERVED2;    /*!< Reserved, 0x0A                                                            */
N  __IO uint16_t DR;       /*!< SPI data register,                                   Address offset: 0x0C */
X  volatile uint16_t DR;        
N  uint16_t  RESERVED3;    /*!< Reserved, 0x0E                                                            */
N  __IO uint16_t CRCPR;    /*!< SPI CRC polynomial register (not used in I2S mode),  Address offset: 0x10 */
X  volatile uint16_t CRCPR;     
N  uint16_t  RESERVED4;    /*!< Reserved, 0x12                                                            */
N  __IO uint16_t RXCRCR;   /*!< SPI Rx CRC register (not used in I2S mode),          Address offset: 0x14 */
X  volatile uint16_t RXCRCR;    
N  uint16_t  RESERVED5;    /*!< Reserved, 0x16                                                            */
N  __IO uint16_t TXCRCR;   /*!< SPI Tx CRC register (not used in I2S mode),          Address offset: 0x18 */
X  volatile uint16_t TXCRCR;    
N  uint16_t  RESERVED6;    /*!< Reserved, 0x1A                                                            */ 
N // __IO uint16_t I2SCFGR;  /*!< SPI_I2S configuration register,                      Address offset: 0x1C */
N // uint16_t  RESERVED7;    /*!< Reserved, 0x1E                                                            */
N // __IO uint16_t I2SPR;    /*!< SPI_I2S prescaler register,                          Address offset: 0x20 */
N  //uint16_t  RESERVED8;    /*!< Reserved, 0x22                                                            */    
N} SPI_TypeDef;
N
N
N/** 
N  * @brief TIM
N  */
Ntypedef struct
N{
N  __IO uint16_t CR1;             /*!< TIM control register 1,                      Address offset: 0x00 */
X  volatile uint16_t CR1;              
N  uint16_t      RESERVED0;       /*!< Reserved,                                                    0x02 */
N  __IO uint16_t CR2;             /*!< TIM control register 2,                      Address offset: 0x04 */
X  volatile uint16_t CR2;              
N  uint16_t      RESERVED1;       /*!< Reserved,                                                    0x06 */
N  __IO uint16_t SMCR;            /*!< TIM slave Mode Control register,             Address offset: 0x08 */
X  volatile uint16_t SMCR;             
N  uint16_t      RESERVED2;       /*!< Reserved,                                                    0x0A */
N  __IO uint16_t DIER;            /*!< TIM DMA/interrupt enable register,           Address offset: 0x0C */
X  volatile uint16_t DIER;             
N  uint16_t      RESERVED3;       /*!< Reserved,                                                    0x0E */
N  __IO uint16_t SR;              /*!< TIM status register,                         Address offset: 0x10 */
X  volatile uint16_t SR;               
N  uint16_t      RESERVED4;       /*!< Reserved,                                                    0x12 */
N  __IO uint16_t EGR;             /*!< TIM event generation register,               Address offset: 0x14 */
X  volatile uint16_t EGR;              
N  uint16_t      RESERVED5;       /*!< Reserved,                                                    0x16 */
N  __IO uint16_t CCMR1;           /*!< TIM  capture/compare mode register 1,        Address offset: 0x18 */
X  volatile uint16_t CCMR1;            
N  uint16_t      RESERVED6;       /*!< Reserved,                                                    0x1A */
N  __IO uint16_t CCMR2;           /*!< TIM  capture/compare mode register 2,        Address offset: 0x1C */
X  volatile uint16_t CCMR2;            
N  uint16_t      RESERVED7;       /*!< Reserved,                                                    0x1E */
N  __IO uint16_t CCER;            /*!< TIM capture/compare enable register,         Address offset: 0x20 */
X  volatile uint16_t CCER;             
N  uint16_t      RESERVED8;       /*!< Reserved,                                                    0x22 */
N  __IO uint32_t CNT;             /*!< TIM counter register,                        Address offset: 0x24 */
X  volatile uint32_t CNT;              
N  __IO uint16_t PSC;             /*!< TIM prescaler register,                      Address offset: 0x28 */
X  volatile uint16_t PSC;              
N  uint16_t      RESERVED10;      /*!< Reserved,                                                    0x2A */
N  __IO uint32_t ARR;             /*!< TIM auto-reload register,                    Address offset: 0x2C */
X  volatile uint32_t ARR;              
N  __IO uint16_t RCR;             /*!< TIM  repetition counter register,            Address offset: 0x30 */
X  volatile uint16_t RCR;              
N  uint16_t      RESERVED12;      /*!< Reserved,                                                    0x32 */
N  __IO uint32_t CCR1;            /*!< TIM capture/compare register 1,              Address offset: 0x34 */
X  volatile uint32_t CCR1;             
N  __IO uint32_t CCR2;            /*!< TIM capture/compare register 2,              Address offset: 0x38 */
X  volatile uint32_t CCR2;             
N  __IO uint32_t CCR3;            /*!< TIM capture/compare register 3,              Address offset: 0x3C */
X  volatile uint32_t CCR3;             
N  __IO uint32_t CCR4;            /*!< TIM capture/compare register 4,              Address offset: 0x40 */
X  volatile uint32_t CCR4;             
N  __IO uint16_t BDTR;            /*!< TIM break and dead-time register,            Address offset: 0x44 */
X  volatile uint16_t BDTR;             
N  uint16_t      RESERVED17;      /*!< Reserved,                                                    0x26 */
N  __IO uint16_t DCR;             /*!< TIM DMA control register,                    Address offset: 0x48 */
X  volatile uint16_t DCR;              
N  uint16_t      RESERVED18;      /*!< Reserved,                                                    0x4A */
N  __IO uint16_t DMAR;            /*!< TIM DMA address for full transfer register,  Address offset: 0x4C */
X  volatile uint16_t DMAR;             
N  uint16_t      RESERVED19;      /*!< Reserved,                                                    0x4E */
N  __IO uint16_t OR;              /*!< TIM option register,                         Address offset: 0x50 */
X  volatile uint16_t OR;               
N  uint16_t      RESERVED20;      /*!< Reserved,                                                    0x52 */
N} TIM_TypeDef;
N
N/**
N  * @brief TSC 
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;          /*!< TSC configer register                          Address offset: 0x00 */
X  volatile uint32_t CR;           
N  __IO uint32_t CFGR;        /*!< TSC configuration register,                    Address offset: 0x04 */
X  volatile uint32_t CFGR;         
N}TSC_TypeDef;
N
N/** 
N  * @brief Universal Synchronous Asynchronous Receiver Transmitter
N  */
N  
Ntypedef struct
N{
N  __IO uint32_t CR1;    /*!< USART Control register 1,                 Address offset: 0x00 */ 
X  volatile uint32_t CR1;      
N  __IO uint32_t CR2;    /*!< USART Control register 2,                 Address offset: 0x04 */ 
X  volatile uint32_t CR2;      
N  __IO uint32_t CR3;    /*!< USART Control register 3,                 Address offset: 0x08 */
X  volatile uint32_t CR3;     
N  __IO uint16_t BRR;    /*!< USART Baud rate register,                 Address offset: 0x0C */
X  volatile uint16_t BRR;     
N  //uint16_t  RESERVED1;  /*!< Reserved, 0x0E                                                 */  
N  //__IO uint16_t GTPR;   /*!< USART Guard time and prescaler register,  Address offset: 0x10 */
N  //uint16_t  RESERVED2;  /*!< Reserved, 0x12                                                 */
N  uint32_t  RESERVED2;  /*!< Reserved, 0x12                                                 */
N  __IO uint32_t RTOR;   /*!< USART Receiver Time Out register,         Address offset: 0x14 */  
X  volatile uint32_t RTOR;      
N  __IO uint16_t RQR;    /*!< USART Request register,                   Address offset: 0x18 */
X  volatile uint16_t RQR;     
N  uint16_t  RESERVED3;  /*!< Reserved, 0x1A                                                 */
N  __IO uint32_t ISR;    /*!< USART Interrupt and status register,      Address offset: 0x1C */
X  volatile uint32_t ISR;     
N  __IO uint32_t ICR;    /*!< USART Interrupt flag Clear register,      Address offset: 0x20 */
X  volatile uint32_t ICR;     
N  __IO uint16_t RDR;    /*!< USART Receive Data register,              Address offset: 0x24 */
X  volatile uint16_t RDR;     
N  uint16_t  RESERVED4;  /*!< Reserved, 0x26                                                 */
N  __IO uint16_t TDR;    /*!< USART Transmit Data register,             Address offset: 0x28 */
X  volatile uint16_t TDR;     
N  uint16_t  RESERVED5;  /*!< Reserved, 0x2A                                                 */
N} USART_TypeDef;
N
N
N/** 
N  * @brief Window WATCHDOG
N  */
Ntypedef struct
N{
N  __IO uint32_t CR;   /*!< WWDG Control register,       Address offset: 0x00 */
X  volatile uint32_t CR;    
N  __IO uint32_t CFR;  /*!< WWDG Configuration register, Address offset: 0x04 */
X  volatile uint32_t CFR;   
N  __IO uint32_t SR;   /*!< WWDG Status register,        Address offset: 0x08 */
X  volatile uint32_t SR;    
N} WWDG_TypeDef;
N
N/**
N  * @}
N  */
N  
N/** @addtogroup Peripheral_memory_map
N  * @{
N  */
N
N#define FLASH_BASE            ((uint32_t)0x08000000) /*!< FLASH base address in the alias region */
N#define SRAM_BASE             ((uint32_t)0x20000000) /*!< SRAM base address in the alias region */
N#define PERIPH_BASE           ((uint32_t)0x40000000) /*!< Peripheral base address in the alias region */
N
N/*!< Peripheral memory map */
N#define APBPERIPH_BASE        PERIPH_BASE
N#define AHBPERIPH_BASE        (PERIPH_BASE + 0x00020000)
N#define AHB2PERIPH_BASE       (PERIPH_BASE + 0x08000000)
N
N#define TIM2_BASE             (APBPERIPH_BASE + 0x00000000)
N#define TIM3_BASE             (APBPERIPH_BASE + 0x00000400)
N#define TIM6_BASE             (APBPERIPH_BASE + 0x00001000)
N//#define TIM7_BASE             (APBPERIPH_BASE + 0x00001400)
N#define TIM14_BASE            (APBPERIPH_BASE + 0x00002000)
N#define RTC_BASE              (APBPERIPH_BASE + 0x00002800)
N#define WWDG_BASE             (APBPERIPH_BASE + 0x00002C00)
N#define IWDG_BASE             (APBPERIPH_BASE + 0x00003000)
N#define SPI2_BASE             (APBPERIPH_BASE + 0x00003800)
N#define USART2_BASE           (APBPERIPH_BASE + 0x00004400)
N#define I2C1_BASE             (APBPERIPH_BASE + 0x00005400)
N#define I2C2_BASE             (APBPERIPH_BASE + 0x00005800)
N#define USB_BASE              (APBPERIPH_BASE + 0x00005C00)
N#define CRS_BASE              (APBPERIPH_BASE + 0x00006C00)
N#define PWR_BASE              (APBPERIPH_BASE + 0x00007000)
N
N#define SYSCFG_BASE           (APBPERIPH_BASE + 0x00010000)
N#define COMP_BASE             (APBPERIPH_BASE + 0x00010000)
N#define OPA_BASE             (APBPERIPH_BASE + 0x00010000)
N#define DAC_BASE              (APBPERIPH_BASE + 0x00010000)
N
N#define EXTI_BASE             (APBPERIPH_BASE + 0x00010400)
N#define ADC1_BASE             (APBPERIPH_BASE + 0x00012400) /* KVL: TBC*/
N#define ADC_BASE              (APBPERIPH_BASE + 0x00012708) /* KVL: TBC*/
N#define TIM1_BASE             (APBPERIPH_BASE + 0x00012C00)
N#define SPI1_BASE             (APBPERIPH_BASE + 0x00013000)
N#define USART1_BASE           (APBPERIPH_BASE + 0x00013800)
N#define TIM15_BASE            (APBPERIPH_BASE + 0x00014000)
N#define TIM16_BASE            (APBPERIPH_BASE + 0x00014400)
N#define TIM17_BASE            (APBPERIPH_BASE + 0x00014800)
N#define DBGMCU_BASE           (APBPERIPH_BASE + 0x00015800)
N
N#define DMA1_BASE             (AHBPERIPH_BASE + 0x00000000)
N#define DMA1_Channel1_BASE    (DMA1_BASE + 0x00000008)
N#define DMA1_Channel2_BASE    (DMA1_BASE + 0x0000001C)
N#define DMA1_Channel3_BASE    (DMA1_BASE + 0x00000030)
N#define DMA1_Channel4_BASE    (DMA1_BASE + 0x00000044)
N#define DMA1_Channel5_BASE    (DMA1_BASE + 0x00000058)
N#define DMA1_Channel6_BASE    (DMA1_BASE + 0x0000006C)
N#define DMA1_Channel7_BASE    (DMA1_BASE + 0x00000080)
N
N#define RCC_BASE              (AHBPERIPH_BASE + 0x00001000)
N#define FLASH_R_BASE          (AHBPERIPH_BASE + 0x00002000) /*!< FLASH registers base address */
N#define OB_BASE               ((uint32_t)0x1FFFF800)        /*!< FLASH Option Bytes base address */
N#define CRC_BASE              (AHBPERIPH_BASE + 0x00003000)
N#define TSC_BASE              (AHBPERIPH_BASE + 0x00004000)
N
N#define GPIOA_BASE            (AHB2PERIPH_BASE + 0x00000000)
N#define GPIOB_BASE            (AHB2PERIPH_BASE + 0x00000400)
N#define GPIOC_BASE            (AHB2PERIPH_BASE + 0x00000800)
N#define GPIOD_BASE            (AHB2PERIPH_BASE + 0x00000C00)
N//#define GPIOE_BASE            (AHB2PERIPH_BASE + 0x00001000)
N#define GPIOF_BASE            (AHB2PERIPH_BASE + 0x00001400)
N
N/**
N  * @}
N  */
N  
N/** @addtogroup Peripheral_declaration
N  * @{
N  */  
N
N#define TIM2                ((TIM_TypeDef *) TIM2_BASE)
N#define TIM3                ((TIM_TypeDef *) TIM3_BASE)
N#define TIM6                ((TIM_TypeDef *) TIM6_BASE)
N#define TIM7                ((TIM_TypeDef *) TIM7_BASE)
N#define TIM14               ((TIM_TypeDef *) TIM14_BASE)
N#define RTC                 ((RTC_TypeDef *) RTC_BASE)
N#define WWDG                ((WWDG_TypeDef *) WWDG_BASE)
N#define IWDG                ((IWDG_TypeDef *) IWDG_BASE)
N#define SPI2                ((SPI_TypeDef *) SPI2_BASE)
N#define USART2              ((USART_TypeDef *) USART2_BASE)
N#define I2C1                ((I2C_TypeDef *) I2C1_BASE)
N#define I2C2                ((I2C_TypeDef *) I2C2_BASE)
N#define USB                 ((USB_TypeDef *) USB_BASE)
N#define CRS                 ((CRS_TypeDef *) CRS_BASE)
N#define PWR                 ((PWR_TypeDef *) PWR_BASE)
N
N#define SYSCFG              ((SYSCFG_TypeDef *) SYSCFG_BASE)
N#define COMP                ((COMP_TypeDef *) COMP_BASE)
N#define OPA                 ((OPA_TypeDef *) OPA_BASE)
N#define DAC                 ((DAC_TypeDef *) DAC_BASE)
N#define EXTI                ((EXTI_TypeDef *) EXTI_BASE)
N#define ADC1                ((ADC_TypeDef *) ADC1_BASE)
N#define ADC                 ((ADC_Common_TypeDef *) ADC_BASE)
N#define TIM1                ((TIM_TypeDef *) TIM1_BASE)
N#define SPI1                ((SPI_TypeDef *) SPI1_BASE)
N#define USART1              ((USART_TypeDef *) USART1_BASE)
N#define TIM15               ((TIM_TypeDef *) TIM15_BASE)
N#define TIM16               ((TIM_TypeDef *) TIM16_BASE)
N#define TIM17               ((TIM_TypeDef *) TIM17_BASE)
N#define DBGMCU              ((DBGMCU_TypeDef *) DBGMCU_BASE)
N
N#define DMA1                ((DMA_TypeDef *) DMA1_BASE)
N#define DMA1_Channel1       ((DMA_Channel_TypeDef *) DMA1_Channel1_BASE)
N#define DMA1_Channel2       ((DMA_Channel_TypeDef *) DMA1_Channel2_BASE)
N#define DMA1_Channel3       ((DMA_Channel_TypeDef *) DMA1_Channel3_BASE)
N#define DMA1_Channel4       ((DMA_Channel_TypeDef *) DMA1_Channel4_BASE)
N#define DMA1_Channel5       ((DMA_Channel_TypeDef *) DMA1_Channel5_BASE)
N#define DMA1_Channel6       ((DMA_Channel_TypeDef *) DMA1_Channel6_BASE)
N#define DMA1_Channel7       ((DMA_Channel_TypeDef *) DMA1_Channel7_BASE)
N
N#define FLASH               ((FLASH_TypeDef *) FLASH_R_BASE)
N#define OB                  ((OB_TypeDef *) OB_BASE) 
N#define RCC                 ((RCC_TypeDef *) RCC_BASE)
N#define CRC                 ((CRC_TypeDef *) CRC_BASE)
N#define TSC                 ((TSC_TypeDef *) TSC_BASE)
N
N#define GPIOA               ((GPIO_TypeDef *) GPIOA_BASE)
N#define GPIOB               ((GPIO_TypeDef *) GPIOB_BASE)
N#define GPIOC               ((GPIO_TypeDef *) GPIOC_BASE)
N#define GPIOD               ((GPIO_TypeDef *) GPIOD_BASE)
N#define GPIOE               ((GPIO_TypeDef *) GPIOE_BASE)
N#define GPIOF               ((GPIO_TypeDef *) GPIOF_BASE)
N
N/**
N  * @}
N  */
N
N/** @addtogroup Exported_constants
N  * @{
N  */
N  
N  /** @addtogroup Peripheral_Registers_Bits_Definition
N  * @{
N  */
N    
N/******************************************************************************/
N/*                         Peripheral Registers Bits Definition               */
N/******************************************************************************/
N/******************************************************************************/
N/*                                                                            */
N/*                      Analog to Digital Converter (ADC)                     */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bits definition for ADC_ISR register  ******************/
N#define ADC_ISR_AWD                          ((uint32_t)0x00000080)        /*!< Analog watchdog flag */
N#define ADC_ISR_OVR                          ((uint32_t)0x00000010)        /*!< Overrun flag */
N#define ADC_ISR_EOSEQ                        ((uint32_t)0x00000008)        /*!< End of Sequence flag */
N#define ADC_ISR_EOC                          ((uint32_t)0x00000004)        /*!< End of Conversion */
N#define ADC_ISR_EOSMP                        ((uint32_t)0x00000002)        /*!< End of sampling flag */
N#define ADC_ISR_ADRDY                        ((uint32_t)0x00000001)        /*!< ADC Ready */
N
N/* Old EOSEQ bit definition, maintained for legacy purpose */
N#define ADC_ISR_EOS                          ADC_ISR_EOSEQ
N
N/********************  Bits definition for ADC_IER register  ******************/
N#define ADC_IER_AWDIE                        ((uint32_t)0x00000080)        /*!< Analog Watchdog interrupt enable */
N#define ADC_IER_OVRIE                        ((uint32_t)0x00000010)        /*!< Overrun interrupt enable */
N#define ADC_IER_EOSEQIE                      ((uint32_t)0x00000008)        /*!< End of Sequence of conversion interrupt enable */
N#define ADC_IER_EOCIE                        ((uint32_t)0x00000004)        /*!< End of Conversion interrupt enable */
N#define ADC_IER_EOSMPIE                      ((uint32_t)0x00000002)        /*!< End of sampling interrupt enable */
N#define ADC_IER_ADRDYIE                      ((uint32_t)0x00000001)        /*!< ADC Ready interrupt enable */
N
N/* Old EOSEQIE bit definition, maintained for legacy purpose */
N#define ADC_IER_EOSIE                        ADC_IER_EOSEQIE
N
N/********************  Bits definition for ADC_CR register  *******************/
N#define ADC_CR_ADCAL                         ((uint32_t)0x80000000)        /*!< ADC calibration */
N#define ADC_CR_ADSTP                         ((uint32_t)0x00000010)        /*!< ADC stop of conversion command */
N#define ADC_CR_ADSTART                       ((uint32_t)0x00000004)        /*!< ADC start of conversion */
N#define ADC_CR_ADDIS                         ((uint32_t)0x00000002)        /*!< ADC disable command */
N#define ADC_CR_ADEN                          ((uint32_t)0x00000001)        /*!< ADC enable control */
N
N/*******************  Bits definition for ADC_CFGR1 register  *****************/
N#define  ADC_CFGR1_AWDCH                      ((uint32_t)0x7C000000)       /*!< AWDCH[4:0] bits (Analog watchdog channel select bits) */
N#define  ADC_CFGR1_AWDCH_0                    ((uint32_t)0x04000000)       /*!< Bit 0 */
N#define  ADC_CFGR1_AWDCH_1                    ((uint32_t)0x08000000)       /*!< Bit 1 */
N#define  ADC_CFGR1_AWDCH_2                    ((uint32_t)0x10000000)       /*!< Bit 2 */
N#define  ADC_CFGR1_AWDCH_3                    ((uint32_t)0x20000000)       /*!< Bit 3 */
N#define  ADC_CFGR1_AWDCH_4                    ((uint32_t)0x40000000)       /*!< Bit 4 */
N#define  ADC_CFGR1_AWDEN                      ((uint32_t)0x00800000)       /*!< Analog watchdog enable on regular channels */
N#define  ADC_CFGR1_AWDSGL                     ((uint32_t)0x00400000)       /*!< Enable the watchdog on a single channel or on all channels  */
N#define  ADC_CFGR1_DISCEN                     ((uint32_t)0x00010000)       /*!< Discontinuous mode on regular channels */
N#define  ADC_CFGR1_AUTOFF                     ((uint32_t)0x00008000)       /*!< ADC auto power off */
N#define  ADC_CFGR1_WAIT                       ((uint32_t)0x00004000)       /*!< ADC wait conversion mode */
N#define  ADC_CFGR1_CONT                       ((uint32_t)0x00002000)       /*!< Continuous Conversion */
N#define  ADC_CFGR1_OVRMOD                     ((uint32_t)0x00001000)       /*!< Overrun mode */
N#define  ADC_CFGR1_EXTEN                      ((uint32_t)0x00000C00)       /*!< EXTEN[1:0] bits (External Trigger Conversion mode for regular channels) */
N#define  ADC_CFGR1_EXTEN_0                    ((uint32_t)0x00000400)       /*!< Bit 0 */
N#define  ADC_CFGR1_EXTEN_1                    ((uint32_t)0x00000800)       /*!< Bit 1 */
N#define  ADC_CFGR1_EXTSEL                     ((uint32_t)0x000001C0)       /*!< EXTSEL[2:0] bits (External Event Select for regular group) */
N#define  ADC_CFGR1_EXTSEL_0                   ((uint32_t)0x00000040)       /*!< Bit 0 */
N#define  ADC_CFGR1_EXTSEL_1                   ((uint32_t)0x00000080)       /*!< Bit 1 */
N#define  ADC_CFGR1_EXTSEL_2                   ((uint32_t)0x00000100)       /*!< Bit 2 */
N#define  ADC_CFGR1_ALIGN                      ((uint32_t)0x00000020)       /*!< Data Alignment */
N#define  ADC_CFGR1_RES                        ((uint32_t)0x00000018)       /*!< RES[1:0] bits (Resolution) */
N#define  ADC_CFGR1_RES_0                      ((uint32_t)0x00000008)       /*!< Bit 0 */
N#define  ADC_CFGR1_RES_1                      ((uint32_t)0x00000010)       /*!< Bit 1 */
N#define  ADC_CFGR1_SCANDIR                    ((uint32_t)0x00000004)       /*!< Sequence scan direction */
N#define  ADC_CFGR1_DMACFG                     ((uint32_t)0x00000002)       /*!< Direct memory access configuration */
N#define  ADC_CFGR1_DMAEN                      ((uint32_t)0x00000001)       /*!< Direct memory access enable */
N
N/* Old WAIT bit definition, maintained for legacy purpose */
N#define  ADC_CFGR1_AUTDLY                     ADC_CFGR1_WAIT
N
N/*******************  Bits definition for ADC_CFGR2 register  *****************/
N#define  ADC_CFGR2_CKMODE                     ((uint32_t)0xC0000000)       /*!< ADC clock mode */
N#define  ADC_CFGR2_CKMODE_1                   ((uint32_t)0x80000000)       /*!< ADC clocked by PCLK div4 */
N#define  ADC_CFGR2_CKMODE_0                   ((uint32_t)0x40000000)       /*!< ADC clocked by PCLK div2 */
N
N/* Old bit definition, maintained for legacy purpose */
N#define  ADC_CFGR2_JITOFFDIV4                 ADC_CFGR2_CKMODE_1           /*!< ADC clocked by PCLK div4 */
N#define  ADC_CFGR2_JITOFFDIV2                 ADC_CFGR2_CKMODE_0           /*!< ADC clocked by PCLK div2 */
N
N/******************  Bit definition for ADC_SMPR register  ********************/
N#define  ADC_SMPR_SMP                      ((uint32_t)0x00000007)        /*!< SMP[2:0] bits (Sampling time selection) */
N#define  ADC_SMPR_SMP_0                    ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  ADC_SMPR_SMP_1                    ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  ADC_SMPR_SMP_2                    ((uint32_t)0x00000004)        /*!< Bit 2 */
N
N/* Old bit definition, maintained for legacy purpose */
N#define  ADC_SMPR1_SMPR                      ADC_SMPR_SMP        /*!< SMP[2:0] bits (Sampling time selection) */
N#define  ADC_SMPR1_SMPR_0                    ADC_SMPR_SMP_0        /*!< Bit 0 */
N#define  ADC_SMPR1_SMPR_1                    ADC_SMPR_SMP_1        /*!< Bit 1 */
N#define  ADC_SMPR1_SMPR_2                    ADC_SMPR_SMP_2        /*!< Bit 2 */
N
N/*******************  Bit definition for ADC_TR register  ********************/
N#define  ADC_TR_HT                          ((uint32_t)0x0FFF0000)        /*!< Analog watchdog high threshold */
N#define  ADC_TR_LT                          ((uint32_t)0x00000FFF)        /*!< Analog watchdog low threshold */
N
N/* Old bit definition, maintained for legacy purpose */
N#define  ADC_HTR_HT                          ADC_TR_HT                    /*!< Analog watchdog high threshold */
N#define  ADC_LTR_LT                          ADC_TR_LT                    /*!< Analog watchdog low threshold */
N
N/******************  Bit definition for ADC_CHSELR register  ******************/
N#define  ADC_CHSELR_CHSEL19                   ((uint32_t)0x00080000)        /*!< Channel 19 selection */
N#define  ADC_CHSELR_CHSEL18                   ((uint32_t)0x00040000)        /*!< Channel 18 selection */
N#define  ADC_CHSELR_CHSEL17                   ((uint32_t)0x00020000)        /*!< Channel 17 selection */
N#define  ADC_CHSELR_CHSEL16                   ((uint32_t)0x00010000)        /*!< Channel 16 selection */
N#define  ADC_CHSELR_CHSEL15                   ((uint32_t)0x00008000)        /*!< Channel 15 selection */
N#define  ADC_CHSELR_CHSEL14                   ((uint32_t)0x00004000)        /*!< Channel 14 selection */
N#define  ADC_CHSELR_CHSEL13                   ((uint32_t)0x00002000)        /*!< Channel 13 selection */
N#define  ADC_CHSELR_CHSEL12                   ((uint32_t)0x00001000)        /*!< Channel 12 selection */
N#define  ADC_CHSELR_CHSEL11                   ((uint32_t)0x00000800)        /*!< Channel 11 selection */
N#define  ADC_CHSELR_CHSEL10                   ((uint32_t)0x00000400)        /*!< Channel 10 selection */
N#define  ADC_CHSELR_CHSEL9                    ((uint32_t)0x00000200)        /*!< Channel 9 selection */
N#define  ADC_CHSELR_CHSEL8                    ((uint32_t)0x00000100)        /*!< Channel 8 selection */
N#define  ADC_CHSELR_CHSEL7                    ((uint32_t)0x00000080)        /*!< Channel 7 selection */
N#define  ADC_CHSELR_CHSEL6                    ((uint32_t)0x00000040)        /*!< Channel 6 selection */
N#define  ADC_CHSELR_CHSEL5                    ((uint32_t)0x00000020)        /*!< Channel 5 selection */
N#define  ADC_CHSELR_CHSEL4                    ((uint32_t)0x00000010)        /*!< Channel 4 selection */
N#define  ADC_CHSELR_CHSEL3                    ((uint32_t)0x00000008)        /*!< Channel 3 selection */
N#define  ADC_CHSELR_CHSEL2                    ((uint32_t)0x00000004)        /*!< Channel 2 selection */
N#define  ADC_CHSELR_CHSEL1                    ((uint32_t)0x00000002)        /*!< Channel 1 selection */
N#define  ADC_CHSELR_CHSEL0                    ((uint32_t)0x00000001)        /*!< Channel 0 selection */
N
N/********************  Bit definition for ADC_DR register  ********************/
N#define  ADC_DR_DATA                         ((uint32_t)0x0000FFFF)        /*!< Regular data */
N
N/*******************  Bit definition for ADC_CCR register  ********************/
N#define  ADC_CCR_VBATEN                       ((uint32_t)0x01000000)       /*!< Voltage battery enable */
N#define  ADC_CCR_TSEN                         ((uint32_t)0x00800000)       /*!< Tempurature sensore enable */
N#define  ADC_CCR_VREFEN                       ((uint32_t)0x00400000)       /*!< Vrefint enable */
N/******************************************************************************/
N/*                                                                            */
N/*                      Analog Comparators (COMP)                             */
N/*                                                                            */
N/******************************************************************************/
N/***********************  Bit definition for COMP_CSR register  ***************/
N/* NCOMP bits definition */
N#define	COMP_CSR_NCOMPEN							 ((uint32_t)0x00000001) /*!< MCOMP enable */
N#define	COMP_CSR_NCOMP_VIP_SEL				 ((uint32_t)0x0000000e) /*!<  */
N#define	COMP_CSR_NCOMP_VIP_SEL_0			 ((uint32_t)0x00000002) /*!<  */
N#define	COMP_CSR_NCOMP_VIP_SEL_1			 ((uint32_t)0x00000004) /*!<  */
N#define	COMP_CSR_NCOMP_VIP_SEL_2			 ((uint32_t)0x00000008) /*!<  */
N#define	COMP_CSR_NCOMP_VIN_SEL				 ((uint32_t)0x00000030) /*!<  */
N#define	COMP_CSR_NCOMP_VIN_SEL_0			 ((uint32_t)0x00000010) /*!<  */
N#define	COMP_CSR_NCOMP_VIN_SEL_1			 ((uint32_t)0x00000020) /*!<  */
N#define	COMP_CSR_NCOMPOUTSEL					 ((uint32_t)0x00000600) /*!<  */
N#define	COMP_CSR_NCOMPOUTSEL_0				 ((uint32_t)0x00000200) /*!<  */
N#define	COMP_CSR_NCOMPOUTSEL_1				 ((uint32_t)0x00000400) /*!<  */
N#define	COMP_CSR_NCOMP_POL						 ((uint32_t)0x00000800) /*!<  */
N#define	COMP_CSR_COMP1OUT							 ((uint32_t)0x00004000) /*!<  */
N#define	COMP_CSR_NCOMPLOCK						 ((uint32_t)0x00008000) /*!<  */
N
N/* PCOMP bits definition */
N#define	COMP_CSR_PCOMPEN							 ((uint32_t)0x00010000) /*!< PCOMP enable */
N#define	COMP_CSR_PCOMP_VIP_SEL				 ((uint32_t)0x00060000) /*!<  */
N#define	COMP_CSR_PCOMP_VIP_SEL_0			 ((uint32_t)0x00020000) /*!<  */
N#define	COMP_CSR_PCOMP_VIP_SEL_1			 ((uint32_t)0x00040000) /*!<  */
N#define	COMP_CSR_PCOMP_VIN_SEL				 ((uint32_t)0x00180000) /*!<  */
N#define	COMP_CSR_PCOMP_VIN_SEL_0			 ((uint32_t)0x00080000) /*!<  */
N#define	COMP_CSR_PCOMP_VIN_SEL_1			 ((uint32_t)0x00100000) /*!<  */
N#define	COMP_CSR_WNDWEN								 ((uint32_t)0x00800000) /*!<  */
N
N#define	COMP_CSR_PCOMPOUTSEL					 ((uint32_t)0x07000000) /*!<  */
N#define	COMP_CSR_PCOMPOUTSEL_0				 ((uint32_t)0x01000000) /*!<  */
N#define	COMP_CSR_PCOMPOUTSEL_1				 ((uint32_t)0x02000000) /*!<  */
N#define	COMP_CSR_PCOMPOUTSEL_2				 ((uint32_t)0x04000000) /*!<  */
N#define	COMP_CSR_PCOMP_POL						 ((uint32_t)0x08000000) /*!<  */
N#define	COMP_CSR_COMP2OUT							 ((uint32_t)0x40000000) /*!<  */
N#define	COMP_CSR_PCOMP_LOCK						 ((uint32_t)0x80000000) /*!<  */
N
N/******************************************************************************/
N/*                                                                            */
N/*                       CRC calculation unit (CRC)                           */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for CRC_DR register  *********************/
N#define  CRC_DR_DR                           ((uint32_t)0xFFFFFFFF) /*!< Data register bits */
N
N/*******************  Bit definition for CRC_IDR register  ********************/
N#define  CRC_IDR_IDR                         ((uint8_t)0xFF)        /*!< General-purpose 8-bit data register bits */
N
N/********************  Bit definition for CRC_CR register  ********************/
N#define  CRC_CR_RESET                        ((uint32_t)0x00000001) /*!< RESET the CRC computation unit bit */
N//#define  CRC_CR_POLSIZE                      ((uint32_t)0x00000018) /*!< Polynomial size bits (only for FT32F072X8 devices)*/
N//#define  CRC_CR_POLSIZE_0                    ((uint32_t)0x00000008) /*!< Polynomial size bit 0 (only for FT32F072X8 devices) */
N//#define  CRC_CR_POLSIZE_1                    ((uint32_t)0x00000010) /*!< Polynomial size bit 1 (only for FT32F072X8 devices) */
N#define  CRC_CR_REV_IN                       ((uint32_t)0x00000060) /*!< REV_IN Reverse Input Data bits */
N#define  CRC_CR_REV_IN_0                     ((uint32_t)0x00000020) /*!< REV_IN Bit 0 */
N#define  CRC_CR_REV_IN_1                     ((uint32_t)0x00000040) /*!< REV_IN Bit 1 */
N#define  CRC_CR_REV_OUT                      ((uint32_t)0x00000080) /*!< REV_OUT Reverse Output Data bits */
N
N/*******************  Bit definition for CRC_INIT register  *******************/
N#define  CRC_INIT_INIT                       ((uint32_t)0xFFFFFFFF) /*!< Initial CRC value bits */
N
N/*******************  Bit definition for CRC_POL register  ********************/
N//#define  CRC_POL_POL                         ((uint32_t)0xFFFFFFFF) /*!< Coefficients of the polynomial (only for FT32F072X8 devices) */
N
N/******************************************************************************/
N/*                                                                            */
N/*                          CRS Clock Recovery System                         */
N/*                   (Available only for FT32F072X8 devices)                */
N/******************************************************************************/
N
N/*******************  Bit definition for CRS_CR register  *********************/
N#define  CRS_CR_SYNCOKIE                     ((uint32_t)0x00000001) /* SYNC event OK interrupt enable        */
N#define  CRS_CR_SYNCWARNIE                   ((uint32_t)0x00000002) /* SYNC warning interrupt enable         */
N#define  CRS_CR_ERRIE                        ((uint32_t)0x00000004) /* SYNC error interrupt enable           */
N#define  CRS_CR_ESYNCIE                      ((uint32_t)0x00000008) /* Expected SYNC(ESYNCF) interrupt Enable*/
N#define  CRS_CR_CEN                          ((uint32_t)0x00000020) /* Frequency error counter enable        */
N#define  CRS_CR_AUTOTRIMEN                   ((uint32_t)0x00000040) /* Automatic trimming enable             */
N#define  CRS_CR_SWSYNC                       ((uint32_t)0x00000080) /* A Software SYNC event is generated    */
N#define  CRS_CR_TRIM                         ((uint32_t)0x00003F00) /* HSI48 oscillator smooth trimming      */
N
N/*******************  Bit definition for CRS_CFGR register  *********************/
N#define  CRS_CFGR_RELOAD                     ((uint32_t)0x0000FFFF) /* Counter reload value               */
N#define  CRS_CFGR_FELIM                      ((uint32_t)0x00FF0000) /* Frequency error limit              */
N#define  CRS_CFGR_SYNCDIV                    ((uint32_t)0x07000000) /* SYNC divider                       */
N#define  CRS_CFGR_SYNCDIV_0                  ((uint32_t)0x01000000) /* Bit 0                              */
N#define  CRS_CFGR_SYNCDIV_1                  ((uint32_t)0x02000000) /* Bit 1                              */
N#define  CRS_CFGR_SYNCDIV_2                  ((uint32_t)0x04000000) /* Bit 2                              */
N#define  CRS_CFGR_SYNCSRC                    ((uint32_t)0x30000000) /* SYNC signal source selection       */
N#define  CRS_CFGR_SYNCSRC_0                  ((uint32_t)0x10000000) /* Bit 0                              */
N#define  CRS_CFGR_SYNCSRC_1                  ((uint32_t)0x20000000) /* Bit 1                              */
N#define  CRS_CFGR_SYNCPOL                    ((uint32_t)0x80000000) /* SYNC polarity selection            */
N
N/*******************  Bit definition for CRS_ISR register  *********************/
N#define  CRS_ISR_SYNCOKF                     ((uint32_t)0x00000001) /* SYNC event OK flag             */
N#define  CRS_ISR_SYNCWARNF                   ((uint32_t)0x00000002) /* SYNC warning                   */
N#define  CRS_ISR_ERRF                        ((uint32_t)0x00000004) /* SYNC error flag                */
N#define  CRS_ISR_ESYNCF                      ((uint32_t)0x00000008) /* Expected SYNC flag             */
N#define  CRS_ISR_SYNCERR                     ((uint32_t)0x00000100) /* SYNC error                     */
N#define  CRS_ISR_SYNCMISS                    ((uint32_t)0x00000200) /* SYNC missed                    */
N#define  CRS_ISR_TRIMOVF                     ((uint32_t)0x00000400) /* Trimming overflow or underflow */
N#define  CRS_ISR_FEDIR                       ((uint32_t)0x00008000) /* Frequency error direction      */
N#define  CRS_ISR_FECAP                       ((uint32_t)0xFFFF0000) /* Frequency error capture        */
N
N/*******************  Bit definition for CRS_ICR register  *********************/
N#define  CRS_ICR_SYNCOKC                     ((uint32_t)0x00000001) /* SYNC event OK clear flag     */
N#define  CRS_ICR_SYNCWARNC                   ((uint32_t)0x00000002) /* SYNC warning clear flag      */
N#define  CRS_ICR_ERRC                        ((uint32_t)0x00000004) /* Error clear flag        */
N#define  CRS_ICR_ESYNCC                      ((uint32_t)0x00000008) /* Expected SYNC clear flag     */
N
N/******************************************************************************/
N/*                                                                            */
N/*                 Digital to Analog Converter (DAC)                          */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for DAC_CTRL register  ********************/
N#define	DAC_CTRL_EN		((uint32_t)(0x00000001))
N#define	DAC_CTRL_REF_SEL	((uint32_t)(0x00000006))	
N#define	DAC_CTRL_REF_SEL_0	((uint32_t)(0x00000000))		// 2V
N#define	DAC_CTRL_REF_SEL_1	((uint32_t)(0x00000002))		// 3V
N#define	DAC_CTRL_REF_SEL_2	((uint32_t)(0x00000004))		// 4V
N#define	DAC_CTRL_REF_SEL_3	((uint32_t)(0x00000006))		// VDDA
N
N#define IS_DAC_REF_SEL(SEL)	(((SEL) == DAC_CTRL_REF_SEL_0) ||\
N				(((SEL) == DAC_CTRL_REF_SEL_1) ||\
N				(((SEL) == DAC_CTRL_REF_SEL_2) ||\
N				((SEL) == DAC_CTRL_REF_SEL_3))
X#define IS_DAC_REF_SEL(SEL)	(((SEL) == DAC_CTRL_REF_SEL_0) ||				(((SEL) == DAC_CTRL_REF_SEL_1) ||				(((SEL) == DAC_CTRL_REF_SEL_2) ||				((SEL) == DAC_CTRL_REF_SEL_3))
N
N/******************************************************************************/
N/*                                                                            */
N/*                           Debug MCU (DBGMCU)                               */
N/*                                                                            */
N/******************************************************************************/
N
N/****************  Bit definition for DBGMCU_IDCODE register  *****************/
N//#define  DBGMCU_IDCODE_DEV_ID                ((uint32_t)0x00000FFF)        /*!< Device Identifier */
N//
N//#define  DBGMCU_IDCODE_REV_ID                ((uint32_t)0xFFFF0000)        /*!< REV_ID[15:0] bits (Revision Identifier) */
N//#define  DBGMCU_IDCODE_REV_ID_0              ((uint32_t)0x00010000)        /*!< Bit 0 */
N//#define  DBGMCU_IDCODE_REV_ID_1              ((uint32_t)0x00020000)        /*!< Bit 1 */
N//#define  DBGMCU_IDCODE_REV_ID_2              ((uint32_t)0x00040000)        /*!< Bit 2 */
N//#define  DBGMCU_IDCODE_REV_ID_3              ((uint32_t)0x00080000)        /*!< Bit 3 */
N//#define  DBGMCU_IDCODE_REV_ID_4              ((uint32_t)0x00100000)        /*!< Bit 4 */
N//#define  DBGMCU_IDCODE_REV_ID_5              ((uint32_t)0x00200000)        /*!< Bit 5 */
N//#define  DBGMCU_IDCODE_REV_ID_6              ((uint32_t)0x00400000)        /*!< Bit 6 */
N//#define  DBGMCU_IDCODE_REV_ID_7              ((uint32_t)0x00800000)        /*!< Bit 7 */
N//#define  DBGMCU_IDCODE_REV_ID_8              ((uint32_t)0x01000000)        /*!< Bit 8 */
N//#define  DBGMCU_IDCODE_REV_ID_9              ((uint32_t)0x02000000)        /*!< Bit 9 */
N//#define  DBGMCU_IDCODE_REV_ID_10             ((uint32_t)0x04000000)        /*!< Bit 10 */
N//#define  DBGMCU_IDCODE_REV_ID_11             ((uint32_t)0x08000000)        /*!< Bit 11 */
N//#define  DBGMCU_IDCODE_REV_ID_12             ((uint32_t)0x10000000)        /*!< Bit 12 */
N//#define  DBGMCU_IDCODE_REV_ID_13             ((uint32_t)0x20000000)        /*!< Bit 13 */
N//#define  DBGMCU_IDCODE_REV_ID_14             ((uint32_t)0x40000000)        /*!< Bit 14 */
N//#define  DBGMCU_IDCODE_REV_ID_15             ((uint32_t)0x80000000)        /*!< Bit 15 */
N
N#define  DBGMCU_IDCODE_DESIGNER								 ((uint32_t)0x00000FFE)        /*!< Device Identifier */
N
N#define  DBGMCU_IDCODE_PARTNO								   ((uint32_t)0x0FFFF000)        /*!< Device Identifier */
N#define  DBGMCU_IDCODE_PARTNO_0                ((uint32_t)0x00010000)        /*!< Bit 0 */
N#define  DBGMCU_IDCODE_PARTNO_1                ((uint32_t)0x00020000)        /*!< Bit 1 */
N#define  DBGMCU_IDCODE_PARTNO_2                ((uint32_t)0x00040000)        /*!< Bit 2 */
N#define  DBGMCU_IDCODE_PARTNO_3                ((uint32_t)0x00080000)        /*!< Bit 3 */
N#define  DBGMCU_IDCODE_PARTNO_4                ((uint32_t)0x00100000)        /*!< Bit 4 */
N#define  DBGMCU_IDCODE_PARTNO_5                ((uint32_t)0x00200000)        /*!< Bit 5 */
N#define  DBGMCU_IDCODE_PARTNO_6                ((uint32_t)0x00400000)        /*!< Bit 6 */
N#define  DBGMCU_IDCODE_PARTNO_7                ((uint32_t)0x00800000)        /*!< Bit 7 */
N#define  DBGMCU_IDCODE_PARTNO_8                ((uint32_t)0x01000000)        /*!< Bit 8 */
N#define  DBGMCU_IDCODE_PARTNO_9                ((uint32_t)0x02000000)        /*!< Bit 9 */
N#define  DBGMCU_IDCODE_PARTNO_10               ((uint32_t)0x04000000)        /*!< Bit 10 */
N#define  DBGMCU_IDCODE_PARTNO_11               ((uint32_t)0x08000000)        /*!< Bit 11 */
N#define  DBGMCU_IDCODE_PARTNO_12               ((uint32_t)0x10000000)        /*!< Bit 12 */
N#define  DBGMCU_IDCODE_PARTNO_13               ((uint32_t)0x20000000)        /*!< Bit 13 */
N#define  DBGMCU_IDCODE_PARTNO_14               ((uint32_t)0x40000000)        /*!< Bit 14 */
N#define  DBGMCU_IDCODE_PARTNO_15               ((uint32_t)0x80000000)        /*!< Bit 15 */
N
N#define  DBGMCU_IDCODE_VERSION								 ((uint32_t)0xF0000000)        /*!< Device Identifier */
N
N/******************  Bit definition for DBGMCU_CR register  *******************/
N#define  DBGMCU_CR_DBG_STOP                  ((uint32_t)0x00000002)        /*!< Debug Stop Mode */
N#define  DBGMCU_CR_DBG_STANDBY               ((uint32_t)0x00000004)        /*!< Debug Standby mode */
N
N/******************  Bit definition for DBGMCU_APB1_FZ register  **************/
N//#define  DBGMCU_APB1_FZ_DBG_TIM2_STOP        ((uint32_t)0x00000001)        /*!< TIM2 counter stopped when core is halted */
N#define  DBGMCU_APB1_FZ_DBG_TIM3_STOP        ((uint32_t)0x00000002)        /*!< TIM3 counter stopped when core is halted */
N#define  DBGMCU_APB1_FZ_DBG_TIM6_STOP        ((uint32_t)0x00000010)        /*!< TIM6 counter stopped when core is halted */
N#define  DBGMCU_APB1_FZ_DBG_TIM7_STOP        ((uint32_t)0x00000020)        /*!< TIM7 counter stopped when core is halted (only for FT32F072X8 devices) */
N#define  DBGMCU_APB1_FZ_DBG_TIM14_STOP       ((uint32_t)0x00000100)        /*!< TIM14 counter stopped when core is halted */
N#define  DBGMCU_APB1_FZ_DBG_RTC_STOP         ((uint32_t)0x00000400)        /*!< RTC Calendar frozen when core is halted */
N#define  DBGMCU_APB1_FZ_DBG_WWDG_STOP        ((uint32_t)0x00000800)        /*!< Debug Window Watchdog stopped when Core is halted */
N#define  DBGMCU_APB1_FZ_DBG_IWDG_STOP        ((uint32_t)0x00001000)        /*!< Debug Independent Watchdog stopped when Core is halted */
N#define  DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT    ((uint32_t)0x20000000)   /*!< I2C1 SMBUS timeout mode stopped when Core is halted */
N//#define  DBGMCU_APB1_FZ_DBG_CAN_STOP         ((uint32_t)0x02000000)        /*!< CAN debug stopped when Core is halted (only for FT32F072X8 devices) */
N
N/******************  Bit definition for DBGMCU_APB2_FZ register  **************/
N#define  DBGMCU_APB2_FZ_DBG_TIM1_STOP        ((uint32_t)0x00000800)        /*!< TIM1 counter stopped when core is halted */
N#define  DBGMCU_APB2_FZ_DBG_TIM15_STOP       ((uint32_t)0x00010000)        /*!< TIM15 counter stopped when core is halted */
N#define  DBGMCU_APB2_FZ_DBG_TIM16_STOP       ((uint32_t)0x00020000)        /*!< TIM16 counter stopped when core is halted */
N#define  DBGMCU_APB2_FZ_DBG_TIM17_STOP       ((uint32_t)0x00040000)        /*!< TIM17 counter stopped when core is halted */
N
N/******************************************************************************/
N/*                                                                            */
N/*                           DMA Controller (DMA)                             */
N/*                                                                            */
N/******************************************************************************/
N
N/*******************  Bit definition for DMA_ISR register  ********************/
N#define  DMA_ISR_GIF1                        ((uint32_t)0x00000001)        /*!< Channel 1 Global interrupt flag    */
N#define  DMA_ISR_TCIF1                       ((uint32_t)0x00000002)        /*!< Channel 1 Transfer Complete flag   */
N#define  DMA_ISR_HTIF1                       ((uint32_t)0x00000004)        /*!< Channel 1 Half Transfer flag       */
N#define  DMA_ISR_TEIF1                       ((uint32_t)0x00000008)        /*!< Channel 1 Transfer Error flag      */
N#define  DMA_ISR_GIF2                        ((uint32_t)0x00000010)        /*!< Channel 2 Global interrupt flag    */
N#define  DMA_ISR_TCIF2                       ((uint32_t)0x00000020)        /*!< Channel 2 Transfer Complete flag   */
N#define  DMA_ISR_HTIF2                       ((uint32_t)0x00000040)        /*!< Channel 2 Half Transfer flag       */
N#define  DMA_ISR_TEIF2                       ((uint32_t)0x00000080)        /*!< Channel 2 Transfer Error flag      */
N#define  DMA_ISR_GIF3                        ((uint32_t)0x00000100)        /*!< Channel 3 Global interrupt flag    */
N#define  DMA_ISR_TCIF3                       ((uint32_t)0x00000200)        /*!< Channel 3 Transfer Complete flag   */
N#define  DMA_ISR_HTIF3                       ((uint32_t)0x00000400)        /*!< Channel 3 Half Transfer flag       */
N#define  DMA_ISR_TEIF3                       ((uint32_t)0x00000800)        /*!< Channel 3 Transfer Error flag      */
N#define  DMA_ISR_GIF4                        ((uint32_t)0x00001000)        /*!< Channel 4 Global interrupt flag    */
N#define  DMA_ISR_TCIF4                       ((uint32_t)0x00002000)        /*!< Channel 4 Transfer Complete flag   */
N#define  DMA_ISR_HTIF4                       ((uint32_t)0x00004000)        /*!< Channel 4 Half Transfer flag       */
N#define  DMA_ISR_TEIF4                       ((uint32_t)0x00008000)        /*!< Channel 4 Transfer Error flag      */
N#define  DMA_ISR_GIF5                        ((uint32_t)0x00010000)        /*!< Channel 5 Global interrupt flag    */
N#define  DMA_ISR_TCIF5                       ((uint32_t)0x00020000)        /*!< Channel 5 Transfer Complete flag   */
N#define  DMA_ISR_HTIF5                       ((uint32_t)0x00040000)        /*!< Channel 5 Half Transfer flag       */
N#define  DMA_ISR_TEIF5                       ((uint32_t)0x00080000)        /*!< Channel 5 Transfer Error flag      */
N//#define  DMA_ISR_GIF6                        ((uint32_t)0x00100000)        /*!< Channel 6 Global interrupt flag (only for FT32F072X8 devices) */
N//#define  DMA_ISR_TCIF6                       ((uint32_t)0x00200000)        /*!< Channel 6 Transfer Complete flag (only for FT32F072X8 devices) */
N//#define  DMA_ISR_HTIF6                       ((uint32_t)0x00400000)        /*!< Channel 6 Half Transfer flag (only for FT32F072X8 devices) */
N//#define  DMA_ISR_TEIF6                       ((uint32_t)0x00800000)        /*!< Channel 6 Transfer Error flag (only for FT32F072X8 devices) */
N//#define  DMA_ISR_GIF7                        ((uint32_t)0x01000000)        /*!< Channel 7 Global interrupt flag (only for FT32F072X8 devices) */
N//#define  DMA_ISR_TCIF7                       ((uint32_t)0x02000000)        /*!< Channel 7 Transfer Complete flag (only for FT32F072X8 devices) */
N//#define  DMA_ISR_HTIF7                       ((uint32_t)0x04000000)        /*!< Channel 7 Half Transfer flag (only for FT32F072X8 devices) */
N//#define  DMA_ISR_TEIF7                       ((uint32_t)0x08000000)        /*!< Channel 7 Transfer Error flag (only for FT32F072X8 devices) */
N
N/*******************  Bit definition for DMA_IFCR register  *******************/
N#define  DMA_IFCR_CGIF1                      ((uint32_t)0x00000001)        /*!< Channel 1 Global interrupt clear    */
N#define  DMA_IFCR_CTCIF1                     ((uint32_t)0x00000002)        /*!< Channel 1 Transfer Complete clear   */
N#define  DMA_IFCR_CHTIF1                     ((uint32_t)0x00000004)        /*!< Channel 1 Half Transfer clear       */
N#define  DMA_IFCR_CTEIF1                     ((uint32_t)0x00000008)        /*!< Channel 1 Transfer Error clear      */
N#define  DMA_IFCR_CGIF2                      ((uint32_t)0x00000010)        /*!< Channel 2 Global interrupt clear    */
N#define  DMA_IFCR_CTCIF2                     ((uint32_t)0x00000020)        /*!< Channel 2 Transfer Complete clear   */
N#define  DMA_IFCR_CHTIF2                     ((uint32_t)0x00000040)        /*!< Channel 2 Half Transfer clear       */
N#define  DMA_IFCR_CTEIF2                     ((uint32_t)0x00000080)        /*!< Channel 2 Transfer Error clear      */
N#define  DMA_IFCR_CGIF3                      ((uint32_t)0x00000100)        /*!< Channel 3 Global interrupt clear    */
N#define  DMA_IFCR_CTCIF3                     ((uint32_t)0x00000200)        /*!< Channel 3 Transfer Complete clear   */
N#define  DMA_IFCR_CHTIF3                     ((uint32_t)0x00000400)        /*!< Channel 3 Half Transfer clear       */
N#define  DMA_IFCR_CTEIF3                     ((uint32_t)0x00000800)        /*!< Channel 3 Transfer Error clear      */
N#define  DMA_IFCR_CGIF4                      ((uint32_t)0x00001000)        /*!< Channel 4 Global interrupt clear    */
N#define  DMA_IFCR_CTCIF4                     ((uint32_t)0x00002000)        /*!< Channel 4 Transfer Complete clear   */
N#define  DMA_IFCR_CHTIF4                     ((uint32_t)0x00004000)        /*!< Channel 4 Half Transfer clear       */
N#define  DMA_IFCR_CTEIF4                     ((uint32_t)0x00008000)        /*!< Channel 4 Transfer Error clear      */
N#define  DMA_IFCR_CGIF5                      ((uint32_t)0x00010000)        /*!< Channel 5 Global interrupt clear    */
N#define  DMA_IFCR_CTCIF5                     ((uint32_t)0x00020000)        /*!< Channel 5 Transfer Complete clear   */
N#define  DMA_IFCR_CHTIF5                     ((uint32_t)0x00040000)        /*!< Channel 5 Half Transfer clear       */
N#define  DMA_IFCR_CTEIF5                     ((uint32_t)0x00080000)        /*!< Channel 5 Transfer Error clear      */
N//#define  DMA_IFCR_CGIF6                      ((uint32_t)0x00100000)        /*!< Channel 6 Global interrupt clear (only for FT32F072X8 devices) */
N//#define  DMA_IFCR_CTCIF6                     ((uint32_t)0x00200000)        /*!< Channel 6 Transfer Complete clear (only for FT32F072X8 devices) */
N//#define  DMA_IFCR_CHTIF6                     ((uint32_t)0x00400000)        /*!< Channel 6 Half Transfer clear (only for FT32F072X8 devices) */
N//#define  DMA_IFCR_CTEIF6                     ((uint32_t)0x00800000)        /*!< Channel 6 Transfer Error clear (only for FT32F072X8 devices) */
N//#define  DMA_IFCR_CGIF7                      ((uint32_t)0x01000000)        /*!< Channel 7 Global interrupt clear (only for FT32F072X8 devices) */
N//#define  DMA_IFCR_CTCIF7                     ((uint32_t)0x02000000)        /*!< Channel 7 Transfer Complete clear (only for FT32F072X8 devices) */
N//#define  DMA_IFCR_CHTIF7                     ((uint32_t)0x04000000)        /*!< Channel 7 Half Transfer clear (only for FT32F072X8 devices) */
N//#define  DMA_IFCR_CTEIF7                     ((uint32_t)0x08000000)        /*!< Channel 7 Transfer Error clear (only for FT32F072X8 devices) */
N
N/*******************  Bit definition for DMA_CCR register  ********************/
N#define  DMA_CCR_EN                          ((uint32_t)0x00000001)        /*!< Channel enable                      */
N#define  DMA_CCR_TCIE                        ((uint32_t)0x00000002)        /*!< Transfer complete interrupt enable  */
N#define  DMA_CCR_HTIE                        ((uint32_t)0x00000004)        /*!< Half Transfer interrupt enable      */
N#define  DMA_CCR_TEIE                        ((uint32_t)0x00000008)        /*!< Transfer error interrupt enable     */
N#define  DMA_CCR_DIR                         ((uint32_t)0x00000010)        /*!< Data transfer direction             */
N#define  DMA_CCR_CIRC                        ((uint32_t)0x00000020)        /*!< Circular mode                       */
N#define  DMA_CCR_PINC                        ((uint32_t)0x00000040)        /*!< Peripheral increment mode           */
N#define  DMA_CCR_MINC                        ((uint32_t)0x00000080)        /*!< Memory increment mode               */
N
N#define  DMA_CCR_PSIZE                       ((uint32_t)0x00000300)        /*!< PSIZE[1:0] bits (Peripheral size)   */
N#define  DMA_CCR_PSIZE_0                     ((uint32_t)0x00000100)        /*!< Bit 0                               */
N#define  DMA_CCR_PSIZE_1                     ((uint32_t)0x00000200)        /*!< Bit 1                               */
N
N#define  DMA_CCR_MSIZE                       ((uint32_t)0x00000C00)        /*!< MSIZE[1:0] bits (Memory size)       */
N#define  DMA_CCR_MSIZE_0                     ((uint32_t)0x00000400)        /*!< Bit 0                               */
N#define  DMA_CCR_MSIZE_1                     ((uint32_t)0x00000800)        /*!< Bit 1                               */
N
N#define  DMA_CCR_PL                          ((uint32_t)0x00003000)        /*!< PL[1:0] bits(Channel Priority level)*/
N#define  DMA_CCR_PL_0                        ((uint32_t)0x00001000)        /*!< Bit 0                               */
N#define  DMA_CCR_PL_1                        ((uint32_t)0x00002000)        /*!< Bit 1                               */
N
N#define  DMA_CCR_MEM2MEM                     ((uint32_t)0x00004000)        /*!< Memory to memory mode               */
N
N/******************  Bit definition for DMA_CNDTR register  *******************/
N#define  DMA_CNDTR_NDT                       ((uint32_t)0x00000FFF)        /*!< Number of data to Transfer          */
N
N/******************  Bit definition for DMA_CPAR register  ********************/
N#define  DMA_CPAR1_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address                  */
N#define  DMA_CPAR2_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address                  */
N#define  DMA_CPAR3_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address                  */
N#define  DMA_CPAR4_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address                  */
N#define  DMA_CPAR5_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address                  */
N
N/******************  Bit definition for DMA_CMAR register  ********************/
N#define  DMA_CMAR1_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address                      */
N#define  DMA_CMAR2_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address                      */
N#define  DMA_CMAR3_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address                      */
N#define  DMA_CMAR4_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address                      */
N#define  DMA_CMAR5_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address                      */
N
N/******************  Bit definition for DMA_RMPCR1 register  ********************/
N//#define DMA_RMPCR1_DEFAULT                  ((uint32_t)0x00000000)        /*!< Default remap position for DMA1 */
N//#define DMA_RMPCR1_CH1_ADC                  ((uint32_t)0x00000001)        /*!< Remap ADC on DMA1 Channel 1*/
N//#define DMA_RMPCR1_CH1_TIM17_CH1            ((uint32_t)0x00000007)        /*!< Remap TIM17 channel 1 on DMA1 channel 1 */
N//#define DMA_RMPCR1_CH1_TIM17_UP             ((uint32_t)0x00000007)        /*!< Remap TIM17 up on DMA1 channel 1 */
N//#define DMA_RMPCR1_CH1_USART1_RX            ((uint32_t)0x00000008)        /*!< Remap USART1 Rx on DMA1 channel 1 */
N//#define DMA_RMPCR1_CH1_USART2_RX            ((uint32_t)0x00000009)        /*!< Remap USART2 Rx on DMA1 channel 1 */
N//#define DMA_RMPCR1_CH1_USART3_RX            ((uint32_t)0x0000000A)        /*!< Remap USART3 Rx on DMA1 channel 1 */
N//#define DMA_RMPCR1_CH1_USART4_RX            ((uint32_t)0x0000000B)        /*!< Remap USART4 Rx on DMA1 channel 1 */
N//#define DMA_RMPCR1_CH1_USART5_RX            ((uint32_t)0x0000000C)        /*!< Remap USART5 Rx on DMA1 channel 1 */
N//#define DMA_RMPCR1_CH1_USART6_RX            ((uint32_t)0x0000000D)        /*!< Remap USART6 Rx on DMA1 channel 1 */
N//#define DMA_RMPCR1_CH1_USART7_RX            ((uint32_t)0x0000000E)        /*!< Remap USART7 Rx on DMA1 channel 1 */
N//#define DMA_RMPCR1_CH1_USART8_RX            ((uint32_t)0x0000000F)        /*!< Remap USART8 Rx on DMA1 channel 1 */
N//#define DMA_RMPCR1_CH2_ADC                  ((uint32_t)0x00000010)        /*!< Remap ADC on DMA1 channel 2 */
N//#define DMA_RMPCR1_CH2_I2C1_TX              ((uint32_t)0x00000020)        /*!< Remap I2C1 Tx on DMA1 channel 2 */
N//#define DMA_RMPCR1_CH2_SPI_1RX              ((uint32_t)0x00000030)        /*!< Remap SPI1 Rx on DMA1 channel 2 */
N//#define DMA_RMPCR1_CH2_TIM1_CH1             ((uint32_t)0x00000040)        /*!< Remap TIM1 channel 1 on DMA1 channel 2 */
N//#define DMA_RMPCR1_CH2_TIM17_CH1            ((uint32_t)0x00000070)        /*!< Remap TIM17 channel 1 on DMA1 channel 2 */
N//#define DMA_RMPCR1_CH2_TIM17_UP             ((uint32_t)0x00000070)        /*!< Remap TIM17 up on DMA1 channel 2 */
N//#define DMA_RMPCR1_CH2_USART1_TX            ((uint32_t)0x00000080)        /*!< Remap USART1 Tx on DMA1 channel 2 */
N//#define DMA_RMPCR1_CH2_USART2_TX            ((uint32_t)0x00000090)        /*!< Remap USART2 Tx on DMA1 channel 2 */
N//#define DMA_RMPCR1_CH2_USART3_TX            ((uint32_t)0x000000A0)        /*!< Remap USART3 Tx on DMA1 channel 2 */
N//#define DMA_RMPCR1_CH2_USART4_TX            ((uint32_t)0x000000B0)        /*!< Remap USART4 Tx on DMA1 channel 2 */
N//#define DMA_RMPCR1_CH2_USART5_TX            ((uint32_t)0x000000C0)        /*!< Remap USART5 Tx on DMA1 channel 2 */
N//#define DMA_RMPCR1_CH2_USART6_TX            ((uint32_t)0x000000D0)        /*!< Remap USART6 Tx on DMA1 channel 2 */
N//#define DMA_RMPCR1_CH2_USART7_TX            ((uint32_t)0x000000E0)        /*!< Remap USART7 Tx on DMA1 channel 2 */
N//#define DMA_RMPCR1_CH2_USART8_TX            ((uint32_t)0x000000F0)        /*!< Remap USART8 Tx on DMA1 channel 2 */
N//#define DMA_RMPCR1_CH3_TIM6_UP              ((uint32_t)0x00000100)        /*!< Remap TIM6 up on DMA1 channel 3 */
N//#define DMA_RMPCR1_CH3_DAC_CH1              ((uint32_t)0x00000100)        /*!< Remap DAC Channel 1on DMA1 channel 3 */
N//#define DMA_RMPCR1_CH3_I2C1_RX              ((uint32_t)0x00000200)        /*!< Remap I2C1 Rx on DMA1 channel 3 */
N//#define DMA_RMPCR1_CH3_SPI1_TX              ((uint32_t)0x00000300)        /*!< Remap SPI1 Tx on DMA1 channel 3 */
N//#define DMA_RMPCR1_CH3_TIM1_CH2             ((uint32_t)0x00000400)        /*!< Remap TIM1 channel 2 on DMA1 channel 3 */
N//#define DMA_RMPCR1_CH3_TIM2_CH2             ((uint32_t)0x00000500)        /*!< Remap TIM2 channel 2 on DMA1 channel 3 */
N//#define DMA_RMPCR1_CH3_TIM16_CH1            ((uint32_t)0x00000700)        /*!< Remap TIM16 channel 1 on DMA1 channel 3 */
N//#define DMA_RMPCR1_CH3_TIM16_UP             ((uint32_t)0x00000700)        /*!< Remap TIM16 up on DMA1 channel 3 */
N//#define DMA_RMPCR1_CH3_USART1_RX            ((uint32_t)0x00000800)        /*!< Remap USART1 Rx on DMA1 channel 3 */
N//#define DMA_RMPCR1_CH3_USART2_RX            ((uint32_t)0x00000900)        /*!< Remap USART2 Rx on DMA1 channel 3 */
N//#define DMA_RMPCR1_CH3_USART3_RX            ((uint32_t)0x00000A00)        /*!< Remap USART3 Rx on DMA1 channel 3 */
N//#define DMA_RMPCR1_CH3_USART4_RX            ((uint32_t)0x00000B00)        /*!< Remap USART4 Rx on DMA1 channel 3 */
N//#define DMA_RMPCR1_CH3_USART5_RX            ((uint32_t)0x00000C00)        /*!< Remap USART5 Rx on DMA1 channel 3 */
N//#define DMA_RMPCR1_CH3_USART6_RX            ((uint32_t)0x00000D00)        /*!< Remap USART6 Rx on DMA1 channel 3 */
N//#define DMA_RMPCR1_CH3_USART7_RX            ((uint32_t)0x00000E00)        /*!< Remap USART7 Rx on DMA1 channel 3 */
N//#define DMA_RMPCR1_CH3_USART8_RX            ((uint32_t)0x00000F00)        /*!< Remap USART8 Rx on DMA1 channel 3 */
N//#define DMA_RMPCR1_CH4_TIM7_UP              ((uint32_t)0x00001000)        /*!< Remap TIM7 up on DMA1 channel 4 */
N//#define DMA_RMPCR1_CH4_DAC_CH2              ((uint32_t)0x00001000)        /*!< Remap DAC Channel 2 on DMA1 channel 4 */
N//#define DMA_RMPCR1_CH4_I2C2_TX              ((uint32_t)0x00002000)        /*!< Remap I2C2 Tx on DMA1 channel 4 */
N//#define DMA_RMPCR1_CH4_SPI2_RX              ((uint32_t)0x00003000)        /*!< Remap SPI2 Rx on DMA1 channel 4 */
N//#define DMA_RMPCR1_CH4_TIM2_CH4             ((uint32_t)0x00005000)        /*!< Remap TIM2 channel 4 on DMA1 channel 4 */
N//#define DMA_RMPCR1_CH4_TIM3_CH1             ((uint32_t)0x00006000)        /*!< Remap TIM3 channel 1 on DMA1 channel 4 */
N//#define DMA_RMPCR1_CH4_TIM3_TRIG            ((uint32_t)0x00006000)        /*!< Remap TIM3 Trig on DMA1 channel 4 */
N//#define DMA_RMPCR1_CH4_TIM16_CH1            ((uint32_t)0x00007000)        /*!< Remap TIM16 channel 1 on DMA1 channel 4 */
N//#define DMA_RMPCR1_CH4_TIM16_UP             ((uint32_t)0x00007000)        /*!< Remap TIM16 up on DMA1 channel 4 */
N//#define DMA_RMPCR1_CH4_USART1_TX            ((uint32_t)0x00008000)        /*!< Remap USART1 Tx on DMA1 channel 4 */
N//#define DMA_RMPCR1_CH4_USART2_TX            ((uint32_t)0x00009000)        /*!< Remap USART2 Tx on DMA1 channel 4 */
N//#define DMA_RMPCR1_CH4_USART3_TX            ((uint32_t)0x0000A000)        /*!< Remap USART3 Tx on DMA1 channel 4 */
N//#define DMA_RMPCR1_CH4_USART4_TX            ((uint32_t)0x0000B000)        /*!< Remap USART4 Tx on DMA1 channel 4 */
N//#define DMA_RMPCR1_CH4_USART5_TX            ((uint32_t)0x0000C000)        /*!< Remap USART5 Tx on DMA1 channel 4 */
N//#define DMA_RMPCR1_CH4_USART6_TX            ((uint32_t)0x0000D000)        /*!< Remap USART6 Tx on DMA1 channel 4 */
N//#define DMA_RMPCR1_CH4_USART7_TX            ((uint32_t)0x0000E000)        /*!< Remap USART7 Tx on DMA1 channel 4 */
N//#define DMA_RMPCR1_CH4_USART8_TX            ((uint32_t)0x0000F000)        /*!< Remap USART8 Tx on DMA1 channel 4 */
N//#define DMA_RMPCR1_CH5_I2C2_RX              ((uint32_t)0x00020000)        /*!< Remap I2C2 Rx on DMA1 channel 5 */
N//#define DMA_RMPCR1_CH5_SPI2_TX              ((uint32_t)0x00030000)        /*!< Remap SPI1 Tx on DMA1 channel 5 */
N//#define DMA_RMPCR1_CH5_TIM1_CH3             ((uint32_t)0x00040000)        /*!< Remap TIM1 channel 3 on DMA1 channel 5 */
N//#define DMA_RMPCR1_CH5_USART1_RX            ((uint32_t)0x00080000)        /*!< Remap USART1 Rx on DMA1 channel 5 */
N//#define DMA_RMPCR1_CH5_USART2_RX            ((uint32_t)0x00090000)        /*!< Remap USART2 Rx on DMA1 channel 5 */
N//#define DMA_RMPCR1_CH5_USART3_RX            ((uint32_t)0x000A0000)        /*!< Remap USART3 Rx on DMA1 channel 5 */
N//#define DMA_RMPCR1_CH5_USART4_RX            ((uint32_t)0x000B0000)        /*!< Remap USART4 Rx on DMA1 channel 5 */
N//#define DMA_RMPCR1_CH5_USART5_RX            ((uint32_t)0x000C0000)        /*!< Remap USART5 Rx on DMA1 channel 5 */
N//#define DMA_RMPCR1_CH5_USART6_RX            ((uint32_t)0x000D0000)        /*!< Remap USART6 Rx on DMA1 channel 5 */
N//#define DMA_RMPCR1_CH5_USART7_RX            ((uint32_t)0x000E0000)        /*!< Remap USART7 Rx on DMA1 channel 5 */
N//#define DMA_RMPCR1_CH5_USART8_RX            ((uint32_t)0x000F0000)        /*!< Remap USART8 Rx on DMA1 channel 5 */
N//#define DMA_RMPCR1_CH6_I2C1_TX              ((uint32_t)0x00200000)        /*!< Remap I2C1 Tx on DMA1 channel 6 */
N//#define DMA_RMPCR1_CH6_SPI2_RX              ((uint32_t)0x00300000)        /*!< Remap SPI2 Rx on DMA1 channel 6 */
N//#define DMA_RMPCR1_CH6_TIM1_CH1             ((uint32_t)0x00400000)        /*!< Remap TIM1 channel 1 on DMA1 channel 6 */
N//#define DMA_RMPCR1_CH6_TIM1_CH2             ((uint32_t)0x00400000)        /*!< Remap TIM1 channel 2 on DMA1 channel 6 */
N//#define DMA_RMPCR1_CH6_TIM1_CH3             ((uint32_t)0x00400000)        /*!< Remap TIM1 channel 3 on DMA1 channel 6 */
N//#define DMA_RMPCR1_CH6_TIM3_CH1             ((uint32_t)0x00600000)        /*!< Remap TIM3 channel 1 on DMA1 channel 6 */
N//#define DMA_RMPCR1_CH6_TIM3_TRIG            ((uint32_t)0x00600000)        /*!< Remap TIM3 Trig on DMA1 channel 6 */
N//#define DMA_RMPCR1_CH6_TIM16_CH1            ((uint32_t)0x00700000)        /*!< Remap TIM16 channel 1 on DMA1 channel 6 */
N//#define DMA_RMPCR1_CH6_TIM16_UP             ((uint32_t)0x00700000)        /*!< Remap TIM16 up on DMA1 channel 6 */
N//#define DMA_RMPCR1_CH6_USART1_RX            ((uint32_t)0x00800000)        /*!< Remap USART1 Rx on DMA1 channel 6 */
N//#define DMA_RMPCR1_CH6_USART2_RX            ((uint32_t)0x00900000)        /*!< Remap USART2 Rx on DMA1 channel 6 */
N//#define DMA_RMPCR1_CH6_USART3_RX            ((uint32_t)0x00A00000)        /*!< Remap USART3 Rx on DMA1 channel 6 */
N//#define DMA_RMPCR1_CH6_USART4_RX            ((uint32_t)0x00B00000)        /*!< Remap USART4 Rx on DMA1 channel 6 */
N//#define DMA_RMPCR1_CH6_USART5_RX            ((uint32_t)0x00C00000)        /*!< Remap USART5 Rx on DMA1 channel 6 */
N//#define DMA_RMPCR1_CH6_USART6_RX            ((uint32_t)0x00D00000)        /*!< Remap USART6 Rx on DMA1 channel 6 */
N//#define DMA_RMPCR1_CH6_USART7_RX            ((uint32_t)0x00E00000)        /*!< Remap USART7 Rx on DMA1 channel 6 */
N//#define DMA_RMPCR1_CH6_USART8_RX            ((uint32_t)0x00F00000)        /*!< Remap USART8 Rx on DMA1 channel 6 */
N//#define DMA_RMPCR1_CH7_I2C1_RX              ((uint32_t)0x02000000)        /*!< Remap I2C1 Rx on DMA1 channel 7 */
N//#define DMA_RMPCR1_CH7_SPI2_TX              ((uint32_t)0x03000000)        /*!< Remap SPI2 Tx on DMA1 channel 7 */
N//#define DMA_RMPCR1_CH7_TIM2_CH2             ((uint32_t)0x05000000)        /*!< Remap TIM2 channel 2 on DMA1 channel 7 */
N//#define DMA_RMPCR1_CH7_TIM2_CH4             ((uint32_t)0x05000000)        /*!< Remap TIM2 channel 4 on DMA1 channel 7 */
N//#define DMA_RMPCR1_CH7_TIM17_CH1            ((uint32_t)0x07000000)        /*!< Remap TIM17 channel 1 on DMA1 channel 7 */
N//#define DMA_RMPCR1_CH7_TIM17_UP             ((uint32_t)0x07000000)        /*!< Remap TIM17 up on DMA1 channel 7 */
N//#define DMA_RMPCR1_CH7_USART1_TX            ((uint32_t)0x08000000)        /*!< Remap USART1 Tx on DMA1 channel 7 */
N//#define DMA_RMPCR1_CH7_USART2_TX            ((uint32_t)0x09000000)        /*!< Remap USART2 Tx on DMA1 channel 7 */
N//#define DMA_RMPCR1_CH7_USART3_TX            ((uint32_t)0x0A000000)        /*!< Remap USART3 Tx on DMA1 channel 7 */
N//#define DMA_RMPCR1_CH7_USART4_TX            ((uint32_t)0x0B000000)        /*!< Remap USART4 Tx on DMA1 channel 7 */
N//#define DMA_RMPCR1_CH7_USART5_TX            ((uint32_t)0x0C000000)        /*!< Remap USART5 Tx on DMA1 channel 7 */
N//#define DMA_RMPCR1_CH7_USART6_TX            ((uint32_t)0x0D000000)        /*!< Remap USART6 Tx on DMA1 channel 7 */
N//#define DMA_RMPCR1_CH7_USART7_TX            ((uint32_t)0x0E000000)        /*!< Remap USART7 Tx on DMA1 channel 7 */
N//#define DMA_RMPCR1_CH7_USART8_TX            ((uint32_t)0x0F000000)        /*!< Remap USART8 Tx on DMA1 channel 7 */
N//
N///******************  Bit definition for DMA_RMPCR2 register  ********************/
N//#define DMA_RMPCR2_DEFAULT                  ((uint32_t)0x00000000)        /*!< Default remap position for DMA2 */
N//#define DMA_RMPCR2_CH1_I2C2_TX              ((uint32_t)0x00000002)        /*!< Remap I2C2 TX on DMA2 channel 1 */
N//#define DMA_RMPCR2_CH1_USART1_TX            ((uint32_t)0x00000008)        /*!< Remap USART1 Tx on DMA2 channel 1 */
N//#define DMA_RMPCR2_CH1_USART2_TX            ((uint32_t)0x00000009)        /*!< Remap USART2 Tx on DMA2 channel 1 */
N//#define DMA_RMPCR2_CH1_USART3_TX            ((uint32_t)0x0000000A)        /*!< Remap USART3 Tx on DMA2 channel 1 */
N//#define DMA_RMPCR2_CH1_USART4_TX            ((uint32_t)0x0000000B)        /*!< Remap USART4 Tx on DMA2 channel 1 */
N//#define DMA_RMPCR2_CH1_USART5_TX            ((uint32_t)0x0000000C)        /*!< Remap USART5 Tx on DMA2 channel 1 */
N//#define DMA_RMPCR2_CH1_USART6_TX            ((uint32_t)0x0000000D)        /*!< Remap USART6 Tx on DMA2 channel 1 */
N//#define DMA_RMPCR2_CH1_USART7_TX            ((uint32_t)0x0000000E)        /*!< Remap USART7 Tx on DMA2 channel 1 */
N//#define DMA_RMPCR2_CH1_USART8_TX            ((uint32_t)0x0000000F)        /*!< Remap USART8 Tx on DMA2 channel 1 */
N//#define DMA_RMPCR2_CH2_I2C2_RX              ((uint32_t)0x00000020)        /*!< Remap I2C2 Rx on DMA2 channel 2 */
N//#define DMA_RMPCR2_CH2_USART1_RX            ((uint32_t)0x00000080)        /*!< Remap USART1 Rx on DMA2 channel 2 */
N//#define DMA_RMPCR2_CH2_USART2_RX            ((uint32_t)0x00000090)        /*!< Remap USART2 Rx on DMA2 channel 2 */
N//#define DMA_RMPCR2_CH2_USART3_RX            ((uint32_t)0x000000A0)        /*!< Remap USART3 Rx on DMA2 channel 2 */
N//#define DMA_RMPCR2_CH2_USART4_RX            ((uint32_t)0x000000B0)        /*!< Remap USART4 Rx on DMA2 channel 2 */
N//#define DMA_RMPCR2_CH2_USART5_RX            ((uint32_t)0x000000C0)        /*!< Remap USART5 Rx on DMA2 channel 2 */
N//#define DMA_RMPCR2_CH2_USART6_RX            ((uint32_t)0x000000D0)        /*!< Remap USART6 Rx on DMA2 channel 2 */
N//#define DMA_RMPCR2_CH2_USART7_RX            ((uint32_t)0x000000E0)        /*!< Remap USART7 Rx on DMA2 channel 2 */
N//#define DMA_RMPCR2_CH2_USART8_RX            ((uint32_t)0x000000F0)        /*!< Remap USART8 Rx on DMA2 channel 2 */
N//#define DMA_RMPCR2_CH3_TIM6_UP              ((uint32_t)0x00000100)        /*!< Remap TIM6 up on DMA2 channel 3 */
N//#define DMA_RMPCR2_CH3_DAC_CH1              ((uint32_t)0x00000100)        /*!< Remap DAC channel 1 on DMA2 channel 3 */
N//#define DMA_RMPCR2_CH3_SPI1_RX              ((uint32_t)0x00000300)        /*!< Remap SPI1 Rx on DMA2 channel 3 */
N//#define DMA_RMPCR2_CH3_USART1_RX            ((uint32_t)0x00000800)        /*!< Remap USART1 Rx on DMA2 channel 3 */
N//#define DMA_RMPCR2_CH3_USART2_RX            ((uint32_t)0x00000900)        /*!< Remap USART2 Rx on DMA2 channel 3 */
N//#define DMA_RMPCR2_CH3_USART3_RX            ((uint32_t)0x00000A00)        /*!< Remap USART3 Rx on DMA2 channel 3 */
N//#define DMA_RMPCR2_CH3_USART4_RX            ((uint32_t)0x00000B00)        /*!< Remap USART4 Rx on DMA2 channel 3 */
N//#define DMA_RMPCR2_CH3_USART5_RX            ((uint32_t)0x00000C00)        /*!< Remap USART5 Rx on DMA2 channel 3 */
N//#define DMA_RMPCR2_CH3_USART6_RX            ((uint32_t)0x00000D00)        /*!< Remap USART6 Rx on DMA2 channel 3 */
N//#define DMA_RMPCR2_CH3_USART7_RX            ((uint32_t)0x00000E00)        /*!< Remap USART7 Rx on DMA2 channel 3 */
N//#define DMA_RMPCR2_CH3_USART8_RX            ((uint32_t)0x00000F00)        /*!< Remap USART8 Rx on DMA2 channel 3 */
N//#define DMA_RMPCR2_CH4_TIM7_UP              ((uint32_t)0x00001000)        /*!< Remap TIM7 up on DMA2 channel 4 */
N//#define DMA_RMPCR2_CH4_DAC_CH2              ((uint32_t)0x00001000)        /*!< Remap DAC channel 2 on DMA2 channel 4 */
N//#define DMA_RMPCR2_CH4_SPI1_TX              ((uint32_t)0x00003000)        /*!< Remap SPI1 Tx on DMA2 channel 4 */
N//#define DMA_RMPCR2_CH4_USART1_TX            ((uint32_t)0x00008000)        /*!< Remap USART1 Tx on DMA2 channel 4 */
N//#define DMA_RMPCR2_CH4_USART2_TX            ((uint32_t)0x00009000)        /*!< Remap USART2 Tx on DMA2 channel 4 */
N//#define DMA_RMPCR2_CH4_USART3_TX            ((uint32_t)0x0000A000)        /*!< Remap USART3 Tx on DMA2 channel 4 */
N//#define DMA_RMPCR2_CH4_USART4_TX            ((uint32_t)0x0000B000)        /*!< Remap USART4 Tx on DMA2 channel 4 */
N//#define DMA_RMPCR2_CH4_USART5_TX            ((uint32_t)0x0000C000)        /*!< Remap USART5 Tx on DMA2 channel 4 */
N//#define DMA_RMPCR2_CH4_USART6_TX            ((uint32_t)0x0000D000)        /*!< Remap USART6 Tx on DMA2 channel 4 */
N//#define DMA_RMPCR2_CH4_USART7_TX            ((uint32_t)0x0000E000)        /*!< Remap USART7 Tx on DMA2 channel 4 */
N//#define DMA_RMPCR2_CH4_USART8_TX            ((uint32_t)0x0000F000)        /*!< Remap USART8 Tx on DMA2 channel 4 */
N//#define DMA_RMPCR2_CH5_ADC                  ((uint32_t)0x00010000)        /*!< Remap ADC on DMA2 channel 5 */
N//#define DMA_RMPCR2_CH5_USART1_TX            ((uint32_t)0x00080000)        /*!< Remap USART1 Tx on DMA2 channel 5 */
N//#define DMA_RMPCR2_CH5_USART2_TX            ((uint32_t)0x00090000)        /*!< Remap USART2 Tx on DMA2 channel 5 */
N//#define DMA_RMPCR2_CH5_USART3_TX            ((uint32_t)0x000A0000)        /*!< Remap USART3 Tx on DMA2 channel 5 */
N//#define DMA_RMPCR2_CH5_USART4_TX            ((uint32_t)0x000B0000)        /*!< Remap USART4 Tx on DMA2 channel 5 */
N//#define DMA_RMPCR2_CH5_USART5_TX            ((uint32_t)0x000C0000)        /*!< Remap USART5 Tx on DMA2 channel 5 */
N//#define DMA_RMPCR2_CH5_USART6_TX            ((uint32_t)0x000D0000)        /*!< Remap USART6 Tx on DMA2 channel 5 */
N//#define DMA_RMPCR2_CH5_USART7_TX            ((uint32_t)0x000E0000)        /*!< Remap USART7 Tx on DMA2 channel 5 */
N//#define DMA_RMPCR2_CH5_USART8_TX            ((uint32_t)0x000F0000)        /*!< Remap USART8 Tx on DMA2 channel 5 */
N
N/******************************************************************************/
N/*                                                                            */
N/*                 External Interrupt/Event Controller (EXTI)                 */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for EXTI_IMR register  *******************/
N#define  EXTI_IMR_MR0                        ((uint32_t)0x00000001)        /*!< Interrupt Mask on line 0  */
N#define  EXTI_IMR_MR1                        ((uint32_t)0x00000002)        /*!< Interrupt Mask on line 1  */
N#define  EXTI_IMR_MR2                        ((uint32_t)0x00000004)        /*!< Interrupt Mask on line 2  */
N#define  EXTI_IMR_MR3                        ((uint32_t)0x00000008)        /*!< Interrupt Mask on line 3  */
N#define  EXTI_IMR_MR4                        ((uint32_t)0x00000010)        /*!< Interrupt Mask on line 4  */
N#define  EXTI_IMR_MR5                        ((uint32_t)0x00000020)        /*!< Interrupt Mask on line 5  */
N#define  EXTI_IMR_MR6                        ((uint32_t)0x00000040)        /*!< Interrupt Mask on line 6  */
N#define  EXTI_IMR_MR7                        ((uint32_t)0x00000080)        /*!< Interrupt Mask on line 7  */
N#define  EXTI_IMR_MR8                        ((uint32_t)0x00000100)        /*!< Interrupt Mask on line 8  */
N#define  EXTI_IMR_MR9                        ((uint32_t)0x00000200)        /*!< Interrupt Mask on line 9  */
N#define  EXTI_IMR_MR10                       ((uint32_t)0x00000400)        /*!< Interrupt Mask on line 10 */
N#define  EXTI_IMR_MR11                       ((uint32_t)0x00000800)        /*!< Interrupt Mask on line 11 */
N#define  EXTI_IMR_MR12                       ((uint32_t)0x00001000)        /*!< Interrupt Mask on line 12 */
N#define  EXTI_IMR_MR13                       ((uint32_t)0x00002000)        /*!< Interrupt Mask on line 13 */
N#define  EXTI_IMR_MR14                       ((uint32_t)0x00004000)        /*!< Interrupt Mask on line 14 */
N#define  EXTI_IMR_MR15                       ((uint32_t)0x00008000)        /*!< Interrupt Mask on line 15 */
N#define  EXTI_IMR_MR16                       ((uint32_t)0x00010000)        /*!< Interrupt Mask on line 16 */
N#define  EXTI_IMR_MR17                       ((uint32_t)0x00020000)        /*!< Interrupt Mask on line 17 */
N#define  EXTI_IMR_MR18                       ((uint32_t)0x00040000)        /*!< Interrupt Mask on line 18 */
N#define  EXTI_IMR_MR19                       ((uint32_t)0x00080000)        /*!< Interrupt Mask on line 19 */
N#define  EXTI_IMR_MR20                       ((uint32_t)0x00100000)        /*!< Interrupt Mask on line 20 */
N#define  EXTI_IMR_MR21                       ((uint32_t)0x00200000)        /*!< Interrupt Mask on line 21 */
N#define  EXTI_IMR_MR22                       ((uint32_t)0x00400000)        /*!< Interrupt Mask on line 22 */
N#define  EXTI_IMR_MR23                       ((uint32_t)0x00800000)        /*!< Interrupt Mask on line 23 */
N#define  EXTI_IMR_MR24                       ((uint32_t)0x01000000)        /*!< Interrupt Mask on line 24 */
N#define  EXTI_IMR_MR25                       ((uint32_t)0x02000000)        /*!< Interrupt Mask on line 25 */
N#define  EXTI_IMR_MR26                       ((uint32_t)0x04000000)        /*!< Interrupt Mask on line 26 */
N#define  EXTI_IMR_MR27                       ((uint32_t)0x08000000)        /*!< Interrupt Mask on line 27 */
N#define  EXTI_IMR_MR28                       ((uint32_t)0x10000000)        /*!< Interrupt Mask on line 28 */
N#define  EXTI_IMR_MR29                       ((uint32_t)0x20000000)        /*!< Interrupt Mask on line 29 */
N#define  EXTI_IMR_MR30                       ((uint32_t)0x40000000)        /*!< Interrupt Mask on line 30 */
N#define  EXTI_IMR_MR31                       ((uint32_t)0x80000000)        /*!< Interrupt Mask on line 31 */
N
N/******************  Bit definition for EXTI_EMR register  ********************/
N#define  EXTI_EMR_MR0                        ((uint32_t)0x00000001)        /*!< Event Mask on line 0  */
N#define  EXTI_EMR_MR1                        ((uint32_t)0x00000002)        /*!< Event Mask on line 1  */
N#define  EXTI_EMR_MR2                        ((uint32_t)0x00000004)        /*!< Event Mask on line 2  */
N#define  EXTI_EMR_MR3                        ((uint32_t)0x00000008)        /*!< Event Mask on line 3  */
N#define  EXTI_EMR_MR4                        ((uint32_t)0x00000010)        /*!< Event Mask on line 4  */
N#define  EXTI_EMR_MR5                        ((uint32_t)0x00000020)        /*!< Event Mask on line 5  */
N#define  EXTI_EMR_MR6                        ((uint32_t)0x00000040)        /*!< Event Mask on line 6  */
N#define  EXTI_EMR_MR7                        ((uint32_t)0x00000080)        /*!< Event Mask on line 7  */
N#define  EXTI_EMR_MR8                        ((uint32_t)0x00000100)        /*!< Event Mask on line 8  */
N#define  EXTI_EMR_MR9                        ((uint32_t)0x00000200)        /*!< Event Mask on line 9  */
N#define  EXTI_EMR_MR10                       ((uint32_t)0x00000400)        /*!< Event Mask on line 10 */
N#define  EXTI_EMR_MR11                       ((uint32_t)0x00000800)        /*!< Event Mask on line 11 */
N#define  EXTI_EMR_MR12                       ((uint32_t)0x00001000)        /*!< Event Mask on line 12 */
N#define  EXTI_EMR_MR13                       ((uint32_t)0x00002000)        /*!< Event Mask on line 13 */
N#define  EXTI_EMR_MR14                       ((uint32_t)0x00004000)        /*!< Event Mask on line 14 */
N#define  EXTI_EMR_MR15                       ((uint32_t)0x00008000)        /*!< Event Mask on line 15 */
N#define  EXTI_EMR_MR16                       ((uint32_t)0x00010000)        /*!< Event Mask on line 16 */
N#define  EXTI_EMR_MR17                       ((uint32_t)0x00020000)        /*!< Event Mask on line 17 */
N#define  EXTI_EMR_MR18                       ((uint32_t)0x00040000)        /*!< Event Mask on line 18 */
N#define  EXTI_EMR_MR19                       ((uint32_t)0x00080000)        /*!< Event Mask on line 19 */
N#define  EXTI_EMR_MR20                       ((uint32_t)0x00100000)        /*!< Event Mask on line 20 */
N#define  EXTI_EMR_MR21                       ((uint32_t)0x00200000)        /*!< Event Mask on line 21 */
N#define  EXTI_EMR_MR22                       ((uint32_t)0x00400000)        /*!< Event Mask on line 22 */
N#define  EXTI_EMR_MR23                       ((uint32_t)0x00800000)        /*!< Event Mask on line 23 */
N#define  EXTI_EMR_MR24                       ((uint32_t)0x01000000)        /*!< Event Mask on line 24 */
N#define  EXTI_EMR_MR25                       ((uint32_t)0x02000000)        /*!< Event Mask on line 25 */
N#define  EXTI_EMR_MR26                       ((uint32_t)0x04000000)        /*!< Event Mask on line 26 */
N#define  EXTI_EMR_MR27                       ((uint32_t)0x08000000)        /*!< Event Mask on line 27 */
N#define  EXTI_EMR_MR28                       ((uint32_t)0x10000000)        /*!< Event Mask on line 28 */
N#define  EXTI_EMR_MR29                       ((uint32_t)0x20000000)        /*!< Event Mask on line 29 */
N#define  EXTI_EMR_MR30                       ((uint32_t)0x40000000)        /*!< Event Mask on line 30 */
N#define  EXTI_EMR_MR31                       ((uint32_t)0x80000000)        /*!< Event Mask on line 31 */
N
N/*******************  Bit definition for EXTI_RTSR register  ******************/
N#define  EXTI_RTSR_TR0                       ((uint32_t)0x00000001)        /*!< Rising trigger event configuration bit of line 0 */
N#define  EXTI_RTSR_TR1                       ((uint32_t)0x00000002)        /*!< Rising trigger event configuration bit of line 1 */
N#define  EXTI_RTSR_TR2                       ((uint32_t)0x00000004)        /*!< Rising trigger event configuration bit of line 2 */
N#define  EXTI_RTSR_TR3                       ((uint32_t)0x00000008)        /*!< Rising trigger event configuration bit of line 3 */
N#define  EXTI_RTSR_TR4                       ((uint32_t)0x00000010)        /*!< Rising trigger event configuration bit of line 4 */
N#define  EXTI_RTSR_TR5                       ((uint32_t)0x00000020)        /*!< Rising trigger event configuration bit of line 5 */
N#define  EXTI_RTSR_TR6                       ((uint32_t)0x00000040)        /*!< Rising trigger event configuration bit of line 6 */
N#define  EXTI_RTSR_TR7                       ((uint32_t)0x00000080)        /*!< Rising trigger event configuration bit of line 7 */
N#define  EXTI_RTSR_TR8                       ((uint32_t)0x00000100)        /*!< Rising trigger event configuration bit of line 8 */
N#define  EXTI_RTSR_TR9                       ((uint32_t)0x00000200)        /*!< Rising trigger event configuration bit of line 9 */
N#define  EXTI_RTSR_TR10                      ((uint32_t)0x00000400)        /*!< Rising trigger event configuration bit of line 10 */
N#define  EXTI_RTSR_TR11                      ((uint32_t)0x00000800)        /*!< Rising trigger event configuration bit of line 11 */
N#define  EXTI_RTSR_TR12                      ((uint32_t)0x00001000)        /*!< Rising trigger event configuration bit of line 12 */
N#define  EXTI_RTSR_TR13                      ((uint32_t)0x00002000)        /*!< Rising trigger event configuration bit of line 13 */
N#define  EXTI_RTSR_TR14                      ((uint32_t)0x00004000)        /*!< Rising trigger event configuration bit of line 14 */
N#define  EXTI_RTSR_TR15                      ((uint32_t)0x00008000)        /*!< Rising trigger event configuration bit of line 15 */
N#define  EXTI_RTSR_TR16                      ((uint32_t)0x00010000)        /*!< Rising trigger event configuration bit of line 16 */
N#define  EXTI_RTSR_TR17                      ((uint32_t)0x00020000)        /*!< Rising trigger event configuration bit of line 17 */
N#define  EXTI_RTSR_TR19                      ((uint32_t)0x00080000)        /*!< Rising trigger event configuration bit of line 19 */
N//#define  EXTI_RTSR_TR20                      ((uint32_t)0x00100000)        /*!< Rising trigger event configuration bit of line 20 */
N#define  EXTI_RTSR_TR21                      ((uint32_t)0x00200000)        /*!< Rising trigger event configuration bit of line 21 */
N#define  EXTI_RTSR_TR22                      ((uint32_t)0x00400000)        /*!< Rising trigger event configuration bit of line 22 */
N
N/*******************  Bit definition for EXTI_FTSR register *******************/
N#define  EXTI_FTSR_TR0                       ((uint32_t)0x00000001)        /*!< Falling trigger event configuration bit of line 0 */
N#define  EXTI_FTSR_TR1                       ((uint32_t)0x00000002)        /*!< Falling trigger event configuration bit of line 1 */
N#define  EXTI_FTSR_TR2                       ((uint32_t)0x00000004)        /*!< Falling trigger event configuration bit of line 2 */
N#define  EXTI_FTSR_TR3                       ((uint32_t)0x00000008)        /*!< Falling trigger event configuration bit of line 3 */
N#define  EXTI_FTSR_TR4                       ((uint32_t)0x00000010)        /*!< Falling trigger event configuration bit of line 4 */
N#define  EXTI_FTSR_TR5                       ((uint32_t)0x00000020)        /*!< Falling trigger event configuration bit of line 5 */
N#define  EXTI_FTSR_TR6                       ((uint32_t)0x00000040)        /*!< Falling trigger event configuration bit of line 6 */
N#define  EXTI_FTSR_TR7                       ((uint32_t)0x00000080)        /*!< Falling trigger event configuration bit of line 7 */
N#define  EXTI_FTSR_TR8                       ((uint32_t)0x00000100)        /*!< Falling trigger event configuration bit of line 8 */
N#define  EXTI_FTSR_TR9                       ((uint32_t)0x00000200)        /*!< Falling trigger event configuration bit of line 9 */
N#define  EXTI_FTSR_TR10                      ((uint32_t)0x00000400)        /*!< Falling trigger event configuration bit of line 10 */
N#define  EXTI_FTSR_TR11                      ((uint32_t)0x00000800)        /*!< Falling trigger event configuration bit of line 11 */
N#define  EXTI_FTSR_TR12                      ((uint32_t)0x00001000)        /*!< Falling trigger event configuration bit of line 12 */
N#define  EXTI_FTSR_TR13                      ((uint32_t)0x00002000)        /*!< Falling trigger event configuration bit of line 13 */
N#define  EXTI_FTSR_TR14                      ((uint32_t)0x00004000)        /*!< Falling trigger event configuration bit of line 14 */
N#define  EXTI_FTSR_TR15                      ((uint32_t)0x00008000)        /*!< Falling trigger event configuration bit of line 15 */
N#define  EXTI_FTSR_TR16                      ((uint32_t)0x00010000)        /*!< Falling trigger event configuration bit of line 16 */
N#define  EXTI_FTSR_TR17                      ((uint32_t)0x00020000)        /*!< Falling trigger event configuration bit of line 17 */
N#define  EXTI_FTSR_TR19                      ((uint32_t)0x00080000)        /*!< Falling trigger event configuration bit of line 19 */
N//#define  EXTI_FTSR_TR20                      ((uint32_t)0x00100000)        /*!< Falling trigger event configuration bit of line 20 */
N#define  EXTI_FTSR_TR21                      ((uint32_t)0x00200000)        /*!< Falling trigger event configuration bit of line 21 */
N#define  EXTI_FTSR_TR22                      ((uint32_t)0x00400000)        /*!< Falling trigger event configuration bit of line 22 */
N
N/******************* Bit definition for EXTI_SWIER register *******************/
N#define  EXTI_SWIER_SWIER0                   ((uint32_t)0x00000001)        /*!< Software Interrupt on line 0  */
N#define  EXTI_SWIER_SWIER1                   ((uint32_t)0x00000002)        /*!< Software Interrupt on line 1  */
N#define  EXTI_SWIER_SWIER2                   ((uint32_t)0x00000004)        /*!< Software Interrupt on line 2  */
N#define  EXTI_SWIER_SWIER3                   ((uint32_t)0x00000008)        /*!< Software Interrupt on line 3  */
N#define  EXTI_SWIER_SWIER4                   ((uint32_t)0x00000010)        /*!< Software Interrupt on line 4  */
N#define  EXTI_SWIER_SWIER5                   ((uint32_t)0x00000020)        /*!< Software Interrupt on line 5  */
N#define  EXTI_SWIER_SWIER6                   ((uint32_t)0x00000040)        /*!< Software Interrupt on line 6  */
N#define  EXTI_SWIER_SWIER7                   ((uint32_t)0x00000080)        /*!< Software Interrupt on line 7  */
N#define  EXTI_SWIER_SWIER8                   ((uint32_t)0x00000100)        /*!< Software Interrupt on line 8  */
N#define  EXTI_SWIER_SWIER9                   ((uint32_t)0x00000200)        /*!< Software Interrupt on line 9  */
N#define  EXTI_SWIER_SWIER10                  ((uint32_t)0x00000400)        /*!< Software Interrupt on line 10 */
N#define  EXTI_SWIER_SWIER11                  ((uint32_t)0x00000800)        /*!< Software Interrupt on line 11 */
N#define  EXTI_SWIER_SWIER12                  ((uint32_t)0x00001000)        /*!< Software Interrupt on line 12 */
N#define  EXTI_SWIER_SWIER13                  ((uint32_t)0x00002000)        /*!< Software Interrupt on line 13 */
N#define  EXTI_SWIER_SWIER14                  ((uint32_t)0x00004000)        /*!< Software Interrupt on line 14 */
N#define  EXTI_SWIER_SWIER15                  ((uint32_t)0x00008000)        /*!< Software Interrupt on line 15 */
N#define  EXTI_SWIER_SWIER16                  ((uint32_t)0x00010000)        /*!< Software Interrupt on line 16 */
N#define  EXTI_SWIER_SWIER17                  ((uint32_t)0x00020000)        /*!< Software Interrupt on line 17 */
N#define  EXTI_SWIER_SWIER19                  ((uint32_t)0x00080000)        /*!< Software Interrupt on line 19 */
N//#define  EXTI_SWIER_SWIER20                  ((uint32_t)0x00100000)        /*!< Software Interrupt on line 20 */
N#define  EXTI_SWIER_SWIER21                  ((uint32_t)0x00200000)        /*!< Software Interrupt on line 21 */
N#define  EXTI_SWIER_SWIER22                  ((uint32_t)0x00400000)        /*!< Software Interrupt on line 22 */
N
N/******************  Bit definition for EXTI_PR register  *********************/
N#define  EXTI_PR_PR0                         ((uint32_t)0x00000001)        /*!< Pending bit 0  */
N#define  EXTI_PR_PR1                         ((uint32_t)0x00000002)        /*!< Pending bit 1  */
N#define  EXTI_PR_PR2                         ((uint32_t)0x00000004)        /*!< Pending bit 2  */
N#define  EXTI_PR_PR3                         ((uint32_t)0x00000008)        /*!< Pending bit 3  */
N#define  EXTI_PR_PR4                         ((uint32_t)0x00000010)        /*!< Pending bit 4  */
N#define  EXTI_PR_PR5                         ((uint32_t)0x00000020)        /*!< Pending bit 5  */
N#define  EXTI_PR_PR6                         ((uint32_t)0x00000040)        /*!< Pending bit 6  */
N#define  EXTI_PR_PR7                         ((uint32_t)0x00000080)        /*!< Pending bit 7  */
N#define  EXTI_PR_PR8                         ((uint32_t)0x00000100)        /*!< Pending bit 8  */
N#define  EXTI_PR_PR9                         ((uint32_t)0x00000200)        /*!< Pending bit 9  */
N#define  EXTI_PR_PR10                        ((uint32_t)0x00000400)        /*!< Pending bit 10 */
N#define  EXTI_PR_PR11                        ((uint32_t)0x00000800)        /*!< Pending bit 11 */
N#define  EXTI_PR_PR12                        ((uint32_t)0x00001000)        /*!< Pending bit 12 */
N#define  EXTI_PR_PR13                        ((uint32_t)0x00002000)        /*!< Pending bit 13 */
N#define  EXTI_PR_PR14                        ((uint32_t)0x00004000)        /*!< Pending bit 14 */
N#define  EXTI_PR_PR15                        ((uint32_t)0x00008000)        /*!< Pending bit 15 */
N#define  EXTI_PR_PR16                        ((uint32_t)0x00010000)        /*!< Pending bit 16 */
N#define  EXTI_PR_PR17                        ((uint32_t)0x00020000)        /*!< Pending bit 17 */
N#define  EXTI_PR_PR19                        ((uint32_t)0x00080000)        /*!< Pending bit 19 */
N//#define  EXTI_PR_PR20                        ((uint32_t)0x00100000)        /*!< Pending bit 20 */
N#define  EXTI_PR_PR21                        ((uint32_t)0x00200000)        /*!< Pending bit 21 */
N#define  EXTI_PR_PR22                        ((uint32_t)0x00400000)        /*!< Pending bit 22 */
N
N/******************************************************************************/
N/*                                                                            */
N/*                      FLASH and Option Bytes Registers                      */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for FLASH_ACR register  ******************/
N#define  FLASH_ACR_LATENCY                   ((uint32_t)0x00000001)        /*!< LATENCY bit (Latency) */
N
N#define  FLASH_ACR_PRFTBE                    ((uint32_t)0x00000010)        /*!< Prefetch Buffer Enable */
N#define  FLASH_ACR_PRFTBS                    ((uint32_t)0x00000020)        /*!< Prefetch Buffer Status */
N
N/******************  Bit definition for FLASH_KEYR register  ******************/
N#define  FLASH_KEYR_FKEYR                    ((uint32_t)0xFFFFFFFF)        /*!< FPEC Key */
N
N/*****************  Bit definition for FLASH_OPTKEYR register  ****************/
N#define  FLASH_OPTKEYR_OPTKEYR               ((uint32_t)0xFFFFFFFF)        /*!< Option Byte Key */
N
N/******************  FLASH Keys  **********************************************/
N#define FLASH_FKEY1                          ((uint32_t)0x45670123)        /*!< Flash program erase key1 */
N#define FLASH_FKEY2                          ((uint32_t)0xCDEF89AB)        /*!< Flash program erase key2: used with FLASH_PEKEY1
N                                                                                to unlock the write access to the FPEC. */
N                                                               
N#define FLASH_OPTKEY1                        ((uint32_t)0x45670123)        /*!< Flash option key1 */
N#define FLASH_OPTKEY2                        ((uint32_t)0xCDEF89AB)        /*!< Flash option key2: used with FLASH_OPTKEY1 to
N                                                                                unlock the write access to the option byte block */
N
N/******************  Bit definition for FLASH_SR register  *******************/
N#define  FLASH_SR_BSY                        ((uint32_t)0x00000001)        /*!< Busy */
N#define  FLASH_SR_PGERR                      ((uint32_t)0x00000004)        /*!< Programming Error */
N#define  FLASH_SR_WRPRTERR                   ((uint32_t)0x00000010)        /*!< Write Protection Error */
N#define  FLASH_SR_EOP                        ((uint32_t)0x00000020)        /*!< End of operation */
N#define  FLASH_SR_WRPERR                     FLASH_SR_WRPRTERR             /*!< Legacy of Write Protection Error */
N
N/*******************  Bit definition for FLASH_CR register  *******************/
N#define  FLASH_CR_PG                         ((uint32_t)0x00000001)        /*!< Programming */
N#define  FLASH_CR_PER                        ((uint32_t)0x00000002)        /*!< Page Erase */
N#define  FLASH_CR_MER                        ((uint32_t)0x00000004)        /*!< Mass Erase */
N#define  FLASH_CR_MAS2K                      ((uint32_t)0x00000008)        /*!< Mass Erase */
N#define  FLASH_CR_OPTPG                      ((uint32_t)0x00000010)        /*!< Option Byte Programming */
N#define  FLASH_CR_OPTER                      ((uint32_t)0x00000020)        /*!< Option Byte Erase */
N#define  FLASH_CR_STRT                       ((uint32_t)0x00000040)        /*!< Start */
N#define  FLASH_CR_LOCK                       ((uint32_t)0x00000080)        /*!< Lock */
N#define  FLASH_CR_OPTWRE                     ((uint32_t)0x00000200)        /*!< Option Bytes Write Enable */
N#define  FLASH_CR_ERRIE                      ((uint32_t)0x00000400)        /*!< Error Interrupt Enable */
N#define  FLASH_CR_EOPIE                      ((uint32_t)0x00001000)        /*!< End of operation interrupt enable */
N#define  FLASH_CR_OBL_LAUNCH                 ((uint32_t)0x00002000)        /*!< Option Bytes Loader Launch */
N
N/*******************  Bit definition for FLASH_AR register  *******************/
N#define  FLASH_AR_FAR                        ((uint32_t)0xFFFFFFFF)        /*!< Flash Address */
N
N/******************  Bit definition for FLASH_OBR register  *******************/
N#define  FLASH_OBR_OPTERR                    ((uint32_t)0x00000001)        /*!< Option Byte Error */
N#define  FLASH_OBR_RDPRT1                    ((uint32_t)0x00000002)        /*!< Read protection Level bit 1 */
N#define  FLASH_OBR_RDPRT2                    ((uint32_t)0x00000004)        /*!< Read protection Level bit 2 */
N
N//#define  FLASH_OBR_USER                      ((uint32_t)0x00003700)        /*!< User Option Bytes */
N#define  FLASH_OBR_IWDG_SW                   ((uint32_t)0x00000100)        /*!< IWDG SW */
N#define  FLASH_OBR_nRST_STOP                 ((uint32_t)0x00000200)        /*!< nRST_STOP */
N#define  FLASH_OBR_nRST_STDBY                ((uint32_t)0x00000400)        /*!< nRST_STDBY */
N//#define  FLASH_OBR_nBOOT0                    ((uint32_t)0x00000800)        /*!< nBOOT0 */
N#define  FLASH_OBR_nBOOT1                    ((uint32_t)0x00001000)        /*!< nBOOT1 */
N#define  FLASH_OBR_VDDA_MONITOR              ((uint32_t)0x00002000)        /*!< VDDA power supply supervisor */
N//#define  FLASH_OBR_RAM_PARITY_CHECK          ((uint32_t)0x00004000)        /*!< RAM Parity Check */
N//#define  FLASH_OBR_nBOOT0_SW                 ((uint32_t)0x00008000)        /*!< nBOOT0 SW*/
N#define  FLASH_OBR_DATA0                     ((uint32_t)0x00FF0000)        /*!< DATA0 */
N#define  FLASH_OBR_DATA1                     ((uint32_t)0xFF000000)        /*!< DATA0 */
N
N/* Old BOOT1 bit definition, maintained for legacy purpose */
N#define FLASH_OBR_BOOT1                      FLASH_OBR_nBOOT1
N
N/* Old OBR_VDDA bit definition, maintained for legacy purpose */
N#define FLASH_OBR_VDDA_ANALOG                FLASH_OBR_VDDA_MONITOR
N
N/******************  Bit definition for FLASH_WRPR register  ******************/
N#define  FLASH_WRPR_WRP                      ((uint32_t)0xFFFFFFFF)        /*!< Write Protect */
N
N/*----------------------------------------------------------------------------*/
N
N/******************  Bit definition for OB_RDP register  **********************/
N#define  OB_RDP_RDP                          ((uint32_t)0x000000FF)        /*!< Read protection option byte */
N#define  OB_RDP_nRDP                         ((uint32_t)0x0000FF00)        /*!< Read protection complemented option byte */
N
N/******************  Bit definition for OB_USER register  *********************/
N#define  OB_USER_USER                        ((uint32_t)0x00FF0000)        /*!< User option byte */
N#define  OB_USER_nUSER                       ((uint32_t)0xFF000000)        /*!< User complemented option byte */
N
N/******************  Bit definition for OB_WRP0 register  *********************/
N#define  OB_WRP0_WRP0                        ((uint32_t)0x000000FF)        /*!< Flash memory write protection option bytes */
N#define  OB_WRP0_nWRP0                       ((uint32_t)0x0000FF00)        /*!< Flash memory write protection complemented option bytes */
N
N/******************  Bit definition for OB_WRP1 register  *********************/
N#define  OB_WRP1_WRP1                        ((uint32_t)0x00FF0000)        /*!< Flash memory write protection option bytes */
N#define  OB_WRP1_nWRP1                       ((uint32_t)0xFF000000)        /*!< Flash memory write protection complemented option bytes */
N
N/******************  Bit definition for OB_WRP2 register  *********************/
N#define  OB_WRP2_WRP2                        ((uint32_t)0x000000FF)        /*!< Flash memory write protection option bytes (only for FT32F072X8 devices) */
N#define  OB_WRP2_nWRP2                       ((uint32_t)0x0000FF00)        /*!< Flash memory write protection complemented option bytes (only for FT32F072X8 devices) */
N
N/******************  Bit definition for OB_WRP3 register  *********************/
N#define  OB_WRP3_WRP3                        ((uint32_t)0x00FF0000)        /*!< Flash memory write protection option bytes (only for FT32F072X8 devices) */
N#define  OB_WRP3_nWRP3                       ((uint32_t)0xFF000000)        /*!< Flash memory write protection complemented option bytes (only for FT32F072X8 devices) */
N
N/******************************************************************************/
N/*                                                                            */
N/*                       General Purpose IOs (GPIO)                           */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for GPIO_MODER register  *****************/
N#define GPIO_MODER_MODER0          ((uint32_t)0x00000003)
N#define GPIO_MODER_MODER0_0        ((uint32_t)0x00000001)
N#define GPIO_MODER_MODER0_1        ((uint32_t)0x00000002)
N#define GPIO_MODER_MODER1          ((uint32_t)0x0000000C)
N#define GPIO_MODER_MODER1_0        ((uint32_t)0x00000004)
N#define GPIO_MODER_MODER1_1        ((uint32_t)0x00000008)
N#define GPIO_MODER_MODER2          ((uint32_t)0x00000030)
N#define GPIO_MODER_MODER2_0        ((uint32_t)0x00000010)
N#define GPIO_MODER_MODER2_1        ((uint32_t)0x00000020)
N#define GPIO_MODER_MODER3          ((uint32_t)0x000000C0)
N#define GPIO_MODER_MODER3_0        ((uint32_t)0x00000040)
N#define GPIO_MODER_MODER3_1        ((uint32_t)0x00000080)
N#define GPIO_MODER_MODER4          ((uint32_t)0x00000300)
N#define GPIO_MODER_MODER4_0        ((uint32_t)0x00000100)
N#define GPIO_MODER_MODER4_1        ((uint32_t)0x00000200)
N#define GPIO_MODER_MODER5          ((uint32_t)0x00000C00)
N#define GPIO_MODER_MODER5_0        ((uint32_t)0x00000400)
N#define GPIO_MODER_MODER5_1        ((uint32_t)0x00000800)
N#define GPIO_MODER_MODER6          ((uint32_t)0x00003000)
N#define GPIO_MODER_MODER6_0        ((uint32_t)0x00001000)
N#define GPIO_MODER_MODER6_1        ((uint32_t)0x00002000)
N#define GPIO_MODER_MODER7          ((uint32_t)0x0000C000)
N#define GPIO_MODER_MODER7_0        ((uint32_t)0x00004000)
N#define GPIO_MODER_MODER7_1        ((uint32_t)0x00008000)
N#define GPIO_MODER_MODER8          ((uint32_t)0x00030000)
N#define GPIO_MODER_MODER8_0        ((uint32_t)0x00010000)
N#define GPIO_MODER_MODER8_1        ((uint32_t)0x00020000)
N#define GPIO_MODER_MODER9          ((uint32_t)0x000C0000)
N#define GPIO_MODER_MODER9_0        ((uint32_t)0x00040000)
N#define GPIO_MODER_MODER9_1        ((uint32_t)0x00080000)
N#define GPIO_MODER_MODER10         ((uint32_t)0x00300000)
N#define GPIO_MODER_MODER10_0       ((uint32_t)0x00100000)
N#define GPIO_MODER_MODER10_1       ((uint32_t)0x00200000)
N#define GPIO_MODER_MODER11         ((uint32_t)0x00C00000)
N#define GPIO_MODER_MODER11_0       ((uint32_t)0x00400000)
N#define GPIO_MODER_MODER11_1       ((uint32_t)0x00800000)
N#define GPIO_MODER_MODER12         ((uint32_t)0x03000000)
N#define GPIO_MODER_MODER12_0       ((uint32_t)0x01000000)
N#define GPIO_MODER_MODER12_1       ((uint32_t)0x02000000)
N#define GPIO_MODER_MODER13         ((uint32_t)0x0C000000)
N#define GPIO_MODER_MODER13_0       ((uint32_t)0x04000000)
N#define GPIO_MODER_MODER13_1       ((uint32_t)0x08000000)
N#define GPIO_MODER_MODER14         ((uint32_t)0x30000000)
N#define GPIO_MODER_MODER14_0       ((uint32_t)0x10000000)
N#define GPIO_MODER_MODER14_1       ((uint32_t)0x20000000)
N#define GPIO_MODER_MODER15         ((uint32_t)0xC0000000)
N#define GPIO_MODER_MODER15_0       ((uint32_t)0x40000000)
N#define GPIO_MODER_MODER15_1       ((uint32_t)0x80000000)
N
N/******************  Bit definition for GPIO_OTYPER register  *****************/
N#define GPIO_OTYPER_OT_0           ((uint32_t)0x00000001)
N#define GPIO_OTYPER_OT_1           ((uint32_t)0x00000002)
N#define GPIO_OTYPER_OT_2           ((uint32_t)0x00000004)
N#define GPIO_OTYPER_OT_3           ((uint32_t)0x00000008)
N#define GPIO_OTYPER_OT_4           ((uint32_t)0x00000010)
N#define GPIO_OTYPER_OT_5           ((uint32_t)0x00000020)
N#define GPIO_OTYPER_OT_6           ((uint32_t)0x00000040)
N#define GPIO_OTYPER_OT_7           ((uint32_t)0x00000080)
N#define GPIO_OTYPER_OT_8           ((uint32_t)0x00000100)
N#define GPIO_OTYPER_OT_9           ((uint32_t)0x00000200)
N#define GPIO_OTYPER_OT_10          ((uint32_t)0x00000400)
N#define GPIO_OTYPER_OT_11          ((uint32_t)0x00000800)
N#define GPIO_OTYPER_OT_12          ((uint32_t)0x00001000)
N#define GPIO_OTYPER_OT_13          ((uint32_t)0x00002000)
N#define GPIO_OTYPER_OT_14          ((uint32_t)0x00004000)
N#define GPIO_OTYPER_OT_15          ((uint32_t)0x00008000)
N
N/****************  Bit definition for GPIO_OSPEEDR register  ******************/
N#define GPIO_OSPEEDR_OSPEEDR0     ((uint32_t)0x00000003)
N#define GPIO_OSPEEDR_OSPEEDR0_0   ((uint32_t)0x00000001)
N#define GPIO_OSPEEDR_OSPEEDR0_1   ((uint32_t)0x00000002)
N#define GPIO_OSPEEDR_OSPEEDR1     ((uint32_t)0x0000000C)
N#define GPIO_OSPEEDR_OSPEEDR1_0   ((uint32_t)0x00000004)
N#define GPIO_OSPEEDR_OSPEEDR1_1   ((uint32_t)0x00000008)
N#define GPIO_OSPEEDR_OSPEEDR2     ((uint32_t)0x00000030)
N#define GPIO_OSPEEDR_OSPEEDR2_0   ((uint32_t)0x00000010)
N#define GPIO_OSPEEDR_OSPEEDR2_1   ((uint32_t)0x00000020)
N#define GPIO_OSPEEDR_OSPEEDR3     ((uint32_t)0x000000C0)
N#define GPIO_OSPEEDR_OSPEEDR3_0   ((uint32_t)0x00000040)
N#define GPIO_OSPEEDR_OSPEEDR3_1   ((uint32_t)0x00000080)
N#define GPIO_OSPEEDR_OSPEEDR4     ((uint32_t)0x00000300)
N#define GPIO_OSPEEDR_OSPEEDR4_0   ((uint32_t)0x00000100)
N#define GPIO_OSPEEDR_OSPEEDR4_1   ((uint32_t)0x00000200)
N#define GPIO_OSPEEDR_OSPEEDR5     ((uint32_t)0x00000C00)
N#define GPIO_OSPEEDR_OSPEEDR5_0   ((uint32_t)0x00000400)
N#define GPIO_OSPEEDR_OSPEEDR5_1   ((uint32_t)0x00000800)
N#define GPIO_OSPEEDR_OSPEEDR6     ((uint32_t)0x00003000)
N#define GPIO_OSPEEDR_OSPEEDR6_0   ((uint32_t)0x00001000)
N#define GPIO_OSPEEDR_OSPEEDR6_1   ((uint32_t)0x00002000)
N#define GPIO_OSPEEDR_OSPEEDR7     ((uint32_t)0x0000C000)
N#define GPIO_OSPEEDR_OSPEEDR7_0   ((uint32_t)0x00004000)
N#define GPIO_OSPEEDR_OSPEEDR7_1   ((uint32_t)0x00008000)
N#define GPIO_OSPEEDR_OSPEEDR8     ((uint32_t)0x00030000)
N#define GPIO_OSPEEDR_OSPEEDR8_0   ((uint32_t)0x00010000)
N#define GPIO_OSPEEDR_OSPEEDR8_1   ((uint32_t)0x00020000)
N#define GPIO_OSPEEDR_OSPEEDR9     ((uint32_t)0x000C0000)
N#define GPIO_OSPEEDR_OSPEEDR9_0   ((uint32_t)0x00040000)
N#define GPIO_OSPEEDR_OSPEEDR9_1   ((uint32_t)0x00080000)
N#define GPIO_OSPEEDR_OSPEEDR10    ((uint32_t)0x00300000)
N#define GPIO_OSPEEDR_OSPEEDR10_0  ((uint32_t)0x00100000)
N#define GPIO_OSPEEDR_OSPEEDR10_1  ((uint32_t)0x00200000)
N#define GPIO_OSPEEDR_OSPEEDR11    ((uint32_t)0x00C00000)
N#define GPIO_OSPEEDR_OSPEEDR11_0  ((uint32_t)0x00400000)
N#define GPIO_OSPEEDR_OSPEEDR11_1  ((uint32_t)0x00800000)
N#define GPIO_OSPEEDR_OSPEEDR12    ((uint32_t)0x03000000)
N#define GPIO_OSPEEDR_OSPEEDR12_0  ((uint32_t)0x01000000)
N#define GPIO_OSPEEDR_OSPEEDR12_1  ((uint32_t)0x02000000)
N#define GPIO_OSPEEDR_OSPEEDR13    ((uint32_t)0x0C000000)
N#define GPIO_OSPEEDR_OSPEEDR13_0  ((uint32_t)0x04000000)
N#define GPIO_OSPEEDR_OSPEEDR13_1  ((uint32_t)0x08000000)
N#define GPIO_OSPEEDR_OSPEEDR14    ((uint32_t)0x30000000)
N#define GPIO_OSPEEDR_OSPEEDR14_0  ((uint32_t)0x10000000)
N#define GPIO_OSPEEDR_OSPEEDR14_1  ((uint32_t)0x20000000)
N#define GPIO_OSPEEDR_OSPEEDR15    ((uint32_t)0xC0000000)
N#define GPIO_OSPEEDR_OSPEEDR15_0  ((uint32_t)0x40000000)
N#define GPIO_OSPEEDR_OSPEEDR15_1  ((uint32_t)0x80000000)
N
N/* Old Bit definition for GPIO_OSPEEDR register maintained for legacy purpose */
N#define GPIO_OSPEEDER_OSPEEDR0     GPIO_OSPEEDR_OSPEEDR0
N#define GPIO_OSPEEDER_OSPEEDR0_0   GPIO_OSPEEDR_OSPEEDR0_0
N#define GPIO_OSPEEDER_OSPEEDR0_1   GPIO_OSPEEDR_OSPEEDR0_1
N#define GPIO_OSPEEDER_OSPEEDR1     GPIO_OSPEEDR_OSPEEDR1
N#define GPIO_OSPEEDER_OSPEEDR1_0   GPIO_OSPEEDR_OSPEEDR1_0
N#define GPIO_OSPEEDER_OSPEEDR1_1   GPIO_OSPEEDR_OSPEEDR1_1
N#define GPIO_OSPEEDER_OSPEEDR2     GPIO_OSPEEDR_OSPEEDR2
N#define GPIO_OSPEEDER_OSPEEDR2_0   GPIO_OSPEEDR_OSPEEDR2_0
N#define GPIO_OSPEEDER_OSPEEDR2_1   GPIO_OSPEEDR_OSPEEDR2_1
N#define GPIO_OSPEEDER_OSPEEDR3     GPIO_OSPEEDR_OSPEEDR3
N#define GPIO_OSPEEDER_OSPEEDR3_0   GPIO_OSPEEDR_OSPEEDR3_0
N#define GPIO_OSPEEDER_OSPEEDR3_1   GPIO_OSPEEDR_OSPEEDR3_1
N#define GPIO_OSPEEDER_OSPEEDR4     GPIO_OSPEEDR_OSPEEDR4
N#define GPIO_OSPEEDER_OSPEEDR4_0   GPIO_OSPEEDR_OSPEEDR4_0
N#define GPIO_OSPEEDER_OSPEEDR4_1   GPIO_OSPEEDR_OSPEEDR4_1
N#define GPIO_OSPEEDER_OSPEEDR5     GPIO_OSPEEDR_OSPEEDR5
N#define GPIO_OSPEEDER_OSPEEDR5_0   GPIO_OSPEEDR_OSPEEDR5_0
N#define GPIO_OSPEEDER_OSPEEDR5_1   GPIO_OSPEEDR_OSPEEDR5_1
N#define GPIO_OSPEEDER_OSPEEDR6     GPIO_OSPEEDR_OSPEEDR6
N#define GPIO_OSPEEDER_OSPEEDR6_0   GPIO_OSPEEDR_OSPEEDR6_0
N#define GPIO_OSPEEDER_OSPEEDR6_1   GPIO_OSPEEDR_OSPEEDR6_1
N#define GPIO_OSPEEDER_OSPEEDR7     GPIO_OSPEEDR_OSPEEDR7
N#define GPIO_OSPEEDER_OSPEEDR7_0   GPIO_OSPEEDR_OSPEEDR7_0
N#define GPIO_OSPEEDER_OSPEEDR7_1   GPIO_OSPEEDR_OSPEEDR7_1
N#define GPIO_OSPEEDER_OSPEEDR8     GPIO_OSPEEDR_OSPEEDR8
N#define GPIO_OSPEEDER_OSPEEDR8_0   GPIO_OSPEEDR_OSPEEDR8_0
N#define GPIO_OSPEEDER_OSPEEDR8_1   GPIO_OSPEEDR_OSPEEDR8_1
N#define GPIO_OSPEEDER_OSPEEDR9     GPIO_OSPEEDR_OSPEEDR9
N#define GPIO_OSPEEDER_OSPEEDR9_0   GPIO_OSPEEDR_OSPEEDR9_0
N#define GPIO_OSPEEDER_OSPEEDR9_1   GPIO_OSPEEDR_OSPEEDR9_1
N#define GPIO_OSPEEDER_OSPEEDR10    GPIO_OSPEEDR_OSPEEDR10
N#define GPIO_OSPEEDER_OSPEEDR10_0  GPIO_OSPEEDR_OSPEEDR10_0
N#define GPIO_OSPEEDER_OSPEEDR10_1  GPIO_OSPEEDR_OSPEEDR10_1
N#define GPIO_OSPEEDER_OSPEEDR11    GPIO_OSPEEDR_OSPEEDR11
N#define GPIO_OSPEEDER_OSPEEDR11_0  GPIO_OSPEEDR_OSPEEDR11_0
N#define GPIO_OSPEEDER_OSPEEDR11_1  GPIO_OSPEEDR_OSPEEDR11_1
N#define GPIO_OSPEEDER_OSPEEDR12    GPIO_OSPEEDR_OSPEEDR12
N#define GPIO_OSPEEDER_OSPEEDR12_0  GPIO_OSPEEDR_OSPEEDR12_0
N#define GPIO_OSPEEDER_OSPEEDR12_1  GPIO_OSPEEDR_OSPEEDR12_1
N#define GPIO_OSPEEDER_OSPEEDR13    GPIO_OSPEEDR_OSPEEDR13
N#define GPIO_OSPEEDER_OSPEEDR13_0  GPIO_OSPEEDR_OSPEEDR13_0
N#define GPIO_OSPEEDER_OSPEEDR13_1  GPIO_OSPEEDR_OSPEEDR13_1
N#define GPIO_OSPEEDER_OSPEEDR14    GPIO_OSPEEDR_OSPEEDR14
N#define GPIO_OSPEEDER_OSPEEDR14_0  GPIO_OSPEEDR_OSPEEDR14_0
N#define GPIO_OSPEEDER_OSPEEDR14_1  GPIO_OSPEEDR_OSPEEDR14_1
N#define GPIO_OSPEEDER_OSPEEDR15    GPIO_OSPEEDR_OSPEEDR15
N#define GPIO_OSPEEDER_OSPEEDR15_0  GPIO_OSPEEDR_OSPEEDR15_0
N#define GPIO_OSPEEDER_OSPEEDR15_1  GPIO_OSPEEDR_OSPEEDR15_1
N
N/*******************  Bit definition for GPIO_PUPDR register ******************/
N#define GPIO_PUPDR_PUPDR0          ((uint32_t)0x00000003)
N#define GPIO_PUPDR_PUPDR0_0        ((uint32_t)0x00000001)
N#define GPIO_PUPDR_PUPDR0_1        ((uint32_t)0x00000002)
N#define GPIO_PUPDR_PUPDR1          ((uint32_t)0x0000000C)
N#define GPIO_PUPDR_PUPDR1_0        ((uint32_t)0x00000004)
N#define GPIO_PUPDR_PUPDR1_1        ((uint32_t)0x00000008)
N#define GPIO_PUPDR_PUPDR2          ((uint32_t)0x00000030)
N#define GPIO_PUPDR_PUPDR2_0        ((uint32_t)0x00000010)
N#define GPIO_PUPDR_PUPDR2_1        ((uint32_t)0x00000020)
N#define GPIO_PUPDR_PUPDR3          ((uint32_t)0x000000C0)
N#define GPIO_PUPDR_PUPDR3_0        ((uint32_t)0x00000040)
N#define GPIO_PUPDR_PUPDR3_1        ((uint32_t)0x00000080)
N#define GPIO_PUPDR_PUPDR4          ((uint32_t)0x00000300)
N#define GPIO_PUPDR_PUPDR4_0        ((uint32_t)0x00000100)
N#define GPIO_PUPDR_PUPDR4_1        ((uint32_t)0x00000200)
N#define GPIO_PUPDR_PUPDR5          ((uint32_t)0x00000C00)
N#define GPIO_PUPDR_PUPDR5_0        ((uint32_t)0x00000400)
N#define GPIO_PUPDR_PUPDR5_1        ((uint32_t)0x00000800)
N#define GPIO_PUPDR_PUPDR6          ((uint32_t)0x00003000)
N#define GPIO_PUPDR_PUPDR6_0        ((uint32_t)0x00001000)
N#define GPIO_PUPDR_PUPDR6_1        ((uint32_t)0x00002000)
N#define GPIO_PUPDR_PUPDR7          ((uint32_t)0x0000C000)
N#define GPIO_PUPDR_PUPDR7_0        ((uint32_t)0x00004000)
N#define GPIO_PUPDR_PUPDR7_1        ((uint32_t)0x00008000)
N#define GPIO_PUPDR_PUPDR8          ((uint32_t)0x00030000)
N#define GPIO_PUPDR_PUPDR8_0        ((uint32_t)0x00010000)
N#define GPIO_PUPDR_PUPDR8_1        ((uint32_t)0x00020000)
N#define GPIO_PUPDR_PUPDR9          ((uint32_t)0x000C0000)
N#define GPIO_PUPDR_PUPDR9_0        ((uint32_t)0x00040000)
N#define GPIO_PUPDR_PUPDR9_1        ((uint32_t)0x00080000)
N#define GPIO_PUPDR_PUPDR10         ((uint32_t)0x00300000)
N#define GPIO_PUPDR_PUPDR10_0       ((uint32_t)0x00100000)
N#define GPIO_PUPDR_PUPDR10_1       ((uint32_t)0x00200000)
N#define GPIO_PUPDR_PUPDR11         ((uint32_t)0x00C00000)
N#define GPIO_PUPDR_PUPDR11_0       ((uint32_t)0x00400000)
N#define GPIO_PUPDR_PUPDR11_1       ((uint32_t)0x00800000)
N#define GPIO_PUPDR_PUPDR12         ((uint32_t)0x03000000)
N#define GPIO_PUPDR_PUPDR12_0       ((uint32_t)0x01000000)
N#define GPIO_PUPDR_PUPDR12_1       ((uint32_t)0x02000000)
N#define GPIO_PUPDR_PUPDR13         ((uint32_t)0x0C000000)
N#define GPIO_PUPDR_PUPDR13_0       ((uint32_t)0x04000000)
N#define GPIO_PUPDR_PUPDR13_1       ((uint32_t)0x08000000)
N#define GPIO_PUPDR_PUPDR14         ((uint32_t)0x30000000)
N#define GPIO_PUPDR_PUPDR14_0       ((uint32_t)0x10000000)
N#define GPIO_PUPDR_PUPDR14_1       ((uint32_t)0x20000000)
N#define GPIO_PUPDR_PUPDR15         ((uint32_t)0xC0000000)
N#define GPIO_PUPDR_PUPDR15_0       ((uint32_t)0x40000000)
N#define GPIO_PUPDR_PUPDR15_1       ((uint32_t)0x80000000)
N
N/*******************  Bit definition for GPIO_IDR register  *******************/
N#define GPIO_IDR_0                 ((uint32_t)0x00000001)
N#define GPIO_IDR_1                 ((uint32_t)0x00000002)
N#define GPIO_IDR_2                 ((uint32_t)0x00000004)
N#define GPIO_IDR_3                 ((uint32_t)0x00000008)
N#define GPIO_IDR_4                 ((uint32_t)0x00000010)
N#define GPIO_IDR_5                 ((uint32_t)0x00000020)
N#define GPIO_IDR_6                 ((uint32_t)0x00000040)
N#define GPIO_IDR_7                 ((uint32_t)0x00000080)
N#define GPIO_IDR_8                 ((uint32_t)0x00000100)
N#define GPIO_IDR_9                 ((uint32_t)0x00000200)
N#define GPIO_IDR_10                ((uint32_t)0x00000400)
N#define GPIO_IDR_11                ((uint32_t)0x00000800)
N#define GPIO_IDR_12                ((uint32_t)0x00001000)
N#define GPIO_IDR_13                ((uint32_t)0x00002000)
N#define GPIO_IDR_14                ((uint32_t)0x00004000)
N#define GPIO_IDR_15                ((uint32_t)0x00008000)
N
N/******************  Bit definition for GPIO_ODR register  ********************/
N#define GPIO_ODR_0                 ((uint32_t)0x00000001)
N#define GPIO_ODR_1                 ((uint32_t)0x00000002)
N#define GPIO_ODR_2                 ((uint32_t)0x00000004)
N#define GPIO_ODR_3                 ((uint32_t)0x00000008)
N#define GPIO_ODR_4                 ((uint32_t)0x00000010)
N#define GPIO_ODR_5                 ((uint32_t)0x00000020)
N#define GPIO_ODR_6                 ((uint32_t)0x00000040)
N#define GPIO_ODR_7                 ((uint32_t)0x00000080)
N#define GPIO_ODR_8                 ((uint32_t)0x00000100)
N#define GPIO_ODR_9                 ((uint32_t)0x00000200)
N#define GPIO_ODR_10                ((uint32_t)0x00000400)
N#define GPIO_ODR_11                ((uint32_t)0x00000800)
N#define GPIO_ODR_12                ((uint32_t)0x00001000)
N#define GPIO_ODR_13                ((uint32_t)0x00002000)
N#define GPIO_ODR_14                ((uint32_t)0x00004000)
N#define GPIO_ODR_15                ((uint32_t)0x00008000)
N
N/****************** Bit definition for GPIO_BSRR register  ********************/
N#define GPIO_BSRR_BS_0             ((uint32_t)0x00000001)
N#define GPIO_BSRR_BS_1             ((uint32_t)0x00000002)
N#define GPIO_BSRR_BS_2             ((uint32_t)0x00000004)
N#define GPIO_BSRR_BS_3             ((uint32_t)0x00000008)
N#define GPIO_BSRR_BS_4             ((uint32_t)0x00000010)
N#define GPIO_BSRR_BS_5             ((uint32_t)0x00000020)
N#define GPIO_BSRR_BS_6             ((uint32_t)0x00000040)
N#define GPIO_BSRR_BS_7             ((uint32_t)0x00000080)
N#define GPIO_BSRR_BS_8             ((uint32_t)0x00000100)
N#define GPIO_BSRR_BS_9             ((uint32_t)0x00000200)
N#define GPIO_BSRR_BS_10            ((uint32_t)0x00000400)
N#define GPIO_BSRR_BS_11            ((uint32_t)0x00000800)
N#define GPIO_BSRR_BS_12            ((uint32_t)0x00001000)
N#define GPIO_BSRR_BS_13            ((uint32_t)0x00002000)
N#define GPIO_BSRR_BS_14            ((uint32_t)0x00004000)
N#define GPIO_BSRR_BS_15            ((uint32_t)0x00008000)
N#define GPIO_BSRR_BR_0             ((uint32_t)0x00010000)
N#define GPIO_BSRR_BR_1             ((uint32_t)0x00020000)
N#define GPIO_BSRR_BR_2             ((uint32_t)0x00040000)
N#define GPIO_BSRR_BR_3             ((uint32_t)0x00080000)
N#define GPIO_BSRR_BR_4             ((uint32_t)0x00100000)
N#define GPIO_BSRR_BR_5             ((uint32_t)0x00200000)
N#define GPIO_BSRR_BR_6             ((uint32_t)0x00400000)
N#define GPIO_BSRR_BR_7             ((uint32_t)0x00800000)
N#define GPIO_BSRR_BR_8             ((uint32_t)0x01000000)
N#define GPIO_BSRR_BR_9             ((uint32_t)0x02000000)
N#define GPIO_BSRR_BR_10            ((uint32_t)0x04000000)
N#define GPIO_BSRR_BR_11            ((uint32_t)0x08000000)
N#define GPIO_BSRR_BR_12            ((uint32_t)0x10000000)
N#define GPIO_BSRR_BR_13            ((uint32_t)0x20000000)
N#define GPIO_BSRR_BR_14            ((uint32_t)0x40000000)
N#define GPIO_BSRR_BR_15            ((uint32_t)0x80000000)
N
N/****************** Bit definition for GPIO_LCKR register  ********************/
N#define GPIO_LCKR_LCK0             ((uint32_t)0x00000001)
N#define GPIO_LCKR_LCK1             ((uint32_t)0x00000002)
N#define GPIO_LCKR_LCK2             ((uint32_t)0x00000004)
N#define GPIO_LCKR_LCK3             ((uint32_t)0x00000008)
N#define GPIO_LCKR_LCK4             ((uint32_t)0x00000010)
N#define GPIO_LCKR_LCK5             ((uint32_t)0x00000020)
N#define GPIO_LCKR_LCK6             ((uint32_t)0x00000040)
N#define GPIO_LCKR_LCK7             ((uint32_t)0x00000080)
N#define GPIO_LCKR_LCK8             ((uint32_t)0x00000100)
N#define GPIO_LCKR_LCK9             ((uint32_t)0x00000200)
N#define GPIO_LCKR_LCK10            ((uint32_t)0x00000400)
N#define GPIO_LCKR_LCK11            ((uint32_t)0x00000800)
N#define GPIO_LCKR_LCK12            ((uint32_t)0x00001000)
N#define GPIO_LCKR_LCK13            ((uint32_t)0x00002000)
N#define GPIO_LCKR_LCK14            ((uint32_t)0x00004000)
N#define GPIO_LCKR_LCK15            ((uint32_t)0x00008000)
N#define GPIO_LCKR_LCKK             ((uint32_t)0x00010000)
N
N/****************** Bit definition for GPIO_AFRL register  ********************/
N#define GPIO_AFRL_AFR0            ((uint32_t)0x0000000F)
N#define GPIO_AFRL_AFR1            ((uint32_t)0x000000F0)
N#define GPIO_AFRL_AFR2            ((uint32_t)0x00000F00)
N#define GPIO_AFRL_AFR3            ((uint32_t)0x0000F000)
N#define GPIO_AFRL_AFR4            ((uint32_t)0x000F0000)
N#define GPIO_AFRL_AFR5            ((uint32_t)0x00F00000)
N#define GPIO_AFRL_AFR6            ((uint32_t)0x0F000000)
N#define GPIO_AFRL_AFR7            ((uint32_t)0xF0000000)
N
N/****************** Bit definition for GPIO_AFRH register  ********************/
N#define GPIO_AFRH_AFR8            ((uint32_t)0x0000000F)
N#define GPIO_AFRH_AFR9            ((uint32_t)0x000000F0)
N#define GPIO_AFRH_AFR10            ((uint32_t)0x00000F00)
N#define GPIO_AFRH_AFR11            ((uint32_t)0x0000F000)
N#define GPIO_AFRH_AFR12            ((uint32_t)0x000F0000)
N#define GPIO_AFRH_AFR13            ((uint32_t)0x00F00000)
N#define GPIO_AFRH_AFR14            ((uint32_t)0x0F000000)
N#define GPIO_AFRH_AFR15            ((uint32_t)0xF0000000)
N
N/* Old Bit definition for GPIO_AFRL register maintained for legacy purpose ****/
N#define GPIO_AFRL_AFRL0            GPIO_AFRL_AFR0
N#define GPIO_AFRL_AFRL1            GPIO_AFRL_AFR1
N#define GPIO_AFRL_AFRL2            GPIO_AFRL_AFR2
N#define GPIO_AFRL_AFRL3            GPIO_AFRL_AFR3
N#define GPIO_AFRL_AFRL4            GPIO_AFRL_AFR4
N#define GPIO_AFRL_AFRL5            GPIO_AFRL_AFR5
N#define GPIO_AFRL_AFRL6            GPIO_AFRL_AFR6
N#define GPIO_AFRL_AFRL7            GPIO_AFRL_AFR7
N
N/* Old Bit definition for GPIO_AFRH register maintained for legacy purpose ****/
N#define GPIO_AFRH_AFRH0            GPIO_AFRH_AFR8
N#define GPIO_AFRH_AFRH1            GPIO_AFRH_AFR9
N#define GPIO_AFRH_AFRH2            GPIO_AFRH_AFR10
N#define GPIO_AFRH_AFRH3            GPIO_AFRH_AFR11
N#define GPIO_AFRH_AFRH4            GPIO_AFRH_AFR12
N#define GPIO_AFRH_AFRH5            GPIO_AFRH_AFR13
N#define GPIO_AFRH_AFRH6            GPIO_AFRH_AFR14
N#define GPIO_AFRH_AFRH7            GPIO_AFRH_AFR15
N
N/****************** Bit definition for GPIO_BRR register  *********************/
N#define GPIO_BRR_BR_0              ((uint32_t)0x00000001)
N#define GPIO_BRR_BR_1              ((uint32_t)0x00000002)
N#define GPIO_BRR_BR_2              ((uint32_t)0x00000004)
N#define GPIO_BRR_BR_3              ((uint32_t)0x00000008)
N#define GPIO_BRR_BR_4              ((uint32_t)0x00000010)
N#define GPIO_BRR_BR_5              ((uint32_t)0x00000020)
N#define GPIO_BRR_BR_6              ((uint32_t)0x00000040)
N#define GPIO_BRR_BR_7              ((uint32_t)0x00000080)
N#define GPIO_BRR_BR_8              ((uint32_t)0x00000100)
N#define GPIO_BRR_BR_9              ((uint32_t)0x00000200)
N#define GPIO_BRR_BR_10             ((uint32_t)0x00000400)
N#define GPIO_BRR_BR_11             ((uint32_t)0x00000800)
N#define GPIO_BRR_BR_12             ((uint32_t)0x00001000)
N#define GPIO_BRR_BR_13             ((uint32_t)0x00002000)
N#define GPIO_BRR_BR_14             ((uint32_t)0x00004000)
N#define GPIO_BRR_BR_15             ((uint32_t)0x00008000)
N
N#define GPIO_BRR_BR0               GPIO_BRR_BR_0 
N#define GPIO_BRR_BR1               GPIO_BRR_BR_1 
N#define GPIO_BRR_BR2               GPIO_BRR_BR_2 
N#define GPIO_BRR_BR3               GPIO_BRR_BR_3 
N#define GPIO_BRR_BR4               GPIO_BRR_BR_4 
N#define GPIO_BRR_BR5               GPIO_BRR_BR_5 
N#define GPIO_BRR_BR6               GPIO_BRR_BR_6 
N#define GPIO_BRR_BR7               GPIO_BRR_BR_7 
N#define GPIO_BRR_BR8               GPIO_BRR_BR_8 
N#define GPIO_BRR_BR9               GPIO_BRR_BR_9 
N#define GPIO_BRR_BR10              GPIO_BRR_BR_10
N#define GPIO_BRR_BR11              GPIO_BRR_BR_11
N#define GPIO_BRR_BR12              GPIO_BRR_BR_12
N#define GPIO_BRR_BR13              GPIO_BRR_BR_13
N#define GPIO_BRR_BR14              GPIO_BRR_BR_14
N#define GPIO_BRR_BR15              GPIO_BRR_BR_15     
N
N/*******************  Bit definition for GPIO_LEDM register  *******************/
N#define	GPIOA_LEDM_LEDM8					((uint32_t)0x00000100)
N#define	GPIOA_LEDM_LEDM9					((uint32_t)0x00000200)
N#define	GPIOA_LEDM_LEDM10					((uint32_t)0x00000400)
N#define	GPIOA_LEDM_LEDM13					((uint32_t)0x00002000)
N#define	GPIOA_LEDM_LEDM14					((uint32_t)0x00004000)
N#define	GPIOA_LEDM_LEDM15					((uint32_t)0x00008000)
N
N
N#define	GPIOB_LEDM_LEDM0					((uint32_t)0x00000001)
N#define	GPIOB_LEDM_LEDM1					((uint32_t)0x00000002)
N#define	GPIOB_LEDM_LEDM3					((uint32_t)0x00000008)
N#define	GPIOB_LEDM_LEDM4					((uint32_t)0x00000010)
N#define	GPIOB_LEDM_LEDM5					((uint32_t)0x00000020)
N#define	GPIOB_LEDM_LEDM6					((uint32_t)0x00000040)
N#define	GPIOB_LEDM_LEDM7					((uint32_t)0x00000080)
N/******************************************************************************/
N/*                                                                            */
N/*                   Inter-integrated Circuit Interface (I2C)                 */
N/*                                                                            */
N/******************************************************************************/
N
N/*******************  Bit definition for I2C_CR1 register  *******************/
N#define  I2C_CR1_PE                          ((uint32_t)0x00000001)        /*!< Peripheral enable */
N#define  I2C_CR1_TXIE                        ((uint32_t)0x00000002)        /*!< TX interrupt enable */
N#define  I2C_CR1_RXIE                        ((uint32_t)0x00000004)        /*!< RX interrupt enable */
N#define  I2C_CR1_ADDRIE                      ((uint32_t)0x00000008)        /*!< Address match interrupt enable */
N#define  I2C_CR1_NACKIE                      ((uint32_t)0x00000010)        /*!< NACK received interrupt enable */
N#define  I2C_CR1_STOPIE                      ((uint32_t)0x00000020)        /*!< STOP detection interrupt enable */
N#define  I2C_CR1_TCIE                        ((uint32_t)0x00000040)        /*!< Transfer complete interrupt enable */
N#define  I2C_CR1_ERRIE                       ((uint32_t)0x00000080)        /*!< Errors interrupt enable */
N#define  I2C_CR1_DFN                         ((uint32_t)0x00000F00)        /*!< Digital noise filter */
N#define  I2C_CR1_ANFOFF                      ((uint32_t)0x00001000)        /*!< Analog noise filter OFF */
N//#define  I2C_CR1_SWRST                       ((uint32_t)0x00002000)        /*!< Software reset */
N#define  I2C_CR1_TXDMAEN                     ((uint32_t)0x00004000)        /*!< DMA transmission requests enable */
N#define  I2C_CR1_RXDMAEN                     ((uint32_t)0x00008000)        /*!< DMA reception requests enable */
N#define  I2C_CR1_SBC                         ((uint32_t)0x00010000)        /*!< Slave byte control */
N#define  I2C_CR1_NOSTRETCH                   ((uint32_t)0x00020000)        /*!< Clock stretching disable */
N#define  I2C_CR1_GCEN                        ((uint32_t)0x00080000)        /*!< General call enable */
N#define  I2C_CR1_SMBHEN                      ((uint32_t)0x00100000)        /*!< SMBus host address enable */
N#define  I2C_CR1_SMBDEN                      ((uint32_t)0x00200000)        /*!< SMBus device default address enable */
N#define  I2C_CR1_ALERTEN                     ((uint32_t)0x00400000)        /*!< SMBus alert enable */
N#define  I2C_CR1_PECEN                       ((uint32_t)0x00800000)        /*!< PEC enable */
N
N/******************  Bit definition for I2C_CR2 register  ********************/
N#define  I2C_CR2_SADD                        ((uint32_t)0x000003FF)        /*!< Slave address (master mode) */
N#define  I2C_CR2_RD_WRN                      ((uint32_t)0x00000400)        /*!< Transfer direction (master mode) */
N#define  I2C_CR2_ADD10                       ((uint32_t)0x00000800)        /*!< 10-bit addressing mode (master mode) */
N#define  I2C_CR2_HEAD10R                     ((uint32_t)0x00001000)        /*!< 10-bit address header only read direction (master mode) */
N#define  I2C_CR2_START                       ((uint32_t)0x00002000)        /*!< START generation */
N#define  I2C_CR2_STOP                        ((uint32_t)0x00004000)        /*!< STOP generation (master mode) */
N#define  I2C_CR2_NACK                        ((uint32_t)0x00008000)        /*!< NACK generation (slave mode) */
N#define  I2C_CR2_NBYTES                      ((uint32_t)0x00FF0000)        /*!< Number of bytes */
N#define  I2C_CR2_RELOAD                      ((uint32_t)0x01000000)        /*!< NBYTES reload mode */
N#define  I2C_CR2_AUTOEND                     ((uint32_t)0x02000000)        /*!< Automatic end mode (master mode) */
N#define  I2C_CR2_PECBYTE                     ((uint32_t)0x04000000)        /*!< Packet error checking byte */
N
N/*******************  Bit definition for I2C_OAR1 register  ******************/
N#define  I2C_OAR1_OA1                        ((uint32_t)0x000003FF)        /*!< Interface own address 1 */
N#define  I2C_OAR1_OA1MODE                    ((uint32_t)0x00000400)        /*!< Own address 1 10-bit mode */
N#define  I2C_OAR1_OA1EN                      ((uint32_t)0x00008000)        /*!< Own address 1 enable */
N
N/*******************  Bit definition for I2C_OAR2 register  ******************/
N#define  I2C_OAR2_OA2                        ((uint32_t)0x000000FE)        /*!< Interface own address 2 */
N#define  I2C_OAR2_OA2MSK                     ((uint32_t)0x00000700)        /*!< Own address 2 masks */
N#define  I2C_OAR2_OA2EN                      ((uint32_t)0x00008000)        /*!< Own address 2 enable */
N
N/*******************  Bit definition for I2C_TIMINGR register *******************/
N#define  I2C_TIMINGR_SCLL                    ((uint32_t)0x000000FF)        /*!< SCL low period (master mode) */
N#define  I2C_TIMINGR_SCLH                    ((uint32_t)0x0000FF00)        /*!< SCL high period (master mode) */
N#define  I2C_TIMINGR_SDADEL                  ((uint32_t)0x000F0000)        /*!< Data hold time */
N#define  I2C_TIMINGR_SCLDEL                  ((uint32_t)0x00F00000)        /*!< Data setup time */
N#define  I2C_TIMINGR_PRESC                   ((uint32_t)0xF0000000)        /*!< Timings prescaler */
N
N/******************* Bit definition for I2C_TIMEOUTR register *******************/
N#define  I2C_TIMEOUTR_TIMEOUTA               ((uint32_t)0x00000FFF)        /*!< Bus timeout A */
N#define  I2C_TIMEOUTR_TIDLE                  ((uint32_t)0x00001000)        /*!< Idle clock timeout detection */
N#define  I2C_TIMEOUTR_TIMOUTEN               ((uint32_t)0x00008000)        /*!< Clock timeout enable */
N#define  I2C_TIMEOUTR_TIMEOUTB               ((uint32_t)0x0FFF0000)        /*!< Bus timeout B*/
N#define  I2C_TIMEOUTR_TEXTEN                 ((uint32_t)0x80000000)        /*!< Extended clock timeout enable */
N
N/******************  Bit definition for I2C_ISR register  *********************/
N#define  I2C_ISR_TXE                         ((uint32_t)0x00000001)        /*!< Transmit data register empty */
N#define  I2C_ISR_TXIS                        ((uint32_t)0x00000002)        /*!< Transmit interrupt status */
N#define  I2C_ISR_RXNE                        ((uint32_t)0x00000004)        /*!< Receive data register not empty */
N#define  I2C_ISR_ADDR                        ((uint32_t)0x00000008)        /*!< Address matched (slave mode)*/
N#define  I2C_ISR_NACKF                       ((uint32_t)0x00000010)        /*!< NACK received flag */
N#define  I2C_ISR_STOPF                       ((uint32_t)0x00000020)        /*!< STOP detection flag */
N#define  I2C_ISR_TC                          ((uint32_t)0x00000040)        /*!< Transfer complete (master mode) */
N#define  I2C_ISR_TCR                         ((uint32_t)0x00000080)        /*!< Transfer complete reload */
N#define  I2C_ISR_BERR                        ((uint32_t)0x00000100)        /*!< Bus error */
N#define  I2C_ISR_ARLO                        ((uint32_t)0x00000200)        /*!< Arbitration lost */
N#define  I2C_ISR_OVR                         ((uint32_t)0x00000400)        /*!< Overrun/Underrun */
N#define  I2C_ISR_PECERR                      ((uint32_t)0x00000800)        /*!< PEC error in reception */
N#define  I2C_ISR_TIMEOUT                     ((uint32_t)0x00001000)        /*!< Timeout or Tlow detection flag */
N#define  I2C_ISR_ALERT                       ((uint32_t)0x00002000)        /*!< SMBus alert */
N#define  I2C_ISR_BUSY                        ((uint32_t)0x00008000)        /*!< Bus busy */
N#define  I2C_ISR_DIR                         ((uint32_t)0x00010000)        /*!< Transfer direction (slave mode) */
N#define  I2C_ISR_ADDCODE                     ((uint32_t)0x00FE0000)        /*!< Address match code (slave mode) */
N
N/******************  Bit definition for I2C_ICR register  *********************/
N#define  I2C_ICR_ADDRCF                      ((uint32_t)0x00000008)        /*!< Address matched clear flag */
N#define  I2C_ICR_NACKCF                      ((uint32_t)0x00000010)        /*!< NACK clear flag */
N#define  I2C_ICR_STOPCF                      ((uint32_t)0x00000020)        /*!< STOP detection clear flag */
N#define  I2C_ICR_BERRCF                      ((uint32_t)0x00000100)        /*!< Bus error clear flag */
N#define  I2C_ICR_ARLOCF                      ((uint32_t)0x00000200)        /*!< Arbitration lost clear flag */
N#define  I2C_ICR_OVRCF                       ((uint32_t)0x00000400)        /*!< Overrun/Underrun clear flag */
N#define  I2C_ICR_PECCF                       ((uint32_t)0x00000800)        /*!< PAC error clear flag */
N#define  I2C_ICR_TIMOUTCF                    ((uint32_t)0x00001000)        /*!< Timeout clear flag */
N#define  I2C_ICR_ALERTCF                     ((uint32_t)0x00002000)        /*!< Alert clear flag */
N
N/******************  Bit definition for I2C_PECR register  *********************/
N#define  I2C_PECR_PEC                        ((uint32_t)0x000000FF)       /*!< PEC register */
N
N/******************  Bit definition for I2C_RXDR register  *********************/
N#define  I2C_RXDR_RXDATA                     ((uint32_t)0x000000FF)        /*!< 8-bit receive data */
N
N/******************  Bit definition for I2C_TXDR register  *********************/
N#define  I2C_TXDR_TXDATA                     ((uint32_t)0x000000FF)        /*!< 8-bit transmit data */
N
N/******************************************************************************/
N/*                                                                            */
N/*                        Independent WATCHDOG (IWDG)                         */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for IWDG_KR register  ********************/
N#define  IWDG_KR_KEY                         ((uint16_t)0xFFFF)            /*!< Key value (write only, read 0000h) */
N
N/*******************  Bit definition for IWDG_PR register  ********************/
N#define  IWDG_PR_PR                          ((uint8_t)0x07)               /*!< PR[2:0] (Prescaler divider) */
N#define  IWDG_PR_PR_0                        ((uint8_t)0x01)               /*!< Bit 0 */
N#define  IWDG_PR_PR_1                        ((uint8_t)0x02)               /*!< Bit 1 */
N#define  IWDG_PR_PR_2                        ((uint8_t)0x04)               /*!< Bit 2 */
N
N/*******************  Bit definition for IWDG_RLR register  *******************/
N#define  IWDG_RLR_RL                         ((uint16_t)0x0FFF)            /*!< Watchdog counter reload value */
N
N/*******************  Bit definition for IWDG_SR register  ********************/
N#define  IWDG_SR_PVU                         ((uint8_t)0x01)               /*!< Watchdog prescaler value update */
N#define  IWDG_SR_RVU                         ((uint8_t)0x02)               /*!< Watchdog counter reload value update */
N#define  IWDG_SR_WVU                         ((uint8_t)0x04)               /*!< Watchdog counter window value update */
N
N/*******************  Bit definition for IWDG_KR register  ********************/
N#define  IWDG_WINR_WIN                         ((uint16_t)0x0FFF)            /*!< Watchdog counter window value */
N
N/******************************************************************************/
N/*                                                                            */
N/*                          Power Control (PWR)                               */
N/*                                                                            */
N/******************************************************************************/
N
N/********************  Bit definition for PWR_CR register  ********************/
N#define  PWR_CR_LPDS                         ((uint16_t)0x0001)     /*!< Low-power deepsleep/sleep */
N#define  PWR_CR_PDDS                         ((uint16_t)0x0002)     /*!< Power Down Deepsleep */
N#define  PWR_CR_CWUF                         ((uint16_t)0x0004)     /*!< Clear Wakeup Flag */
N#define  PWR_CR_CSBF                         ((uint16_t)0x0008)     /*!< Clear Standby Flag */
N#define  PWR_CR_PVDE                         ((uint16_t)0x0010)     /*!< Power Voltage Detector Enable */
N
N#define  PWR_CR_PLS                          ((uint16_t)0x02E0)     /*!< PLS[3] PLS[2:0] bits (PVD Level Selection) */
N#define  PWR_CR_PLS_0                        ((uint16_t)0x0020)     /*!< Bit 0 */
N#define  PWR_CR_PLS_1                        ((uint16_t)0x0040)     /*!< Bit 1 */
N#define  PWR_CR_PLS_2                        ((uint16_t)0x0080)     /*!< Bit 2 */
N#define  PWR_CR_PLS_3                        ((uint16_t)0x0200)     /*!< Bit 3 */
N#define  PWR_CR_DBP                          ((uint16_t)0x0100)     /*!<       */
N
N/* PVD level configuration */
N#define  PWR_CR_PLS_LEV0                     ((uint16_t)0x0000)     /*!< PVD level 0 */
N#define  PWR_CR_PLS_LEV1                     ((uint16_t)0x0020)     /*!< PVD level 1 */
N#define  PWR_CR_PLS_LEV2                     ((uint16_t)0x0040)     /*!< PVD level 2 */
N#define  PWR_CR_PLS_LEV3                     ((uint16_t)0x0060)     /*!< PVD level 3 */
N#define  PWR_CR_PLS_LEV4                     ((uint16_t)0x0080)     /*!< PVD level 4 */
N#define  PWR_CR_PLS_LEV5                     ((uint16_t)0x00A0)     /*!< PVD level 5 */
N#define  PWR_CR_PLS_LEV6                     ((uint16_t)0x00C0)     /*!< PVD level 6 */
N#define  PWR_CR_PLS_LEV7                     ((uint16_t)0x00E0)     /*!< PVD level 7 */
N#define  PWR_CR_PLS_LEV8                     ((uint16_t)0x0200)     /*!< PVD level 8 */
N#define  PWR_CR_PLS_LEV9                     ((uint16_t)0x0220)     /*!< PVD level 9 */
N#define  PWR_CR_PLS_LEV10                    ((uint16_t)0x0240)     /*!< PVD level 10 */
N#define  PWR_CR_PLS_LEV11                    ((uint16_t)0x0260)     /*!< PVD level 11 */
N#define  PWR_CR_PLS_LEV12                    ((uint16_t)0x0280)     /*!< PVD level 12 */
N#define  PWR_CR_PLS_LEV13                    ((uint16_t)0x02A0)     /*!< PVD level 13 */
N#define  PWR_CR_PLS_LEV14                    ((uint16_t)0x02C0)     /*!< PVD level 14 */
N#define  PWR_CR_PLS_LEV15                    ((uint16_t)0x02E0)     /*!< PVD level 15 */
N
N
N#define  PWR_CR_DBP                          ((uint16_t)0x0100)     /*!< Disable Backup Domain write protection */
N
N/* Old Bit definition maintained for legacy purpose ****/
N#define  PWR_CR_LPSDSR                       PWR_CR_LPDS     /*!< Low-power deepsleep */
N
N/*******************  Bit definition for PWR_CSR register  ********************/
N#define  PWR_CSR_WUF                         ((uint16_t)0x0001)     /*!< Wakeup Flag */
N#define  PWR_CSR_SBF                         ((uint16_t)0x0002)     /*!< Standby Flag */
N#define  PWR_CSR_PVDO                        ((uint16_t)0x0004)     /*!< PVD Output */
N//#define  PWR_CSR_VREFINTRDY                  ((uint16_t)0x0008)     /*!< Internal voltage reference (VREFINT) ready */
N
N#define  PWR_CSR_EWUP1                       ((uint16_t)0x0100)     /*!< Enable WKUP pin 1 */
N#define  PWR_CSR_EWUP2                       ((uint16_t)0x0200)     /*!< Enable WKUP pin 2 */
N//#define  PWR_CSR_EWUP3                       ((uint16_t)0x0400)     /*!< Enable WKUP pin 3 */
N//#define  PWR_CSR_EWUP4                       ((uint16_t)0x0800)     /*!< Enable WKUP pin 4 */
N//#define  PWR_CSR_EWUP5                       ((uint16_t)0x1000)     /*!< Enable WKUP pin 5 */
N//#define  PWR_CSR_EWUP6                       ((uint16_t)0x2000)     /*!< Enable WKUP pin 6 */
N//#define  PWR_CSR_EWUP7                       ((uint16_t)0x4000)     /*!< Enable WKUP pin 7 */
N//#define  PWR_CSR_EWUP8                       ((uint16_t)0x8000)     /*!< Enable WKUP pin 8 */
N
N/* Old Bit definition maintained for legacy purpose ****/
N//#define  PWR_CSR_VREFINTRDYF                 PWR_CSR_VREFINTRDY     /*!< Internal voltage reference (VREFINT) ready flag */
N/******************************************************************************/
N/*                                                                            */
N/*                         Reset and Clock Control                            */
N/*                                                                            */
N/******************************************************************************/
N
N/********************  Bit definition for RCC_CR register  ********************/
N#define  RCC_CR_HSION                        ((uint32_t)0x00000001)        /*!< Internal High Speed clock enable */
N#define  RCC_CR_HSIRDY                       ((uint32_t)0x00000002)        /*!< Internal High Speed clock ready flag */
N#define  RCC_CR_HSITRIM                      ((uint32_t)0x000000F8)        /*!< Internal High Speed clock trimming */
N#define  RCC_CR_HSICAL                       ((uint32_t)0x0000FF00)        /*!< Internal High Speed clock Calibration */
N#define  RCC_CR_HSEON                        ((uint32_t)0x00010000)        /*!< External High Speed clock enable */
N#define  RCC_CR_HSERDY                       ((uint32_t)0x00020000)        /*!< External High Speed clock ready flag */
N#define  RCC_CR_HSEBYP                       ((uint32_t)0x00040000)        /*!< External High Speed clock Bypass */
N#define  RCC_CR_CSSON                        ((uint32_t)0x00080000)        /*!< Clock Security System enable */
N#define  RCC_CR_PLLON                        ((uint32_t)0x01000000)        /*!< PLL enable */
N#define  RCC_CR_PLLRDY                       ((uint32_t)0x02000000)        /*!< PLL clock ready flag */
N
N/*******************  Bit definition for RCC_CFGR register  *******************/
N#define  RCC_CFGR_SW                         ((uint32_t)0x00000003)        /*!< SW[1:0] bits (System clock Switch) */
N#define  RCC_CFGR_SW_0                       ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  RCC_CFGR_SW_1                       ((uint32_t)0x00000002)        /*!< Bit 1 */
N/* SW configuration */
N#define  RCC_CFGR_SW_HSI                     ((uint32_t)0x00000000)        /*!< HSI selected as system clock */
N#define  RCC_CFGR_SW_HSE                     ((uint32_t)0x00000001)        /*!< HSE selected as system clock */
N#define  RCC_CFGR_SW_PLL                     ((uint32_t)0x00000002)        /*!< PLL selected as system clock */
N#define  RCC_CFGR_SW_HSI48                   ((uint32_t)0x00000003)        /*!< HSI48 selected as system clock */
N
N#define  RCC_CFGR_SWS                        ((uint32_t)0x0000000C)        /*!< SWS[1:0] bits (System Clock Switch Status) */
N#define  RCC_CFGR_SWS_0                      ((uint32_t)0x00000004)        /*!< Bit 0 */
N#define  RCC_CFGR_SWS_1                      ((uint32_t)0x00000008)        /*!< Bit 1 */
N/* SWS configuration */
N#define  RCC_CFGR_SWS_HSI                    ((uint32_t)0x00000000)        /*!< HSI oscillator used as system clock */
N#define  RCC_CFGR_SWS_HSE                    ((uint32_t)0x00000004)        /*!< HSE oscillator used as system clock */
N#define  RCC_CFGR_SWS_PLL                    ((uint32_t)0x00000008)        /*!< PLL used as system clock */
N#define  RCC_CFGR_SWS_HSI48                  ((uint32_t)0x0000000C)        /*!< HSI48 used as system clock */
N
N#define  RCC_CFGR_HPRE                       ((uint32_t)0x000000F0)        /*!< HPRE[3:0] bits (AHB prescaler) */
N#define  RCC_CFGR_HPRE_0                     ((uint32_t)0x00000010)        /*!< Bit 0 */
N#define  RCC_CFGR_HPRE_1                     ((uint32_t)0x00000020)        /*!< Bit 1 */
N#define  RCC_CFGR_HPRE_2                     ((uint32_t)0x00000040)        /*!< Bit 2 */
N#define  RCC_CFGR_HPRE_3                     ((uint32_t)0x00000080)        /*!< Bit 3 */
N/* HPRE configuration */
N#define  RCC_CFGR_HPRE_DIV1                  ((uint32_t)0x00000000)        /*!< SYSCLK not divided */
N#define  RCC_CFGR_HPRE_DIV2                  ((uint32_t)0x00000080)        /*!< SYSCLK divided by 2 */
N#define  RCC_CFGR_HPRE_DIV4                  ((uint32_t)0x00000090)        /*!< SYSCLK divided by 4 */
N#define  RCC_CFGR_HPRE_DIV8                  ((uint32_t)0x000000A0)        /*!< SYSCLK divided by 8 */
N#define  RCC_CFGR_HPRE_DIV16                 ((uint32_t)0x000000B0)        /*!< SYSCLK divided by 16 */
N#define  RCC_CFGR_HPRE_DIV64                 ((uint32_t)0x000000C0)        /*!< SYSCLK divided by 64 */
N#define  RCC_CFGR_HPRE_DIV128                ((uint32_t)0x000000D0)        /*!< SYSCLK divided by 128 */
N#define  RCC_CFGR_HPRE_DIV256                ((uint32_t)0x000000E0)        /*!< SYSCLK divided by 256 */
N#define  RCC_CFGR_HPRE_DIV512                ((uint32_t)0x000000F0)        /*!< SYSCLK divided by 512 */
N
N#define  RCC_CFGR_PPRE                       ((uint32_t)0x00000700)        /*!< PRE[2:0] bits (APB prescaler) */
N#define  RCC_CFGR_PPRE_0                     ((uint32_t)0x00000100)        /*!< Bit 0 */
N#define  RCC_CFGR_PPRE_1                     ((uint32_t)0x00000200)        /*!< Bit 1 */
N#define  RCC_CFGR_PPRE_2                     ((uint32_t)0x00000400)        /*!< Bit 2 */
N/* PPRE configuration */
N#define  RCC_CFGR_PPRE_DIV1                  ((uint32_t)0x00000000)        /*!< HCLK not divided */
N#define  RCC_CFGR_PPRE_DIV2                  ((uint32_t)0x00000400)        /*!< HCLK divided by 2 */
N#define  RCC_CFGR_PPRE_DIV4                  ((uint32_t)0x00000500)        /*!< HCLK divided by 4 */
N#define  RCC_CFGR_PPRE_DIV8                  ((uint32_t)0x00000600)        /*!< HCLK divided by 8 */
N#define  RCC_CFGR_PPRE_DIV16                 ((uint32_t)0x00000700)        /*!< HCLK divided by 16 */
N
N#define  RCC_CFGR_ADCPRE                     ((uint32_t)0x00004000)        /*!< ADC prescaler: Obsolete. Proper ADC clock selection is 
N                                                                                done inside the ADC_CFGR2 */
N
N#define  RCC_CFGR_PLLSRC                     ((uint32_t)0x00018000)        /*!< PLL entry clock source */
N#define  RCC_CFGR_PLLSRC_0                   ((uint32_t)0x00008000)        /*!< Bit 0 (available only in the FT32F072X8 devices) */
N#define  RCC_CFGR_PLLSRC_1                   ((uint32_t)0x00010000)        /*!< Bit 1 */
N
N#define  RCC_CFGR_PLLSRC_PREDIV1             ((uint32_t)0x00010000)        /*!< PREDIV1 clock selected as PLL entry clock source; 
N                                                                                Old PREDIV1 bit definition, maintained for legacy purpose */
N#define  RCC_CFGR_PLLSRC_HSI_DIV2            ((uint32_t)0x00000000)        /*!< HSI clock divided by 2 selected as PLL entry clock source */
N#define  RCC_CFGR_PLLSRC_HSI_PREDIV          ((uint32_t)0x00008000)        /*!< HSI PREDIV clock selected as PLL entry clock source 
N                                                                                (This bit and configuration is only available for FT32F072X8 devices)*/
N#define  RCC_CFGR_PLLSRC_HSE_PREDIV          ((uint32_t)0x00010000)        /*!< HSE PREDIV clock selected as PLL entry clock source */
N#define  RCC_CFGR_PLLSRC_HSI48_PREDIV        ((uint32_t)0x00018000)        /*!< HSI48 PREDIV clock selected as PLL entry clock source */
N
N#define  RCC_CFGR_PLLXTPRE                   ((uint32_t)0x00020000)        /*!< HSE divider for PLL entry */
N#define  RCC_CFGR_PLLXTPRE_PREDIV1           ((uint32_t)0x00000000)        /*!< PREDIV1 clock not divided for PLL entry */
N#define  RCC_CFGR_PLLXTPRE_PREDIV1_Div2      ((uint32_t)0x00020000)        /*!< PREDIV1 clock divided by 2 for PLL entry */
N
N/*!< Old bit definition maintained for legacy purposes */
N#define  RCC_CFGR_PLLSRC_HSI_Div2            RCC_CFGR_PLLSRC_HSI_DIV2
N
N/* PLLMUL configuration */
N#define  RCC_CFGR_PLLMUL                    ((uint32_t)0x003C0000)        /*!< PLLMUL[3:0] bits (PLL multiplication factor) */
N#define  RCC_CFGR_PLLMUL_0                  ((uint32_t)0x00040000)        /*!< Bit 0 */
N#define  RCC_CFGR_PLLMUL_1                  ((uint32_t)0x00080000)        /*!< Bit 1 */
N#define  RCC_CFGR_PLLMUL_2                  ((uint32_t)0x00100000)        /*!< Bit 2 */
N#define  RCC_CFGR_PLLMUL_3                  ((uint32_t)0x00200000)        /*!< Bit 3 */
N
N#define  RCC_CFGR_PLLMUL2                   ((uint32_t)0x00000000)        /*!< PLL input clock*2 */
N#define  RCC_CFGR_PLLMUL3                   ((uint32_t)0x00040000)        /*!< PLL input clock*3 */
N#define  RCC_CFGR_PLLMUL4                   ((uint32_t)0x00080000)        /*!< PLL input clock*4 */
N#define  RCC_CFGR_PLLMUL5                   ((uint32_t)0x000C0000)        /*!< PLL input clock*5 */
N#define  RCC_CFGR_PLLMUL6                   ((uint32_t)0x00100000)        /*!< PLL input clock*6 */
N#define  RCC_CFGR_PLLMUL7                   ((uint32_t)0x00140000)        /*!< PLL input clock*7 */
N#define  RCC_CFGR_PLLMUL8                   ((uint32_t)0x00180000)        /*!< PLL input clock*8 */
N#define  RCC_CFGR_PLLMUL9                   ((uint32_t)0x001C0000)        /*!< PLL input clock*9 */
N#define  RCC_CFGR_PLLMUL10                  ((uint32_t)0x00200000)        /*!< PLL input clock10 */
N#define  RCC_CFGR_PLLMUL11                  ((uint32_t)0x00240000)        /*!< PLL input clock*11 */
N#define  RCC_CFGR_PLLMUL12                  ((uint32_t)0x00280000)        /*!< PLL input clock*12 */
N#define  RCC_CFGR_PLLMUL13                  ((uint32_t)0x002C0000)        /*!< PLL input clock*13 */
N#define  RCC_CFGR_PLLMUL14                  ((uint32_t)0x00300000)        /*!< PLL input clock*14 */
N#define  RCC_CFGR_PLLMUL15                  ((uint32_t)0x00340000)        /*!< PLL input clock*15 */
N#define  RCC_CFGR_PLLMUL16                  ((uint32_t)0x00380000)        /*!< PLL input clock*16 */
N
N/* Old PLLMUL configuration bit definition maintained for legacy purposes */
N#define  RCC_CFGR_PLLMULL                    RCC_CFGR_PLLMUL        /*!< PLLMUL[3:0] bits (PLL multiplication factor) */
N#define  RCC_CFGR_PLLMULL_0                  RCC_CFGR_PLLMUL_0        /*!< Bit 0 */
N#define  RCC_CFGR_PLLMULL_1                  RCC_CFGR_PLLMUL_1        /*!< Bit 1 */
N#define  RCC_CFGR_PLLMULL_2                  RCC_CFGR_PLLMUL_2        /*!< Bit 2 */
N#define  RCC_CFGR_PLLMULL_3                  RCC_CFGR_PLLMUL_3       /*!< Bit 3 */
N
N#define  RCC_CFGR_PLLMULL2                   RCC_CFGR_PLLMUL2       /*!< PLL input clock*2 */
N#define  RCC_CFGR_PLLMULL3                   RCC_CFGR_PLLMUL3        /*!< PLL input clock*3 */
N#define  RCC_CFGR_PLLMULL4                   RCC_CFGR_PLLMUL4        /*!< PLL input clock*4 */
N#define  RCC_CFGR_PLLMULL5                   RCC_CFGR_PLLMUL5        /*!< PLL input clock*5 */
N#define  RCC_CFGR_PLLMULL6                   RCC_CFGR_PLLMUL6        /*!< PLL input clock*6 */
N#define  RCC_CFGR_PLLMULL7                   RCC_CFGR_PLLMUL7        /*!< PLL input clock*7 */
N#define  RCC_CFGR_PLLMULL8                   RCC_CFGR_PLLMUL8        /*!< PLL input clock*8 */
N#define  RCC_CFGR_PLLMULL9                   RCC_CFGR_PLLMUL9        /*!< PLL input clock*9 */
N#define  RCC_CFGR_PLLMULL10                  RCC_CFGR_PLLMUL10        /*!< PLL input clock10 */
N#define  RCC_CFGR_PLLMULL11                  RCC_CFGR_PLLMUL11        /*!< PLL input clock*11 */
N#define  RCC_CFGR_PLLMULL12                  RCC_CFGR_PLLMUL12        /*!< PLL input clock*12 */
N#define  RCC_CFGR_PLLMULL13                  RCC_CFGR_PLLMUL13        /*!< PLL input clock*13 */
N#define  RCC_CFGR_PLLMULL14                  RCC_CFGR_PLLMUL14        /*!< PLL input clock*14 */
N#define  RCC_CFGR_PLLMULL15                  RCC_CFGR_PLLMUL15        /*!< PLL input clock*15 */
N#define  RCC_CFGR_PLLMULL16                  RCC_CFGR_PLLMUL16        /*!< PLL input clock*16 */
N
N#define  RCC_CFGR_MCO                        ((uint32_t)0x0F000000)        /*!< MCO[2:0] bits (Microcontroller Clock Output) */
N#define  RCC_CFGR_MCO_0                      ((uint32_t)0x01000000)        /*!< Bit 0 */
N#define  RCC_CFGR_MCO_1                      ((uint32_t)0x02000000)        /*!< Bit 1 */
N#define  RCC_CFGR_MCO_2                      ((uint32_t)0x04000000)        /*!< Bit 2 */
N#define  RCC_CFGR_MCO_3                      ((uint32_t)0x08000000)        /*!< Bit 3 */
N/* MCO configuration */
N#define  RCC_CFGR_MCO_NOCLOCK                ((uint32_t)0x00000000)        /*!< No clock */
N#define  RCC_CFGR_MCO_HSI14                  ((uint32_t)0x01000000)        /*!< HSI14 clock selected as MCO source */
N#define  RCC_CFGR_MCO_LSI                    ((uint32_t)0x02000000)        /*!< LSI clock selected as MCO source */
N#define  RCC_CFGR_MCO_LSE                    ((uint32_t)0x03000000)        /*!< LSE clock selected as MCO source */
N#define  RCC_CFGR_MCO_SYSCLK                 ((uint32_t)0x04000000)        /*!< System clock selected as MCO source */
N#define  RCC_CFGR_MCO_HSI                    ((uint32_t)0x05000000)        /*!< HSI clock selected as MCO source */
N#define  RCC_CFGR_MCO_HSE                    ((uint32_t)0x06000000)        /*!< HSE clock selected as MCO source  */
N#define  RCC_CFGR_MCO_PLL                    ((uint32_t)0x07000000)        /*!< PLL clock selected as MCO source */
N#define  RCC_CFGR_MCO_HSI48                  ((uint32_t)0x08000000)        /*!< HSI48 clock selected as MCO source */
N
N#define  RCC_CFGR_MCO_PRE                    ((uint32_t)0x70000000)        /*!< MCO prescaler*/
N#define  RCC_CFGR_MCO_PRE_1                  ((uint32_t)0x00000000)        /*!< MCO is divided by 1*/
N#define  RCC_CFGR_MCO_PRE_2                  ((uint32_t)0x10000000)        /*!< MCO is divided by 2*/
N#define  RCC_CFGR_MCO_PRE_4                  ((uint32_t)0x20000000)        /*!< MCO is divided by 4*/
N#define  RCC_CFGR_MCO_PRE_8                  ((uint32_t)0x30000000)        /*!< MCO is divided by 8*/
N#define  RCC_CFGR_MCO_PRE_16                 ((uint32_t)0x40000000)        /*!< MCO is divided by 16*/
N#define  RCC_CFGR_MCO_PRE_32                 ((uint32_t)0x50000000)        /*!< MCO is divided by 32*/
N#define  RCC_CFGR_MCO_PRE_64                 ((uint32_t)0x60000000)        /*!< MCO is divided by 64*/
N#define  RCC_CFGR_MCO_PRE_128                ((uint32_t)0x70000000)        /*!< MCO is divided by 128*/
N
N#define  RCC_CFGR_MCOPRE                     RCC_CFGR_MCO_PRE            /*!< MCO prescaler*/
N#define  RCC_CFGR_MCOPRE_1                   RCC_CFGR_MCO_PRE_1          /*!< MCO is divided by 1*/
N#define  RCC_CFGR_MCOPRE_2                   RCC_CFGR_MCO_PRE_2          /*!< MCO is divided by 2*/
N#define  RCC_CFGR_MCOPRE_4                   RCC_CFGR_MCO_PRE_4          /*!< MCO is divided by 4*/
N#define  RCC_CFGR_MCOPRE_8                   RCC_CFGR_MCO_PRE_8          /*!< MCO is divided by 8*/
N#define  RCC_CFGR_MCOPRE_16                  RCC_CFGR_MCO_PRE_16         /*!< MCO is divided by 16*/
N#define  RCC_CFGR_MCOPRE_32                  RCC_CFGR_MCO_PRE_32         /*!< MCO is divided by 32*/
N#define  RCC_CFGR_MCOPRE_64                  RCC_CFGR_MCO_PRE_64         /*!< MCO is divided by 64*/
N#define  RCC_CFGR_MCOPRE_128                 RCC_CFGR_MCO_PRE_128        /*!< MCO is divided by 128*/
N
N#define  RCC_CFGR_PLLNODIV                   ((uint32_t)0x80000000)        /*!< PLL is not divided to MCO */
N
N/*******************  Bit definition for RCC_CIR register  ********************/
N#define  RCC_CIR_LSIRDYF                     ((uint32_t)0x00000001)        /*!< LSI Ready Interrupt flag */
N#define  RCC_CIR_LSERDYF                     ((uint32_t)0x00000002)        /*!< LSE Ready Interrupt flag */
N#define  RCC_CIR_HSIRDYF                     ((uint32_t)0x00000004)        /*!< HSI Ready Interrupt flag */
N#define  RCC_CIR_HSERDYF                     ((uint32_t)0x00000008)        /*!< HSE Ready Interrupt flag */
N#define  RCC_CIR_PLLRDYF                     ((uint32_t)0x00000010)        /*!< PLL Ready Interrupt flag */
N#define  RCC_CIR_HSI14RDYF                   ((uint32_t)0x00000020)        /*!< HSI14 Ready Interrupt flag */
N//#define  RCC_CIR_HSI48RDYF                   ((uint32_t)0x00000040)        /*!< HSI48 Ready Interrupt flag */
N#define  RCC_CIR_CSSF                        ((uint32_t)0x00000080)        /*!< Clock Security System Interrupt flag */
N#define  RCC_CIR_LSIRDYIE                    ((uint32_t)0x00000100)        /*!< LSI Ready Interrupt Enable */
N#define  RCC_CIR_LSERDYIE                    ((uint32_t)0x00000200)        /*!< LSE Ready Interrupt Enable */
N#define  RCC_CIR_HSIRDYIE                    ((uint32_t)0x00000400)        /*!< HSI Ready Interrupt Enable */
N#define  RCC_CIR_HSERDYIE                    ((uint32_t)0x00000800)        /*!< HSE Ready Interrupt Enable */
N#define  RCC_CIR_PLLRDYIE                    ((uint32_t)0x00001000)        /*!< PLL Ready Interrupt Enable */
N#define  RCC_CIR_HSI14RDYIE                  ((uint32_t)0x00002000)        /*!< HSI14 Ready Interrupt Enable */
N#define  RCC_CIR_HSI48RDYIE                  ((uint32_t)0x00004000)        /*!< HSI48 Ready Interrupt Enable */
N#define  RCC_CIR_LSIRDYC                     ((uint32_t)0x00010000)        /*!< LSI Ready Interrupt Clear */
N#define  RCC_CIR_LSERDYC                     ((uint32_t)0x00020000)        /*!< LSE Ready Interrupt Clear */
N#define  RCC_CIR_HSIRDYC                     ((uint32_t)0x00040000)        /*!< HSI Ready Interrupt Clear */
N#define  RCC_CIR_HSERDYC                     ((uint32_t)0x00080000)        /*!< HSE Ready Interrupt Clear */
N#define  RCC_CIR_PLLRDYC                     ((uint32_t)0x00100000)        /*!< PLL Ready Interrupt Clear */
N#define  RCC_CIR_HSI14RDYC                   ((uint32_t)0x00200000)        /*!< HSI14 Ready Interrupt Clear */
N#define  RCC_CIR_HSI48RDYC                   ((uint32_t)0x00400000)        /*!< HSI48 Ready Interrupt Clear */
N#define  RCC_CIR_CSSC                        ((uint32_t)0x00800000)        /*!< Clock Security System Interrupt Clear */
N
N/*****************  Bit definition for RCC_APB2RSTR register  *****************/
N#define  RCC_APB2RSTR_SYSCFGRST              ((uint32_t)0x00000001)        /*!< SYSCFG clock reset */
N//#define  RCC_APB2RSTR_USART8RST              ((uint32_t)0x00000080)        /*!< USART8 clock reset */
N//#define  RCC_APB2RSTR_USART7RST              ((uint32_t)0x00000040)        /*!< USART7 clock reset */
N//#define  RCC_APB2RSTR_USART6RST              ((uint32_t)0x00000020)        /*!< USART6 clock reset */
N#define  RCC_APB2RSTR_ADCRST                 ((uint32_t)0x00000200)        /*!< ADC clock reset */
N#define  RCC_APB2RSTR_TIM1RST                ((uint32_t)0x00000800)        /*!< TIM1 clock reset */
N#define  RCC_APB2RSTR_SPI1RST                ((uint32_t)0x00001000)        /*!< SPI1 clock reset */
N#define  RCC_APB2RSTR_USART1RST              ((uint32_t)0x00004000)        /*!< USART1 clock reset */
N#define  RCC_APB2RSTR_TIM15RST               ((uint32_t)0x00010000)        /*!< TIM15 clock reset */
N#define  RCC_APB2RSTR_TIM16RST               ((uint32_t)0x00020000)        /*!< TIM16 clock reset */
N#define  RCC_APB2RSTR_TIM17RST               ((uint32_t)0x00040000)        /*!< TIM17 clock reset */
N#define  RCC_APB2RSTR_DBGMCURST              ((uint32_t)0x00400000)        /*!< DBGMCU clock reset */
N
N/* Old ADC1 clock reset bit definition maintained for legacy purpose */
N#define  RCC_APB2RSTR_ADC1RST                RCC_APB2RSTR_ADCRST          
N
N/*****************  Bit definition for RCC_APB1RSTR register  *****************/
N//#define  RCC_APB1RSTR_TIM2RST                ((uint32_t)0x00000001)        /*!< Timer 2 clock reset */
N#define  RCC_APB1RSTR_TIM3RST                ((uint32_t)0x00000002)        /*!< Timer 3 clock reset */
N#define  RCC_APB1RSTR_TIM6RST                ((uint32_t)0x00000010)        /*!< Timer 6 clock reset */
N//#define  RCC_APB1RSTR_TIM7RST                ((uint32_t)0x00000020)        /*!< Timer 7 clock reset */
N#define  RCC_APB1RSTR_TIM14RST               ((uint32_t)0x00000100)        /*!< Timer 14 clock reset */
N#define  RCC_APB1RSTR_WWDGRST                ((uint32_t)0x00000800)        /*!< Window Watchdog clock reset */
N#define  RCC_APB1RSTR_SPI2RST                ((uint32_t)0x00004000)        /*!< SPI2 clock reset */
N#define  RCC_APB1RSTR_USART2RST              ((uint32_t)0x00020000)        /*!< USART 2 clock reset */
N//#define  RCC_APB1RSTR_USART3RST              ((uint32_t)0x00040000)        /*!< USART 3 clock reset */
N//#define  RCC_APB1RSTR_USART4RST              ((uint32_t)0x00080000)        /*!< USART 4 clock reset */
N//#define  RCC_APB1RSTR_USART5RST              ((uint32_t)0x00100000)        /*!< USART 5 clock reset */
N#define  RCC_APB1RSTR_I2C1RST                ((uint32_t)0x00200000)        /*!< I2C 1 clock reset */
N#define  RCC_APB1RSTR_I2C2RST                ((uint32_t)0x00400000)        /*!< I2C 2 clock reset */
N#define  RCC_APB1RSTR_USBRST                 ((uint32_t)0x00800000)        /*!< USB clock reset */
N//#define  RCC_APB1RSTR_CANRST                 ((uint32_t)0x02000000)        /*!< CAN clock reset */
N#define  RCC_APB1RSTR_CRSRST                 ((uint32_t)0x08000000)        /*!< CRS clock reset */
N#define  RCC_APB1RSTR_PWRRST                 ((uint32_t)0x10000000)        /*!< PWR clock reset */
N//#define  RCC_APB1RSTR_DACRST                 ((uint32_t)0x20000000)        /*!< DAC clock reset */
N//#define  RCC_APB1RSTR_CECRST                 ((uint32_t)0x40000000)        /*!< CEC clock reset */
N
N/******************  Bit definition for RCC_AHBENR register  ******************/
N#define  RCC_AHBENR_DMAEN                    ((uint32_t)0x00000001)        /*!< DMA clock enable */
N//#define  RCC_AHBENR_DMA2EN                   ((uint32_t)0x00000002)        /*!< DMA2 clock enable */
N#define  RCC_AHBENR_SRAMEN                   ((uint32_t)0x00000004)        /*!< SRAM interface clock enable */
N//#define  RCC_AHBENR_FLITFEN                  ((uint32_t)0x00000010)        /*!< FLITF clock enable */
N#define  RCC_AHBENR_CRCEN                    ((uint32_t)0x00000040)        /*!< CRC clock enable */
N#define  RCC_AHBENR_GPIOAEN                  ((uint32_t)0x00020000)        /*!< GPIOA clock enable */
N#define  RCC_AHBENR_GPIOBEN                  ((uint32_t)0x00040000)        /*!< GPIOB clock enable */
N#define  RCC_AHBENR_GPIOCEN                  ((uint32_t)0x00080000)        /*!< GPIOC clock enable */
N#define  RCC_AHBENR_GPIODEN                  ((uint32_t)0x00100000)        /*!< GPIOD clock enable */
N//#define  RCC_AHBENR_GPIOEEN                  ((uint32_t)0x00200000)        /*!< GPIOE clock enable */
N#define  RCC_AHBENR_GPIOFEN                  ((uint32_t)0x00400000)        /*!< GPIOF clock enable */
N#define  RCC_AHBENR_TSCEN                    ((uint32_t)0x01000000)        /*!< TS controller clock enable */
N
N#define  RCC_AHBENR_IOPAEN                  RCC_AHBENR_GPIOAEN          /*!< GPIOA clock enable */
N#define  RCC_AHBENR_IOPBEN                  RCC_AHBENR_GPIOBEN          /*!< GPIOB clock enable */
N#define  RCC_AHBENR_IOPCEN                  RCC_AHBENR_GPIOCEN          /*!< GPIOC clock enable */
N#define  RCC_AHBENR_IOPDEN                  RCC_AHBENR_GPIODEN          /*!< GPIOD clock enable */
N                                              
N#define  RCC_AHBENR_IOPFEN                  RCC_AHBENR_GPIOFEN          /*!< GPIOF clock enable */
N/* Old Bit definition maintained for legacy purpose */
N#define  RCC_AHBENR_DMA1EN                   RCC_AHBENR_DMAEN        /*!< DMA1 clock enable */
N#define  RCC_AHBENR_TSEN                     RCC_AHBENR_TSCEN        /*!< TS clock enable */
N
N/*****************  Bit definition for RCC_APB2ENR register  ******************/
N#define  RCC_APB2ENR_SYSCFGCOMPEN            ((uint32_t)0x00000001)        /*!< SYSCFG and comparator clock enable */
N//#define  RCC_APB2ENR_USART6EN                ((uint32_t)0x00000020)        /*!< USART6 clock enable */
N//#define  RCC_APB2ENR_USART7EN                ((uint32_t)0x00000040)        /*!< USART7 clock enable */
N//#define  RCC_APB2ENR_USART8EN                ((uint32_t)0x00000080)        /*!< USART8 clock enable */
N#define  RCC_APB2ENR_ADCEN                   ((uint32_t)0x00000200)        /*!< ADC1 clock enable */
N#define  RCC_APB2ENR_TIM1EN                  ((uint32_t)0x00000800)        /*!< TIM1 clock enable */
N#define  RCC_APB2ENR_SPI1EN                  ((uint32_t)0x00001000)        /*!< SPI1 clock enable */
N#define  RCC_APB2ENR_USART1EN                ((uint32_t)0x00004000)        /*!< USART1 clock enable */
N#define  RCC_APB2ENR_TIM15EN                 ((uint32_t)0x00010000)        /*!< TIM15 clock enable */
N#define  RCC_APB2ENR_TIM16EN                 ((uint32_t)0x00020000)        /*!< TIM16 clock enable */
N#define  RCC_APB2ENR_TIM17EN                 ((uint32_t)0x00040000)        /*!< TIM17 clock enable */
N#define  RCC_APB2ENR_DBGMCUEN                ((uint32_t)0x00400000)        /*!< DBGMCU clock enable */
N
N/* Old Bit definition maintained for legacy purpose */
N#define  RCC_APB2ENR_SYSCFGEN                RCC_APB2ENR_SYSCFGCOMPEN        /*!< SYSCFG clock enable */
N#define  RCC_APB2ENR_ADC1EN                  RCC_APB2ENR_ADCEN               /*!< ADC1 clock enable */
N
N/*****************  Bit definition for RCC_APB1ENR register  ******************/
N//#define  RCC_APB1ENR_TIM2EN                  ((uint32_t)0x00000001)        /*!< Timer 2 clock enable */
N#define  RCC_APB1ENR_TIM3EN                  ((uint32_t)0x00000002)        /*!< Timer 3 clock enable */
N#define  RCC_APB1ENR_TIM6EN                  ((uint32_t)0x00000010)        /*!< Timer 6 clock enable */
N//#define  RCC_APB1ENR_TIM7EN                  ((uint32_t)0x00000020)        /*!< Timer 7 clock enable */
N#define  RCC_APB1ENR_TIM14EN                 ((uint32_t)0x00000100)        /*!< Timer 14 clock enable */
N#define  RCC_APB1ENR_WWDGEN                  ((uint32_t)0x00000800)        /*!< Window Watchdog clock enable */
N#define  RCC_APB1ENR_SPI2EN                  ((uint32_t)0x00004000)        /*!< SPI2 clock enable */
N#define  RCC_APB1ENR_USART2EN                ((uint32_t)0x00020000)        /*!< USART2 clock enable */
N//#define  RCC_APB1ENR_USART3EN                ((uint32_t)0x00040000)        /*!< USART3 clock enable */
N//#define  RCC_APB1ENR_USART4EN                ((uint32_t)0x00080000)        /*!< USART4 clock enable */
N//#define  RCC_APB1ENR_USART5EN                ((uint32_t)0x00100000)        /*!< USART5 clock enable */
N#define  RCC_APB1ENR_I2C1EN                  ((uint32_t)0x00200000)        /*!< I2C1 clock enable */
N#define  RCC_APB1ENR_I2C2EN                  ((uint32_t)0x00400000)        /*!< I2C2 clock enable */
N#define  RCC_APB1ENR_USBEN                   ((uint32_t)0x00800000)        /*!< USB clock enable */
N//#define  RCC_APB1ENR_CANEN                   ((uint32_t)0x02000000)         /*!< CAN clock enable */
N#define  RCC_APB1ENR_CRSEN                   ((uint32_t)0x08000000)        /*!< CRS clock enable */
N#define  RCC_APB1ENR_PWREN                   ((uint32_t)0x10000000)        /*!< PWR clock enable */
N//#define  RCC_APB1ENR_DACEN                   ((uint32_t)0x20000000)        /*!< DAC clock enable */
N//#define  RCC_APB1ENR_CECEN                   ((uint32_t)0x40000000)        /*!< CEC clock enable */
N
N/*******************  Bit definition for RCC_BDCR register  *******************/
N#define  RCC_BDCR_LSEON                      ((uint32_t)0x00000001)        /*!< External Low Speed oscillator enable */
N#define  RCC_BDCR_LSERDY                     ((uint32_t)0x00000002)        /*!< External Low Speed oscillator Ready */
N#define  RCC_BDCR_LSEBYP                     ((uint32_t)0x00000004)        /*!< External Low Speed oscillator Bypass */
N
N#define  RCC_BDCR_LSEDRV                     ((uint32_t)0x00000038)        /*!< LSEDRV[1:0] bits (LSE Osc. drive capability) */
N#define  RCC_BDCR_LSEDRV_0                   ((uint32_t)0x00000008)        /*!< Bit 0 */
N#define  RCC_BDCR_LSEDRV_1                   ((uint32_t)0x00000010)        /*!< Bit 1 */
N#define  RCC_BDCR_LSEDRV_2                   ((uint32_t)0x00000020)        /*!< Bit 2 */
N
N#define  RCC_BDCR_RTCSEL                     ((uint32_t)0x00000300)        /*!< RTCSEL[1:0] bits (RTC clock source selection) */
N#define  RCC_BDCR_RTCSEL_0                   ((uint32_t)0x00000100)        /*!< Bit 0 */
N#define  RCC_BDCR_RTCSEL_1                   ((uint32_t)0x00000200)        /*!< Bit 1 */
N
N/* RTC configuration */
N#define  RCC_BDCR_RTCSEL_NOCLOCK             ((uint32_t)0x00000000)        /*!< No clock */
N#define  RCC_BDCR_RTCSEL_LSE                 ((uint32_t)0x00000100)        /*!< LSE oscillator clock used as RTC clock */
N#define  RCC_BDCR_RTCSEL_LSI                 ((uint32_t)0x00000200)        /*!< LSI oscillator clock used as RTC clock */
N#define  RCC_BDCR_RTCSEL_HSE                 ((uint32_t)0x00000300)        /*!< HSE oscillator clock divided by 32 used as RTC clock */
N
N#define  RCC_BDCR_RTCISO                     ((uint32_t)0x00002000)        /*!<  */
N#define  RCC_BDCR_RTCPD                      ((uint32_t)0x00004000)        /*!<   */
N#define  RCC_BDCR_RTCEN                      ((uint32_t)0x00008000)        /*!< RTC clock enable */
N#define  RCC_BDCR_BDRST                      ((uint32_t)0x00010000)        /*!< Backup domain software reset  */
N
N/*******************  Bit definition for RCC_CSR register  ********************/  
N#define  RCC_CSR_LSION                       ((uint32_t)0x00000001)        /*!< Internal Low Speed oscillator enable */
N#define  RCC_CSR_LSIRDY                      ((uint32_t)0x00000002)        /*!< Internal Low Speed oscillator Ready */
N#define  RCC_CSR_V18PWRRSTF                  ((uint32_t)0x00800000)        /*!< V1.8 power domain reset flag */
N#define  RCC_CSR_RMVF                        ((uint32_t)0x01000000)        /*!< Remove reset flag */
N#define  RCC_CSR_OBLRSTF                     ((uint32_t)0x02000000)        /*!< OBL reset flag */
N#define  RCC_CSR_PINRSTF                     ((uint32_t)0x04000000)        /*!< PIN reset flag */
N#define  RCC_CSR_PORRSTF                     ((uint32_t)0x08000000)        /*!< POR/PDR reset flag */
N#define  RCC_CSR_SFTRSTF                     ((uint32_t)0x10000000)        /*!< Software Reset flag */
N#define  RCC_CSR_IWDGRSTF                    ((uint32_t)0x20000000)        /*!< Independent Watchdog reset flag */
N#define  RCC_CSR_WWDGRSTF                    ((uint32_t)0x40000000)        /*!< Window watchdog reset flag */
N#define  RCC_CSR_LPWRRSTF                    ((uint32_t)0x80000000)        /*!< Low-Power reset flag */
N
N/* Old Bit definition maintained for legacy purpose */
N#define  RCC_CSR_OBL                         RCC_CSR_OBLRSTF        /*!< OBL reset flag */
N/*******************  Bit definition for RCC_AHBRSTR register  ****************/
N#define  RCC_AHBRSTR_GPIOARST                ((uint32_t)0x00020000)         /*!< GPIOA clock reset */
N#define  RCC_AHBRSTR_GPIOBRST                ((uint32_t)0x00040000)         /*!< GPIOB clock reset */
N#define  RCC_AHBRSTR_GPIOCRST                ((uint32_t)0x00080000)         /*!< GPIOC clock reset */
N#define  RCC_AHBRSTR_GPIODRST                ((uint32_t)0x00010000)         /*!< GPIOD clock reset */
N//#define  RCC_AHBRSTR_GPIOERST                ((uint32_t)0x00020000)         /*!< GPIOE clock reset */
N#define  RCC_AHBRSTR_GPIOFRST                ((uint32_t)0x00040000)         /*!< GPIOF clock reset */
N#define  RCC_AHBRSTR_TSCRST                  ((uint32_t)0x00100000)         /*!< TS clock reset */
N
N/* Old Bit definition maintained for legacy purpose */
N#define  RCC_AHBRSTR_TSRST                   RCC_AHBRSTR_TSCRST         /*!< TS clock reset */ 
N
N#define  RCC_AHBRSTR_IOPARST                 RCC_AHBRSTR_GPIOARST
N#define  RCC_AHBRSTR_IOPBRST                 RCC_AHBRSTR_GPIOBRST
N#define  RCC_AHBRSTR_IOPCRST                 RCC_AHBRSTR_GPIOCRST
N#define  RCC_AHBRSTR_IOPDRST                 RCC_AHBRSTR_GPIODRST
N#define  RCC_AHBRSTR_IOPFRST                 RCC_AHBRSTR_GPIOFRST
N  
N/*******************  Bit definition for RCC_CFGR2 register  ******************/
N/* PREDIV1 configuration */
N#define  RCC_CFGR2_PREDIV1                   ((uint32_t)0x0000000F)        /*!< PREDIV1[3:0] bits */
N#define  RCC_CFGR2_PREDIV1_0                 ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  RCC_CFGR2_PREDIV1_1                 ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  RCC_CFGR2_PREDIV1_2                 ((uint32_t)0x00000004)        /*!< Bit 2 */
N#define  RCC_CFGR2_PREDIV1_3                 ((uint32_t)0x00000008)        /*!< Bit 3 */
N
N#define  RCC_CFGR2_PREDIV1_DIV1              ((uint32_t)0x00000000)        /*!< PREDIV1 input clock not divided */
N#define  RCC_CFGR2_PREDIV1_DIV2              ((uint32_t)0x00000001)        /*!< PREDIV1 input clock divided by 2 */
N#define  RCC_CFGR2_PREDIV1_DIV3              ((uint32_t)0x00000002)        /*!< PREDIV1 input clock divided by 3 */
N#define  RCC_CFGR2_PREDIV1_DIV4              ((uint32_t)0x00000003)        /*!< PREDIV1 input clock divided by 4 */
N#define  RCC_CFGR2_PREDIV1_DIV5              ((uint32_t)0x00000004)        /*!< PREDIV1 input clock divided by 5 */
N#define  RCC_CFGR2_PREDIV1_DIV6              ((uint32_t)0x00000005)        /*!< PREDIV1 input clock divided by 6 */
N#define  RCC_CFGR2_PREDIV1_DIV7              ((uint32_t)0x00000006)        /*!< PREDIV1 input clock divided by 7 */
N#define  RCC_CFGR2_PREDIV1_DIV8              ((uint32_t)0x00000007)        /*!< PREDIV1 input clock divided by 8 */
N#define  RCC_CFGR2_PREDIV1_DIV9              ((uint32_t)0x00000008)        /*!< PREDIV1 input clock divided by 9 */
N#define  RCC_CFGR2_PREDIV1_DIV10             ((uint32_t)0x00000009)        /*!< PREDIV1 input clock divided by 10 */
N#define  RCC_CFGR2_PREDIV1_DIV11             ((uint32_t)0x0000000A)        /*!< PREDIV1 input clock divided by 11 */
N#define  RCC_CFGR2_PREDIV1_DIV12             ((uint32_t)0x0000000B)        /*!< PREDIV1 input clock divided by 12 */
N#define  RCC_CFGR2_PREDIV1_DIV13             ((uint32_t)0x0000000C)        /*!< PREDIV1 input clock divided by 13 */
N#define  RCC_CFGR2_PREDIV1_DIV14             ((uint32_t)0x0000000D)        /*!< PREDIV1 input clock divided by 14 */
N#define  RCC_CFGR2_PREDIV1_DIV15             ((uint32_t)0x0000000E)        /*!< PREDIV1 input clock divided by 15 */
N#define  RCC_CFGR2_PREDIV1_DIV16             ((uint32_t)0x0000000F)        /*!< PREDIV1 input clock divided by 16 */
N
N/* Old Bit definition maintained for legacy purpose */
N#define  RCC_CFGR2_PREDIV                  RCC_CFGR2_PREDIV1          
N#define  RCC_CFGR2_PREDIV_0                RCC_CFGR2_PREDIV1_0    
N#define  RCC_CFGR2_PREDIV_1                RCC_CFGR2_PREDIV1_1    
N#define  RCC_CFGR2_PREDIV_2                RCC_CFGR2_PREDIV1_2    
N#define  RCC_CFGR2_PREDIV_3                RCC_CFGR2_PREDIV1_3    
N                                                                   
N#define  RCC_CFGR2_PREDIV_DIV1             RCC_CFGR2_PREDIV1_DIV1 
N#define  RCC_CFGR2_PREDIV_DIV2             RCC_CFGR2_PREDIV1_DIV2 
N#define  RCC_CFGR2_PREDIV_DIV3             RCC_CFGR2_PREDIV1_DIV3 
N#define  RCC_CFGR2_PREDIV_DIV4             RCC_CFGR2_PREDIV1_DIV4 
N#define  RCC_CFGR2_PREDIV_DIV5             RCC_CFGR2_PREDIV1_DIV5 
N#define  RCC_CFGR2_PREDIV_DIV6             RCC_CFGR2_PREDIV1_DIV6 
N#define  RCC_CFGR2_PREDIV_DIV7             RCC_CFGR2_PREDIV1_DIV7 
N#define  RCC_CFGR2_PREDIV_DIV8             RCC_CFGR2_PREDIV1_DIV8 
N#define  RCC_CFGR2_PREDIV_DIV9             RCC_CFGR2_PREDIV1_DIV9 
N#define  RCC_CFGR2_PREDIV_DIV10            RCC_CFGR2_PREDIV1_DIV10
N#define  RCC_CFGR2_PREDIV_DIV11            RCC_CFGR2_PREDIV1_DIV11
N#define  RCC_CFGR2_PREDIV_DIV12            RCC_CFGR2_PREDIV1_DIV12
N#define  RCC_CFGR2_PREDIV_DIV13            RCC_CFGR2_PREDIV1_DIV13
N#define  RCC_CFGR2_PREDIV_DIV14            RCC_CFGR2_PREDIV1_DIV14
N#define  RCC_CFGR2_PREDIV_DIV15            RCC_CFGR2_PREDIV1_DIV15
N#define  RCC_CFGR2_PREDIV_DIV16            RCC_CFGR2_PREDIV1_DIV16
N/*******************  Bit definition for RCC_CFGR3 register  ******************/
N#define  RCC_CFGR3_USART1SW                  ((uint32_t)0x00000003)        /*!< USART1SW[1:0] bits */
N#define  RCC_CFGR3_USART1SW_0                ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  RCC_CFGR3_USART1SW_1                ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  RCC_CFGR3_I2C1SW                    ((uint32_t)0x00000010)        /*!< I2C1SW bits */
N//#define  RCC_CFGR3_CECSW                     ((uint32_t)0x00000040)        /*!< CECSW bits */
N#define  RCC_CFGR3_USBSW                     ((uint32_t)0x00000080)        /*!< USBSW bits */
N#define  RCC_CFGR3_ADCSW                     ((uint32_t)0x00000100)        /*!< ADCSW bits */
N//#define  RCC_CFGR3_USART2SW                  ((uint32_t)0x00030000)        /*!< USART2SW[1:0] bits */
N//#define  RCC_CFGR3_USART2SW_0                ((uint32_t)0x00010000)        /*!< Bit 0 */
N//#define  RCC_CFGR3_USART2SW_1                ((uint32_t)0x00020000)        /*!< Bit 1 */
N//#define  RCC_CFGR3_USART3SW                  ((uint32_t)0x000C0000)        /*!< USART3SW[1:0] bits */
N//#define  RCC_CFGR3_USART3SW_0                ((uint32_t)0x00040000)        /*!< Bit 0 */
N//#define  RCC_CFGR3_USART3SW_1                ((uint32_t)0x00080000)        /*!< Bit 1 */
N
N
N/*******************  Bit definition for RCC_CR2 register  ********************/
N#define  RCC_CR2_HSI14ON                     ((uint32_t)0x00000001)        /*!< Internal High Speed 14MHz clock enable */
N#define  RCC_CR2_HSI14RDY                    ((uint32_t)0x00000002)        /*!< Internal High Speed 14MHz clock ready flag */
N#define  RCC_CR2_HSI14DIS                    ((uint32_t)0x00000004)        /*!< Internal High Speed 14MHz clock disable */
N#define  RCC_CR2_HSI14TRIM                   ((uint32_t)0x000000F8)        /*!< Internal High Speed 14MHz clock trimming */
N#define  RCC_CR2_HSI14CAL                    ((uint32_t)0x0000FF00)        /*!< Internal High Speed 14MHz clock Calibration */
N#define  RCC_CR2_HSI48ON                     ((uint32_t)0x00010000)        /*!< Internal High Speed 48MHz clock enable */
N#define  RCC_CR2_HSI48RDY                    ((uint32_t)0x00020000)        /*!< Internal High Speed 48MHz clock ready flag */
N#define  RCC_CR2_HSI48CAL                    ((uint32_t)0xFF800000)        /*!< Internal High Speed 48MHz clock Calibration */
N
N/******************************************************************************/
N/*                                                                            */
N/*                           Real-Time Clock (RTC)                            */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bits definition for RTC_TR register  *******************/         
N#define RTC_TR_SU                            ((uint32_t)0x0000000F)      
N#define RTC_TR_SU_0                          ((uint32_t)0x00000001)        
N#define RTC_TR_SU_1                          ((uint32_t)0x00000002)        
N#define RTC_TR_SU_2                          ((uint32_t)0x00000004)        
N#define RTC_TR_SU_3                          ((uint32_t)0x00000008)         
N#define RTC_TR_ST                            ((uint32_t)0x00000070)        
N#define RTC_TR_ST_0                          ((uint32_t)0x00000010)        
N#define RTC_TR_ST_1                          ((uint32_t)0x00000020)        
N#define RTC_TR_ST_2                          ((uint32_t)0x00000040)          
N#define RTC_TR_MNU                           ((uint32_t)0x00000F00)        
N#define RTC_TR_MNU_0                         ((uint32_t)0x00000100)        
N#define RTC_TR_MNU_1                         ((uint32_t)0x00000200)        
N#define RTC_TR_MNU_2                         ((uint32_t)0x00000400)        
N#define RTC_TR_MNU_3                         ((uint32_t)0x00000800)        
N#define RTC_TR_MNT                           ((uint32_t)0x00007000)        
N#define RTC_TR_MNT_0                         ((uint32_t)0x00001000)        
N#define RTC_TR_MNT_1                         ((uint32_t)0x00002000)        
N#define RTC_TR_MNT_2                         ((uint32_t)0x00004000)       
N#define RTC_TR_HU                            ((uint32_t)0x000F0000)        
N#define RTC_TR_HU_0                          ((uint32_t)0x00010000)        
N#define RTC_TR_HU_1                          ((uint32_t)0x00020000)        
N#define RTC_TR_HU_2                          ((uint32_t)0x00040000)        
N#define RTC_TR_HU_3                          ((uint32_t)0x00080000)
N#define RTC_TR_HT                            ((uint32_t)0x00300000)        
N#define RTC_TR_HT_0                          ((uint32_t)0x00100000)        
N#define RTC_TR_HT_1                          ((uint32_t)0x00200000)  
N#define RTC_TR_PM                            ((uint32_t)0x00400000)     
N
N/********************  Bits definition for RTC_DR register  *******************/       
N#define RTC_DR_DU                            ((uint32_t)0x0000000F)        
N#define RTC_DR_DU_0                          ((uint32_t)0x00000001)        
N#define RTC_DR_DU_1                          ((uint32_t)0x00000002)        
N#define RTC_DR_DU_2                          ((uint32_t)0x00000004)        
N#define RTC_DR_DU_3                          ((uint32_t)0x00000008)           
N#define RTC_DR_DT                            ((uint32_t)0x00000030)        
N#define RTC_DR_DT_0                          ((uint32_t)0x00000010)        
N#define RTC_DR_DT_1                          ((uint32_t)0x00000020)         
N#define RTC_DR_MU                            ((uint32_t)0x00000F00)        
N#define RTC_DR_MU_0                          ((uint32_t)0x00000100)        
N#define RTC_DR_MU_1                          ((uint32_t)0x00000200)        
N#define RTC_DR_MU_2                          ((uint32_t)0x00000400)        
N#define RTC_DR_MU_3                          ((uint32_t)0x00000800)         
N#define RTC_DR_MT                            ((uint32_t)0x00001000)        
N#define RTC_DR_WDU                           ((uint32_t)0x0000E000)        
N#define RTC_DR_WDU_0                         ((uint32_t)0x00002000)        
N#define RTC_DR_WDU_1                         ((uint32_t)0x00004000)        
N#define RTC_DR_WDU_2                         ((uint32_t)0x00008000)       
N#define RTC_DR_YU                            ((uint32_t)0x000F0000)        
N#define RTC_DR_YU_0                          ((uint32_t)0x00010000)        
N#define RTC_DR_YU_1                          ((uint32_t)0x00020000)        
N#define RTC_DR_YU_2                          ((uint32_t)0x00040000)        
N#define RTC_DR_YU_3                          ((uint32_t)0x00080000) 
N#define RTC_DR_YT                            ((uint32_t)0x00F00000)        
N#define RTC_DR_YT_0                          ((uint32_t)0x00100000)        
N#define RTC_DR_YT_1                          ((uint32_t)0x00200000)        
N#define RTC_DR_YT_2                          ((uint32_t)0x00400000)        
N#define RTC_DR_YT_3                          ((uint32_t)0x00800000)    
N
N/********************  Bits definition for RTC_CR register  *******************/        
N//#define RTC_CR_WUCKSEL                       ((uint32_t)0x00000007)        
N//#define RTC_CR_WUCKSEL_0                     ((uint32_t)0x00000001)        
N//#define RTC_CR_WUCKSEL_1                     ((uint32_t)0x00000002)        
N//#define RTC_CR_WUCKSEL_2                     ((uint32_t)0x00000004)          
N#define RTC_CR_TSEDGE                        ((uint32_t)0x00000008)        
N#define RTC_CR_REFCKON                       ((uint32_t)0x00000010)          
N#define RTC_CR_BYPSHAD                       ((uint32_t)0x00000020)         
N#define RTC_CR_FMT                           ((uint32_t)0x00000040)        
N#define RTC_CR_ALRAE                         ((uint32_t)0x00000100)        
N//#define RTC_CR_WUTE                          ((uint32_t)0x00000400)        
N#define RTC_CR_TSE                           ((uint32_t)0x00000800)
N#define RTC_CR_ALRAIE                        ((uint32_t)0x00001000)       
N//#define RTC_CR_WUTIE                         ((uint32_t)0x00004000)          
N#define RTC_CR_TSIE                          ((uint32_t)0x00008000)        
N#define RTC_CR_ADD1H                         ((uint32_t)0x00010000)         
N#define RTC_CR_SUB1H                         ((uint32_t)0x00020000)        
N#define RTC_CR_BKP                           ((uint32_t)0x00040000)        
N#define RTC_CR_COSEL                         ((uint32_t)0x00080000)          
N#define RTC_CR_POL                           ((uint32_t)0x00100000)       
N#define RTC_CR_OSEL                          ((uint32_t)0x00200000)        
N//#define RTC_CR_OSEL_0                        ((uint32_t)0x00200000)        
N//#define RTC_CR_OSEL_1                        ((uint32_t)0x00400000)
N#define RTC_CR_COE                           ((uint32_t)0x00800000)
N
N/* Old bit definition maintained for legacy purpose */
N#define RTC_CR_BCK                           RTC_CR_BKP
N#define RTC_CR_CALSEL                        RTC_CR_COSEL
N
N/********************  Bits definition for RTC_ISR register  ******************/
N#define RTC_ISR_RECALPF                      ((uint32_t)0x00010000)        
N//#define RTC_ISR_TAMP3F                       ((uint32_t)0x00008000)        
N#define RTC_ISR_TAMP2F                       ((uint32_t)0x00004000)        
N#define RTC_ISR_TAMP1F                       ((uint32_t)0x00002000)        
N#define RTC_ISR_TSOVF                        ((uint32_t)0x00001000)        
N#define RTC_ISR_TSF                          ((uint32_t)0x00000800)        
N//#define RTC_ISR_WUTF                         ((uint32_t)0x00000400)        
N#define RTC_ISR_ALRAF                        ((uint32_t)0x00000100)        
N#define RTC_ISR_INIT                         ((uint32_t)0x00000080)        
N#define RTC_ISR_INITF                        ((uint32_t)0x00000040)        
N#define RTC_ISR_RSF                          ((uint32_t)0x00000020)        
N#define RTC_ISR_INITS                        ((uint32_t)0x00000010)        
N#define RTC_ISR_SHPF                         ((uint32_t)0x00000008)        
N//#define RTC_ISR_WUTWF                        ((uint32_t)0x00000004)        
N#define RTC_ISR_ALRAWF                       ((uint32_t)0x00000001)        
N
N/********************  Bits definition for RTC_PRER register  *****************/
N#define RTC_PRER_PREDIV_A                    ((uint32_t)0x007F0000)        
N#define RTC_PRER_PREDIV_S                    ((uint32_t)0x00007FFF)        
N
N/********************  Bits definition for RTC_WUTR register  *****************/
N//#define RTC_WUTR_WUT                         ((uint32_t)0x0000FFFF)
N
N/********************  Bits definition for RTC_ALRMAR register  ***************/
N#define RTC_ALRMAR_MSK4                      ((uint32_t)0x80000000)        
N#define RTC_ALRMAR_WDSEL                     ((uint32_t)0x40000000)        
N#define RTC_ALRMAR_DT                        ((uint32_t)0x30000000)        
N#define RTC_ALRMAR_DT_0                      ((uint32_t)0x10000000)        
N#define RTC_ALRMAR_DT_1                      ((uint32_t)0x20000000)        
N#define RTC_ALRMAR_DU                        ((uint32_t)0x0F000000)        
N#define RTC_ALRMAR_DU_0                      ((uint32_t)0x01000000)        
N#define RTC_ALRMAR_DU_1                      ((uint32_t)0x02000000)        
N#define RTC_ALRMAR_DU_2                      ((uint32_t)0x04000000)        
N#define RTC_ALRMAR_DU_3                      ((uint32_t)0x08000000)        
N#define RTC_ALRMAR_MSK3                      ((uint32_t)0x00800000)        
N#define RTC_ALRMAR_PM                        ((uint32_t)0x00400000)        
N#define RTC_ALRMAR_HT                        ((uint32_t)0x00300000)        
N#define RTC_ALRMAR_HT_0                      ((uint32_t)0x00100000)        
N#define RTC_ALRMAR_HT_1                      ((uint32_t)0x00200000)        
N#define RTC_ALRMAR_HU                        ((uint32_t)0x000F0000)        
N#define RTC_ALRMAR_HU_0                      ((uint32_t)0x00010000)        
N#define RTC_ALRMAR_HU_1                      ((uint32_t)0x00020000)        
N#define RTC_ALRMAR_HU_2                      ((uint32_t)0x00040000)        
N#define RTC_ALRMAR_HU_3                      ((uint32_t)0x00080000)        
N#define RTC_ALRMAR_MSK2                      ((uint32_t)0x00008000)        
N#define RTC_ALRMAR_MNT                       ((uint32_t)0x00007000)        
N#define RTC_ALRMAR_MNT_0                     ((uint32_t)0x00001000)        
N#define RTC_ALRMAR_MNT_1                     ((uint32_t)0x00002000)        
N#define RTC_ALRMAR_MNT_2                     ((uint32_t)0x00004000)        
N#define RTC_ALRMAR_MNU                       ((uint32_t)0x00000F00)        
N#define RTC_ALRMAR_MNU_0                     ((uint32_t)0x00000100)        
N#define RTC_ALRMAR_MNU_1                     ((uint32_t)0x00000200)        
N#define RTC_ALRMAR_MNU_2                     ((uint32_t)0x00000400)        
N#define RTC_ALRMAR_MNU_3                     ((uint32_t)0x00000800)        
N#define RTC_ALRMAR_MSK1                      ((uint32_t)0x00000080)        
N#define RTC_ALRMAR_ST                        ((uint32_t)0x00000070)        
N#define RTC_ALRMAR_ST_0                      ((uint32_t)0x00000010)        
N#define RTC_ALRMAR_ST_1                      ((uint32_t)0x00000020)        
N#define RTC_ALRMAR_ST_2                      ((uint32_t)0x00000040)        
N#define RTC_ALRMAR_SU                        ((uint32_t)0x0000000F)        
N#define RTC_ALRMAR_SU_0                      ((uint32_t)0x00000001)        
N#define RTC_ALRMAR_SU_1                      ((uint32_t)0x00000002)        
N#define RTC_ALRMAR_SU_2                      ((uint32_t)0x00000004)        
N#define RTC_ALRMAR_SU_3                      ((uint32_t)0x00000008)        
N
N/********************  Bits definition for RTC_WPR register  ******************/
N#define RTC_WPR_KEY                          ((uint32_t)0x000000FF)        
N
N/********************  Bits definition for RTC_SSR register  ******************/
N//#define RTC_SSR_SS                           ((uint32_t)0x0003FFFF) 
N#define RTC_SSR_SS                           ((uint32_t)0x0000FFFF)               
N
N/********************  Bits definition for RTC_SHIFTR register  ***************/
N#define RTC_SHIFTR_SUBFS                     ((uint32_t)0x00007FFF)        
N#define RTC_SHIFTR_ADD1S                     ((uint32_t)0x80000000)        
N
N/********************  Bits definition for RTC_TSTR register  *****************/
N#define RTC_TSTR_PM                          ((uint32_t)0x00400000)        
N#define RTC_TSTR_HT                          ((uint32_t)0x00300000)        
N#define RTC_TSTR_HT_0                        ((uint32_t)0x00100000)        
N#define RTC_TSTR_HT_1                        ((uint32_t)0x00200000)        
N#define RTC_TSTR_HU                          ((uint32_t)0x000F0000)        
N#define RTC_TSTR_HU_0                        ((uint32_t)0x00010000)        
N#define RTC_TSTR_HU_1                        ((uint32_t)0x00020000)        
N#define RTC_TSTR_HU_2                        ((uint32_t)0x00040000)        
N#define RTC_TSTR_HU_3                        ((uint32_t)0x00080000)        
N#define RTC_TSTR_MNT                         ((uint32_t)0x00007000)        
N#define RTC_TSTR_MNT_0                       ((uint32_t)0x00001000)        
N#define RTC_TSTR_MNT_1                       ((uint32_t)0x00002000)        
N#define RTC_TSTR_MNT_2                       ((uint32_t)0x00004000)        
N#define RTC_TSTR_MNU                         ((uint32_t)0x00000F00)        
N#define RTC_TSTR_MNU_0                       ((uint32_t)0x00000100)        
N#define RTC_TSTR_MNU_1                       ((uint32_t)0x00000200)        
N#define RTC_TSTR_MNU_2                       ((uint32_t)0x00000400)        
N#define RTC_TSTR_MNU_3                       ((uint32_t)0x00000800)        
N#define RTC_TSTR_ST                          ((uint32_t)0x00000070)        
N#define RTC_TSTR_ST_0                        ((uint32_t)0x00000010)        
N#define RTC_TSTR_ST_1                        ((uint32_t)0x00000020)        
N#define RTC_TSTR_ST_2                        ((uint32_t)0x00000040)        
N#define RTC_TSTR_SU                          ((uint32_t)0x0000000F)        
N#define RTC_TSTR_SU_0                        ((uint32_t)0x00000001)        
N#define RTC_TSTR_SU_1                        ((uint32_t)0x00000002)        
N#define RTC_TSTR_SU_2                        ((uint32_t)0x00000004)        
N#define RTC_TSTR_SU_3                        ((uint32_t)0x00000008)        
N
N/********************  Bits definition for RTC_TSDR register  *****************/
N#define RTC_TSDR_WDU                         ((uint32_t)0x0000E000)        
N#define RTC_TSDR_WDU_0                       ((uint32_t)0x00002000)        
N#define RTC_TSDR_WDU_1                       ((uint32_t)0x00004000)        
N#define RTC_TSDR_WDU_2                       ((uint32_t)0x00008000)        
N#define RTC_TSDR_MT                          ((uint32_t)0x00001000)        
N#define RTC_TSDR_MU                          ((uint32_t)0x00000F00)        
N#define RTC_TSDR_MU_0                        ((uint32_t)0x00000100)        
N#define RTC_TSDR_MU_1                        ((uint32_t)0x00000200)        
N#define RTC_TSDR_MU_2                        ((uint32_t)0x00000400)        
N#define RTC_TSDR_MU_3                        ((uint32_t)0x00000800)        
N#define RTC_TSDR_DT                          ((uint32_t)0x00000030)        
N#define RTC_TSDR_DT_0                        ((uint32_t)0x00000010)        
N#define RTC_TSDR_DT_1                        ((uint32_t)0x00000020)        
N#define RTC_TSDR_DU                          ((uint32_t)0x0000000F)        
N#define RTC_TSDR_DU_0                        ((uint32_t)0x00000001)        
N#define RTC_TSDR_DU_1                        ((uint32_t)0x00000002)        
N#define RTC_TSDR_DU_2                        ((uint32_t)0x00000004)        
N#define RTC_TSDR_DU_3                        ((uint32_t)0x00000008)        
N
N/********************  Bits definition for RTC_TSSSR register  ****************/
N//#define RTC_TSSSR_SS                         ((uint32_t)0x0003FFFF)
N#define RTC_TSSSR_SS                         ((uint32_t)0x0000FFFF)
N
N/********************  Bits definition for RTC_CALR register  ******************/
N#define RTC_CALR_CALP                         ((uint32_t)0x00008000)        
N#define RTC_CALR_CALW8                        ((uint32_t)0x00004000)        
N#define RTC_CALR_CALW16                       ((uint32_t)0x00002000)        
N#define RTC_CALR_CALM                         ((uint32_t)0x000001FF)        
N#define RTC_CALR_CALM_0                       ((uint32_t)0x00000001)        
N#define RTC_CALR_CALM_1                       ((uint32_t)0x00000002)        
N#define RTC_CALR_CALM_2                       ((uint32_t)0x00000004)        
N#define RTC_CALR_CALM_3                       ((uint32_t)0x00000008)        
N#define RTC_CALR_CALM_4                       ((uint32_t)0x00000010)        
N#define RTC_CALR_CALM_5                       ((uint32_t)0x00000020)        
N#define RTC_CALR_CALM_6                       ((uint32_t)0x00000040)        
N#define RTC_CALR_CALM_7                       ((uint32_t)0x00000080)        
N#define RTC_CALR_CALM_8                       ((uint32_t)0x00000100)
N
N/* Old Bits definition for RTC_CAL register maintained for legacy purpose */
N#define RTC_CAL_CALP                         RTC_CALR_CALP  
N#define RTC_CAL_CALW8                        RTC_CALR_CALW8 
N#define RTC_CAL_CALW16                       RTC_CALR_CALW16
N#define RTC_CAL_CALM                         RTC_CALR_CALM  
N#define RTC_CAL_CALM_0                       RTC_CALR_CALM_0
N#define RTC_CAL_CALM_1                       RTC_CALR_CALM_1
N#define RTC_CAL_CALM_2                       RTC_CALR_CALM_2
N#define RTC_CAL_CALM_3                       RTC_CALR_CALM_3
N#define RTC_CAL_CALM_4                       RTC_CALR_CALM_4
N#define RTC_CAL_CALM_5                       RTC_CALR_CALM_5
N#define RTC_CAL_CALM_6                       RTC_CALR_CALM_6
N#define RTC_CAL_CALM_7                       RTC_CALR_CALM_7
N#define RTC_CAL_CALM_8                       RTC_CALR_CALM_8
N
N/********************  Bits definition for RTC_TAFCR register  ****************/
N#define RTC_TAFCR_PC15MODE                   ((uint32_t)0x00800000)
N#define RTC_TAFCR_PC15VALUE                  ((uint32_t)0x00400000)
N#define RTC_TAFCR_PC14MODE                   ((uint32_t)0x00200000)
N#define RTC_TAFCR_PC14VALUE                  ((uint32_t)0x00100000)
N#define RTC_TAFCR_PC13MODE                   ((uint32_t)0x00080000)
N#define RTC_TAFCR_PC13VALUE                  ((uint32_t)0x00040000)        
N#define RTC_TAFCR_TAMPPUDIS                  ((uint32_t)0x00008000)        
N#define RTC_TAFCR_TAMPPRCH                   ((uint32_t)0x00006000)        
N#define RTC_TAFCR_TAMPPRCH_0                 ((uint32_t)0x00002000)        
N#define RTC_TAFCR_TAMPPRCH_1                 ((uint32_t)0x00004000)        
N#define RTC_TAFCR_TAMPFLT                    ((uint32_t)0x00001800)        
N#define RTC_TAFCR_TAMPFLT_0                  ((uint32_t)0x00000800)        
N#define RTC_TAFCR_TAMPFLT_1                  ((uint32_t)0x00001000)        
N#define RTC_TAFCR_TAMPFREQ                   ((uint32_t)0x00000700)        
N#define RTC_TAFCR_TAMPFREQ_0                 ((uint32_t)0x00000100)        
N#define RTC_TAFCR_TAMPFREQ_1                 ((uint32_t)0x00000200)        
N#define RTC_TAFCR_TAMPFREQ_2                 ((uint32_t)0x00000400)        
N#define RTC_TAFCR_TAMPTS                     ((uint32_t)0x00000080)        
N//#define RTC_TAFCR_TAMP3EDGE                  ((uint32_t)0x00000040)        
N//#define RTC_TAFCR_TAMP3E                     ((uint32_t)0x00000020)        
N#define RTC_TAFCR_TAMP2EDGE                  ((uint32_t)0x00000010)        
N#define RTC_TAFCR_TAMP2E                     ((uint32_t)0x00000008)        
N#define RTC_TAFCR_TAMPIE                     ((uint32_t)0x00000004)        
N#define RTC_TAFCR_TAMP1TRG                   ((uint32_t)0x00000002)        
N#define RTC_TAFCR_TAMP1E                     ((uint32_t)0x00000001)        
N
N/* Old bit definition maintained for legacy purpose */
N#define RTC_TAFCR_ALARMOUTTYPE               RTC_TAFCR_PC13VALUE
N#define RTC_TAFCR_TAMP2TRG									 RTC_TAFCR_TAMP2EDGE
N/********************  Bits definition for RTC_ALRMASSR register  *************/
N#define RTC_ALRMASSR_MASKSS                  ((uint32_t)0x0F000000)        
N#define RTC_ALRMASSR_MASKSS_0                ((uint32_t)0x01000000)        
N#define RTC_ALRMASSR_MASKSS_1                ((uint32_t)0x02000000)        
N#define RTC_ALRMASSR_MASKSS_2                ((uint32_t)0x04000000)        
N#define RTC_ALRMASSR_MASKSS_3                ((uint32_t)0x08000000)        
N#define RTC_ALRMASSR_SS                      ((uint32_t)0x00007FFF)        
N
N/********************  Bits definition for RTC_BKP0R register  ****************/
N#define RTC_BKP0R                            ((uint32_t)0xFFFFFFFF)        
N
N/********************  Bits definition for RTC_BKP1R register  ****************/
N#define RTC_BKP1R                            ((uint32_t)0xFFFFFFFF)        
N
N/********************  Bits definition for RTC_BKP2R register  ****************/
N#define RTC_BKP2R                            ((uint32_t)0xFFFFFFFF)        
N
N/********************  Bits definition for RTC_BKP3R register  ****************/
N#define RTC_BKP3R                            ((uint32_t)0xFFFFFFFF)        
N
N/********************  Bits definition for RTC_BKP4R register  ****************/
N#define RTC_BKP4R                            ((uint32_t)0xFFFFFFFF)        
N
N/******************************************************************************/
N/*                                                                            */
N/*                        Serial Peripheral Interface (SPI)                   */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for SPI_CR1 register  ********************/
N#define  SPI_CR1_CPHA                        ((uint16_t)0x0001)            /*!< Clock Phase */
N#define  SPI_CR1_CPOL                        ((uint16_t)0x0002)            /*!< Clock Polarity */
N#define  SPI_CR1_MSTR                        ((uint16_t)0x0004)            /*!< Master Selection */
N#define  SPI_CR1_BR                          ((uint16_t)0x0038)            /*!< BR[2:0] bits (Baud Rate Control) */
N#define  SPI_CR1_BR_0                        ((uint16_t)0x0008)            /*!< Bit 0 */
N#define  SPI_CR1_BR_1                        ((uint16_t)0x0010)            /*!< Bit 1 */
N#define  SPI_CR1_BR_2                        ((uint16_t)0x0020)            /*!< Bit 2 */
N#define  SPI_CR1_SPE                         ((uint16_t)0x0040)            /*!< SPI Enable */
N#define  SPI_CR1_LSBFIRST                    ((uint16_t)0x0080)            /*!< Frame Format */
N#define  SPI_CR1_SSI                         ((uint16_t)0x0100)            /*!< Internal slave select */
N#define  SPI_CR1_SSM                         ((uint16_t)0x0200)            /*!< Software slave management */
N#define  SPI_CR1_RXONLY                      ((uint16_t)0x0400)            /*!< Receive only */
N#define  SPI_CR1_CRCL                        ((uint16_t)0x0800)            /*!< CRC Length */
N#define  SPI_CR1_CRCNEXT                     ((uint16_t)0x1000)            /*!< Transmit CRC next */
N#define  SPI_CR1_CRCEN                       ((uint16_t)0x2000)            /*!< Hardware CRC calculation enable */
N#define  SPI_CR1_BIDIOE                      ((uint16_t)0x4000)            /*!< Output enable in bidirectional mode */
N#define  SPI_CR1_BIDIMODE                    ((uint16_t)0x8000)            /*!< Bidirectional data mode enable */
N
N/*******************  Bit definition for SPI_CR2 register  ********************/
N#define  SPI_CR2_RXDMAEN                     ((uint16_t)0x0001)            /*!< Rx Buffer DMA Enable */
N#define  SPI_CR2_TXDMAEN                     ((uint16_t)0x0002)            /*!< Tx Buffer DMA Enable */
N#define  SPI_CR2_SSOE                        ((uint16_t)0x0004)            /*!< SS Output Enable */
N#define  SPI_CR2_NSSP                        ((uint16_t)0x0008)            /*!< NSS pulse management Enable */
N#define  SPI_CR2_FRF                         ((uint16_t)0x0010)            /*!< Frame Format Enable */
N#define  SPI_CR2_ERRIE                       ((uint16_t)0x0020)            /*!< Error Interrupt Enable */
N#define  SPI_CR2_RXNEIE                      ((uint16_t)0x0040)            /*!< RX buffer Not Empty Interrupt Enable */
N#define  SPI_CR2_TXEIE                       ((uint16_t)0x0080)            /*!< Tx buffer Empty Interrupt Enable */
N#define  SPI_CR2_DS                          ((uint16_t)0x0F00)            /*!< DS[3:0] Data Size */
N#define  SPI_CR2_DS_0                        ((uint16_t)0x0100)            /*!< Bit 0 */
N#define  SPI_CR2_DS_1                        ((uint16_t)0x0200)            /*!< Bit 1 */
N#define  SPI_CR2_DS_2                        ((uint16_t)0x0400)            /*!< Bit 2 */
N#define  SPI_CR2_DS_3                        ((uint16_t)0x0800)            /*!< Bit 3 */
N#define  SPI_CR2_FRXTH                       ((uint16_t)0x1000)            /*!< FIFO reception Threshold */
N#define  SPI_CR2_LDMARX                      ((uint16_t)0x2000)            /*!< Last DMA transfer for reception */
N#define  SPI_CR2_LDMATX                      ((uint16_t)0x4000)            /*!< Last DMA transfer for transmission */
N
N/********************  Bit definition for SPI_SR register  ********************/
N#define  SPI_SR_RXNE                         ((uint16_t)0x0001)            /*!< Receive buffer Not Empty */
N#define  SPI_SR_TXE                          ((uint16_t)0x0002)            /*!< Transmit buffer Empty */
N//#define  SPI_SR_CHSIDE                       ((uint16_t)0x0004)            /*!< Channel side */
N//#define  SPI_SR_UDR                          ((uint16_t)0x0008)            /*!< Underrun flag */
N#define  SPI_SR_CRCERR                       ((uint16_t)0x0010)            /*!< CRC Error flag */
N#define  SPI_SR_MODF                         ((uint16_t)0x0020)            /*!< Mode fault */
N#define  SPI_SR_OVR                          ((uint16_t)0x0040)            /*!< Overrun flag */
N#define  SPI_SR_BSY                          ((uint16_t)0x0080)            /*!< Busy flag */
N#define  SPI_SR_FRE                          ((uint16_t)0x0100)            /*!< TI frame format error */
N#define  SPI_SR_FRLVL                        ((uint16_t)0x0600)            /*!< FIFO Reception Level */
N#define  SPI_SR_FRLVL_0                      ((uint16_t)0x0200)            /*!< Bit 0 */
N#define  SPI_SR_FRLVL_1                      ((uint16_t)0x0400)            /*!< Bit 1 */
N#define  SPI_SR_FTLVL                        ((uint16_t)0x1800)            /*!< FIFO Transmission Level */
N#define  SPI_SR_FTLVL_0                      ((uint16_t)0x0800)            /*!< Bit 0 */
N#define  SPI_SR_FTLVL_1                      ((uint16_t)0x1000)            /*!< Bit 1 */  
N
N/********************  Bit definition for SPI_DR register  ********************/
N#define  SPI_DR_DR                           ((uint16_t)0xFFFF)            /*!< Data Register */
N
N/*******************  Bit definition for SPI_CRCPR register  ******************/
N#define  SPI_CRCPR_CRCPOLY                   ((uint16_t)0xFFFF)            /*!< CRC polynomial register */
N
N/******************  Bit definition for SPI_RXCRCR register  ******************/
N#define  SPI_RXCRCR_RXCRC                    ((uint16_t)0xFFFF)            /*!< Rx CRC Register */
N
N/******************  Bit definition for SPI_TXCRCR register  ******************/
N#define  SPI_TXCRCR_TXCRC                    ((uint16_t)0xFFFF)            /*!< Tx CRC Register */
N
N/******************  Bit definition for SPI_I2SCFGR register  *****************/
N//#define  SPI_I2SCFGR_CHLEN                   ((uint16_t)0x0001)            /*!<Channel length (number of bits per audio channel) */
N//#define  SPI_I2SCFGR_DATLEN                  ((uint16_t)0x0006)            /*!<DATLEN[1:0] bits (Data length to be transferred) */
N//#define  SPI_I2SCFGR_DATLEN_0                ((uint16_t)0x0002)            /*!<Bit 0 */
N//#define  SPI_I2SCFGR_DATLEN_1                ((uint16_t)0x0004)            /*!<Bit 1 */
N//#define  SPI_I2SCFGR_CKPOL                   ((uint16_t)0x0008)            /*!<steady state clock polarity */
N//#define  SPI_I2SCFGR_I2SSTD                  ((uint16_t)0x0030)            /*!<I2SSTD[1:0] bits (I2S standard selection) */
N//#define  SPI_I2SCFGR_I2SSTD_0                ((uint16_t)0x0010)            /*!<Bit 0 */
N//#define  SPI_I2SCFGR_I2SSTD_1                ((uint16_t)0x0020)            /*!<Bit 1 */
N//#define  SPI_I2SCFGR_PCMSYNC                 ((uint16_t)0x0080)            /*!<PCM frame synchronization */
N//#define  SPI_I2SCFGR_I2SCFG                  ((uint16_t)0x0300)            /*!<I2SCFG[1:0] bits (I2S configuration mode) */
N//#define  SPI_I2SCFGR_I2SCFG_0                ((uint16_t)0x0100)            /*!<Bit 0 */
N//#define  SPI_I2SCFGR_I2SCFG_1                ((uint16_t)0x0200)            /*!<Bit 1 */
N//#define  SPI_I2SCFGR_I2SE                    ((uint16_t)0x0400)            /*!<I2S Enable */
N//#define  SPI_I2SCFGR_I2SMOD                  ((uint16_t)0x0800)            /*!<I2S mode selection */
N
N/******************  Bit definition for SPI_I2SPR register  *******************/
N//#define  SPI_I2SPR_I2SDIV                    ((uint16_t)0x00FF)            /*!<I2S Linear prescaler */
N//#define  SPI_I2SPR_ODD                       ((uint16_t)0x0100)            /*!<Odd factor for the prescaler */
N//#define  SPI_I2SPR_MCKOE                     ((uint16_t)0x0200)            /*!<Master Clock Output Enable */
N
N/******************************************************************************/
N/*                                                                            */
N/*                       System Configuration (SYSCFG)                        */
N/*                                                                            */
N/******************************************************************************/
N/*****************  Bit definition for SYSCFG_CFGR1 register  ****************/
N#define SYSCFG_CFGR1_MEM_MODE               ((uint32_t)0x00000003) /*!< SYSCFG_Memory Remap Config */
N#define SYSCFG_CFGR1_MEM_MODE_0             ((uint32_t)0x00000001) /*!< SYSCFG_Memory Remap Config Bit 0 */
N#define SYSCFG_CFGR1_MEM_MODE_1             ((uint32_t)0x00000002) /*!< SYSCFG_Memory Remap Config Bit 1 */
N#define SYSCFG_CFGR1_IRDA_ENV_SEL           ((uint32_t)0x000000C0) /*!< IRDA_SEL_ENV config */
N#define SYSCFG_CFGR1_IRDA_ENV_SEL_0         ((uint32_t)0x00000040) /*!< IRDA_SEL_ENV Bit 0 */
N#define SYSCFG_CFGR1_IRDA_ENV_SEL_1         ((uint32_t)0x00000080) /*!< IRDA_SEL_ENV Bit 1 */
N//#define SYSCFG_CFGR1_PA11_PA12_RMP          ((uint32_t)0x00000010) /*!< PA11 and PA12 remap on QFN28 and TSSOP20 packages*/
N#define SYSCFG_CFGR1_ADC_DMA_RMP            ((uint32_t)0x00000100) /*!< ADC DMA remap */
N#define SYSCFG_CFGR1_USART1TX_DMA_RMP       ((uint32_t)0x00000200) /*!< USART1 TX DMA remap */
N#define SYSCFG_CFGR1_USART1RX_DMA_RMP       ((uint32_t)0x00000400) /*!< USART1 RX DMA remap */
N#define SYSCFG_CFGR1_TIM16_DMA_RMP          ((uint32_t)0x00000800) /*!< Timer 16 DMA remap */
N#define SYSCFG_CFGR1_TIM17_DMA_RMP          ((uint32_t)0x00001000) /*!< Timer 17 DMA remap */
N//#define SYSCFG_CFGR1_TIM16_DMA_RMP2         ((uint32_t)0x00002000) /*!< Timer 16 DMA remap 2 (only for FT32F072X8) */
N//#define SYSCFG_CFGR1_TIM17_DMA_RMP2         ((uint32_t)0x00004000) /*!< Timer 17 DMA remap 2 (only for FT32F072X8) */
N#define SYSCFG_CFGR1_I2C_PB6_FMP            ((uint32_t)0x00010000) /*!< I2C PB6 Fast mode plus */
N#define SYSCFG_CFGR1_I2C_PB7_FMP            ((uint32_t)0x00020000) /*!< I2C PB7 Fast mode plus */
N#define SYSCFG_CFGR1_I2C_PB8_FMP            ((uint32_t)0x00040000) /*!< I2C PB8 Fast mode plus */
N#define SYSCFG_CFGR1_I2C_PB9_FMP            ((uint32_t)0x00080000) /*!< I2C PB9 Fast mode plus */
N#define SYSCFG_CFGR1_I2C1_FMP               ((uint32_t)0x00100000) /*!< I2C PB9 Fast mode plus */
N//#define SYSCFG_CFGR1_I2C_FMP_I2C1           ((uint32_t)0x00100000) /*!< Enable Fast Mode Plus on PB10, PB11, PF6 and PF7(only for FT32F072X8 devices) */
N//#define SYSCFG_CFGR1_I2C_FMP_I2C2           ((uint32_t)0x00200000) /*!< Enable I2C2 Fast mode plus (only for FT32F072X8) */
N//#define SYSCFG_CFGR1_I2C_FMP_PA9            ((uint32_t)0x00400000) /*!< Enable Fast Mode Plus on PA9 (only for FT32F072X8devices) */
N//#define SYSCFG_CFGR1_I2C_FMP_PA10           ((uint32_t)0x00800000) /*!< Enable Fast Mode Plus on PA10(only for FT32F072X8devices) */
N//#define SYSCFG_CFGR1_SPI2_DMA_RMP           ((uint32_t)0x01000000) /*!< SPI2 DMA remap (only for FT32F072X8) */
N//#define SYSCFG_CFGR1_USART2_DMA_RMP         ((uint32_t)0x02000000) /*!< USART2 DMA remap (only for FT32F072X8) */
N//#define SYSCFG_CFGR1_USART3_DMA_RMP         ((uint32_t)0x04000000) /*!< USART3 DMA remap (only for FT32F072X8) */
N//#define SYSCFG_CFGR1_I2C1_DMA_RMP           ((uint32_t)0x08000000) /*!< I2C1 DMA remap (only for FT32F072X8) */
N//#define SYSCFG_CFGR1_TIM1_DMA_RMP           ((uint32_t)0x10000000) /*!< TIM1 DMA remap (only for FT32F072X8) */
N//#define SYSCFG_CFGR1_TIM2_DMA_RMP           ((uint32_t)0x20000000) /*!< TIM2 DMA remap (only for FT32F072X8) */
N//#define SYSCFG_CFGR1_TIM3_DMA_RMP           ((uint32_t)0x40000000) /*!< TIM3 DMA remap (only for FT32F072X8) */
N
N
N/* Old bit definition maintained for legacy purpose */
N#define SYSCFG_CFGR1_I2C_FMP_PB6               SYSCFG_CFGR1_I2C_PB6_FMP
N#define SYSCFG_CFGR1_I2C_FMP_PB7               SYSCFG_CFGR1_I2C_PB7_FMP
N#define SYSCFG_CFGR1_I2C_FMP_PB8               SYSCFG_CFGR1_I2C_PB8_FMP
N#define SYSCFG_CFGR1_I2C_FMP_PB9               SYSCFG_CFGR1_I2C_PB9_FMP
N
N
N
N/*****************  Bit definition for SYSCFG_EXTICR1 register  ***************/
N#define SYSCFG_EXTICR1_EXTI0            ((uint16_t)0x000F) /*!< EXTI 0 configuration */
N#define SYSCFG_EXTICR1_EXTI1            ((uint16_t)0x00F0) /*!< EXTI 1 configuration */
N#define SYSCFG_EXTICR1_EXTI2            ((uint16_t)0x0F00) /*!< EXTI 2 configuration */
N#define SYSCFG_EXTICR1_EXTI3            ((uint16_t)0xF000) /*!< EXTI 3 configuration */
N
N/** 
N  * @brief  EXTI0 configuration  
N  */
N#define SYSCFG_EXTICR1_EXTI0_PA         ((uint16_t)0x0000) /*!< PA[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PB         ((uint16_t)0x0001) /*!< PB[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PC         ((uint16_t)0x0002) /*!< PC[0] pin */
N//#define SYSCFG_EXTICR1_EXTI0_PD         ((uint16_t)0x0003) /*!< PD[0] pin */
N//#define SYSCFG_EXTICR1_EXTI0_PE         ((uint16_t)0x0004) /*!< PE[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PF         ((uint16_t)0x0005) /*!< PF[0] pin */
N
N/** 
N  * @brief  EXTI1 configuration  
N  */ 
N#define SYSCFG_EXTICR1_EXTI1_PA         ((uint16_t)0x0000) /*!< PA[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PB         ((uint16_t)0x0010) /*!< PB[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PC         ((uint16_t)0x0020) /*!< PC[1] pin */
N//#define SYSCFG_EXTICR1_EXTI1_PD         ((uint16_t)0x0030) /*!< PD[1] pin */
N//#define SYSCFG_EXTICR1_EXTI1_PE         ((uint16_t)0x0040) /*!< PE[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PF         ((uint16_t)0x0050) /*!< PF[1] pin */
N
N/** 
N  * @brief  EXTI2 configuration  
N  */
N#define SYSCFG_EXTICR1_EXTI2_PA         ((uint16_t)0x0000) /*!< PA[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PB         ((uint16_t)0x0100) /*!< PB[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PC         ((uint16_t)0x0200) /*!< PC[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PD         ((uint16_t)0x0300) /*!< PD[2] pin */
N//#define SYSCFG_EXTICR1_EXTI2_PE         ((uint16_t)0x0400) /*!< PE[2] pin */
N//#define SYSCFG_EXTICR1_EXTI2_PF         ((uint16_t)0x0500) /*!< PF[2] pin */
N
N/** 
N  * @brief  EXTI3 configuration  
N  */
N#define SYSCFG_EXTICR1_EXTI3_PA         ((uint16_t)0x0000) /*!< PA[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PB         ((uint16_t)0x1000) /*!< PB[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PC         ((uint16_t)0x2000) /*!< PC[3] pin */
N//#define SYSCFG_EXTICR1_EXTI3_PD         ((uint16_t)0x3000) /*!< PD[3] pin */
N//#define SYSCFG_EXTICR1_EXTI3_PE         ((uint16_t)0x4000) /*!< PE[3] pin */
N//#define SYSCFG_EXTICR1_EXTI3_PF         ((uint16_t)0x5000) /*!< PF[3] pin */
N
N/*****************  Bit definition for SYSCFG_EXTICR2 register  *****************/
N#define SYSCFG_EXTICR2_EXTI4            ((uint16_t)0x000F) /*!< EXTI 4 configuration */
N#define SYSCFG_EXTICR2_EXTI5            ((uint16_t)0x00F0) /*!< EXTI 5 configuration */
N#define SYSCFG_EXTICR2_EXTI6            ((uint16_t)0x0F00) /*!< EXTI 6 configuration */
N#define SYSCFG_EXTICR2_EXTI7            ((uint16_t)0xF000) /*!< EXTI 7 configuration */
N
N/** 
N  * @brief  EXTI4 configuration  
N  */
N#define SYSCFG_EXTICR2_EXTI4_PA         ((uint16_t)0x0000) /*!< PA[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PB         ((uint16_t)0x0001) /*!< PB[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PC         ((uint16_t)0x0002) /*!< PC[4] pin */
N//#define SYSCFG_EXTICR2_EXTI4_PD         ((uint16_t)0x0003) /*!< PD[4] pin */
N//#define SYSCFG_EXTICR2_EXTI4_PE         ((uint16_t)0x0004) /*!< PE[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PF         ((uint16_t)0x0005) /*!< PF[4] pin */
N
N/** 
N  * @brief  EXTI5 configuration  
N  */
N#define SYSCFG_EXTICR2_EXTI5_PA         ((uint16_t)0x0000) /*!< PA[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PB         ((uint16_t)0x0010) /*!< PB[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PC         ((uint16_t)0x0020) /*!< PC[5] pin */
N//#define SYSCFG_EXTICR2_EXTI5_PD         ((uint16_t)0x0030) /*!< PD[5] pin */
N//#define SYSCFG_EXTICR2_EXTI5_PE         ((uint16_t)0x0040) /*!< PE[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PF         ((uint16_t)0x0050) /*!< PF[5] pin */
N
N/** 
N  * @brief  EXTI6 configuration  
N  */
N#define SYSCFG_EXTICR2_EXTI6_PA         ((uint16_t)0x0000) /*!< PA[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PB         ((uint16_t)0x0100) /*!< PB[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PC         ((uint16_t)0x0200) /*!< PC[6] pin */
N//#define SYSCFG_EXTICR2_EXTI6_PD         ((uint16_t)0x0300) /*!< PD[6] pin */
N//#define SYSCFG_EXTICR2_EXTI6_PE         ((uint16_t)0x0400) /*!< PE[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PF         ((uint16_t)0x0500) /*!< PF[6] pin */
N
N/** 
N  * @brief  EXTI7 configuration  
N  */
N#define SYSCFG_EXTICR2_EXTI7_PA         ((uint16_t)0x0000) /*!< PA[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PB         ((uint16_t)0x1000) /*!< PB[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PC         ((uint16_t)0x2000) /*!< PC[7] pin */
N//#define SYSCFG_EXTICR2_EXTI7_PD         ((uint16_t)0x3000) /*!< PD[7] pin */
N//#define SYSCFG_EXTICR2_EXTI7_PE         ((uint16_t)0x4000) /*!< PE[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PF         ((uint16_t)0x5000) /*!< PF[7] pin */
N
N/*****************  Bit definition for SYSCFG_EXTICR3 register  *****************/
N#define SYSCFG_EXTICR3_EXTI8            ((uint16_t)0x000F) /*!< EXTI 8 configuration */
N#define SYSCFG_EXTICR3_EXTI9            ((uint16_t)0x00F0) /*!< EXTI 9 configuration */
N#define SYSCFG_EXTICR3_EXTI10           ((uint16_t)0x0F00) /*!< EXTI 10 configuration */
N#define SYSCFG_EXTICR3_EXTI11           ((uint16_t)0xF000) /*!< EXTI 11 configuration */
N
N/** 
N  * @brief  EXTI8 configuration  
N  */
N#define SYSCFG_EXTICR3_EXTI8_PA         ((uint16_t)0x0000) /*!< PA[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PB         ((uint16_t)0x0001) /*!< PB[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PC         ((uint16_t)0x0002) /*!< PC[8] pin */
N//#define SYSCFG_EXTICR3_EXTI8_PD         ((uint16_t)0x0003) /*!< PD[8] pin */
N//#define SYSCFG_EXTICR3_EXTI8_PE         ((uint16_t)0x0004) /*!< PE[8] pin */
N
N/** 
N  * @brief  EXTI9 configuration  
N  */
N#define SYSCFG_EXTICR3_EXTI9_PA         ((uint16_t)0x0000) /*!< PA[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PB         ((uint16_t)0x0010) /*!< PB[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PC         ((uint16_t)0x0020) /*!< PC[9] pin */
N//#define SYSCFG_EXTICR3_EXTI9_PD         ((uint16_t)0x0030) /*!< PD[9] pin */
N//#define SYSCFG_EXTICR3_EXTI9_PE         ((uint16_t)0x0040) /*!< PE[9] pin */
N//#define SYSCFG_EXTICR3_EXTI9_PF         ((uint16_t)0x0050) /*!< PF[9] pin */
N
N/** 
N  * @brief  EXTI10 configuration  
N  */
N#define SYSCFG_EXTICR3_EXTI10_PA        ((uint16_t)0x0000) /*!< PA[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PB        ((uint16_t)0x0100) /*!< PB[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PC        ((uint16_t)0x0200) /*!< PC[10] pin */
N//#define SYSCFG_EXTICR3_EXTI10_PD        ((uint16_t)0x0300) /*!< PE[10] pin */
N//#define SYSCFG_EXTICR3_EXTI10_PE        ((uint16_t)0x0400) /*!< PD[10] pin */
N//#define SYSCFG_EXTICR3_EXTI10_PF        ((uint16_t)0x0500) /*!< PF[10] pin */
N
N/** 
N  * @brief  EXTI11 configuration  
N  */
N#define SYSCFG_EXTICR3_EXTI11_PA        ((uint16_t)0x0000) /*!< PA[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PB        ((uint16_t)0x1000) /*!< PB[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PC        ((uint16_t)0x2000) /*!< PC[11] pin */
N//#define SYSCFG_EXTICR3_EXTI11_PD        ((uint16_t)0x3000) /*!< PD[11] pin */
N//#define SYSCFG_EXTICR3_EXTI11_PE        ((uint16_t)0x4000) /*!< PE[11] pin */
N
N/*****************  Bit definition for SYSCFG_EXTICR4 register  *****************/
N#define SYSCFG_EXTICR4_EXTI12           ((uint16_t)0x000F) /*!< EXTI 12 configuration */
N#define SYSCFG_EXTICR4_EXTI13           ((uint16_t)0x00F0) /*!< EXTI 13 configuration */
N#define SYSCFG_EXTICR4_EXTI14           ((uint16_t)0x0F00) /*!< EXTI 14 configuration */
N#define SYSCFG_EXTICR4_EXTI15           ((uint16_t)0xF000) /*!< EXTI 15 configuration */
N
N/** 
N  * @brief  EXTI12 configuration  
N  */
N#define SYSCFG_EXTICR4_EXTI12_PA        ((uint16_t)0x0000) /*!< PA[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PB        ((uint16_t)0x0001) /*!< PB[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PC        ((uint16_t)0x0002) /*!< PC[12] pin */
N//#define SYSCFG_EXTICR4_EXTI12_PD        ((uint16_t)0x0003) /*!< PD[12] pin */
N//#define SYSCFG_EXTICR4_EXTI12_PE        ((uint16_t)0x0004) /*!< PE[12] pin */
N
N/** 
N  * @brief  EXTI13 configuration  
N  */
N#define SYSCFG_EXTICR4_EXTI13_PA        ((uint16_t)0x0000) /*!< PA[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PB        ((uint16_t)0x0010) /*!< PB[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PC        ((uint16_t)0x0020) /*!< PC[13] pin */
N//#define SYSCFG_EXTICR4_EXTI13_PD        ((uint16_t)0x0030) /*!< PD[13] pin */
N//#define SYSCFG_EXTICR4_EXTI13_PE        ((uint16_t)0x0040) /*!< PE[13] pin */
N
N/** 
N  * @brief  EXTI14 configuration  
N  */
N#define SYSCFG_EXTICR4_EXTI14_PA        ((uint16_t)0x0000) /*!< PA[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PB        ((uint16_t)0x0100) /*!< PB[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PC        ((uint16_t)0x0200) /*!< PC[14] pin */
N//#define SYSCFG_EXTICR4_EXTI14_PD        ((uint16_t)0x0300) /*!< PD[14] pin */
N//#define SYSCFG_EXTICR4_EXTI14_PE        ((uint16_t)0x0400) /*!< PE[14] pin */
N
N/** 
N  * @brief  EXTI15 configuration  
N  */
N#define SYSCFG_EXTICR4_EXTI15_PA        ((uint16_t)0x0000) /*!< PA[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PB        ((uint16_t)0x1000) /*!< PB[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PC        ((uint16_t)0x2000) /*!< PC[15] pin */
N//#define SYSCFG_EXTICR4_EXTI15_PD        ((uint16_t)0x3000) /*!< PD[15] pin */
N//#define SYSCFG_EXTICR4_EXTI15_PE        ((uint16_t)0x4000) /*!< PE[15] pin */
N
N/*****************  Bit definition for SYSCFG_CFGR2 register  ****************/
N#define SYSCFG_CFGR2_LOCKUP_LOCK               ((uint32_t)0x00000001) /*!< Enables and locks the PVD connection with Timer1 Break Input and also the PVD_EN and PVDSEL[2:0] bits of the Power Control Interface */
N#define SYSCFG_CFGR2_PVD_LOCK                  ((uint32_t)0x00000004) /*!< Enables and locks the LOCKUP (Hardfault) output of CortexM0 with Break Input of TIMER1 */
N
N/* Old Bit definition maintained for legacy purpose */
N
N
N/*****************  Bit definition for SYSCFG_xxx ISR Wrapper register  ****************/
N//#define SYSCFG_ITLINE0_SR_EWDG                ((uint32_t)0x00000001) /*!< EWDG interrupt */
N//#define SYSCFG_ITLINE1_SR_PVDOUT              ((uint32_t)0x00000001) /*!< Power voltage detection -> exti[31] Interrupt */
N//#define SYSCFG_ITLINE1_SR_VDDIO2              ((uint32_t)0x00000002) /*!< VDDIO2 -> exti[16] Interrupt */
N//#define SYSCFG_ITLINE2_SR_RTC_WAKEUP          ((uint32_t)0x00000001) /*!< RTC WAKEUP -> exti[20] Interrupt */
N//#define SYSCFG_ITLINE2_SR_RTC_TSTAMP          ((uint32_t)0x00000002) /*!< RTC Time Stamp -> exti[19] interrupt */
N//#define SYSCFG_ITLINE2_SR_RTC_ALRA            ((uint32_t)0x00000003) /*!< RTC Alarm -> exti[17] interrupt .... */
N//#define SYSCFG_ITLINE3_SR_FLASH_ITF           ((uint32_t)0x00000001) /*!< Flash ITF Interrupt */
N//#define SYSCFG_ITLINE4_SR_CRS                 ((uint32_t)0x00000001) /*!< CRS interrupt */
N//#define SYSCFG_ITLINE4_SR_CLK_CTRL            ((uint32_t)0x00000002) /*!< CLK CTRL interrupt */
N//#define SYSCFG_ITLINE5_SR_EXTI0               ((uint32_t)0x00000001) /*!< External Interrupt 0 */
N//#define SYSCFG_ITLINE5_SR_EXTI1               ((uint32_t)0x00000002) /*!< External Interrupt 1 */
N//#define SYSCFG_ITLINE6_SR_EXTI2               ((uint32_t)0x00000001) /*!< External Interrupt 2 */
N//#define SYSCFG_ITLINE6_SR_EXTI3               ((uint32_t)0x00000002) /*!< External Interrupt 3 */
N//#define SYSCFG_ITLINE7_SR_EXTI4               ((uint32_t)0x00000001) /*!< External Interrupt 15 to 4 */
N//#define SYSCFG_ITLINE7_SR_EXTI5               ((uint32_t)0x00000002) /*!< External Interrupt 15 to 4 */
N//#define SYSCFG_ITLINE7_SR_EXTI6               ((uint32_t)0x00000004) /*!< External Interrupt 15 to 4 */
N//#define SYSCFG_ITLINE7_SR_EXTI7               ((uint32_t)0x00000008) /*!< External Interrupt 15 to 4 */
N//#define SYSCFG_ITLINE7_SR_EXTI8               ((uint32_t)0x00000010) /*!< External Interrupt 15 to 4 */
N//#define SYSCFG_ITLINE7_SR_EXTI9               ((uint32_t)0x00000020) /*!< External Interrupt 15 to 4 */
N//#define SYSCFG_ITLINE7_SR_EXTI10              ((uint32_t)0x00000040) /*!< External Interrupt 15 to 4 */
N//#define SYSCFG_ITLINE7_SR_EXTI11              ((uint32_t)0x00000080) /*!< External Interrupt 15 to 4 */
N//#define SYSCFG_ITLINE7_SR_EXTI12              ((uint32_t)0x00000100) /*!< External Interrupt 15 to 4 */
N//#define SYSCFG_ITLINE7_SR_EXTI13              ((uint32_t)0x00000200) /*!< External Interrupt 15 to 4 */
N//#define SYSCFG_ITLINE7_SR_EXTI14              ((uint32_t)0x00000400) /*!< External Interrupt 15 to 4 */
N//#define SYSCFG_ITLINE7_SR_EXTI15              ((uint32_t)0x00000800) /*!< External Interrupt 15 to 4 */
N//#define SYSCFG_ITLINE8_SR_TSC_EOA             ((uint32_t)0x00000001) /*!< Touch control EOA Interrupt */
N//#define SYSCFG_ITLINE8_SR_TSC_MCE             ((uint32_t)0x00000002) /*!< Touch control MCE Interrupt */
N//#define SYSCFG_ITLINE9_SR_DMA1_CH1            ((uint32_t)0x00000001) /*!< DMA1 Channel 1 Interrupt */
N//#define SYSCFG_ITLINE10_SR_DMA1_CH2           ((uint32_t)0x00000001) /*!< DMA1 Channel 2 Interrupt */
N//#define SYSCFG_ITLINE10_SR_DMA1_CH3           ((uint32_t)0x00000002) /*!< DMA2 Channel 3 Interrupt */
N//#define SYSCFG_ITLINE10_SR_DMA2_CH1           ((uint32_t)0x00000004) /*!< DMA2 Channel 1 Interrupt */
N//#define SYSCFG_ITLINE10_SR_DMA2_CH2           ((uint32_t)0x00000008) /*!< DMA2 Channel 2 Interrupt */
N//#define SYSCFG_ITLINE11_SR_DMA1_CH4           ((uint32_t)0x00000001) /*!< DMA1 Channel 4 Interrupt */
N//#define SYSCFG_ITLINE11_SR_DMA1_CH5           ((uint32_t)0x00000002) /*!< DMA1 Channel 5 Interrupt */
N//#define SYSCFG_ITLINE11_SR_DMA1_CH6           ((uint32_t)0x00000004) /*!< DMA1 Channel 6 Interrupt */
N//#define SYSCFG_ITLINE11_SR_DMA1_CH7           ((uint32_t)0x00000008) /*!< DMA1 Channel 7 Interrupt */
N//#define SYSCFG_ITLINE11_SR_DMA2_CH3           ((uint32_t)0x00000010) /*!< DMA2 Channel 3 Interrupt */
N//#define SYSCFG_ITLINE11_SR_DMA2_CH4           ((uint32_t)0x00000020) /*!< DMA2 Channel 4 Interrupt */
N//#define SYSCFG_ITLINE11_SR_DMA2_CH5           ((uint32_t)0x00000040) /*!< DMA2 Channel 5 Interrupt */
N//#define SYSCFG_ITLINE12_SR_ADC                ((uint32_t)0x00000001) /*!< ADC Interrupt */
N//#define SYSCFG_ITLINE12_SR_COMP1              ((uint32_t)0x00000002) /*!< COMP1 Interrupt -> exti[21] */
N//#define SYSCFG_ITLINE12_SR_COMP2              ((uint32_t)0x00000004) /*!< COMP2 Interrupt -> exti[22] */
N//#define SYSCFG_ITLINE13_SR_TIM1_BRK           ((uint32_t)0x00000001) /*!< TIM1 BRK Interrupt */
N//#define SYSCFG_ITLINE13_SR_TIM1_UPD           ((uint32_t)0x00000002) /*!< TIM1 UPD Interrupt */
N//#define SYSCFG_ITLINE13_SR_TIM1_TRG           ((uint32_t)0x00000004) /*!< TIM1 TRG Interrupt */
N//#define SYSCFG_ITLINE13_SR_TIM1_CCU           ((uint32_t)0x00000008) /*!< TIM1 CCU Interrupt */
N//#define SYSCFG_ITLINE14_SR_TIM1_CC            ((uint32_t)0x00000001) /*!< TIM1 CC Interrupt */
N//#define SYSCFG_ITLINE15_SR_TIM2_GLB           ((uint32_t)0x00000001) /*!< TIM2 GLB Interrupt */
N//#define SYSCFG_ITLINE16_SR_TIM3_GLB           ((uint32_t)0x00000001) /*!< TIM3 GLB Interrupt */
N//#define SYSCFG_ITLINE17_SR_DAC                ((uint32_t)0x00000001) /*!< DAC Interrupt */
N//#define SYSCFG_ITLINE17_SR_TIM6_GLB           ((uint32_t)0x00000002) /*!< TIM6 GLB Interrupt */
N//#define SYSCFG_ITLINE18_SR_TIM7_GLB           ((uint32_t)0x00000001) /*!< TIM7 GLB Interrupt */
N//#define SYSCFG_ITLINE19_SR_TIM14_GLB          ((uint32_t)0x00000001) /*!< TIM14 GLB Interrupt */
N//#define SYSCFG_ITLINE20_SR_TIM15_GLB          ((uint32_t)0x00000001) /*!< TIM15 GLB Interrupt */
N//#define SYSCFG_ITLINE21_SR_TIM16_GLB          ((uint32_t)0x00000001) /*!< TIM16 GLB Interrupt */
N//#define SYSCFG_ITLINE22_SR_TIM17_GLB          ((uint32_t)0x00000001) /*!< TIM17 GLB Interrupt */
N//#define SYSCFG_ITLINE23_SR_I2C1_GLB           ((uint32_t)0x00000001) /*!< I2C1 GLB Interrupt -> exti[23] */
N//#define SYSCFG_ITLINE24_SR_I2C2_GLB           ((uint32_t)0x00000001) /*!< I2C2 GLB Interrupt */
N//#define SYSCFG_ITLINE25_SR_SPI1               ((uint32_t)0x00000001) /*!< SPI1 Interrupt */
N//#define SYSCFG_ITLINE26_SR_SPI2               ((uint32_t)0x00000001) /*!< SPI2  Interrupt */
N//#define SYSCFG_ITLINE27_SR_USART1_GLB         ((uint32_t)0x00000001) /*!< USART1 GLB Interrupt -> exti[25] */
N//#define SYSCFG_ITLINE28_SR_USART2_GLB         ((uint32_t)0x00000001) /*!< USART2 GLB Interrupt -> exti[26] */
N//#define SYSCFG_ITLINE29_SR_USART3_GLB         ((uint32_t)0x00000001) /*!< USART3 GLB Interrupt -> exti[28] */
N//#define SYSCFG_ITLINE29_SR_USART4_GLB         ((uint32_t)0x00000002) /*!< USART4 GLB Interrupt */
N//#define SYSCFG_ITLINE29_SR_USART5_GLB         ((uint32_t)0x00000004) /*!< USART5 GLB Interrupt */
N//#define SYSCFG_ITLINE29_SR_USART6_GLB         ((uint32_t)0x00000008) /*!< USART6 GLB Interrupt */
N//#define SYSCFG_ITLINE29_SR_USART7_GLB         ((uint32_t)0x00000010) /*!< USART7 GLB Interrupt */
N//#define SYSCFG_ITLINE29_SR_USART8_GLB         ((uint32_t)0x00000020) /*!< USART8 GLB Interrupt */
N//#define SYSCFG_ITLINE30_SR_CAN                ((uint32_t)0x00000001) /*!< CAN Interrupt */
N//#define SYSCFG_ITLINE30_SR_CEC                ((uint32_t)0x00000002) /*!< CEC Interrupt */
N
N/******************************************************************************/
N/*                                                                            */
N/*                               Timers (TIM)                                 */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for TIM_CR1 register  ********************/
N#define  TIM_CR1_CEN                         ((uint16_t)0x0001)            /*!<Counter enable */
N#define  TIM_CR1_UDIS                        ((uint16_t)0x0002)            /*!<Update disable */
N#define  TIM_CR1_URS                         ((uint16_t)0x0004)            /*!<Update request source */
N#define  TIM_CR1_OPM                         ((uint16_t)0x0008)            /*!<One pulse mode */
N#define  TIM_CR1_DIR                         ((uint16_t)0x0010)            /*!<Direction */
N
N#define  TIM_CR1_CMS                         ((uint16_t)0x0060)            /*!<CMS[1:0] bits (Center-aligned mode selection) */
N#define  TIM_CR1_CMS_0                       ((uint16_t)0x0020)            /*!<Bit 0 */
N#define  TIM_CR1_CMS_1                       ((uint16_t)0x0040)            /*!<Bit 1 */
N
N#define  TIM_CR1_ARPE                        ((uint16_t)0x0080)            /*!<Auto-reload preload enable */
N
N#define  TIM_CR1_CKD                         ((uint16_t)0x0300)            /*!<CKD[1:0] bits (clock division) */
N#define  TIM_CR1_CKD_0                       ((uint16_t)0x0100)            /*!<Bit 0 */
N#define  TIM_CR1_CKD_1                       ((uint16_t)0x0200)            /*!<Bit 1 */
N
N/*******************  Bit definition for TIM_CR2 register  ********************/
N#define  TIM_CR2_CCPC                        ((uint16_t)0x0001)            /*!<Capture/Compare Preloaded Control */
N#define  TIM_CR2_CCUS                        ((uint16_t)0x0004)            /*!<Capture/Compare Control Update Selection */
N#define  TIM_CR2_CCDS                        ((uint16_t)0x0008)            /*!<Capture/Compare DMA Selection */
N
N#define  TIM_CR2_MMS                         ((uint16_t)0x0070)            /*!<MMS[2:0] bits (Master Mode Selection) */
N#define  TIM_CR2_MMS_0                       ((uint16_t)0x0010)            /*!<Bit 0 */
N#define  TIM_CR2_MMS_1                       ((uint16_t)0x0020)            /*!<Bit 1 */
N#define  TIM_CR2_MMS_2                       ((uint16_t)0x0040)            /*!<Bit 2 */
N
N#define  TIM_CR2_TI1S                        ((uint16_t)0x0080)            /*!<TI1 Selection */
N#define  TIM_CR2_OIS1                        ((uint16_t)0x0100)            /*!<Output Idle state 1 (OC1 output) */
N#define  TIM_CR2_OIS1N                       ((uint16_t)0x0200)            /*!<Output Idle state 1 (OC1N output) */
N#define  TIM_CR2_OIS2                        ((uint16_t)0x0400)            /*!<Output Idle state 2 (OC2 output) */
N#define  TIM_CR2_OIS2N                       ((uint16_t)0x0800)            /*!<Output Idle state 2 (OC2N output) */
N#define  TIM_CR2_OIS3                        ((uint16_t)0x1000)            /*!<Output Idle state 3 (OC3 output) */
N#define  TIM_CR2_OIS3N                       ((uint16_t)0x2000)            /*!<Output Idle state 3 (OC3N output) */
N#define  TIM_CR2_OIS4                        ((uint16_t)0x4000)            /*!<Output Idle state 4 (OC4 output) */
N
N/*******************  Bit definition for TIM_SMCR register  *******************/
N#define  TIM_SMCR_SMS                        ((uint16_t)0x0007)            /*!<SMS[2:0] bits (Slave mode selection) */
N#define  TIM_SMCR_SMS_0                      ((uint16_t)0x0001)            /*!<Bit 0 */
N#define  TIM_SMCR_SMS_1                      ((uint16_t)0x0002)            /*!<Bit 1 */
N#define  TIM_SMCR_SMS_2                      ((uint16_t)0x0004)            /*!<Bit 2 */
N
N#define  TIM_SMCR_OCCS                       ((uint16_t)0x0008)            /*!< OCREF clear selection */
N
N#define  TIM_SMCR_TS                         ((uint16_t)0x0070)            /*!<TS[2:0] bits (Trigger selection) */
N#define  TIM_SMCR_TS_0                       ((uint16_t)0x0010)            /*!<Bit 0 */
N#define  TIM_SMCR_TS_1                       ((uint16_t)0x0020)            /*!<Bit 1 */
N#define  TIM_SMCR_TS_2                       ((uint16_t)0x0040)            /*!<Bit 2 */
N
N#define  TIM_SMCR_MSM                        ((uint16_t)0x0080)            /*!<Master/slave mode */
N
N#define  TIM_SMCR_ETF                        ((uint16_t)0x0F00)            /*!<ETF[3:0] bits (External trigger filter) */
N#define  TIM_SMCR_ETF_0                      ((uint16_t)0x0100)            /*!<Bit 0 */
N#define  TIM_SMCR_ETF_1                      ((uint16_t)0x0200)            /*!<Bit 1 */
N#define  TIM_SMCR_ETF_2                      ((uint16_t)0x0400)            /*!<Bit 2 */
N#define  TIM_SMCR_ETF_3                      ((uint16_t)0x0800)            /*!<Bit 3 */
N
N#define  TIM_SMCR_ETPS                       ((uint16_t)0x3000)            /*!<ETPS[1:0] bits (External trigger prescaler) */
N#define  TIM_SMCR_ETPS_0                     ((uint16_t)0x1000)            /*!<Bit 0 */
N#define  TIM_SMCR_ETPS_1                     ((uint16_t)0x2000)            /*!<Bit 1 */
N
N#define  TIM_SMCR_ECE                        ((uint16_t)0x4000)            /*!<External clock enable */
N#define  TIM_SMCR_ETP                        ((uint16_t)0x8000)            /*!<External trigger polarity */
N
N/*******************  Bit definition for TIM_DIER register  *******************/
N#define  TIM_DIER_UIE                        ((uint16_t)0x0001)            /*!<Update interrupt enable */
N#define  TIM_DIER_CC1IE                      ((uint16_t)0x0002)            /*!<Capture/Compare 1 interrupt enable */
N#define  TIM_DIER_CC2IE                      ((uint16_t)0x0004)            /*!<Capture/Compare 2 interrupt enable */
N#define  TIM_DIER_CC3IE                      ((uint16_t)0x0008)            /*!<Capture/Compare 3 interrupt enable */
N#define  TIM_DIER_CC4IE                      ((uint16_t)0x0010)            /*!<Capture/Compare 4 interrupt enable */
N#define  TIM_DIER_COMIE                      ((uint16_t)0x0020)            /*!<COM interrupt enable */
N#define  TIM_DIER_TIE                        ((uint16_t)0x0040)            /*!<Trigger interrupt enable */
N#define  TIM_DIER_BIE                        ((uint16_t)0x0080)            /*!<Break interrupt enable */
N#define  TIM_DIER_UDE                        ((uint16_t)0x0100)            /*!<Update DMA request enable */
N#define  TIM_DIER_CC1DE                      ((uint16_t)0x0200)            /*!<Capture/Compare 1 DMA request enable */
N#define  TIM_DIER_CC2DE                      ((uint16_t)0x0400)            /*!<Capture/Compare 2 DMA request enable */
N#define  TIM_DIER_CC3DE                      ((uint16_t)0x0800)            /*!<Capture/Compare 3 DMA request enable */
N#define  TIM_DIER_CC4DE                      ((uint16_t)0x1000)            /*!<Capture/Compare 4 DMA request enable */
N#define  TIM_DIER_COMDE                      ((uint16_t)0x2000)            /*!<COM DMA request enable */
N#define  TIM_DIER_TDE                        ((uint16_t)0x4000)            /*!<Trigger DMA request enable */
N
N/********************  Bit definition for TIM_SR register  ********************/
N#define  TIM_SR_UIF                          ((uint16_t)0x0001)            /*!<Update interrupt Flag */
N#define  TIM_SR_CC1IF                        ((uint16_t)0x0002)            /*!<Capture/Compare 1 interrupt Flag */
N#define  TIM_SR_CC2IF                        ((uint16_t)0x0004)            /*!<Capture/Compare 2 interrupt Flag */
N#define  TIM_SR_CC3IF                        ((uint16_t)0x0008)            /*!<Capture/Compare 3 interrupt Flag */
N#define  TIM_SR_CC4IF                        ((uint16_t)0x0010)            /*!<Capture/Compare 4 interrupt Flag */
N#define  TIM_SR_COMIF                        ((uint16_t)0x0020)            /*!<COM interrupt Flag */
N#define  TIM_SR_TIF                          ((uint16_t)0x0040)            /*!<Trigger interrupt Flag */
N#define  TIM_SR_BIF                          ((uint16_t)0x0080)            /*!<Break interrupt Flag */
N#define  TIM_SR_CC1OF                        ((uint16_t)0x0200)            /*!<Capture/Compare 1 Overcapture Flag */
N#define  TIM_SR_CC2OF                        ((uint16_t)0x0400)            /*!<Capture/Compare 2 Overcapture Flag */
N#define  TIM_SR_CC3OF                        ((uint16_t)0x0800)            /*!<Capture/Compare 3 Overcapture Flag */
N#define  TIM_SR_CC4OF                        ((uint16_t)0x1000)            /*!<Capture/Compare 4 Overcapture Flag */
N
N/*******************  Bit definition for TIM_EGR register  ********************/
N#define  TIM_EGR_UG                          ((uint8_t)0x01)               /*!<Update Generation */
N#define  TIM_EGR_CC1G                        ((uint8_t)0x02)               /*!<Capture/Compare 1 Generation */
N#define  TIM_EGR_CC2G                        ((uint8_t)0x04)               /*!<Capture/Compare 2 Generation */
N#define  TIM_EGR_CC3G                        ((uint8_t)0x08)               /*!<Capture/Compare 3 Generation */
N#define  TIM_EGR_CC4G                        ((uint8_t)0x10)               /*!<Capture/Compare 4 Generation */
N#define  TIM_EGR_COMG                        ((uint8_t)0x20)               /*!<Capture/Compare Control Update Generation */
N#define  TIM_EGR_TG                          ((uint8_t)0x40)               /*!<Trigger Generation */
N#define  TIM_EGR_BG                          ((uint8_t)0x80)               /*!<Break Generation */
N
N/******************  Bit definition for TIM_CCMR1 register  *******************/
N#define  TIM_CCMR1_CC1S                      ((uint16_t)0x0003)            /*!<CC1S[1:0] bits (Capture/Compare 1 Selection) */
N#define  TIM_CCMR1_CC1S_0                    ((uint16_t)0x0001)            /*!<Bit 0 */
N#define  TIM_CCMR1_CC1S_1                    ((uint16_t)0x0002)            /*!<Bit 1 */
N
N#define  TIM_CCMR1_OC1FE                     ((uint16_t)0x0004)            /*!<Output Compare 1 Fast enable */
N#define  TIM_CCMR1_OC1PE                     ((uint16_t)0x0008)            /*!<Output Compare 1 Preload enable */
N
N#define  TIM_CCMR1_OC1M                      ((uint16_t)0x0070)            /*!<OC1M[2:0] bits (Output Compare 1 Mode) */
N#define  TIM_CCMR1_OC1M_0                    ((uint16_t)0x0010)            /*!<Bit 0 */
N#define  TIM_CCMR1_OC1M_1                    ((uint16_t)0x0020)            /*!<Bit 1 */
N#define  TIM_CCMR1_OC1M_2                    ((uint16_t)0x0040)            /*!<Bit 2 */
N
N#define  TIM_CCMR1_OC1CE                     ((uint16_t)0x0080)            /*!<Output Compare 1Clear Enable */
N
N#define  TIM_CCMR1_CC2S                      ((uint16_t)0x0300)            /*!<CC2S[1:0] bits (Capture/Compare 2 Selection) */
N#define  TIM_CCMR1_CC2S_0                    ((uint16_t)0x0100)            /*!<Bit 0 */
N#define  TIM_CCMR1_CC2S_1                    ((uint16_t)0x0200)            /*!<Bit 1 */
N
N#define  TIM_CCMR1_OC2FE                     ((uint16_t)0x0400)            /*!<Output Compare 2 Fast enable */
N#define  TIM_CCMR1_OC2PE                     ((uint16_t)0x0800)            /*!<Output Compare 2 Preload enable */
N
N#define  TIM_CCMR1_OC2M                      ((uint16_t)0x7000)            /*!<OC2M[2:0] bits (Output Compare 2 Mode) */
N#define  TIM_CCMR1_OC2M_0                    ((uint16_t)0x1000)            /*!<Bit 0 */
N#define  TIM_CCMR1_OC2M_1                    ((uint16_t)0x2000)            /*!<Bit 1 */
N#define  TIM_CCMR1_OC2M_2                    ((uint16_t)0x4000)            /*!<Bit 2 */
N
N#define  TIM_CCMR1_OC2CE                     ((uint16_t)0x8000)            /*!<Output Compare 2 Clear Enable */
N
N/*----------------------------------------------------------------------------*/
N
N#define  TIM_CCMR1_IC1PSC                    ((uint16_t)0x000C)            /*!<IC1PSC[1:0] bits (Input Capture 1 Prescaler) */
N#define  TIM_CCMR1_IC1PSC_0                  ((uint16_t)0x0004)            /*!<Bit 0 */
N#define  TIM_CCMR1_IC1PSC_1                  ((uint16_t)0x0008)            /*!<Bit 1 */
N
N#define  TIM_CCMR1_IC1F                      ((uint16_t)0x00F0)            /*!<IC1F[3:0] bits (Input Capture 1 Filter) */
N#define  TIM_CCMR1_IC1F_0                    ((uint16_t)0x0010)            /*!<Bit 0 */
N#define  TIM_CCMR1_IC1F_1                    ((uint16_t)0x0020)            /*!<Bit 1 */
N#define  TIM_CCMR1_IC1F_2                    ((uint16_t)0x0040)            /*!<Bit 2 */
N#define  TIM_CCMR1_IC1F_3                    ((uint16_t)0x0080)            /*!<Bit 3 */
N
N#define  TIM_CCMR1_IC2PSC                    ((uint16_t)0x0C00)            /*!<IC2PSC[1:0] bits (Input Capture 2 Prescaler) */
N#define  TIM_CCMR1_IC2PSC_0                  ((uint16_t)0x0400)            /*!<Bit 0 */
N#define  TIM_CCMR1_IC2PSC_1                  ((uint16_t)0x0800)            /*!<Bit 1 */
N
N#define  TIM_CCMR1_IC2F                      ((uint16_t)0xF000)            /*!<IC2F[3:0] bits (Input Capture 2 Filter) */
N#define  TIM_CCMR1_IC2F_0                    ((uint16_t)0x1000)            /*!<Bit 0 */
N#define  TIM_CCMR1_IC2F_1                    ((uint16_t)0x2000)            /*!<Bit 1 */
N#define  TIM_CCMR1_IC2F_2                    ((uint16_t)0x4000)            /*!<Bit 2 */
N#define  TIM_CCMR1_IC2F_3                    ((uint16_t)0x8000)            /*!<Bit 3 */
N
N/******************  Bit definition for TIM_CCMR2 register  *******************/
N#define  TIM_CCMR2_CC3S                      ((uint16_t)0x0003)            /*!<CC3S[1:0] bits (Capture/Compare 3 Selection) */
N#define  TIM_CCMR2_CC3S_0                    ((uint16_t)0x0001)            /*!<Bit 0 */
N#define  TIM_CCMR2_CC3S_1                    ((uint16_t)0x0002)            /*!<Bit 1 */
N
N#define  TIM_CCMR2_OC3FE                     ((uint16_t)0x0004)            /*!<Output Compare 3 Fast enable */
N#define  TIM_CCMR2_OC3PE                     ((uint16_t)0x0008)            /*!<Output Compare 3 Preload enable */
N
N#define  TIM_CCMR2_OC3M                      ((uint16_t)0x0070)            /*!<OC3M[2:0] bits (Output Compare 3 Mode) */
N#define  TIM_CCMR2_OC3M_0                    ((uint16_t)0x0010)            /*!<Bit 0 */
N#define  TIM_CCMR2_OC3M_1                    ((uint16_t)0x0020)            /*!<Bit 1 */
N#define  TIM_CCMR2_OC3M_2                    ((uint16_t)0x0040)            /*!<Bit 2 */
N
N#define  TIM_CCMR2_OC3CE                     ((uint16_t)0x0080)            /*!<Output Compare 3 Clear Enable */
N
N#define  TIM_CCMR2_CC4S                      ((uint16_t)0x0300)            /*!<CC4S[1:0] bits (Capture/Compare 4 Selection) */
N#define  TIM_CCMR2_CC4S_0                    ((uint16_t)0x0100)            /*!<Bit 0 */
N#define  TIM_CCMR2_CC4S_1                    ((uint16_t)0x0200)            /*!<Bit 1 */
N
N#define  TIM_CCMR2_OC4FE                     ((uint16_t)0x0400)            /*!<Output Compare 4 Fast enable */
N#define  TIM_CCMR2_OC4PE                     ((uint16_t)0x0800)            /*!<Output Compare 4 Preload enable */
N
N#define  TIM_CCMR2_OC4M                      ((uint16_t)0x7000)            /*!<OC4M[2:0] bits (Output Compare 4 Mode) */
N#define  TIM_CCMR2_OC4M_0                    ((uint16_t)0x1000)            /*!<Bit 0 */
N#define  TIM_CCMR2_OC4M_1                    ((uint16_t)0x2000)            /*!<Bit 1 */
N#define  TIM_CCMR2_OC4M_2                    ((uint16_t)0x4000)            /*!<Bit 2 */
N
N#define  TIM_CCMR2_OC4CE                     ((uint16_t)0x8000)            /*!<Output Compare 4 Clear Enable */
N
N/*----------------------------------------------------------------------------*/
N
N#define  TIM_CCMR2_IC3PSC                    ((uint16_t)0x000C)            /*!<IC3PSC[1:0] bits (Input Capture 3 Prescaler) */
N#define  TIM_CCMR2_IC3PSC_0                  ((uint16_t)0x0004)            /*!<Bit 0 */
N#define  TIM_CCMR2_IC3PSC_1                  ((uint16_t)0x0008)            /*!<Bit 1 */
N
N#define  TIM_CCMR2_IC3F                      ((uint16_t)0x00F0)            /*!<IC3F[3:0] bits (Input Capture 3 Filter) */
N#define  TIM_CCMR2_IC3F_0                    ((uint16_t)0x0010)            /*!<Bit 0 */
N#define  TIM_CCMR2_IC3F_1                    ((uint16_t)0x0020)            /*!<Bit 1 */
N#define  TIM_CCMR2_IC3F_2                    ((uint16_t)0x0040)            /*!<Bit 2 */
N#define  TIM_CCMR2_IC3F_3                    ((uint16_t)0x0080)            /*!<Bit 3 */
N
N#define  TIM_CCMR2_IC4PSC                    ((uint16_t)0x0C00)            /*!<IC4PSC[1:0] bits (Input Capture 4 Prescaler) */
N#define  TIM_CCMR2_IC4PSC_0                  ((uint16_t)0x0400)            /*!<Bit 0 */
N#define  TIM_CCMR2_IC4PSC_1                  ((uint16_t)0x0800)            /*!<Bit 1 */
N
N#define  TIM_CCMR2_IC4F                      ((uint16_t)0xF000)            /*!<IC4F[3:0] bits (Input Capture 4 Filter) */
N#define  TIM_CCMR2_IC4F_0                    ((uint16_t)0x1000)            /*!<Bit 0 */
N#define  TIM_CCMR2_IC4F_1                    ((uint16_t)0x2000)            /*!<Bit 1 */
N#define  TIM_CCMR2_IC4F_2                    ((uint16_t)0x4000)            /*!<Bit 2 */
N#define  TIM_CCMR2_IC4F_3                    ((uint16_t)0x8000)            /*!<Bit 3 */
N
N/*******************  Bit definition for TIM_CCER register  *******************/
N#define  TIM_CCER_CC1E                       ((uint16_t)0x0001)            /*!<Capture/Compare 1 output enable */
N#define  TIM_CCER_CC1P                       ((uint16_t)0x0002)            /*!<Capture/Compare 1 output Polarity */
N#define  TIM_CCER_CC1NE                      ((uint16_t)0x0004)            /*!<Capture/Compare 1 Complementary output enable */
N#define  TIM_CCER_CC1NP                      ((uint16_t)0x0008)            /*!<Capture/Compare 1 Complementary output Polarity */
N#define  TIM_CCER_CC2E                       ((uint16_t)0x0010)            /*!<Capture/Compare 2 output enable */
N#define  TIM_CCER_CC2P                       ((uint16_t)0x0020)            /*!<Capture/Compare 2 output Polarity */
N#define  TIM_CCER_CC2NE                      ((uint16_t)0x0040)            /*!<Capture/Compare 2 Complementary output enable */
N#define  TIM_CCER_CC2NP                      ((uint16_t)0x0080)            /*!<Capture/Compare 2 Complementary output Polarity */
N#define  TIM_CCER_CC3E                       ((uint16_t)0x0100)            /*!<Capture/Compare 3 output enable */
N#define  TIM_CCER_CC3P                       ((uint16_t)0x0200)            /*!<Capture/Compare 3 output Polarity */
N#define  TIM_CCER_CC3NE                      ((uint16_t)0x0400)            /*!<Capture/Compare 3 Complementary output enable */
N#define  TIM_CCER_CC3NP                      ((uint16_t)0x0800)            /*!<Capture/Compare 3 Complementary output Polarity */
N#define  TIM_CCER_CC4E                       ((uint16_t)0x1000)            /*!<Capture/Compare 4 output enable */
N#define  TIM_CCER_CC4P                       ((uint16_t)0x2000)            /*!<Capture/Compare 4 output Polarity */
N/*******************  Bit definition for TIM_CNT register  ********************/
N#define  TIM_CNT_CNT                         ((uint16_t)0xFFFF)            /*!<Counter Value */
N
N/*******************  Bit definition for TIM_PSC register  ********************/
N#define  TIM_PSC_PSC                         ((uint16_t)0xFFFF)            /*!<Prescaler Value */
N
N/*******************  Bit definition for TIM_ARR register  ********************/
N#define  TIM_ARR_ARR                         ((uint16_t)0xFFFF)            /*!<actual auto-reload Value */
N
N/*******************  Bit definition for TIM_RCR register  ********************/
N#define  TIM_RCR_REP                         ((uint8_t)0xFF)               /*!<Repetition Counter Value */
N
N/*******************  Bit definition for TIM_CCR1 register  *******************/
N#define  TIM_CCR1_CCR1                       ((uint16_t)0xFFFF)            /*!<Capture/Compare 1 Value */
N
N/*******************  Bit definition for TIM_CCR2 register  *******************/
N#define  TIM_CCR2_CCR2                       ((uint16_t)0xFFFF)            /*!<Capture/Compare 2 Value */
N
N/*******************  Bit definition for TIM_CCR3 register  *******************/
N#define  TIM_CCR3_CCR3                       ((uint16_t)0xFFFF)            /*!<Capture/Compare 3 Value */
N
N/*******************  Bit definition for TIM_CCR4 register  *******************/
N#define  TIM_CCR4_CCR4                       ((uint16_t)0xFFFF)            /*!<Capture/Compare 4 Value */
N
N/*******************  Bit definition for TIM_BDTR register  *******************/
N#define  TIM_BDTR_DTG                        ((uint16_t)0x00FF)            /*!<DTG[0:7] bits (Dead-Time Generator set-up) */
N#define  TIM_BDTR_DTG_0                      ((uint16_t)0x0001)            /*!<Bit 0 */
N#define  TIM_BDTR_DTG_1                      ((uint16_t)0x0002)            /*!<Bit 1 */
N#define  TIM_BDTR_DTG_2                      ((uint16_t)0x0004)            /*!<Bit 2 */
N#define  TIM_BDTR_DTG_3                      ((uint16_t)0x0008)            /*!<Bit 3 */
N#define  TIM_BDTR_DTG_4                      ((uint16_t)0x0010)            /*!<Bit 4 */
N#define  TIM_BDTR_DTG_5                      ((uint16_t)0x0020)            /*!<Bit 5 */
N#define  TIM_BDTR_DTG_6                      ((uint16_t)0x0040)            /*!<Bit 6 */
N#define  TIM_BDTR_DTG_7                      ((uint16_t)0x0080)            /*!<Bit 7 */
N
N#define  TIM_BDTR_LOCK                       ((uint16_t)0x0300)            /*!<LOCK[1:0] bits (Lock Configuration) */
N#define  TIM_BDTR_LOCK_0                     ((uint16_t)0x0100)            /*!<Bit 0 */
N#define  TIM_BDTR_LOCK_1                     ((uint16_t)0x0200)            /*!<Bit 1 */
N
N#define  TIM_BDTR_OSSI                       ((uint16_t)0x0400)            /*!<Off-State Selection for Idle mode */
N#define  TIM_BDTR_OSSR                       ((uint16_t)0x0800)            /*!<Off-State Selection for Run mode */
N#define  TIM_BDTR_BKE                        ((uint16_t)0x1000)            /*!<Break enable */
N#define  TIM_BDTR_BKP                        ((uint16_t)0x2000)            /*!<Break Polarity */
N#define  TIM_BDTR_AOE                        ((uint16_t)0x4000)            /*!<Automatic Output enable */
N#define  TIM_BDTR_MOE                        ((uint16_t)0x8000)            /*!<Main Output enable */
N
N/*******************  Bit definition for TIM_DCR register  ********************/
N#define  TIM_DCR_DBA                         ((uint16_t)0x001F)            /*!<DBA[4:0] bits (DMA Base Address) */
N#define  TIM_DCR_DBA_0                       ((uint16_t)0x0001)            /*!<Bit 0 */
N#define  TIM_DCR_DBA_1                       ((uint16_t)0x0002)            /*!<Bit 1 */
N#define  TIM_DCR_DBA_2                       ((uint16_t)0x0004)            /*!<Bit 2 */
N#define  TIM_DCR_DBA_3                       ((uint16_t)0x0008)            /*!<Bit 3 */
N#define  TIM_DCR_DBA_4                       ((uint16_t)0x0010)            /*!<Bit 4 */
N
N#define  TIM_DCR_DBL                         ((uint16_t)0x1F00)            /*!<DBL[4:0] bits (DMA Burst Length) */
N#define  TIM_DCR_DBL_0                       ((uint16_t)0x0100)            /*!<Bit 0 */
N#define  TIM_DCR_DBL_1                       ((uint16_t)0x0200)            /*!<Bit 1 */
N#define  TIM_DCR_DBL_2                       ((uint16_t)0x0400)            /*!<Bit 2 */
N#define  TIM_DCR_DBL_3                       ((uint16_t)0x0800)            /*!<Bit 3 */
N#define  TIM_DCR_DBL_4                       ((uint16_t)0x1000)            /*!<Bit 4 */
N
N/*******************  Bit definition for TIM_DMAR register  *******************/
N#define  TIM_DMAR_DMAB                       ((uint16_t)0xFFFF)            /*!<DMA register for burst accesses */
N
N/*******************  Bit definition for TIM_OR register  *********************/
N#define TIM14_OR_TI1_RMP                       ((uint16_t)0x0003)            /*!<TI1_RMP[1:0] bits (TIM14 Input 4 remap) */
N#define TIM14_OR_TI1_RMP_0                     ((uint16_t)0x0001)            /*!<Bit 0 */
N#define TIM14_OR_TI1_RMP_1                     ((uint16_t)0x0002)            /*!<Bit 1 */
N
N
N/******************************************************************************/
N/*                                                                            */
N/*      Universal Synchronous Asynchronous Receiver Transmitter (USART)       */
N/*                                                                            */
N/******************************************************************************/
N/******************  Bit definition for USART_CR1 register  *******************/
N#define  USART_CR1_UE                        ((uint32_t)0x00000001)            /*!< USART Enable */
N#define  USART_CR1_UESM                      ((uint32_t)0x00000002)            /*!< USART Enable in STOP Mode */
N#define  USART_CR1_RE                        ((uint32_t)0x00000004)            /*!< Receiver Enable */
N#define  USART_CR1_TE                        ((uint32_t)0x00000008)            /*!< Transmitter Enable */
N#define  USART_CR1_IDLEIE                    ((uint32_t)0x00000010)            /*!< IDLE Interrupt Enable */
N#define  USART_CR1_RXNEIE                    ((uint32_t)0x00000020)            /*!< RXNE Interrupt Enable */
N#define  USART_CR1_TCIE                      ((uint32_t)0x00000040)            /*!< Transmission Complete Interrupt Enable */
N#define  USART_CR1_TXEIE                     ((uint32_t)0x00000080)            /*!< TXE Interrupt Enable */
N#define  USART_CR1_PEIE                      ((uint32_t)0x00000100)            /*!< PE Interrupt Enable */
N#define  USART_CR1_PS                        ((uint32_t)0x00000200)            /*!< Parity Selection */
N#define  USART_CR1_PCE                       ((uint32_t)0x00000400)            /*!< Parity Control Enable */
N#define  USART_CR1_WAKE                      ((uint32_t)0x00000800)            /*!< Receiver Wakeup method */
N#define  USART_CR1_M0                        ((uint32_t)0x00001000)            /*!< Word length */
N#define  USART_CR1_MME                       ((uint32_t)0x00002000)            /*!< Mute Mode Enable */
N#define  USART_CR1_CMIE                      ((uint32_t)0x00004000)            /*!< Character match interrupt enable */
N#define  USART_CR1_OVER8                     ((uint32_t)0x00008000)            /*!< Oversampling by 8-bit or 16-bit mode */
N#define  USART_CR1_DEDT                      ((uint32_t)0x001F0000)            /*!< DEDT[4:0] bits (Driver Enable Deassertion Time) */
N#define  USART_CR1_DEDT_0                    ((uint32_t)0x00010000)            /*!< Bit 0 */
N#define  USART_CR1_DEDT_1                    ((uint32_t)0x00020000)            /*!< Bit 1 */
N#define  USART_CR1_DEDT_2                    ((uint32_t)0x00040000)            /*!< Bit 2 */
N#define  USART_CR1_DEDT_3                    ((uint32_t)0x00080000)            /*!< Bit 3 */
N#define  USART_CR1_DEDT_4                    ((uint32_t)0x00100000)            /*!< Bit 4 */
N#define  USART_CR1_DEAT                      ((uint32_t)0x03E00000)            /*!< DEAT[4:0] bits (Driver Enable Assertion Time) */
N#define  USART_CR1_DEAT_0                    ((uint32_t)0x00200000)            /*!< Bit 0 */
N#define  USART_CR1_DEAT_1                    ((uint32_t)0x00400000)            /*!< Bit 1 */
N#define  USART_CR1_DEAT_2                    ((uint32_t)0x00800000)            /*!< Bit 2 */
N#define  USART_CR1_DEAT_3                    ((uint32_t)0x01000000)            /*!< Bit 3 */
N#define  USART_CR1_DEAT_4                    ((uint32_t)0x02000000)            /*!< Bit 4 */
N#define  USART_CR1_RTOIE                     ((uint32_t)0x04000000)            /*!< Receive Time Out interrupt enable */
N//#define  USART_CR1_EOBIE                     ((uint32_t)0x08000000)            /*!< End of Block interrupt enable */
N#define  USART_CR1_M1                        ((uint32_t)0x10000000)            /*!< End of Block interrupt enable */
N 
N#define  USART_CR1_M                         USART_CR1_M0 
N/******************  Bit definition for USART_CR2 register  *******************/
N#define  USART_CR2_ADDM7                     ((uint32_t)0x00000010)            /*!< 7-bit or 4-bit Address Detection */
N//#define  USART_CR2_LBDL                      ((uint32_t)0x00000020)            /*!< LIN Break Detection Length */
N//#define  USART_CR2_LBDIE                     ((uint32_t)0x00000040)            /*!< LIN Break Detection Interrupt Enable */
N#define  USART_CR2_LBCL                      ((uint32_t)0x00000100)            /*!< Last Bit Clock pulse */
N#define  USART_CR2_CPHA                      ((uint32_t)0x00000200)            /*!< Clock Phase */
N#define  USART_CR2_CPOL                      ((uint32_t)0x00000400)            /*!< Clock Polarity */
N#define  USART_CR2_CLKEN                     ((uint32_t)0x00000800)            /*!< Clock Enable */
N#define  USART_CR2_STOP                      ((uint32_t)0x00003000)            /*!< STOP[1:0] bits (STOP bits) */
N#define  USART_CR2_STOP_0                    ((uint32_t)0x00001000)            /*!< Bit 0 */
N#define  USART_CR2_STOP_1                    ((uint32_t)0x00002000)            /*!< Bit 1 */
N#define  USART_CR2_LINEN                     ((uint32_t)0x00004000)            /*!< LIN mode enable */
N#define  USART_CR2_SWAP                      ((uint32_t)0x00008000)            /*!< SWAP TX/RX pins */
N#define  USART_CR2_RXINV                     ((uint32_t)0x00010000)            /*!< RX pin active level inversion */
N#define  USART_CR2_TXINV                     ((uint32_t)0x00020000)            /*!< TX pin active level inversion */
N#define  USART_CR2_DATAINV                   ((uint32_t)0x00040000)            /*!< Binary data inversion */
N#define  USART_CR2_MSBFIRST                  ((uint32_t)0x00080000)            /*!< Most Significant Bit First */
N#define  USART_CR2_ABRE                      ((uint32_t)0x00100000)            /*!< Auto Baud-Rate Enable*/
N#define  USART_CR2_ABRMOD                    ((uint32_t)0x00600000)            /*!< ABRMOD[1:0] bits (Auto Baud-Rate Mode) */
N#define  USART_CR2_ABRMOD_0                  ((uint32_t)0x00200000)            /*!< Bit 0 */
N#define  USART_CR2_ABRMOD_1                  ((uint32_t)0x00400000)            /*!< Bit 1 */
N#define  USART_CR2_RTOEN                     ((uint32_t)0x00800000)            /*!< Receiver Time-Out enable */
N#define  USART_CR2_ADD                       ((uint32_t)0xFF000000)            /*!< Address of the USART node */
N
N#define  USART_CR2_ABRMODE									 USART_CR2_ABRMOD
N#define  USART_CR2_ABRMODE_0                 USART_CR2_ABRMOD_0
N#define  USART_CR2_ABRMODE_1                 USART_CR2_ABRMOD_1
N#define  USART_CR2_ABREN                     USART_CR2_ABRE
N/******************  Bit definition for USART_CR3 register  *******************/
N#define  USART_CR3_EIE                       ((uint32_t)0x00000001)            /*!< Error Interrupt Enable */
N//#define  USART_CR3_IREN                      ((uint32_t)0x00000002)            /*!< IrDA mode Enable */
N//#define  USART_CR3_IRLP                      ((uint32_t)0x00000004)            /*!< IrDA Low-Power */
N#define  USART_CR3_HDSEL                     ((uint32_t)0x00000008)            /*!< Half-Duplex Selection */
N//#define  USART_CR3_NACK                      ((uint32_t)0x00000010)            /*!< SmartCard NACK enable */
N//#define  USART_CR3_SCEN                      ((uint32_t)0x00000020)            /*!< SmartCard mode enable */
N#define  USART_CR3_DMAR                      ((uint32_t)0x00000040)            /*!< DMA Enable Receiver */
N#define  USART_CR3_DMAT                      ((uint32_t)0x00000080)            /*!< DMA Enable Transmitter */
N#define  USART_CR3_RTSE                      ((uint32_t)0x00000100)            /*!< RTS Enable */
N#define  USART_CR3_CTSE                      ((uint32_t)0x00000200)            /*!< CTS Enable */
N#define  USART_CR3_CTSIE                     ((uint32_t)0x00000400)            /*!< CTS Interrupt Enable */
N#define  USART_CR3_ONEBIT                    ((uint32_t)0x00000800)            /*!< One sample bit method enable */
N#define  USART_CR3_OVRDIS                    ((uint32_t)0x00001000)            /*!< Overrun Disable */
N#define  USART_CR3_DDRE                      ((uint32_t)0x00002000)            /*!< DMA Disable on Reception Error */
N#define  USART_CR3_DEM                       ((uint32_t)0x00004000)            /*!< Driver Enable Mode */
N#define  USART_CR3_DEP                       ((uint32_t)0x00008000)            /*!< Driver Enable Polarity Selection */
N//#define  USART_CR3_SCARCNT                   ((uint32_t)0x000E0000)            /*!< SCARCNT[2:0] bits (SmartCard Auto-Retry Count) */
N//#define  USART_CR3_SCARCNT_0                 ((uint32_t)0x00020000)            /*!< Bit 0 */
N//#define  USART_CR3_SCARCNT_1                 ((uint32_t)0x00040000)            /*!< Bit 1 */
N//#define  USART_CR3_SCARCNT_2                 ((uint32_t)0x00080000)            /*!< Bit 2 */
N//#define  USART_CR3_WUS                       ((uint32_t)0x00300000)            /*!< WUS[1:0] bits (Wake UP Interrupt Flag Selection) */
N//#define  USART_CR3_WUS_0                     ((uint32_t)0x00100000)            /*!< Bit 0 */
N//#define  USART_CR3_WUS_1                     ((uint32_t)0x00200000)            /*!< Bit 1 */
N//#define  USART_CR3_WUFIE                     ((uint32_t)0x00400000)            /*!< Wake Up Interrupt Enable */
N
N/******************  Bit definition for USART_BRR register  *******************/
N//#define  USART_BRR_DIV_FRACTION              ((uint16_t)0x000F)                /*!< Fraction of USARTDIV */
N//#define  USART_BRR_DIV_MANTISSA              ((uint16_t)0xFFF0)                /*!< Mantissa of USARTDIV */
N#define  USART_BRR_BRR                       ((uint16_t)0xFFFF)                /*!< Fraction of USARTDIV */
N
N/******************  Bit definition for USART_GTPR register  ******************/
N#define  USART_GTPR_PSC                      ((uint16_t)0x00FF)                /*!< PSC[7:0] bits (Prescaler value) */
N#define  USART_GTPR_GT                       ((uint16_t)0xFF00)                /*!< GT[7:0] bits (Guard time value) */
N
N
N/*******************  Bit definition for USART_RTOR register  *****************/
N#define  USART_RTOR_RTO                      ((uint32_t)0x00FFFFFF)            /*!< Receiver Time Out Value */
N//#define  USART_RTOR_BLEN                     ((uint32_t)0xFF000000)            /*!< Block Length */
N
N/*******************  Bit definition for USART_RQR register  ******************/
N#define  USART_RQR_ABRRQ                    ((uint16_t)0x0001)                /*!< Auto-Baud Rate Request */
N#define  USART_RQR_SBKRQ                    ((uint16_t)0x0002)                /*!< Send Break Request */
N#define  USART_RQR_MMRQ                     ((uint16_t)0x0004)                /*!< Mute Mode Request */
N#define  USART_RQR_RXFRQ                    ((uint16_t)0x0008)                /*!< Receive Data flush Request */
N#define  USART_RQR_TXFRQ                    ((uint16_t)0x0010)                /*!< Transmit data flush Request */
N
N/*******************  Bit definition for USART_ISR register  ******************/
N#define  USART_ISR_PE                        ((uint32_t)0x00000001)            /*!< Parity Error */
N#define  USART_ISR_FE                        ((uint32_t)0x00000002)            /*!< Framing Error */
N#define  USART_ISR_NE                        ((uint32_t)0x00000004)            /*!< Noise detected Flag */
N#define  USART_ISR_ORE                       ((uint32_t)0x00000008)            /*!< OverRun Error */
N#define  USART_ISR_IDLE                      ((uint32_t)0x00000010)            /*!< IDLE line detected */
N#define  USART_ISR_RXNE                      ((uint32_t)0x00000020)            /*!< Read Data Register Not Empty */
N#define  USART_ISR_TC                        ((uint32_t)0x00000040)            /*!< Transmission Complete */
N#define  USART_ISR_TXE                       ((uint32_t)0x00000080)            /*!< Transmit Data Register Empty */
N//#define  USART_ISR_LBD                       ((uint32_t)0x00000100)            /*!< LIN Break Detection Flag */
N#define  USART_ISR_CTSIF                     ((uint32_t)0x00000200)            /*!< CTS interrupt flag */
N#define  USART_ISR_CTS                       ((uint32_t)0x00000400)            /*!< CTS flag */
N#define  USART_ISR_RTOF                      ((uint32_t)0x00000800)            /*!< Receiver Time Out */
N//#define  USART_ISR_EOBF                      ((uint32_t)0x00001000)            /*!< End Of Block Flag */
N#define  USART_ISR_ABRE                      ((uint32_t)0x00004000)            /*!< Auto-Baud Rate Error */
N#define  USART_ISR_ABRF                      ((uint32_t)0x00008000)            /*!< Auto-Baud Rate Flag */
N#define  USART_ISR_BUSY                      ((uint32_t)0x00010000)            /*!< Busy Flag */
N#define  USART_ISR_CMF                       ((uint32_t)0x00020000)            /*!< Character Match Flag */
N#define  USART_ISR_SBKF                      ((uint32_t)0x00040000)            /*!< Send Break Flag */
N#define  USART_ISR_RWU                       ((uint32_t)0x00080000)            /*!< Receive Wake Up from mute mode Flag */
N//#define  USART_ISR_WUF                       ((uint32_t)0x00100000)            /*!< Wake Up from stop mode Flag */
N//#define  USART_ISR_TEACK                     ((uint32_t)0x00200000)            /*!< Transmit Enable Acknowledge Flag */
N//#define  USART_ISR_REACK                     ((uint32_t)0x00400000)            /*!< Receive Enable Acknowledge Flag */
N
N/*******************  Bit definition for USART_ICR register  ******************/
N#define  USART_ICR_PECF                      ((uint32_t)0x00000001)            /*!< Parity Error Clear Flag */
N#define  USART_ICR_FECF                      ((uint32_t)0x00000002)            /*!< Framing Error Clear Flag */
N#define  USART_ICR_NCF                      ((uint32_t)0x00000004)             /*!< Noise detected Clear Flag */
N#define  USART_ICR_ORECF                     ((uint32_t)0x00000008)            /*!< OverRun Error Clear Flag */
N#define  USART_ICR_IDLECF                    ((uint32_t)0x00000010)            /*!< IDLE line detected Clear Flag */
N#define  USART_ICR_TCCF                      ((uint32_t)0x00000040)            /*!< Transmission Complete Clear Flag */
N#define  USART_ICR_LBDCF                     ((uint32_t)0x00000100)            /*!< LIN Break Detection Clear Flag */
N#define  USART_ICR_CTSCF                     ((uint32_t)0x00000200)            /*!< CTS Interrupt Clear Flag */
N#define  USART_ICR_RTOCF                     ((uint32_t)0x00000800)            /*!< Receiver Time Out Clear Flag */
N//#define  USART_ICR_EOBCF                     ((uint32_t)0x00001000)            /*!< End Of Block Clear Flag */
N#define  USART_ICR_CMCF                      ((uint32_t)0x00020000)            /*!< Character Match Clear Flag */
N//#define  USART_ICR_WUCF                      ((uint32_t)0x00100000)            /*!< Wake Up from stop mode Clear Flag */
N
N/*******************  Bit definition for USART_RDR register  ******************/
N#define  USART_RDR_RDR                       ((uint16_t)0x01FF)                /*!< RDR[8:0] bits (Receive Data value) */
N
N/*******************  Bit definition for USART_TDR register  ******************/
N#define  USART_TDR_TDR                       ((uint16_t)0x01FF)                /*!< TDR[8:0] bits (Transmit Data value) */
N
N/******************************************************************************/
N/*                                                                            */
N/*                         Window WATCHDOG (WWDG)                             */
N/*                                                                            */
N/******************************************************************************/
N
N/*******************  Bit definition for WWDG_CR register  ********************/
N#define  WWDG_CR_T                           ((uint8_t)0x7F)               /*!< T[6:0] bits (7-Bit counter (MSB to LSB)) */
N#define  WWDG_CR_T0                          ((uint8_t)0x01)               /*!< Bit 0 */
N#define  WWDG_CR_T1                          ((uint8_t)0x02)               /*!< Bit 1 */
N#define  WWDG_CR_T2                          ((uint8_t)0x04)               /*!< Bit 2 */
N#define  WWDG_CR_T3                          ((uint8_t)0x08)               /*!< Bit 3 */
N#define  WWDG_CR_T4                          ((uint8_t)0x10)               /*!< Bit 4 */
N#define  WWDG_CR_T5                          ((uint8_t)0x20)               /*!< Bit 5 */
N#define  WWDG_CR_T6                          ((uint8_t)0x40)               /*!< Bit 6 */
N
N#define  WWDG_CR_WDGA                        ((uint8_t)0x80)               /*!< Activation bit */
N
N/*******************  Bit definition for WWDG_CFR register  *******************/
N#define  WWDG_CFR_W                          ((uint16_t)0x007F)            /*!< W[6:0] bits (7-bit window value) */
N#define  WWDG_CFR_W0                         ((uint16_t)0x0001)            /*!< Bit 0 */
N#define  WWDG_CFR_W1                         ((uint16_t)0x0002)            /*!< Bit 1 */
N#define  WWDG_CFR_W2                         ((uint16_t)0x0004)            /*!< Bit 2 */
N#define  WWDG_CFR_W3                         ((uint16_t)0x0008)            /*!< Bit 3 */
N#define  WWDG_CFR_W4                         ((uint16_t)0x0010)            /*!< Bit 4 */
N#define  WWDG_CFR_W5                         ((uint16_t)0x0020)            /*!< Bit 5 */
N#define  WWDG_CFR_W6                         ((uint16_t)0x0040)            /*!< Bit 6 */
N
N#define  WWDG_CFR_WDGTB                      ((uint16_t)0x0180)            /*!< WDGTB[1:0] bits (Timer Base) */
N#define  WWDG_CFR_WDGTB0                     ((uint16_t)0x0080)            /*!< Bit 0 */
N#define  WWDG_CFR_WDGTB1                     ((uint16_t)0x0100)            /*!< Bit 1 */
N
N#define  WWDG_CFR_EWI                        ((uint16_t)0x0200)            /*!< Early Wakeup Interrupt */
N
N/*******************  Bit definition for WWDG_SR register  ********************/
N#define  WWDG_SR_EWIF                        ((uint8_t)0x01)               /*!< Early Wakeup Interrupt Flag */
N
N
N
N/**
N  * @}
N  */
N
N /**
N  * @}
N  */ 
N
N//#ifdef USE_STDPERIPH_DRIVER
N//  #include "FT32f0xx_conf.h"
N//#endif
N
N/** @addtogroup Exported_macro
N  * @{
N  */
N/**
N  * @}
N  */
N  
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __FT32F072X8_H */
N
N/**
N  * @}
N  */
N
N  /**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT FMD *****END OF FILE****/
L 54 "..\FTLib\CMSIS\inc\ft32f0xx.h" 2
N#else
S #error "Please select first the target FT32F0xx device used in your application (in ft32f0xx.h file)"
N#endif
N
N/**
N  * @}
N  */
N
N
N
N/**
N  * @}
N  */
N
N
N/** @addtogroup Exported_macros
N  * @{
N  */
N#define SET_BIT(REG, BIT)     ((REG) |= (BIT))
N
N#define CLEAR_BIT(REG, BIT)   ((REG) &= ~(BIT))
N
N#define READ_BIT(REG, BIT)    ((REG) & (BIT))
N
N#define CLEAR_REG(REG)        ((REG) = (0x0))
N
N#define WRITE_REG(REG, VAL)   ((REG) = (VAL))
N
N#define READ_REG(REG)         ((REG))
N
N#define MODIFY_REG(REG, CLEARMASK, SETMASK)  WRITE_REG((REG), (((READ_REG(REG)) & (~(CLEARMASK))) | (SETMASK)))
N
N
N#ifdef __cplusplus
S}
N#endif /* __cplusplus */
N
N#endif /* __FT32F0xx_H */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N  
N
N
N
N/*****************************END OF FILE****/
L 28 "..\user\main.h" 2
N
N#include "ft32f0xx_adc.h"
L 1 "..\FTLib\Inc\ft32f0xx_adc.h" 1
N/**
N  ******************************************************************************
N  * @file    			ft32f0xx_adc.h
N  * @author  			FMD AE
N  * @brief   			This file contains all the functions prototypes for the ADC firmware 
N  *          			library   	
N  * @version 			V1.0.0           
N  * @data		 			2021-07-01
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __FT32F0XX_ADC_H
N#define __FT32F0XX_ADC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "ft32f0xx.h"
N
N/** @addtogroup ADC
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief  ADC Init structure definition
N  */
N  
Ntypedef struct
N{
N  uint32_t ADC_Resolution;                  /*!< Selects the resolution of the conversion.
N                                                 This parameter can be a value of @ref ADC_Resolution */
N
N  FunctionalState ADC_ContinuousConvMode;   /*!< Specifies whether the conversion is performed in
N                                                 Continuous or Single mode.
N                                                 This parameter can be set to ENABLE or DISABLE. */
N
N  uint32_t ADC_ExternalTrigConvEdge;        /*!< Selects the external trigger Edge and enables the
N                                                 trigger of a regular group. This parameter can be a value
N                                                 of @ref ADC_external_trigger_edge_conversion */
N
N  uint32_t ADC_ExternalTrigConv;            /*!< Defines the external trigger used to start the analog
N                                                 to digital conversion of regular channels. This parameter
N                                                 can be a value of @ref ADC_external_trigger_sources_for_channels_conversion */
N
N  uint32_t ADC_DataAlign;                   /*!< Specifies whether the ADC data alignment is left or right.
N                                                 This parameter can be a value of @ref ADC_data_align */
N
N  uint32_t  ADC_ScanDirection;              /*!< Specifies in which direction the channels will be scanned
N                                                 in the sequence. 
N                                                 This parameter can be a value of @ref ADC_Scan_Direction */
N}ADC_InitTypeDef;
N
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup ADC_Exported_Constants
N  * @{
N  */ 
N#define IS_ADC_ALL_PERIPH(PERIPH)                  ((PERIPH) == ADC1)
N
N/** @defgroup ADC_JitterOff
N  * @{
N  */ 
N/* These defines are obsolete and maintained for legacy purpose only. They are replaced  by the ADC_ClockMode */  
N#define ADC_JitterOff_PCLKDiv2                    ADC_CFGR2_JITOFFDIV2
N#define ADC_JitterOff_PCLKDiv4                    ADC_CFGR2_JITOFFDIV4
N
N#define IS_ADC_JITTEROFF(JITTEROFF) (((JITTEROFF) & 0x3FFFFFFF) == (uint32_t)RESET)
N
N/**
N  * @}
N  */
N  
N/** @defgroup ADC_ClockMode
N  * @{
N  */ 
N#define ADC_ClockMode_AsynClk                  ((uint32_t)0x00000000)   /*!< ADC Asynchronous clock mode */
N#define ADC_ClockMode_SynClkDiv2               ADC_CFGR2_CKMODE_0   /*!<  Synchronous clock mode divided by 2 */
N#define ADC_ClockMode_SynClkDiv4               ADC_CFGR2_CKMODE_1   /*!<  Synchronous clock mode divided by 4 */
N#define IS_ADC_CLOCKMODE(CLOCK) (((CLOCK) == ADC_ClockMode_AsynClk) ||\
N				                        ((CLOCK) == ADC_ClockMode_SynClkDiv2) ||\
N				                        ((CLOCK) == ADC_ClockMode_SynClkDiv4))
X#define IS_ADC_CLOCKMODE(CLOCK) (((CLOCK) == ADC_ClockMode_AsynClk) ||				                        ((CLOCK) == ADC_ClockMode_SynClkDiv2) ||				                        ((CLOCK) == ADC_ClockMode_SynClkDiv4))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup ADC_Resolution
N  * @{
N  */ 
N#define ADC_Resolution_12b                         ((uint32_t)0x00000000)
N#define ADC_Resolution_10b                         ADC_CFGR1_RES_0
N#define ADC_Resolution_8b                          ADC_CFGR1_RES_1
N#define ADC_Resolution_6b                          ADC_CFGR1_RES
N
N#define IS_ADC_RESOLUTION(RESOLUTION) (((RESOLUTION) == ADC_Resolution_12b) || \
N                                       ((RESOLUTION) == ADC_Resolution_10b) || \
N                                       ((RESOLUTION) == ADC_Resolution_8b) || \
N                                       ((RESOLUTION) == ADC_Resolution_6b))
X#define IS_ADC_RESOLUTION(RESOLUTION) (((RESOLUTION) == ADC_Resolution_12b) ||                                        ((RESOLUTION) == ADC_Resolution_10b) ||                                        ((RESOLUTION) == ADC_Resolution_8b) ||                                        ((RESOLUTION) == ADC_Resolution_6b))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup ADC_external_trigger_edge_conversion 
N  * @{
N  */ 
N#define ADC_ExternalTrigConvEdge_None              ((uint32_t)0x00000000)
N#define ADC_ExternalTrigConvEdge_Rising            ADC_CFGR1_EXTEN_0
N#define ADC_ExternalTrigConvEdge_Falling           ADC_CFGR1_EXTEN_1
N#define ADC_ExternalTrigConvEdge_RisingFalling     ADC_CFGR1_EXTEN
N
N#define IS_ADC_EXT_TRIG_EDGE(EDGE) (((EDGE) == ADC_ExternalTrigConvEdge_None) || \
N                                    ((EDGE) == ADC_ExternalTrigConvEdge_Rising) || \
N                                    ((EDGE) == ADC_ExternalTrigConvEdge_Falling) || \
N                                    ((EDGE) == ADC_ExternalTrigConvEdge_RisingFalling))
X#define IS_ADC_EXT_TRIG_EDGE(EDGE) (((EDGE) == ADC_ExternalTrigConvEdge_None) ||                                     ((EDGE) == ADC_ExternalTrigConvEdge_Rising) ||                                     ((EDGE) == ADC_ExternalTrigConvEdge_Falling) ||                                     ((EDGE) == ADC_ExternalTrigConvEdge_RisingFalling))
N/**
N  * @}
N  */ 
N
N/** @defgroup ADC_external_trigger_sources_for_channels_conversion
N  * @{
N  */ 
N
N/* TIM1 */
N#define ADC_ExternalTrigConv_T1_TRGO               ((uint32_t)0x00000000)
N#define ADC_ExternalTrigConv_T1_CC4                ADC_CFGR1_EXTSEL_0
N
N/* TIM2 */
N#define ADC_ExternalTrigConv_T2_TRGO               ADC_CFGR1_EXTSEL_1
N
N/* TIM3 */
N#define ADC_ExternalTrigConv_T3_TRGO               ((uint32_t)(ADC_CFGR1_EXTSEL_0 | ADC_CFGR1_EXTSEL_1))
N
N/* TIM15 */
N#define ADC_ExternalTrigConv_T15_TRGO              ADC_CFGR1_EXTSEL_2
N
N#define IS_ADC_EXTERNAL_TRIG_CONV(CONV) (((CONV) == ADC_ExternalTrigConv_T1_TRGO) || \
N                                         ((CONV) == ADC_ExternalTrigConv_T1_CC4)   || \
N                                         ((CONV) == ADC_ExternalTrigConv_T2_TRGO)  || \
N                                         ((CONV) == ADC_ExternalTrigConv_T3_TRGO)  || \
N                                         ((CONV) == ADC_ExternalTrigConv_T15_TRGO)) 
X#define IS_ADC_EXTERNAL_TRIG_CONV(CONV) (((CONV) == ADC_ExternalTrigConv_T1_TRGO) ||                                          ((CONV) == ADC_ExternalTrigConv_T1_CC4)   ||                                          ((CONV) == ADC_ExternalTrigConv_T2_TRGO)  ||                                          ((CONV) == ADC_ExternalTrigConv_T3_TRGO)  ||                                          ((CONV) == ADC_ExternalTrigConv_T15_TRGO)) 
N/**
N  * @}
N  */ 
N
N/** @defgroup ADC_data_align 
N  * @{
N  */ 
N  
N#define ADC_DataAlign_Right                        ((uint32_t)0x00000000)
N#define ADC_DataAlign_Left                         ADC_CFGR1_ALIGN
N
N#define IS_ADC_DATA_ALIGN(ALIGN) (((ALIGN) == ADC_DataAlign_Right) || \
N                                  ((ALIGN) == ADC_DataAlign_Left))
X#define IS_ADC_DATA_ALIGN(ALIGN) (((ALIGN) == ADC_DataAlign_Right) ||                                   ((ALIGN) == ADC_DataAlign_Left))
N/**
N  * @}
N  */
N
N/** @defgroup ADC_Scan_Direction 
N  * @{
N  */ 
N  
N#define ADC_ScanDirection_Upward                   ((uint32_t)0x00000000)
N#define ADC_ScanDirection_Backward                 ADC_CFGR1_SCANDIR
N
N#define IS_ADC_SCAN_DIRECTION(DIRECTION) (((DIRECTION) == ADC_ScanDirection_Upward) || \
N                                          ((DIRECTION) == ADC_ScanDirection_Backward))
X#define IS_ADC_SCAN_DIRECTION(DIRECTION) (((DIRECTION) == ADC_ScanDirection_Upward) ||                                           ((DIRECTION) == ADC_ScanDirection_Backward))
N/**
N  * @}
N  */ 
N
N/** @defgroup ADC_DMA_Mode 
N  * @{
N  */ 
N  
N#define ADC_DMAMode_OneShot                        ((uint32_t)0x00000000)
N#define ADC_DMAMode_Circular                       ADC_CFGR1_DMACFG
N
N#define IS_ADC_DMA_MODE(MODE) (((MODE) == ADC_DMAMode_OneShot) || \
N                               ((MODE) == ADC_DMAMode_Circular))
X#define IS_ADC_DMA_MODE(MODE) (((MODE) == ADC_DMAMode_OneShot) ||                                ((MODE) == ADC_DMAMode_Circular))
N/**
N  * @}
N  */ 
N    
N/** @defgroup ADC_analog_watchdog_selection 
N  * @{
N  */ 
N  
N#define ADC_AnalogWatchdog_Channel_0                 ((uint32_t)0x00000000)
N#define ADC_AnalogWatchdog_Channel_1                 ((uint32_t)0x04000000)
N#define ADC_AnalogWatchdog_Channel_2                 ((uint32_t)0x08000000)
N#define ADC_AnalogWatchdog_Channel_3                 ((uint32_t)0x0C000000)
N#define ADC_AnalogWatchdog_Channel_4                 ((uint32_t)0x10000000)
N#define ADC_AnalogWatchdog_Channel_5                 ((uint32_t)0x14000000)
N#define ADC_AnalogWatchdog_Channel_6                 ((uint32_t)0x18000000)
N#define ADC_AnalogWatchdog_Channel_7                 ((uint32_t)0x1C000000)
N#define ADC_AnalogWatchdog_Channel_8                 ((uint32_t)0x20000000)
N#define ADC_AnalogWatchdog_Channel_9                 ((uint32_t)0x24000000)
N#define ADC_AnalogWatchdog_Channel_10                ((uint32_t)0x28000000) 
N#define ADC_AnalogWatchdog_Channel_11                ((uint32_t)0x2C000000) 
N#define ADC_AnalogWatchdog_Channel_12                ((uint32_t)0x30000000) 
N#define ADC_AnalogWatchdog_Channel_13                ((uint32_t)0x34000000) 
N#define ADC_AnalogWatchdog_Channel_14                ((uint32_t)0x38000000) 
N#define ADC_AnalogWatchdog_Channel_15                ((uint32_t)0x3C000000) 
N#define ADC_AnalogWatchdog_Channel_16                ((uint32_t)0x40000000)
N#define ADC_AnalogWatchdog_Channel_17                ((uint32_t)0x44000000)
N#define ADC_AnalogWatchdog_Channel_18                ((uint32_t)0x48000000)
N
N
N#define IS_ADC_ANALOG_WATCHDOG_CHANNEL(CHANNEL) (((CHANNEL) == ADC_AnalogWatchdog_Channel_0)  || \
N                                                 ((CHANNEL) == ADC_AnalogWatchdog_Channel_1)  || \
N                                                 ((CHANNEL) == ADC_AnalogWatchdog_Channel_2)  || \
N                                                 ((CHANNEL) == ADC_AnalogWatchdog_Channel_3)  || \
N                                                 ((CHANNEL) == ADC_AnalogWatchdog_Channel_4)  || \
N                                                 ((CHANNEL) == ADC_AnalogWatchdog_Channel_5)  || \
N                                                 ((CHANNEL) == ADC_AnalogWatchdog_Channel_6)  || \
N                                                 ((CHANNEL) == ADC_AnalogWatchdog_Channel_7)  || \
N                                                 ((CHANNEL) == ADC_AnalogWatchdog_Channel_8)  || \
N                                                 ((CHANNEL) == ADC_AnalogWatchdog_Channel_9)  || \
N                                                 ((CHANNEL) == ADC_AnalogWatchdog_Channel_10) || \
N                                                 ((CHANNEL) == ADC_AnalogWatchdog_Channel_11) || \
N                                                 ((CHANNEL) == ADC_AnalogWatchdog_Channel_12) || \
N                                                 ((CHANNEL) == ADC_AnalogWatchdog_Channel_13) || \
N                                                 ((CHANNEL) == ADC_AnalogWatchdog_Channel_14) || \
N                                                 ((CHANNEL) == ADC_AnalogWatchdog_Channel_15) || \
N                                                 ((CHANNEL) == ADC_AnalogWatchdog_Channel_16) || \
N                                                 ((CHANNEL) == ADC_AnalogWatchdog_Channel_17) || \
N                                                 ((CHANNEL) == ADC_AnalogWatchdog_Channel_18))
X#define IS_ADC_ANALOG_WATCHDOG_CHANNEL(CHANNEL) (((CHANNEL) == ADC_AnalogWatchdog_Channel_0)  ||                                                  ((CHANNEL) == ADC_AnalogWatchdog_Channel_1)  ||                                                  ((CHANNEL) == ADC_AnalogWatchdog_Channel_2)  ||                                                  ((CHANNEL) == ADC_AnalogWatchdog_Channel_3)  ||                                                  ((CHANNEL) == ADC_AnalogWatchdog_Channel_4)  ||                                                  ((CHANNEL) == ADC_AnalogWatchdog_Channel_5)  ||                                                  ((CHANNEL) == ADC_AnalogWatchdog_Channel_6)  ||                                                  ((CHANNEL) == ADC_AnalogWatchdog_Channel_7)  ||                                                  ((CHANNEL) == ADC_AnalogWatchdog_Channel_8)  ||                                                  ((CHANNEL) == ADC_AnalogWatchdog_Channel_9)  ||                                                  ((CHANNEL) == ADC_AnalogWatchdog_Channel_10) ||                                                  ((CHANNEL) == ADC_AnalogWatchdog_Channel_11) ||                                                  ((CHANNEL) == ADC_AnalogWatchdog_Channel_12) ||                                                  ((CHANNEL) == ADC_AnalogWatchdog_Channel_13) ||                                                  ((CHANNEL) == ADC_AnalogWatchdog_Channel_14) ||                                                  ((CHANNEL) == ADC_AnalogWatchdog_Channel_15) ||                                                  ((CHANNEL) == ADC_AnalogWatchdog_Channel_16) ||                                                  ((CHANNEL) == ADC_AnalogWatchdog_Channel_17) ||                                                  ((CHANNEL) == ADC_AnalogWatchdog_Channel_18))
N/**
N  * @}
N  */ 
N  
N/** @defgroup ADC_sampling_times 
N  * @{
N  */ 
N
N#define ADC_SampleTime_1_5Cycles                     ((uint32_t)0x00000000)
N#define ADC_SampleTime_7_5Cycles                     ((uint32_t)0x00000001)
N#define ADC_SampleTime_13_5Cycles                    ((uint32_t)0x00000002)
N#define ADC_SampleTime_28_5Cycles                    ((uint32_t)0x00000003)
N#define ADC_SampleTime_41_5Cycles                    ((uint32_t)0x00000004)
N#define ADC_SampleTime_55_5Cycles                    ((uint32_t)0x00000005)
N#define ADC_SampleTime_71_5Cycles                    ((uint32_t)0x00000006)
N#define ADC_SampleTime_239_5Cycles                   ((uint32_t)0x00000007)
N
N#define IS_ADC_SAMPLE_TIME(TIME) (((TIME) == ADC_SampleTime_1_5Cycles)   || \
N                                  ((TIME) == ADC_SampleTime_7_5Cycles)   || \
N                                  ((TIME) == ADC_SampleTime_13_5Cycles)  || \
N                                  ((TIME) == ADC_SampleTime_28_5Cycles)  || \
N                                  ((TIME) == ADC_SampleTime_41_5Cycles)  || \
N                                  ((TIME) == ADC_SampleTime_55_5Cycles)  || \
N                                  ((TIME) == ADC_SampleTime_71_5Cycles)  || \
N                                  ((TIME) == ADC_SampleTime_239_5Cycles))
X#define IS_ADC_SAMPLE_TIME(TIME) (((TIME) == ADC_SampleTime_1_5Cycles)   ||                                   ((TIME) == ADC_SampleTime_7_5Cycles)   ||                                   ((TIME) == ADC_SampleTime_13_5Cycles)  ||                                   ((TIME) == ADC_SampleTime_28_5Cycles)  ||                                   ((TIME) == ADC_SampleTime_41_5Cycles)  ||                                   ((TIME) == ADC_SampleTime_55_5Cycles)  ||                                   ((TIME) == ADC_SampleTime_71_5Cycles)  ||                                   ((TIME) == ADC_SampleTime_239_5Cycles))
N/**
N  * @}
N  */ 
N
N/** @defgroup ADC_thresholds 
N  * @{
N  */ 
N  
N#define IS_ADC_THRESHOLD(THRESHOLD) ((THRESHOLD) <= 0xFFF)
N
N/**
N  * @}
N  */ 
N
N/** @defgroup ADC_channels 
N  * @{
N  */ 
N  
N#define ADC_Channel_0                              ADC_CHSELR_CHSEL0
N#define ADC_Channel_1                              ADC_CHSELR_CHSEL1
N#define ADC_Channel_2                              ADC_CHSELR_CHSEL2
N#define ADC_Channel_3                              ADC_CHSELR_CHSEL3
N#define ADC_Channel_4                              ADC_CHSELR_CHSEL4
N#define ADC_Channel_5                              ADC_CHSELR_CHSEL5
N#define ADC_Channel_6                              ADC_CHSELR_CHSEL6
N#define ADC_Channel_7                              ADC_CHSELR_CHSEL7
N#define ADC_Channel_8                              ADC_CHSELR_CHSEL8
N#define ADC_Channel_9                              ADC_CHSELR_CHSEL9
N#define ADC_Channel_10                             ADC_CHSELR_CHSEL10
N#define ADC_Channel_11                             ADC_CHSELR_CHSEL11 
N#define ADC_Channel_12                             ADC_CHSELR_CHSEL12 
N#define ADC_Channel_13                             ADC_CHSELR_CHSEL13 
N#define ADC_Channel_14                             ADC_CHSELR_CHSEL14
N#define ADC_Channel_15                             ADC_CHSELR_CHSEL15
N#define ADC_Channel_16                             ADC_CHSELR_CHSEL16
N#define ADC_Channel_17                             ADC_CHSELR_CHSEL17
N#define ADC_Channel_18                             ADC_CHSELR_CHSEL18
N
N#define ADC_Channel_TempSensor                     ((uint32_t)ADC_Channel_16)
N#define ADC_Channel_Vrefint                        ((uint32_t)ADC_Channel_17)
N#define ADC_Channel_Vbat                           ((uint32_t)ADC_Channel_18)
N
N#define IS_ADC_CHANNEL(CHANNEL) (((CHANNEL) != (uint32_t)RESET) && (((CHANNEL) & 0xFFF80000) == (uint32_t)RESET))
N
N/**
N  * @}
N  */ 
N  
N/** @defgroup ADC_interrupts_definition 
N  * @{
N  */ 
N  
N#define ADC_IT_ADRDY                               ADC_IER_ADRDYIE
N#define ADC_IT_EOSMP                               ADC_IER_EOSMPIE
N#define ADC_IT_EOC                                 ADC_IER_EOCIE
N#define ADC_IT_EOSEQ                               ADC_IER_EOSEQIE
N#define ADC_IT_OVR                                 ADC_IER_OVRIE
N#define ADC_IT_AWD                                 ADC_IER_AWDIE
N 
N#define IS_ADC_CONFIG_IT(IT) (((IT) != (uint32_t)RESET) && (((IT) & 0xFFFFFF60) == (uint32_t)RESET))
N
N#define IS_ADC_GET_IT(IT) (((IT) == ADC_IT_ADRDY) || ((IT) == ADC_IT_EOSMP) || \
N                           ((IT) == ADC_IT_EOC)   || ((IT) == ADC_IT_EOSEQ) || \
N                           ((IT) == ADC_IT_OVR)   || ((IT) == ADC_IT_AWD))
X#define IS_ADC_GET_IT(IT) (((IT) == ADC_IT_ADRDY) || ((IT) == ADC_IT_EOSMP) ||                            ((IT) == ADC_IT_EOC)   || ((IT) == ADC_IT_EOSEQ) ||                            ((IT) == ADC_IT_OVR)   || ((IT) == ADC_IT_AWD))
N
N#define IS_ADC_CLEAR_IT(IT) (((IT) != (uint32_t)RESET) && (((IT) & 0xFFFFFF60) == (uint32_t)RESET))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup ADC_flags_definition 
N  * @{
N  */ 
N  
N#define ADC_FLAG_ADRDY                             ADC_ISR_ADRDY
N#define ADC_FLAG_EOSMP                             ADC_ISR_EOSMP
N#define ADC_FLAG_EOC                               ADC_ISR_EOC
N#define ADC_FLAG_EOSEQ                             ADC_ISR_EOSEQ
N#define ADC_FLAG_OVR                               ADC_ISR_OVR
N#define ADC_FLAG_AWD                               ADC_ISR_AWD
N
N#define ADC_FLAG_ADEN                              ((uint32_t)0x01000001)
N#define ADC_FLAG_ADDIS                             ((uint32_t)0x01000002)
N#define ADC_FLAG_ADSTART                           ((uint32_t)0x01000004)
N#define ADC_FLAG_ADSTP                             ((uint32_t)0x01000010)
N#define ADC_FLAG_ADCAL                             ((uint32_t)0x81000000) 
N
N#define IS_ADC_CLEAR_FLAG(FLAG) (((FLAG) != (uint32_t)RESET) && (((FLAG) & 0xFFFFFF60) == (uint32_t)RESET))
N
N#define IS_ADC_GET_FLAG(FLAG) (((FLAG) == ADC_FLAG_ADRDY)   || ((FLAG) == ADC_FLAG_EOSMP) || \
N                               ((FLAG) == ADC_FLAG_EOC)     || ((FLAG) == ADC_FLAG_EOSEQ) || \
N                               ((FLAG) == ADC_FLAG_AWD)     || ((FLAG) == ADC_FLAG_OVR)   || \
N                               ((FLAG) == ADC_FLAG_ADEN)    || ((FLAG) == ADC_FLAG_ADDIS) || \
N                               ((FLAG) == ADC_FLAG_ADSTART) || ((FLAG) == ADC_FLAG_ADSTP) || \
N                               ((FLAG) == ADC_FLAG_ADCAL))
X#define IS_ADC_GET_FLAG(FLAG) (((FLAG) == ADC_FLAG_ADRDY)   || ((FLAG) == ADC_FLAG_EOSMP) ||                                ((FLAG) == ADC_FLAG_EOC)     || ((FLAG) == ADC_FLAG_EOSEQ) ||                                ((FLAG) == ADC_FLAG_AWD)     || ((FLAG) == ADC_FLAG_OVR)   ||                                ((FLAG) == ADC_FLAG_ADEN)    || ((FLAG) == ADC_FLAG_ADDIS) ||                                ((FLAG) == ADC_FLAG_ADSTART) || ((FLAG) == ADC_FLAG_ADSTP) ||                                ((FLAG) == ADC_FLAG_ADCAL))
N
N
N
N
N
N
N#define ADC_Vrefsel_2_5V                    				((uint32_t)0x0000000A)
N#define ADC_Vrefsel_VDDA                    				((uint32_t)(~(uint32_t)0x0000000E))
N#define IS_ADC_Vrefsel(Vref) (((Vref) == ADC_Vrefsel_2_5V)   || \
N                             ((Vref) == ADC_Vrefsel_VDDA)  
X#define IS_ADC_Vrefsel(Vref) (((Vref) == ADC_Vrefsel_2_5V)   ||                              ((Vref) == ADC_Vrefsel_VDDA)  
N
N
N
N#define ADC_VrefEN                             			((uint32_t)0x00000002)	
N/**
N  * @}
N  */
N  
N/**
N  * @}
N  */ 
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */ 
N
N/*  Function used to set the ADC configuration to the default reset state *****/
Nvoid ADC_DeInit(ADC_TypeDef* ADCx);
N
N/* Initialization and Configuration functions *********************************/ 
Nvoid ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct);
Nvoid ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct);
Nvoid ADC_ClockModeConfig(ADC_TypeDef* ADCx, uint32_t ADC_ClockMode);
Nvoid ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState);
N/* This Function is obsolete and maintained for legacy purpose only.
N   ADC_ClockModeConfig() function should be used instead */
Nvoid ADC_JitterCmd(ADC_TypeDef* ADCx, uint32_t ADC_JitterOff, FunctionalState NewState);
N
N/* Power saving functions *****************************************************/
Nvoid ADC_AutoPowerOffCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Nvoid ADC_WaitModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
N
N/* Analog Watchdog configuration functions ************************************/
Nvoid ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Nvoid ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold,uint16_t LowThreshold);
Nvoid ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog_Channel);
Nvoid ADC_AnalogWatchdogSingleChannelCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
N
N/* Temperature Sensor , Vrefint and Vbat management function ******************/
Nvoid ADC_TempSensorCmd(FunctionalState NewState);
Nvoid ADC_VrefintCmd(FunctionalState NewState);
Nvoid ADC_VbatCmd(FunctionalState NewState);
N
N/* Channels Configuration functions *******************************************/
Nvoid ADC_ChannelConfig(ADC_TypeDef* ADCx, uint32_t ADC_Channel, uint32_t ADC_SampleTime);
Nvoid ADC_ContinuousModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Nvoid ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Nvoid ADC_OverrunModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Nuint32_t ADC_GetCalibrationFactor(ADC_TypeDef* ADCx);
Nvoid ADC_StopOfConversion(ADC_TypeDef* ADCx);
Nvoid ADC_StartOfConversion(ADC_TypeDef* ADCx);
Nuint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx);
N
N/* Regular Channels DMA Configuration functions *******************************/
Nvoid ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Nvoid ADC_DMARequestModeConfig(ADC_TypeDef* ADCx, uint32_t ADC_DMARequestMode);
N
N/* Interrupts and flags management functions **********************************/
Nvoid ADC_ITConfig(ADC_TypeDef* ADCx, uint32_t ADC_IT, FunctionalState NewState);
NFlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint32_t ADC_FLAG);
Nvoid ADC_ClearFlag(ADC_TypeDef* ADCx, uint32_t ADC_FLAG);
NITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint32_t ADC_IT);
Nvoid ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint32_t ADC_IT);
Nvoid ADC_VrefselConfig(uint32_t ADC_Vrefsel);
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__ft32F0XX_ADC_H */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/************************ (C) COPYRIGHT FMD *****END OF FILE****/
L 30 "..\user\main.h" 2
N#include "ft32f0xx_comp.h"
L 1 "..\FTLib\Inc\ft32f0xx_comp.h" 1
N/**
N  ******************************************************************************
N  * @file    			ft32f0xx_comp.h
N  * @author  			FMD AE
N  * @brief   			This file contains all the functions prototypes for the COMP firmware 
N  *          			library	
N  * @version 			V1.0.0           
N  * @data		 			2021-07-01
N  ******************************************************************************
N  */
N
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __FT32F0XX_COMP_H
N#define __FT32F0XX_COMP_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "ft32f0xx.h"
N
N/** @addtogroup COMP
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief  COMP Init structure definition  
N  */
N  
Ntypedef struct
N{
N
N  uint32_t COMP_VipSel;     				/*!< Select the positive input of the comparator.
N                                          This parameter can be a value of @ref COMP_VipSel */
N
N  uint32_t COMP_VinSel;             /*!< Select the negative input of the comparator.
N                                          This parameter can be a value of @ref COMP_VinSel */
N
N  uint32_t COMP_OutputSel;          /*!< Selects The output selection of the comparator.
N                                          This parameter can be a value of @ref COMP_OutputSel */
N
N  uint32_t COMP_Pol;       					/*!< Select the output polarity of the comparator.
N                                          This parameter can be a value of @ref COMP_Pol */
N
N}COMP_InitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N   
N/** @defgroup COMP_Exported_Constants
N  * @{
N  */ 
N
N/** @defgroup COMP_Selection
N  * @{
N  */
N
N#define NCOMP_Selection_COMP                    ((uint32_t)0x00000000) /*!< NCOMP Selection */
N#define PCOMP_Selection_COMP                    ((uint32_t)0x00000010) /*!< PCOMP Selection */
N
N#define IS_COMP_ALL_PERIPH(PERIPH) (((PERIPH) == NCOMP_Selection_COMP) || \
N                                    ((PERIPH) == PCOMP_Selection_COMP))
X#define IS_COMP_ALL_PERIPH(PERIPH) (((PERIPH) == NCOMP_Selection_COMP) ||                                     ((PERIPH) == PCOMP_Selection_COMP))
N 
N/**
N  * @}
N  */ 
N
N/** @defgroup COMP_VipSel
N  * @{
N  */
N
N#define	NCOMP_VIP_SEL_1WIRE				((uint32_t)0x00000000)
N#define	NCOMP_VIP_SEL_PAD_PA1			((uint32_t)0x00000002)
N#define	NCOMP_VIP_SEL_PAD_PA4			((uint32_t)0x00000004)
N#define	NCOMP_VIP_SEL_PAD_PA13		((uint32_t)0x00000006)
N#define	NCOMP_VIP_SEL_PAD_PB12		((uint32_t)0x00000008)
N
N#define	PCOMP_VIP_SEL_PAD_PA3			((uint32_t)0x00000000)
N#define	PCOMP_VIP_SEL_PAD_PA4			((uint32_t)0x00020000)
N#define	PCOMP_VIP_SEL_PAD_PA13		((uint32_t)0x00040000)
N#define	PCOMP_VIP_SEL_PAD_PB12		((uint32_t)0x00060000)
N
N
N#define IS_COMP_VIP_SEL(INPUT) 	(((INPUT) == NCOMP_VIP_SEL_1WIRE) || \
N                                        ((INPUT) == NCOMP_VIP_SEL_PAD_PA1) 	|| \
N                                        ((INPUT) == NCOMP_VIP_SEL_PAD_PA4) 	|| \
N                                        ((INPUT) == NCOMP_VIP_SEL_PAD_PA13) || \
N                                        ((INPUT) == NCOMP_VIP_SEL_PAD_PB12) || \
N                                        ((INPUT) == PCOMP_VIP_SEL_PAD_PA3)  || \
N                                        ((INPUT) == PCOMP_VIP_SEL_PAD_PA4)  || \
N                                        ((INPUT) == PCOMP_VIP_SEL_PAD_PA13)	|| \
N																				((INPUT) == PCOMP_VIP_SEL_PAD_PB12))
X#define IS_COMP_VIP_SEL(INPUT) 	(((INPUT) == NCOMP_VIP_SEL_1WIRE) ||                                         ((INPUT) == NCOMP_VIP_SEL_PAD_PA1) 	||                                         ((INPUT) == NCOMP_VIP_SEL_PAD_PA4) 	||                                         ((INPUT) == NCOMP_VIP_SEL_PAD_PA13) ||                                         ((INPUT) == NCOMP_VIP_SEL_PAD_PB12) ||                                         ((INPUT) == PCOMP_VIP_SEL_PAD_PA3)  ||                                         ((INPUT) == PCOMP_VIP_SEL_PAD_PA4)  ||                                         ((INPUT) == PCOMP_VIP_SEL_PAD_PA13)	|| 																				((INPUT) == PCOMP_VIP_SEL_PAD_PB12))
N/**
N  * @}
N  */ 
N  
N/** @defgroup COMP_VinSel
N  * @{
N  */
N	
N#define	NCOMP_VIN_SEL_DAC1_OUT				((uint32_t)0x00000000)
N#define	NCOMP_VIN_SEL_PAD_PA0					((uint32_t)0x00000010)
N#define	NCOMP_VIN_SEL_PAD_PA4					((uint32_t)0x00000020)
N#define	NCOMP_VIN_SEL_PAD_PA5					((uint32_t)0x00000030)
N
N#define	PCOMP_VIN_SEL_DAC2_OUT				((uint32_t)0x00000000)
N#define	PCOMP_VIN_SEL_PAD_PA2					((uint32_t)0x00080000)
N#define	PCOMP_VIN_SEL_PAD_PA4					((uint32_t)0x00100000)
N#define	PCOMP_VIN_SEL_PAD_PA5					((uint32_t)0x00180000)
N
N#define IS_COMP_VINSEL(INPUT) (((INPUT) == NCOMP_VIN_SEL_DAC1_OUT) || \
N                                ((INPUT) == NCOMP_VIN_SEL_PAD_PA0) || \
N                                ((INPUT) == NCOMP_VIN_SEL_PAD_PA4) || \
N                                ((INPUT) == NCOMP_VIN_SEL_PAD_PA5) || \
N                                ((INPUT) == PCOMP_VIN_SEL_DAC2_OUT)|| \
N                                ((INPUT) == PCOMP_VIN_SEL_PAD_PA2) || \
N                                ((INPUT) == PCOMP_VIN_SEL_PAD_PA4) || \
N                                ((INPUT) == PCOMP_VIN_SEL_PAD_PA5))
X#define IS_COMP_VINSEL(INPUT) (((INPUT) == NCOMP_VIN_SEL_DAC1_OUT) ||                                 ((INPUT) == NCOMP_VIN_SEL_PAD_PA0) ||                                 ((INPUT) == NCOMP_VIN_SEL_PAD_PA4) ||                                 ((INPUT) == NCOMP_VIN_SEL_PAD_PA5) ||                                 ((INPUT) == PCOMP_VIN_SEL_DAC2_OUT)||                                 ((INPUT) == PCOMP_VIN_SEL_PAD_PA2) ||                                 ((INPUT) == PCOMP_VIN_SEL_PAD_PA4) ||                                 ((INPUT) == PCOMP_VIN_SEL_PAD_PA5))
N/**
N  * @}
N  */ 
N
N/** @defgroup COMP_OutputSel
N  * @{
N  */
N
N#define	COMP_OUTPUT_NO_SELECTION					((uint32_t)0x00000000)
N#define	NCOMP_OUTPUT_SEL_TIM1_CAPTURE1		((uint32_t)0x00000200)
N#define	NCOMP_OUTPUT_SEL_TIM1_OCREFCLEAR	((uint32_t)0x00000300)
N#define	NCOMP_OUTPUT_SEL_TIM3_CAPTURE1		((uint32_t)0x00000600)
N#define	NCOMP_OUTPUT_SEL_TIM3_OCREFCLEAR	((uint32_t)0x00000700)
N
N#define	PCOMP_OUTPUT_SEL_TIM1_BREAK					((uint32_t)0x01000000)
N#define	PCOMP_OUTPUT_SEL_TIM1_CAPTURE1			((uint32_t)0x02000000)
N#define	PCOMP_OUTPUT_SEL_TIM1_OCREFCLEAR		((uint32_t)0x03000000)
N#define	PCOMP_OUTPUT_SEL_TIM3_CAPTURE1			((uint32_t)0x06000000)
N#define	PCOMP_OUTPUT_SEL_TIM3_OCREFCLEAR		((uint32_t)0x07000000)
N
N
N#define IS_COMP_OUTPUT_SEL(SEL) (((SEL) == NCOMP_OUTPUT_SEL_TIM1_CAPTURE1)  || \
N                                 ((SEL) == NCOMP_OUTPUT_SEL_TIM1_OCREFCLEAR) ||\
N																	((SEL) == NCOMP_OUTPUT_SEL_TIM3_CAPTURE1	) ||\
N																	((SEL) == NCOMP_OUTPUT_SEL_TIM3_OCREFCLEAR) ||\
N																	((SEL) == PCOMP_OUTPUT_SEL_TIM1_BREAK			) ||\
N																	((SEL) == PCOMP_OUTPUT_SEL_TIM1_CAPTURE1	) ||\
N																	((SEL) == PCOMP_OUTPUT_SEL_TIM1_OCREFCLEAR) ||\
N																	((SEL) == PCOMP_OUTPUT_SEL_TIM3_CAPTURE1	) ||\
N																	((SEL) == PCOMP_OUTPUT_SEL_TIM3_OCREFCLEAR) ||\
N																	((SEL) == COMP_OUTPUT_NO_SELECTION))
X#define IS_COMP_OUTPUT_SEL(SEL) (((SEL) == NCOMP_OUTPUT_SEL_TIM1_CAPTURE1)  ||                                  ((SEL) == NCOMP_OUTPUT_SEL_TIM1_OCREFCLEAR) ||																	((SEL) == NCOMP_OUTPUT_SEL_TIM3_CAPTURE1	) ||																	((SEL) == NCOMP_OUTPUT_SEL_TIM3_OCREFCLEAR) ||																	((SEL) == PCOMP_OUTPUT_SEL_TIM1_BREAK			) ||																	((SEL) == PCOMP_OUTPUT_SEL_TIM1_CAPTURE1	) ||																	((SEL) == PCOMP_OUTPUT_SEL_TIM1_OCREFCLEAR) ||																	((SEL) == PCOMP_OUTPUT_SEL_TIM3_CAPTURE1	) ||																	((SEL) == PCOMP_OUTPUT_SEL_TIM3_OCREFCLEAR) ||																	((SEL) == COMP_OUTPUT_NO_SELECTION))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup COMP_Pol
N  * @{
N  */
N
N#define	NCOMP_POL_NOT_INVERT			((uint32_t)0x00000000)
N#define	NCOMP_POL_INVERT					((uint32_t)0x00000800)
N
N#define	PCOMP_POL_NOT_INVERT			((uint32_t)0x00000000)
N#define	PCOMP_POL_INVERT					((uint32_t)0x08000000)
N
N#define IS_COMP_POL(POL)    (((POL) == COMP_POL_NOT_INVERT) || \
N															((POL) == COMP_POL_INVERT))
X#define IS_COMP_POL(POL)    (((POL) == COMP_POL_NOT_INVERT) || 															((POL) == COMP_POL_INVERT))
N
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/** @defgroup COMP_OutputLevel
N  * @{
N  */ 
N/* When output polarity is not inverted, comparator output is high when
N   the non-inverting input is at a higher voltage than the inverting input */
N#define COMP_OutputLevel_High                   COMP_CSR_COMP1OUT
N/* When output polarity is not inverted, comparator output is low when
N   the non-inverting input is at a lower voltage than the inverting input*/
N#define COMP_OutputLevel_Low                    ((uint32_t)0x00000000)
N
N
N#define	IS_COMP_OUTPUT_LEVEL(LEVEL)			(((LEVEL) == COMP_CSR_COMP1OUT) || \
N																					((LEVEL) == COMP_CSR_COMP2OUT))
X#define	IS_COMP_OUTPUT_LEVEL(LEVEL)			(((LEVEL) == COMP_CSR_COMP1OUT) || 																					((LEVEL) == COMP_CSR_COMP2OUT))
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
N/*  Function used to set the COMP configuration to the default reset state ****/
Nvoid COMP_DeInit(void);
N
N/* Initialization and Configuration functions *********************************/
Nvoid COMP_Init(uint32_t COMP_Selection, COMP_InitTypeDef* COMP_InitStruct);
Nvoid COMP_StructInit(COMP_InitTypeDef* COMP_InitStruct);
Nvoid COMP_Cmd(uint32_t COMP_Selection, FunctionalState NewState);
Nuint32_t COMP_GetOutputLevel(uint32_t COMP_Selection);
N
N/* Window mode control function ***********************************************/
Nvoid COMP_WindowCmd(FunctionalState NewState);
N
N/* COMP configuration locking function ****************************************/
Nvoid COMP_LockConfig(uint32_t COMP_Selection);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__FT32F0XX_COMP_H */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT FMD *****END OF FILE****/
L 31 "..\user\main.h" 2
N#include "ft32f0xx_crc.h"
L 1 "..\FTLib\Inc\ft32f0xx_crc.h" 1
N/**
N  ******************************************************************************
N  * @file    			ft32f0xx_crc.h
N  * @author  			FMD AE
N  * @brief   			This file contains all the functions prototypes for the CRC firmware 
N  *          			library.	
N  * @version 			V1.0.0           
N  * @data		 			2021-07-01
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __FT32F0XX_CRC_H
N#define __FT32F0XX_CRC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/*!< Includes ----------------------------------------------------------------*/
N#include "ft32f0xx.h"
N
N
N/** @addtogroup CRC
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup CRC_ReverseInputData
N  * @{
N  */
N#define CRC_ReverseInputData_No             ((uint32_t)0x00000000) /*!< No reverse operation of Input Data */
N#define CRC_ReverseInputData_8bits          CRC_CR_REV_IN_0        /*!< Reverse operation of Input Data on 8 bits */
N#define CRC_ReverseInputData_16bits         CRC_CR_REV_IN_1        /*!< Reverse operation of Input Data on 16 bits */
N#define CRC_ReverseInputData_32bits         CRC_CR_REV_IN          /*!< Reverse operation of Input Data on 32 bits */
N
N#define IS_CRC_REVERSE_INPUT_DATA(DATA) (((DATA) == CRC_ReverseInputData_No)     || \
N                                         ((DATA) == CRC_ReverseInputData_8bits)  || \
N                                         ((DATA) == CRC_ReverseInputData_16bits) || \
N                                         ((DATA) == CRC_ReverseInputData_32bits))
X#define IS_CRC_REVERSE_INPUT_DATA(DATA) (((DATA) == CRC_ReverseInputData_No)     ||                                          ((DATA) == CRC_ReverseInputData_8bits)  ||                                          ((DATA) == CRC_ReverseInputData_16bits) ||                                          ((DATA) == CRC_ReverseInputData_32bits))
N
N/**
N  * @}
N  */
N
N/** @defgroup CRC_PolynomialSize
N  * @brief    Only applicable for FT32F042 and FT32F072 devices 
N  * @{
N  */
N#define CRC_PolSize_7                       CRC_CR_POLSIZE        /*!< 7-bit polynomial for CRC calculation */
N#define CRC_PolSize_8                       CRC_CR_POLSIZE_1      /*!< 8-bit polynomial for CRC calculation */
N#define CRC_PolSize_16                      CRC_CR_POLSIZE_0      /*!< 16-bit polynomial for CRC calculation */
N#define CRC_PolSize_32                      ((uint32_t)0x00000000)/*!< 32-bit polynomial for CRC calculation */
N
N#define IS_CRC_POL_SIZE(SIZE) (((SIZE) == CRC_PolSize_7)  || \
N                               ((SIZE) == CRC_PolSize_8)  || \
N                               ((SIZE) == CRC_PolSize_16) || \
N                               ((SIZE) == CRC_PolSize_32))
X#define IS_CRC_POL_SIZE(SIZE) (((SIZE) == CRC_PolSize_7)  ||                                ((SIZE) == CRC_PolSize_8)  ||                                ((SIZE) == CRC_PolSize_16) ||                                ((SIZE) == CRC_PolSize_32))
N                               
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N/* Configuration of the CRC computation unit **********************************/
Nvoid CRC_DeInit(void);
Nvoid CRC_ResetDR(void);
N//void CRC_PolynomialSizeSelect(uint32_t CRC_PolSize); /*!< Only applicable for FT32F042 and FT32F072 devices */ 
Nvoid CRC_ReverseInputDataSelect(uint32_t CRC_ReverseInputData);
Nvoid CRC_ReverseOutputDataCmd(FunctionalState NewState);
Nvoid CRC_SetInitRegister(uint32_t CRC_InitValue); 
Nvoid CRC_SetPolynomial(uint32_t CRC_Pol);
N
N/* CRC computation ************************************************************/
Nuint32_t CRC_CalcCRC(uint32_t CRC_Data);
Nuint32_t CRC_CalcCRC16bits(uint16_t CRC_Data); 
Nuint32_t CRC_CalcCRC8bits(uint8_t CRC_Data);
Nuint32_t CRC_CalcBlockCRC(uint32_t pBuffer[], uint32_t BufferLength);
Nuint32_t CRC_GetCRC(void);
N
N/* Independent register (IDR) access (write/read) *****************************/
Nvoid CRC_SetIDRegister(uint8_t CRC_IDValue);
Nuint8_t CRC_GetIDRegister(void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __FT32F0XX_CRC_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT FMD *****END OF FILE****/
L 32 "..\user\main.h" 2
N#include "ft32f0xx_crs.h"
L 1 "..\FTLib\Inc\ft32f0xx_crs.h" 1
N/**
N  ******************************************************************************
N  * @file    			ft32f0xx_crs.h
N  * @author  			FMD AE
N  * @brief   			This file contains all the functions prototypes for the CRS firmware 
N  *          			library.	
N  * @version 			V1.0.0           
N  * @data		 			2021-07-01
N  ******************************************************************************
N  */
N	
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __FT32F0XX_CRS_H
N#define __FT32F0XX_CRS_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/*!< Includes ----------------------------------------------------------------*/
N#include "ft32f0xx.h"
N
N
N/** @addtogroup CRS
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup CRS_Interrupt_Sources
N  * @{
N  */
N#define CRS_IT_SYNCOK             CRS_ISR_SYNCOKF    /*!< SYNC event OK */
N#define CRS_IT_SYNCWARN           CRS_ISR_SYNCWARNF  /*!< SYNC warning */
N#define CRS_IT_ERR                CRS_ISR_ERRF       /*!< error */
N#define CRS_IT_ESYNC              CRS_ISR_ESYNCF     /*!< Expected SYNC */
N#define CRS_IT_TRIMOVF            CRS_ISR_TRIMOVF    /*!< Trimming overflow or underflow */
N#define CRS_IT_SYNCERR            CRS_ISR_SYNCERR    /*!< SYNC error */
N#define CRS_IT_SYNCMISS           CRS_ISR_SYNCMISS    /*!< SYNC missed*/
N
N#define IS_CRS_IT(IT) (((IT) == CRS_IT_SYNCOK) || ((IT) == CRS_IT_SYNCWARN) || \
N                       ((IT) == CRS_IT_ERR)  || ((IT) == CRS_IT_ESYNC))
X#define IS_CRS_IT(IT) (((IT) == CRS_IT_SYNCOK) || ((IT) == CRS_IT_SYNCWARN) ||                        ((IT) == CRS_IT_ERR)  || ((IT) == CRS_IT_ESYNC))
N                       
N#define IS_CRS_GET_IT(IT) (((IT) == CRS_IT_SYNCOK) || ((IT) == CRS_IT_SYNCWARN) || \
N                           ((IT) == CRS_IT_ERR) || ((IT) == CRS_IT_ESYNC) || \
N                           ((IT) == CRS_IT_TRIMOVF) || ((IT) == CRS_IT_SYNCERR) || \
N                           ((IT) == CRS_IT_SYNCMISS))
X#define IS_CRS_GET_IT(IT) (((IT) == CRS_IT_SYNCOK) || ((IT) == CRS_IT_SYNCWARN) ||                            ((IT) == CRS_IT_ERR) || ((IT) == CRS_IT_ESYNC) ||                            ((IT) == CRS_IT_TRIMOVF) || ((IT) == CRS_IT_SYNCERR) ||                            ((IT) == CRS_IT_SYNCMISS))
N
N#define IS_CRS_CLEAR_IT(IT) ((IT) != 0x00)                                         
N
N/**
N  * @}
N  */
N
N/** @defgroup CRS_Flags
N  * @{
N  */
N#define CRS_FLAG_SYNCOK             CRS_ISR_SYNCOKF    /*!< SYNC event OK */
N#define CRS_FLAG_SYNCWARN           CRS_ISR_SYNCWARNF  /*!< SYNC warning */
N#define CRS_FLAG_ERR                CRS_ISR_ERRF       /*!< error */
N#define CRS_FLAG_ESYNC              CRS_ISR_ESYNCF     /*!< Expected SYNC */
N#define CRS_FLAG_TRIMOVF            CRS_ISR_TRIMOVF    /*!< Trimming overflow or underflow */
N#define CRS_FLAG_SYNCERR            CRS_ISR_SYNCERR    /*!< SYNC error */
N#define CRS_FLAG_SYNCMISS           CRS_ISR_SYNCMISS    /*!< SYNC missed*/
N
N#define IS_CRS_FLAG(FLAG) (((FLAG) == CRS_FLAG_SYNCOK) || ((FLAG) == CRS_FLAG_SYNCWARN) || \
N                           ((FLAG) == CRS_FLAG_ERR) || ((FLAG) == CRS_FLAG_ESYNC) || \
N                           ((FLAG) == CRS_FLAG_TRIMOVF) || ((FLAG) == CRS_FLAG_SYNCERR) || \
N                           ((FLAG) == CRS_FLAG_SYNCMISS))
X#define IS_CRS_FLAG(FLAG) (((FLAG) == CRS_FLAG_SYNCOK) || ((FLAG) == CRS_FLAG_SYNCWARN) ||                            ((FLAG) == CRS_FLAG_ERR) || ((FLAG) == CRS_FLAG_ESYNC) ||                            ((FLAG) == CRS_FLAG_TRIMOVF) || ((FLAG) == CRS_FLAG_SYNCERR) ||                            ((FLAG) == CRS_FLAG_SYNCMISS))
N
N/**
N  * @}
N  */
N  
N/** @defgroup CRS_Synchro_Source
N  * @{
N  */
N#define CRS_SYNCSource_GPIO       ((uint32_t)0x00)        /*!< Synchro Signal soucre GPIO */
N#define CRS_SYNCSource_LSE        CRS_CFGR_SYNCSRC_0      /*!< Synchro Signal source LSE */
N#define CRS_SYNCSource_USB        CRS_CFGR_SYNCSRC_1      /*!< Synchro Signal source USB SOF */
N
N#define IS_CRS_SYNC_SOURCE(SOURCE) (((SOURCE) == CRS_SYNCSource_GPIO) || \
N                                    ((SOURCE) == CRS_SYNCSource_LSE) ||\
N                                    ((SOURCE) == CRS_SYNCSource_USB))
X#define IS_CRS_SYNC_SOURCE(SOURCE) (((SOURCE) == CRS_SYNCSource_GPIO) ||                                     ((SOURCE) == CRS_SYNCSource_LSE) ||                                    ((SOURCE) == CRS_SYNCSource_USB))
N/**
N  * @}
N  */
N
N/** @defgroup CRS_SynchroDivider
N  * @{
N  */
N#define CRS_SYNC_Div1        ((uint32_t)0x00)                          /*!< Synchro Signal not divided */
N#define CRS_SYNC_Div2        CRS_CFGR_SYNCDIV_0                        /*!< Synchro Signal divided by 2 */
N#define CRS_SYNC_Div4        CRS_CFGR_SYNCDIV_1                        /*!< Synchro Signal divided by 4 */
N#define CRS_SYNC_Div8        (CRS_CFGR_SYNCDIV_1 | CRS_CFGR_SYNCDIV_0) /*!< Synchro Signal divided by 8 */
N#define CRS_SYNC_Div16       CRS_CFGR_SYNCDIV_2                        /*!< Synchro Signal divided by 16 */
N#define CRS_SYNC_Div32       (CRS_CFGR_SYNCDIV_2 | CRS_CFGR_SYNCDIV_0) /*!< Synchro Signal divided by 32 */
N#define CRS_SYNC_Div64       (CRS_CFGR_SYNCDIV_2 | CRS_CFGR_SYNCDIV_1) /*!< Synchro Signal divided by 64 */
N#define CRS_SYNC_Div128      CRS_CFGR_SYNCDIV                          /*!< Synchro Signal divided by 128 */
N
N#define IS_CRS_SYNC_DIV(DIV) (((DIV) == CRS_SYNC_Div1) || ((DIV) == CRS_SYNC_Div2)   ||\
N                              ((DIV) == CRS_SYNC_Div4) || ((DIV) == CRS_SYNC_Div8)   || \
N                              ((DIV) == CRS_SYNC_Div16) || ((DIV) == CRS_SYNC_Div32) || \
N                              ((DIV) == CRS_SYNC_Div64) || ((DIV) == CRS_SYNC_Div128))
X#define IS_CRS_SYNC_DIV(DIV) (((DIV) == CRS_SYNC_Div1) || ((DIV) == CRS_SYNC_Div2)   ||                              ((DIV) == CRS_SYNC_Div4) || ((DIV) == CRS_SYNC_Div8)   ||                               ((DIV) == CRS_SYNC_Div16) || ((DIV) == CRS_SYNC_Div32) ||                               ((DIV) == CRS_SYNC_Div64) || ((DIV) == CRS_SYNC_Div128))
N/**
N  * @}
N  */
N
N/** @defgroup CRS_SynchroPolarity
N  * @{
N  */
N#define CRS_SYNCPolarity_Rising       ((uint32_t)0x00)      /*!< Synchro Active on rising edge */
N#define CRS_SYNCPolarity_Falling      CRS_CFGR_SYNCPOL      /*!< Synchro Active on falling edge */
N
N#define IS_CRS_SYNC_POLARITY(POLARITY) (((POLARITY) == CRS_SYNCPolarity_Rising) || \
N                                    ((POLARITY) == CRS_SYNCPolarity_Falling))
X#define IS_CRS_SYNC_POLARITY(POLARITY) (((POLARITY) == CRS_SYNCPolarity_Rising) ||                                     ((POLARITY) == CRS_SYNCPolarity_Falling))
N/**
N  * @}
N  */
N
N
N    
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N/* Configuration of the CRS **********************************/
Nvoid CRS_DeInit(void);
Nvoid CRS_AdjustHSI48CalibrationValue(uint8_t CRS_HSI48CalibrationValue);
Nvoid CRS_FrequencyErrorCounterCmd(FunctionalState NewState);
Nvoid CRS_AutomaticCalibrationCmd(FunctionalState NewState); 
Nvoid CRS_SoftwareSynchronizationGenerate(void);
Nvoid CRS_FrequencyErrorCounterReload(uint32_t CRS_ReloadValue);
Nvoid CRS_FrequencyErrorLimitConfig(uint8_t CRS_ErrorLimitValue);
Nvoid CRS_SynchronizationPrescalerConfig(uint32_t CRS_Prescaler);
Nvoid CRS_SynchronizationSourceConfig(uint32_t CRS_Source);
Nvoid CRS_SynchronizationPolarityConfig(uint32_t CRS_Polarity);
Nuint32_t CRS_GetReloadValue(void);
Nuint32_t CRS_GetHSI48CalibrationValue(void);
Nuint32_t CRS_GetFrequencyErrorValue(void);
Nuint32_t CRS_GetFrequencyErrorDirection(void);
N
N/* Interrupts and flags management functions **********************************/
Nvoid CRS_ITConfig(uint32_t CRS_IT, FunctionalState NewState);
NFlagStatus CRS_GetFlagStatus(uint32_t CRS_FLAG);
Nvoid CRS_ClearFlag(uint32_t CRS_FLAG);
NITStatus CRS_GetITStatus(uint32_t CRS_IT);
Nvoid CRS_ClearITPendingBit(uint32_t CRS_IT);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __FT32F0XX_CRS_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT FMD *****END OF FILE****/
L 33 "..\user\main.h" 2
N#include "ft32f0xx_dac.h"
L 1 "..\FTLib\Inc\ft32f0xx_dac.h" 1
N/**
N  ******************************************************************************
N  * @file    			ft32f0xx_dac.h
N  * @author  			FMD AE
N  * @brief   			This file contains all the functions prototypes for the DAC firmware 
N  *          			library.	
N  * @version 			V1.0.0           
N  * @data		 			2021-07-01
N  ******************************************************************************
N  */
N#ifndef	__FT32F0XX_DAC_H
N#define	__FT32F0XX_DAC_H
N
N
N#include "ft32f0xx.h"
N
N
N
N/**
N	*	@Parama DAC_CTRL
N	*/
N
N#define	DAC_DATA_RESET			((uint32_t)(0x0000007f))		
N
N#define	DAC_CTRL_READ				(uint8_t)(0x20)
N#define	DAC_DATA1_READ			(uint8_t)(0x24)
N#define	DAC_DATA2_READ			(uint8_t)(0x28)
N
N
N#define IS_DAC_DATA(DATA) ((DATA) <= 0x7F) 
N
N
N/**
N	*	@Parama DAC1_DATA
N	*/
Nvoid DAC_Ref_Config(uint32_t	DAC_RefSel);
Nvoid Bsp_DAC_Config(void);
Nuint8_t DAC_Read_Reg(uint8_t DAC_Register);
Nvoid DAC_Cmd(FunctionalState NewState);
Nvoid DAC_SetChannel1Data(uint32_t DAC_Align, uint8_t Data);
Nvoid DAC_SetChannel2Data(uint32_t DAC_Align, uint8_t Data);
N
N#endif
L 34 "..\user\main.h" 2
N#include "ft32f0xx_dma.h"
L 1 "..\FTLib\Inc\ft32f0xx_dma.h" 1
N/**
N  ******************************************************************************
N  * @file    			ft32f0xx_dma.h
N  * @author  			FMD AE
N  * @brief   			This file contains all the functions prototypes for the DMA firmware
N  *               library.  	
N  * @version 			V1.0.0           
N  * @data		 			2021-07-01
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __FT32F0XX_DMA_H
N#define __FT32F0XX_DMA_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "ft32f0xx.h"
N
N
N/** @addtogroup DMA
N  * @{
N  */
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief  DMA Init structures definition
N  */
Ntypedef struct
N{
N  uint32_t DMA_PeripheralBaseAddr; /*!< Specifies the peripheral base address for DMAy Channelx.              */
N
N  uint32_t DMA_MemoryBaseAddr;     /*!< Specifies the memory base address for DMAy Channelx.                  */
N
N  uint32_t DMA_DIR;                /*!< Specifies if the peripheral is the source or destination.
N                                        This parameter can be a value of @ref DMA_data_transfer_direction     */
N
N  uint32_t DMA_BufferSize;         /*!< Specifies the buffer size, in data unit, of the specified Channel. 
N                                        The data unit is equal to the configuration set in DMA_PeripheralDataSize
N                                        or DMA_MemoryDataSize members depending in the transfer direction     */
N
N  uint32_t DMA_PeripheralInc;      /*!< Specifies whether the Peripheral address register is incremented or not.
N                                        This parameter can be a value of @ref DMA_peripheral_incremented_mode */
N
N  uint32_t DMA_MemoryInc;          /*!< Specifies whether the memory address register is incremented or not.
N                                        This parameter can be a value of @ref DMA_memory_incremented_mode     */
N
N  uint32_t DMA_PeripheralDataSize; /*!< Specifies the Peripheral data width.
N                                        This parameter can be a value of @ref DMA_peripheral_data_size        */
N
N  uint32_t DMA_MemoryDataSize;     /*!< Specifies the Memory data width.
N                                        This parameter can be a value of @ref DMA_memory_data_size            */
N
N  uint32_t DMA_Mode;               /*!< Specifies the operation mode of the DMAy Channelx.
N                                        This parameter can be a value of @ref DMA_circular_normal_mode
N                                        @note: The circular buffer mode cannot be used if the memory-to-memory
N                                              data transfer is configured on the selected Channel */
N
N  uint32_t DMA_Priority;           /*!< Specifies the software priority for the DMAy Channelx.
N                                        This parameter can be a value of @ref DMA_priority_level              */
N
N  uint32_t DMA_M2M;                /*!< Specifies if the DMAy Channelx will be used in memory-to-memory transfer.
N                                        This parameter can be a value of @ref DMA_memory_to_memory            */
N}DMA_InitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup DMA_Exported_Constants
N  * @{
N  */
N
N#define IS_DMA_ALL_PERIPH(PERIPH) (((PERIPH) == DMA1_Channel1) || \
N                                   ((PERIPH) == DMA1_Channel2) || \
N                                   ((PERIPH) == DMA1_Channel3) || \
N                                   ((PERIPH) == DMA1_Channel4) || \
N                                   ((PERIPH) == DMA1_Channel5) || \
N                                   ((PERIPH) == DMA1_Channel6) || \
N                                   ((PERIPH) == DMA1_Channel7) || \
N                                   ((PERIPH) == DMA2_Channel1) || \
N                                   ((PERIPH) == DMA2_Channel2) || \
N                                   ((PERIPH) == DMA2_Channel3) || \
N                                   ((PERIPH) == DMA2_Channel4) || \
N                                   ((PERIPH) == DMA2_Channel5))
X#define IS_DMA_ALL_PERIPH(PERIPH) (((PERIPH) == DMA1_Channel1) ||                                    ((PERIPH) == DMA1_Channel2) ||                                    ((PERIPH) == DMA1_Channel3) ||                                    ((PERIPH) == DMA1_Channel4) ||                                    ((PERIPH) == DMA1_Channel5) ||                                    ((PERIPH) == DMA1_Channel6) ||                                    ((PERIPH) == DMA1_Channel7) ||                                    ((PERIPH) == DMA2_Channel1) ||                                    ((PERIPH) == DMA2_Channel2) ||                                    ((PERIPH) == DMA2_Channel3) ||                                    ((PERIPH) == DMA2_Channel4) ||                                    ((PERIPH) == DMA2_Channel5))
N
N/** @defgroup DMA_data_transfer_direction 
N  * @{
N  */
N
N#define DMA_DIR_PeripheralSRC              ((uint32_t)0x00000000)
N#define DMA_DIR_PeripheralDST              DMA_CCR_DIR
N
N#define IS_DMA_DIR(DIR) (((DIR) == DMA_DIR_PeripheralSRC) || \
N                         ((DIR) == DMA_DIR_PeripheralDST))
X#define IS_DMA_DIR(DIR) (((DIR) == DMA_DIR_PeripheralSRC) ||                          ((DIR) == DMA_DIR_PeripheralDST))
N/**
N  * @}
N  */
N
N/** @defgroup DMA_peripheral_incremented_mode 
N  * @{
N  */
N
N#define DMA_PeripheralInc_Disable          ((uint32_t)0x00000000)
N#define DMA_PeripheralInc_Enable           DMA_CCR_PINC
N
N#define IS_DMA_PERIPHERAL_INC_STATE(STATE) (((STATE) == DMA_PeripheralInc_Disable) || \
N                                            ((STATE) == DMA_PeripheralInc_Enable))
X#define IS_DMA_PERIPHERAL_INC_STATE(STATE) (((STATE) == DMA_PeripheralInc_Disable) ||                                             ((STATE) == DMA_PeripheralInc_Enable))
N/**
N  * @}
N  */
N
N/** @defgroup DMA_memory_incremented_mode 
N  * @{
N  */
N
N#define DMA_MemoryInc_Disable              ((uint32_t)0x00000000)
N#define DMA_MemoryInc_Enable               DMA_CCR_MINC
N
N#define IS_DMA_MEMORY_INC_STATE(STATE) (((STATE) == DMA_MemoryInc_Disable) || \
N                                        ((STATE) == DMA_MemoryInc_Enable))
X#define IS_DMA_MEMORY_INC_STATE(STATE) (((STATE) == DMA_MemoryInc_Disable) ||                                         ((STATE) == DMA_MemoryInc_Enable))
N/**
N  * @}
N  */
N
N/** @defgroup DMA_peripheral_data_size 
N  * @{
N  */
N
N#define DMA_PeripheralDataSize_Byte        ((uint32_t)0x00000000)
N#define DMA_PeripheralDataSize_HalfWord    DMA_CCR_PSIZE_0
N#define DMA_PeripheralDataSize_Word        DMA_CCR_PSIZE_1
N
N#define IS_DMA_PERIPHERAL_DATA_SIZE(SIZE) (((SIZE) == DMA_PeripheralDataSize_Byte) || \
N                                           ((SIZE) == DMA_PeripheralDataSize_HalfWord) || \
N                                           ((SIZE) == DMA_PeripheralDataSize_Word))
X#define IS_DMA_PERIPHERAL_DATA_SIZE(SIZE) (((SIZE) == DMA_PeripheralDataSize_Byte) ||                                            ((SIZE) == DMA_PeripheralDataSize_HalfWord) ||                                            ((SIZE) == DMA_PeripheralDataSize_Word))
N/**
N  * @}
N  */
N
N/** @defgroup DMA_memory_data_size 
N  * @{
N  */
N
N#define DMA_MemoryDataSize_Byte            ((uint32_t)0x00000000)
N#define DMA_MemoryDataSize_HalfWord        DMA_CCR_MSIZE_0
N#define DMA_MemoryDataSize_Word            DMA_CCR_MSIZE_1
N
N#define IS_DMA_MEMORY_DATA_SIZE(SIZE) (((SIZE) == DMA_MemoryDataSize_Byte) || \
N                                       ((SIZE) == DMA_MemoryDataSize_HalfWord) || \
N                                       ((SIZE) == DMA_MemoryDataSize_Word))
X#define IS_DMA_MEMORY_DATA_SIZE(SIZE) (((SIZE) == DMA_MemoryDataSize_Byte) ||                                        ((SIZE) == DMA_MemoryDataSize_HalfWord) ||                                        ((SIZE) == DMA_MemoryDataSize_Word))
N/**
N  * @}
N  */
N
N/** @defgroup DMA_circular_normal_mode 
N  * @{
N  */
N
N#define DMA_Mode_Normal                    ((uint32_t)0x00000000)
N#define DMA_Mode_Circular                  DMA_CCR_CIRC
N
N#define IS_DMA_MODE(MODE) (((MODE) == DMA_Mode_Normal) || ((MODE) == DMA_Mode_Circular))
N/**
N  * @}
N  */
N
N/** @defgroup DMA_priority_level 
N  * @{
N  */
N
N#define DMA_Priority_VeryHigh              DMA_CCR_PL
N#define DMA_Priority_High                  DMA_CCR_PL_1
N#define DMA_Priority_Medium                DMA_CCR_PL_0
N#define DMA_Priority_Low                   ((uint32_t)0x00000000)
N
N#define IS_DMA_PRIORITY(PRIORITY) (((PRIORITY) == DMA_Priority_VeryHigh) || \
N                                   ((PRIORITY) == DMA_Priority_High) || \
N                                   ((PRIORITY) == DMA_Priority_Medium) || \
N                                   ((PRIORITY) == DMA_Priority_Low))
X#define IS_DMA_PRIORITY(PRIORITY) (((PRIORITY) == DMA_Priority_VeryHigh) ||                                    ((PRIORITY) == DMA_Priority_High) ||                                    ((PRIORITY) == DMA_Priority_Medium) ||                                    ((PRIORITY) == DMA_Priority_Low))
N/**
N  * @}
N  */
N
N/** @defgroup DMA_memory_to_memory 
N  * @{
N  */
N
N#define DMA_M2M_Disable                    ((uint32_t)0x00000000)
N#define DMA_M2M_Enable                     DMA_CCR_MEM2MEM
N
N#define IS_DMA_M2M_STATE(STATE) (((STATE) == DMA_M2M_Disable) || ((STATE) == DMA_M2M_Enable))
N
N/**
N  * @}
N  */
N
N/** @defgroup DMA_Remap_Config 
N  * @{
N  */ 
N#define DMAx_CHANNEL1_RMP                                     0x00000000
N#define DMAx_CHANNEL2_RMP                                     0x10000000
N#define DMAx_CHANNEL3_RMP                                     0x20000000
N#define DMAx_CHANNEL4_RMP                                     0x30000000
N#define DMAx_CHANNEL5_RMP                                     0x40000000
N#define DMAx_CHANNEL6_RMP                                     0x50000000
N#define DMAx_CHANNEL7_RMP                                     0x60000000
N
N
N#define IS_DMA_ALL_LIST(LIST) (((LIST) == DMA1) || \
N                               ((LIST) == DMA2))
X#define IS_DMA_ALL_LIST(LIST) (((LIST) == DMA1) ||                                ((LIST) == DMA2))
N
N/****************** DMA1 remap bit field definition********************/
N/* DMA1 - Channel 1 */
N#define DMA1_CH1_DEFAULT      (uint32_t) (DMAx_CHANNEL1_RMP | DMA_RMPCR1_DEFAULT)       /*!< Default remap position for DMA1 */   
N#define DMA1_CH1_ADC          (uint32_t) (DMAx_CHANNEL1_RMP | DMA_RMPCR1_CH1_ADC)       /*!< Remap ADC on DMA1 Channel 1*/   
N#define DMA1_CH1_TIM17_CH1    (uint32_t) (DMAx_CHANNEL1_RMP | DMA_RMPCR1_CH1_TIM17_CH1) /*!< Remap TIM17 channel 1 on DMA1 channel 1 */
N#define DMA1_CH1_TIM17_UP     (uint32_t) (DMAx_CHANNEL1_RMP | DMA_RMPCR1_CH1_TIM17_UP)  /*!< Remap TIM17 up on DMA1 channel 1 */ 
N#define DMA1_CH1_USART1_RX    (uint32_t) (DMAx_CHANNEL1_RMP | DMA_RMPCR1_CH1_USART1_RX) /*!< Remap USART1 Rx on DMA1 channel 1 */ 
N#define DMA1_CH1_USART2_RX    (uint32_t) (DMAx_CHANNEL1_RMP | DMA_RMPCR1_CH1_USART2_RX) /*!< Remap USART2 Rx on DMA1 channel 1 */ 
N#define DMA1_CH1_USART3_RX    (uint32_t) (DMAx_CHANNEL1_RMP | DMA_RMPCR1_CH1_USART3_RX) /*!< Remap USART3 Rx on DMA1 channel 1 */ 
N#define DMA1_CH1_USART4_RX    (uint32_t) (DMAx_CHANNEL1_RMP | DMA_RMPCR1_CH1_USART4_RX) /*!< Remap USART4 Rx on DMA1 channel 1 */ 
N#define DMA1_CH1_USART5_RX    (uint32_t) (DMAx_CHANNEL1_RMP | DMA_RMPCR1_CH1_USART5_RX) /*!< Remap USART5 Rx on DMA1 channel 1 */ 
N#define DMA1_CH1_USART6_RX    (uint32_t) (DMAx_CHANNEL1_RMP | DMA_RMPCR1_CH1_USART6_RX) /*!< Remap USART6 Rx on DMA1 channel 1 */ 
N#define DMA1_CH1_USART7_RX    (uint32_t) (DMAx_CHANNEL1_RMP | DMA_RMPCR1_CH1_USART7_RX) /*!< Remap USART7 Rx on DMA1 channel 1 */ 
N#define DMA1_CH1_USART8_RX    (uint32_t) (DMAx_CHANNEL1_RMP | DMA_RMPCR1_CH1_USART8_RX) /*!< Remap USART8 Rx on DMA1 channel 1 */ 
N/* DMA1 - Channel 2 */
N#define DMA1_CH2_DEFAULT      (uint32_t) (DMAx_CHANNEL2_RMP | DMA_RMPCR1_DEFAULT)       /*!< Default remap position for DMA1 */   
N#define DMA1_CH2_ADC          (uint32_t) (DMAx_CHANNEL2_RMP | DMA_RMPCR1_CH2_ADC)       /*!< Remap ADC on DMA1 channel 2 */  
N#define DMA1_CH2_I2C1_TX      (uint32_t) (DMAx_CHANNEL2_RMP | DMA_RMPCR1_CH2_I2C1_TX)   /*!< Remap I2C1 Tx on DMA1 channel 2 */ 
N#define DMA1_CH2_SPI1_RX      (uint32_t) (DMAx_CHANNEL2_RMP | DMA_RMPCR1_CH2_SPI_1RX)   /*!< Remap SPI1 Rx on DMA1 channel 2 */ 
N#define DMA1_CH2_TIM1_CH1     (uint32_t) (DMAx_CHANNEL2_RMP | DMA_RMPCR1_CH2_TIM1_CH1)  /*!< Remap TIM1 channel 1 on DMA1 channel 2 */
N#define DMA1_CH2_TIM17_CH1    (uint32_t) (DMAx_CHANNEL2_RMP | DMA_RMPCR1_CH2_TIM17_CH1) /*!< Remap TIM17 channel 1 on DMA1 channel 2 */
N#define DMA1_CH2_TIM17_UP     (uint32_t) (DMAx_CHANNEL2_RMP | DMA_RMPCR1_CH2_TIM17_UP)  /*!< Remap TIM17 up on DMA1 channel 2 */ 
N#define DMA1_CH2_USART1_TX    (uint32_t) (DMAx_CHANNEL2_RMP | DMA_RMPCR1_CH2_USART1_TX) /*!< Remap USART1 Tx on DMA1 channel 2 */ 
N#define DMA1_CH2_USART2_TX    (uint32_t) (DMAx_CHANNEL2_RMP | DMA_RMPCR1_CH2_USART2_TX) /*!< Remap USART2 Tx on DMA1 channel 2 */ 
N#define DMA1_CH2_USART3_TX    (uint32_t) (DMAx_CHANNEL2_RMP | DMA_RMPCR1_CH2_USART3_TX) /*!< Remap USART3 Tx on DMA1 channel 2 */ 
N#define DMA1_CH2_USART4_TX    (uint32_t) (DMAx_CHANNEL2_RMP | DMA_RMPCR1_CH2_USART4_TX) /*!< Remap USART4 Tx on DMA1 channel 2 */ 
N#define DMA1_CH2_USART5_TX    (uint32_t) (DMAx_CHANNEL2_RMP | DMA_RMPCR1_CH2_USART5_TX) /*!< Remap USART5 Tx on DMA1 channel 2 */ 
N#define DMA1_CH2_USART6_TX    (uint32_t) (DMAx_CHANNEL2_RMP | DMA_RMPCR1_CH2_USART6_TX) /*!< Remap USART6 Tx on DMA1 channel 2 */ 
N#define DMA1_CH2_USART7_TX    (uint32_t) (DMAx_CHANNEL2_RMP | DMA_RMPCR1_CH2_USART7_TX) /*!< Remap USART7 Tx on DMA1 channel 2 */ 
N#define DMA1_CH2_USART8_TX    (uint32_t) (DMAx_CHANNEL2_RMP | DMA_RMPCR1_CH2_USART8_TX) /*!< Remap USART8 Tx on DMA1 channel 2 */ 
N/* DMA1 - Channel 3 */
N#define DMA1_CH3_DEFAULT      (uint32_t) (DMAx_CHANNEL3_RMP | DMA_RMPCR1_DEFAULT)       /*!< Default remap position for DMAx */   
N#define DMA1_CH3_TIM6_UP      (uint32_t) (DMAx_CHANNEL3_RMP | DMA_RMPCR1_CH3_TIM6_UP)   /*!< Remap TIM6 up on DMA1 channel 3 */ 
N#define DMA1_CH3_DAC_CH1      (uint32_t) (DMAx_CHANNEL3_RMP | DMA_RMPCR1_CH3_DAC_CH1)   /*!< Remap DAC Channel 1on DMA1 channel 3 */ 
N#define DMA1_CH3_I2C1_RX      (uint32_t) (DMAx_CHANNEL3_RMP | DMA_RMPCR1_CH3_I2C1_RX)   /*!< Remap I2C1 Rx on DMA1 channel 3 */ 
N#define DMA1_CH3_SPI1_TX      (uint32_t) (DMAx_CHANNEL3_RMP | DMA_RMPCR1_CH3_SPI1_TX)   /*!< Remap SPI1 Tx on DMA1 channel 3 */ 
N#define DMA1_CH3_TIM1_CH2     (uint32_t) (DMAx_CHANNEL3_RMP | DMA_RMPCR1_CH3_TIM1_CH2)  /*!< Remap TIM1 channel 2 on DMA1 channel 3 */
N#define DMA1_CH3_TIM2_CH2     (uint32_t) (DMAx_CHANNEL3_RMP | DMA_RMPCR1_CH3_TIM2_CH2)  /*!< Remap TIM2 channel 2 on DMA1 channel 3 */
N#define DMA1_CH3_TIM16_CH1    (uint32_t) (DMAx_CHANNEL3_RMP | DMA_RMPCR1_CH3_TIM16_CH1) /*!< Remap TIM16 channel 1 on DMA1 channel 3 */
N#define DMA1_CH3_TIM16_UP     (uint32_t) (DMAx_CHANNEL3_RMP | DMA_RMPCR1_CH3_TIM16_UP)  /*!< Remap TIM16 up on DMA1 channel 3 */ 
N#define DMA1_CH3_USART1_RX    (uint32_t) (DMAx_CHANNEL3_RMP | DMA_RMPCR1_CH3_USART1_RX) /*!< Remap USART1 Rx on DMA1 channel 3 */ 
N#define DMA1_CH3_USART2_RX    (uint32_t) (DMAx_CHANNEL3_RMP | DMA_RMPCR1_CH3_USART2_RX) /*!< Remap USART2 Rx on DMA1 channel 3 */ 
N#define DMA1_CH3_USART3_RX    (uint32_t) (DMAx_CHANNEL3_RMP | DMA_RMPCR1_CH3_USART3_RX) /*!< Remap USART3 Rx on DMA1 channel 3 */ 
N#define DMA1_CH3_USART4_RX    (uint32_t) (DMAx_CHANNEL3_RMP | DMA_RMPCR1_CH3_USART4_RX) /*!< Remap USART4 Rx on DMA1 channel 3 */ 
N#define DMA1_CH3_USART5_RX    (uint32_t) (DMAx_CHANNEL3_RMP | DMA_RMPCR1_CH3_USART5_RX) /*!< Remap USART5 Rx on DMA1 channel 3 */ 
N#define DMA1_CH3_USART6_RX    (uint32_t) (DMAx_CHANNEL3_RMP | DMA_RMPCR1_CH3_USART6_RX) /*!< Remap USART6 Rx on DMA1 channel 3 */ 
N#define DMA1_CH3_USART7_RX    (uint32_t) (DMAx_CHANNEL3_RMP | DMA_RMPCR1_CH3_USART7_RX) /*!< Remap USART7 Rx on DMA1 channel 3 */ 
N#define DMA1_CH3_USART8_RX    (uint32_t) (DMAx_CHANNEL3_RMP | DMA_RMPCR1_CH3_USART8_RX) /*!< Remap USART8 Rx on DMA1 channel 3 */ 
N/* DMA1 - Channel 4 */
N#define DMA1_CH4_DEFAULT      (uint32_t) (DMAx_CHANNEL4_RMP | DMA_RMPCR1_DEFAULT)       /*!< Default remap position for DMA1 */   
N#define DMA1_CH4_TIM7_UP      (uint32_t) (DMAx_CHANNEL4_RMP | DMA_RMPCR1_CH4_TIM7_UP)   /*!< Remap TIM7 up on DMA1 channel 4 */ 
N#define DMA1_CH4_DAC_CH2      (uint32_t) (DMAx_CHANNEL4_RMP | DMA_RMPCR1_CH4_DAC_CH2)   /*!< Remap DAC Channel 2 on DMA1 channel 4 */
N#define DMA1_CH4_I2C2_TX      (uint32_t) (DMAx_CHANNEL4_RMP | DMA_RMPCR1_CH4_I2C2_TX)   /*!< Remap I2C2 Tx on DMA1 channel 4 */ 
N#define DMA1_CH4_SPI2_RX      (uint32_t) (DMAx_CHANNEL4_RMP | DMA_RMPCR1_CH4_SPI2_RX)   /*!< Remap SPI2 Rx on DMA1 channel 4 */ 
N#define DMA1_CH4_TIM2_CH4     (uint32_t) (DMAx_CHANNEL4_RMP | DMA_RMPCR1_CH4_TIM2_CH4)  /*!< Remap TIM2 channel 4 on DMA1 channel 4 */
N#define DMA1_CH4_TIM3_CH1     (uint32_t) (DMAx_CHANNEL4_RMP | DMA_RMPCR1_CH4_TIM3_CH1)  /*!< Remap TIM3 channel 1 on DMA1 channel 4 */
N#define DMA1_CH4_TIM3_TRIG    (uint32_t) (DMAx_CHANNEL4_RMP | DMA_RMPCR1_CH4_TIM3_TRIG) /*!< Remap TIM3 Trig on DMA1 channel 4 */ 
N#define DMA1_CH4_TIM16_CH1    (uint32_t) (DMAx_CHANNEL4_RMP | DMA_RMPCR1_CH4_TIM16_CH1) /*!< Remap TIM16 channel 1 on DMA1 channel 4 */
N#define DMA1_CH4_TIM16_UP     (uint32_t) (DMAx_CHANNEL4_RMP | DMA_RMPCR1_CH4_TIM16_UP)  /*!< Remap TIM16 up on DMA1 channel 4 */ 
N#define DMA1_CH4_USART1_TX    (uint32_t) (DMAx_CHANNEL4_RMP | DMA_RMPCR1_CH4_USART1_TX) /*!< Remap USART1 Tx on DMA1 channel 4 */ 
N#define DMA1_CH4_USART2_TX    (uint32_t) (DMAx_CHANNEL4_RMP | DMA_RMPCR1_CH4_USART2_TX) /*!< Remap USART2 Tx on DMA1 channel 4 */ 
N#define DMA1_CH4_USART3_TX    (uint32_t) (DMAx_CHANNEL4_RMP | DMA_RMPCR1_CH4_USART3_TX) /*!< Remap USART3 Tx on DMA1 channel 4 */ 
N#define DMA1_CH4_USART4_TX    (uint32_t) (DMAx_CHANNEL4_RMP | DMA_RMPCR1_CH4_USART4_TX) /*!< Remap USART4 Tx on DMA1 channel 4 */ 
N#define DMA1_CH4_USART5_TX    (uint32_t) (DMAx_CHANNEL4_RMP | DMA_RMPCR1_CH4_USART5_TX) /*!< Remap USART5 Tx on DMA1 channel 4 */ 
N#define DMA1_CH4_USART6_TX    (uint32_t) (DMAx_CHANNEL4_RMP | DMA_RMPCR1_CH4_USART6_TX) /*!< Remap USART6 Tx on DMA1 channel 4 */ 
N#define DMA1_CH4_USART7_TX    (uint32_t) (DMAx_CHANNEL4_RMP | DMA_RMPCR1_CH4_USART7_TX) /*!< Remap USART7 Tx on DMA1 channel 4 */ 
N#define DMA1_CH4_USART8_TX    (uint32_t) (DMAx_CHANNEL4_RMP | DMA_RMPCR1_CH4_USART8_TX) /*!< Remap USART8 Tx on DMA1 channel 4 */ 
N/* DMA1 - Channel 5 */
N#define DMA1_CH5_DEFAULT      (uint32_t) (DMAx_CHANNEL5_RMP | DMA_RMPCR1_DEFAULT)       /*!< Default remap position for DMA1 */   
N#define DMA1_CH5_I2C2_RX      (uint32_t) (DMAx_CHANNEL5_RMP | DMA_RMPCR1_CH5_I2C2_RX)   /*!< Remap I2C2 Rx on DMA1 channel 5 */ 
N#define DMA1_CH5_SPI2_TX      (uint32_t) (DMAx_CHANNEL5_RMP | DMA_RMPCR1_CH5_SPI2_TX)   /*!< Remap SPI1 Tx on DMA1 channel 5 */ 
N#define DMA1_CH5_TIM1_CH3     (uint32_t) (DMAx_CHANNEL5_RMP | DMA_RMPCR1_CH5_TIM1_CH3)  /*!< Remap TIM1 channel 3 on DMA1 channel 5 */
N#define DMA1_CH5_USART1_RX    (uint32_t) (DMAx_CHANNEL5_RMP | DMA_RMPCR1_CH5_USART1_RX) /*!< Remap USART1 Rx on DMA1 channel 5 */ 
N#define DMA1_CH5_USART2_RX    (uint32_t) (DMAx_CHANNEL5_RMP | DMA_RMPCR1_CH5_USART2_RX) /*!< Remap USART2 Rx on DMA1 channel 5 */ 
N#define DMA1_CH5_USART3_RX    (uint32_t) (DMAx_CHANNEL5_RMP | DMA_RMPCR1_CH5_USART3_RX) /*!< Remap USART3 Rx on DMA1 channel 5 */ 
N#define DMA1_CH5_USART4_RX    (uint32_t) (DMAx_CHANNEL5_RMP | DMA_RMPCR1_CH5_USART4_RX) /*!< Remap USART4 Rx on DMA1 channel 5 */ 
N#define DMA1_CH5_USART5_RX    (uint32_t) (DMAx_CHANNEL5_RMP | DMA_RMPCR1_CH5_USART5_RX) /*!< Remap USART5 Rx on DMA1 channel 5 */ 
N#define DMA1_CH5_USART6_RX    (uint32_t) (DMAx_CHANNEL5_RMP | DMA_RMPCR1_CH5_USART6_RX) /*!< Remap USART6 Rx on DMA1 channel 5 */ 
N#define DMA1_CH5_USART7_RX    (uint32_t) (DMAx_CHANNEL5_RMP | DMA_RMPCR1_CH5_USART7_RX) /*!< Remap USART7 Rx on DMA1 channel 5 */ 
N#define DMA1_CH5_USART8_RX    (uint32_t) (DMAx_CHANNEL5_RMP | DMA_RMPCR1_CH5_USART8_RX) /*!< Remap USART8 Rx on DMA1 channel 5 */ 
N/* DMA1 - Channel 6 */
N#define DMA1_CH6_DEFAULT      (uint32_t) (DMAx_CHANNEL6_RMP | DMA_RMPCR1_DEFAULT)       /*!< Default remap position for DMA1 */   
N#define DMA1_CH6_I2C1_TX      (uint32_t) (DMAx_CHANNEL6_RMP | DMA_RMPCR1_CH6_I2C1_TX)   /*!< Remap I2C1 Tx on DMA1 channel 6 */ 
N#define DMA1_CH6_SPI2_RX      (uint32_t) (DMAx_CHANNEL6_RMP | DMA_RMPCR1_CH6_SPI2_RX)   /*!< Remap SPI2 Rx on DMA1 channel 6 */ 
N#define DMA1_CH6_TIM1_CH1     (uint32_t) (DMAx_CHANNEL6_RMP | DMA_RMPCR1_CH6_TIM1_CH1)  /*!< Remap TIM1 channel 1 on DMA1 channel 6 */
N#define DMA1_CH6_TIM1_CH2     (uint32_t) (DMAx_CHANNEL6_RMP | DMA_RMPCR1_CH6_TIM1_CH2)  /*!< Remap TIM1 channel 2 on DMA1 channel 6 */
N#define DMA1_CH6_TIM1_CH3     (uint32_t) (DMAx_CHANNEL6_RMP | DMA_RMPCR1_CH6_TIM1_CH3)  /*!< Remap TIM1 channel 3 on DMA1 channel 6 */
N#define DMA1_CH6_TIM3_CH1     (uint32_t) (DMAx_CHANNEL6_RMP | DMA_RMPCR1_CH6_TIM3_CH1)  /*!< Remap TIM3 channel 1 on DMA1 channel 6 */
N#define DMA1_CH6_TIM3_TRIG    (uint32_t) (DMAx_CHANNEL6_RMP | DMA_RMPCR1_CH6_TIM3_TRIG) /*!< Remap TIM3 Trig on DMA1 channel 6 */ 
N#define DMA1_CH6_TIM16_CH1    (uint32_t) (DMAx_CHANNEL6_RMP | DMA_RMPCR1_CH6_TIM16_CH1) /*!< Remap TIM16 channel 1 on DMA1 channel 6 */
N#define DMA1_CH6_TIM16_UP     (uint32_t) (DMAx_CHANNEL6_RMP | DMA_RMPCR1_CH6_TIM16_UP)  /*!< Remap TIM16 up on DMA1 channel 6 */ 
N#define DMA1_CH6_USART1_RX    (uint32_t) (DMAx_CHANNEL6_RMP | DMA_RMPCR1_CH6_USART1_RX) /*!< Remap USART1 Rx on DMA1 channel 6 */ 
N#define DMA1_CH6_USART2_RX    (uint32_t) (DMAx_CHANNEL6_RMP | DMA_RMPCR1_CH6_USART2_RX) /*!< Remap USART2 Rx on DMA1 channel 6 */ 
N#define DMA1_CH6_USART3_RX    (uint32_t) (DMAx_CHANNEL6_RMP | DMA_RMPCR1_CH6_USART3_RX) /*!< Remap USART3 Rx on DMA1 channel 6 */ 
N#define DMA1_CH6_USART4_RX    (uint32_t) (DMAx_CHANNEL6_RMP | DMA_RMPCR1_CH6_USART4_RX) /*!< Remap USART4 Rx on DMA1 channel 6 */ 
N#define DMA1_CH6_USART5_RX    (uint32_t) (DMAx_CHANNEL6_RMP | DMA_RMPCR1_CH6_USART5_RX) /*!< Remap USART5 Rx on DMA1 channel 6 */ 
N#define DMA1_CH6_USART6_RX    (uint32_t) (DMAx_CHANNEL6_RMP | DMA_RMPCR1_CH6_USART6_RX) /*!< Remap USART6 Rx on DMA1 channel 6 */ 
N#define DMA1_CH6_USART7_RX    (uint32_t) (DMAx_CHANNEL6_RMP | DMA_RMPCR1_CH6_USART7_RX) /*!< Remap USART7 Rx on DMA1 channel 6 */ 
N#define DMA1_CH6_USART8_RX    (uint32_t) (DMAx_CHANNEL6_RMP | DMA_RMPCR1_CH6_USART8_RX) /*!< Remap USART8 Rx on DMA1 channel 6 */ 
N/* DMA1 - Channel 7 */
N#define DMA1_CH7_DEFAULT      (uint32_t) (DMAx_CHANNEL7_RMP | DMA_RMPCR1_DEFAULT)       /*!< Default remap position for DMA1 */   
N#define DMA1_CH7_I2C1_RX      (uint32_t) (DMAx_CHANNEL7_RMP | DMA_RMPCR1_CH7_I2C1_RX)   /*!< Remap I2C1 Rx on DMA1 channel 7 */ 
N#define DMA1_CH7_SPI2_TX      (uint32_t) (DMAx_CHANNEL7_RMP | DMA_RMPCR1_CH7_SPI2_TX)   /*!< Remap SPI2 Tx on DMA1 channel 7 */ 
N#define DMA1_CH7_TIM2_CH2     (uint32_t) (DMAx_CHANNEL7_RMP | DMA_RMPCR1_CH7_TIM2_CH2)  /*!< Remap TIM2 channel 2 on DMA1 channel 7 */
N#define DMA1_CH7_TIM2_CH4     (uint32_t) (DMAx_CHANNEL7_RMP | DMA_RMPCR1_CH7_TIM2_CH4)  /*!< Remap TIM2 channel 4 on DMA1 channel 7 */
N#define DMA1_CH7_TIM17_CH1    (uint32_t) (DMAx_CHANNEL7_RMP | DMA_RMPCR1_CH7_TIM17_CH1) /*!< Remap TIM17 channel 1 on DMA1 channel 7 */
N#define DMA1_CH7_TIM17_UP     (uint32_t) (DMAx_CHANNEL7_RMP | DMA_RMPCR1_CH7_TIM17_UP)  /*!< Remap TIM17 up on DMA1 channel 7 */ 
N#define DMA1_CH7_USART1_TX    (uint32_t) (DMAx_CHANNEL7_RMP | DMA_RMPCR1_CH7_USART1_TX) /*!< Remap USART1 Tx on DMA1 channel 7 */ 
N#define DMA1_CH7_USART2_TX    (uint32_t) (DMAx_CHANNEL7_RMP | DMA_RMPCR1_CH7_USART2_TX) /*!< Remap USART2 Tx on DMA1 channel 7 */ 
N#define DMA1_CH7_USART3_TX    (uint32_t) (DMAx_CHANNEL7_RMP | DMA_RMPCR1_CH7_USART3_TX) /*!< Remap USART3 Tx on DMA1 channel 7 */ 
N#define DMA1_CH7_USART4_TX    (uint32_t) (DMAx_CHANNEL7_RMP | DMA_RMPCR1_CH7_USART4_TX) /*!< Remap USART4 Tx on DMA1 channel 7 */ 
N#define DMA1_CH7_USART5_TX    (uint32_t) (DMAx_CHANNEL7_RMP | DMA_RMPCR1_CH7_USART5_TX) /*!< Remap USART5 Tx on DMA1 channel 7 */ 
N#define DMA1_CH7_USART6_TX    (uint32_t) (DMAx_CHANNEL7_RMP | DMA_RMPCR1_CH7_USART6_TX) /*!< Remap USART6 Tx on DMA1 channel 7 */ 
N#define DMA1_CH7_USART7_TX    (uint32_t) (DMAx_CHANNEL7_RMP | DMA_RMPCR1_CH7_USART7_TX) /*!< Remap USART7 Tx on DMA1 channel 7 */ 
N#define DMA1_CH7_USART8_TX    (uint32_t) (DMAx_CHANNEL7_RMP | DMA_RMPCR1_CH7_USART8_TX) /*!< Remap USART8 Tx on DMA1 channel 7 */
N
N#define IS_DMA1_REMAP(REMAP)  ((REMAP == DMA1_CH1_DEFAULT)   ||\
N                                    (REMAP == DMA1_CH1_ADC)       ||\
N                                    (REMAP == DMA1_CH1_TIM17_CH1) ||\
N                                    (REMAP == DMA1_CH1_TIM17_UP)  ||\
N                                    (REMAP == DMA1_CH1_USART1_RX) ||\
N                                    (REMAP == DMA1_CH1_USART2_RX) ||\
N                                    (REMAP == DMA1_CH1_USART3_RX) ||\
N                                    (REMAP == DMA1_CH1_USART4_RX) ||\
N                                    (REMAP == DMA1_CH1_USART5_RX) ||\
N                                    (REMAP == DMA1_CH1_USART6_RX) ||\
N                                    (REMAP == DMA1_CH1_USART7_RX) ||\
N                                    (REMAP == DMA1_CH1_USART8_RX) ||\
N                                    (REMAP == DMA1_CH2_DEFAULT)   ||\
N                                    (REMAP == DMA1_CH2_ADC)       ||\
N                                    (REMAP == DMA1_CH2_I2C1_TX)   ||\
N                                    (REMAP == DMA1_CH2_SPI1_RX)   ||\
N                                    (REMAP == DMA1_CH2_TIM1_CH1)  ||\
N                                    (REMAP == DMA1_CH2_I2C1_TX)   ||\
N                                    (REMAP == DMA1_CH2_TIM17_CH1) ||\
N                                    (REMAP == DMA1_CH2_TIM17_UP)  ||\
N                                    (REMAP == DMA1_CH2_USART1_TX) ||\
N                                    (REMAP == DMA1_CH2_USART2_TX) ||\
N                                    (REMAP == DMA1_CH2_USART3_TX) ||\
N                                    (REMAP == DMA1_CH2_USART4_TX) ||\
N                                    (REMAP == DMA1_CH2_USART5_TX) ||\
N                                    (REMAP == DMA1_CH2_USART6_TX) ||\
N                                    (REMAP == DMA1_CH2_USART7_TX) ||\
N                                    (REMAP == DMA1_CH2_USART8_TX) ||\
N                                    (REMAP == DMA1_CH3_DEFAULT)   ||\
N                                    (REMAP == DMA1_CH3_TIM6_UP)   ||\
N                                    (REMAP == DMA1_CH3_DAC_CH1)   ||\
N                                    (REMAP == DMA1_CH3_I2C1_RX)   ||\
N                                    (REMAP == DMA1_CH3_SPI1_TX)   ||\
N                                    (REMAP == DMA1_CH3_TIM1_CH2)  ||\
N                                    (REMAP == DMA1_CH3_TIM2_CH2)  ||\
N                                    (REMAP == DMA1_CH3_TIM16_CH1) ||\
N                                    (REMAP == DMA1_CH3_TIM16_UP)  ||\
N                                    (REMAP == DMA1_CH3_USART1_RX) ||\
N                                    (REMAP == DMA1_CH3_USART2_RX) ||\
N                                    (REMAP == DMA1_CH3_USART3_RX) ||\
N                                    (REMAP == DMA1_CH3_USART4_RX) ||\
N                                    (REMAP == DMA1_CH3_USART5_RX) ||\
N                                    (REMAP == DMA1_CH3_USART6_RX) ||\
N                                    (REMAP == DMA1_CH3_USART7_RX) ||\
N                                    (REMAP == DMA1_CH3_USART8_RX) ||\
N                                    (REMAP == DMA1_CH4_DEFAULT)   ||\
N                                    (REMAP == DMA1_CH4_TIM7_UP)   ||\
N                                    (REMAP == DMA1_CH4_DAC_CH2)   ||\
N                                    (REMAP == DMA1_CH4_I2C2_TX)   ||\
N                                    (REMAP == DMA1_CH4_SPI2_RX)   ||\
N                                    (REMAP == DMA1_CH4_TIM2_CH4)  ||\
N                                    (REMAP == DMA1_CH4_TIM3_CH1)  ||\
N                                    (REMAP == DMA1_CH4_TIM3_TRIG) ||\
N                                    (REMAP == DMA1_CH4_TIM16_CH1) ||\
N                                    (REMAP == DMA1_CH4_TIM16_UP)  ||\
N                                    (REMAP == DMA1_CH4_USART1_TX) ||\
N                                    (REMAP == DMA1_CH4_USART2_TX) ||\
N                                    (REMAP == DMA1_CH4_USART3_TX) ||\
N                                    (REMAP == DMA1_CH4_USART4_TX) ||\
N                                    (REMAP == DMA1_CH4_USART5_TX) ||\
N                                    (REMAP == DMA1_CH4_USART6_TX) ||\
N                                    (REMAP == DMA1_CH4_USART7_TX) ||\
N                                    (REMAP == DMA1_CH4_USART8_TX) ||\
N                                    (REMAP == DMA1_CH5_DEFAULT)   ||\
N                                    (REMAP == DMA1_CH5_I2C2_RX)   ||\
N                                    (REMAP == DMA1_CH5_SPI2_TX)   ||\
N                                    (REMAP == DMA1_CH5_TIM1_CH3)  ||\
N                                    (REMAP == DMA1_CH5_USART1_RX) ||\
N                                    (REMAP == DMA1_CH5_USART2_RX) ||\
N                                    (REMAP == DMA1_CH5_USART3_RX) ||\
N                                    (REMAP == DMA1_CH5_USART4_RX) ||\
N                                    (REMAP == DMA1_CH5_USART5_RX) ||\
N                                    (REMAP == DMA1_CH5_USART6_RX) ||\
N                                    (REMAP == DMA1_CH5_USART7_RX) ||\
N                                    (REMAP == DMA1_CH5_USART8_RX) ||\
N                                    (REMAP == DMA1_CH6_DEFAULT)   ||\
N                                    (REMAP == DMA1_CH6_I2C1_TX)   ||\
N                                    (REMAP == DMA1_CH6_SPI2_RX)   ||\
N                                    (REMAP == DMA1_CH6_TIM1_CH1)  ||\
N                                    (REMAP == DMA1_CH6_TIM1_CH2)  ||\
N                                    (REMAP == DMA1_CH6_TIM1_CH3)  ||\
N                                    (REMAP == DMA1_CH6_TIM3_CH1)  ||\
N                                    (REMAP == DMA1_CH6_TIM3_TRIG) ||\
N                                    (REMAP == DMA1_CH6_TIM16_CH1) ||\
N                                    (REMAP == DMA1_CH6_TIM16_UP)  ||\
N                                    (REMAP == DMA1_CH6_USART1_RX) ||\
N                                    (REMAP == DMA1_CH6_USART2_RX) ||\
N                                    (REMAP == DMA1_CH6_USART3_RX) ||\
N                                    (REMAP == DMA1_CH6_USART4_RX) ||\
N                                    (REMAP == DMA1_CH6_USART5_RX) ||\
N                                    (REMAP == DMA1_CH6_USART6_RX) ||\
N                                    (REMAP == DMA1_CH6_USART7_RX) ||\
N                                    (REMAP == DMA1_CH6_USART8_RX) ||\
N                                    (REMAP == DMA1_CH7_DEFAULT)   ||\
N                                    (REMAP == DMA1_CH7_I2C1_RX)   ||\
N                                    (REMAP == DMA1_CH7_SPI2_TX)   ||\
N                                    (REMAP == DMA1_CH7_TIM2_CH2)  ||\
N                                    (REMAP == DMA1_CH7_TIM2_CH4)  ||\
N                                    (REMAP == DMA1_CH7_TIM17_CH1) ||\
N                                    (REMAP == DMA1_CH7_TIM17_UP)  ||\
N                                    (REMAP == DMA1_CH7_USART1_TX) ||\
N                                    (REMAP == DMA1_CH7_USART2_TX) ||\
N                                    (REMAP == DMA1_CH7_USART3_TX) ||\
N                                    (REMAP == DMA1_CH7_USART4_TX) ||\
N                                    (REMAP == DMA1_CH7_USART5_TX) ||\
N                                    (REMAP == DMA1_CH7_USART6_TX) ||\
N                                    (REMAP == DMA1_CH7_USART7_TX) ||\
N                                    (REMAP == DMA1_CH7_USART8_TX))
X#define IS_DMA1_REMAP(REMAP)  ((REMAP == DMA1_CH1_DEFAULT)   ||                                    (REMAP == DMA1_CH1_ADC)       ||                                    (REMAP == DMA1_CH1_TIM17_CH1) ||                                    (REMAP == DMA1_CH1_TIM17_UP)  ||                                    (REMAP == DMA1_CH1_USART1_RX) ||                                    (REMAP == DMA1_CH1_USART2_RX) ||                                    (REMAP == DMA1_CH1_USART3_RX) ||                                    (REMAP == DMA1_CH1_USART4_RX) ||                                    (REMAP == DMA1_CH1_USART5_RX) ||                                    (REMAP == DMA1_CH1_USART6_RX) ||                                    (REMAP == DMA1_CH1_USART7_RX) ||                                    (REMAP == DMA1_CH1_USART8_RX) ||                                    (REMAP == DMA1_CH2_DEFAULT)   ||                                    (REMAP == DMA1_CH2_ADC)       ||                                    (REMAP == DMA1_CH2_I2C1_TX)   ||                                    (REMAP == DMA1_CH2_SPI1_RX)   ||                                    (REMAP == DMA1_CH2_TIM1_CH1)  ||                                    (REMAP == DMA1_CH2_I2C1_TX)   ||                                    (REMAP == DMA1_CH2_TIM17_CH1) ||                                    (REMAP == DMA1_CH2_TIM17_UP)  ||                                    (REMAP == DMA1_CH2_USART1_TX) ||                                    (REMAP == DMA1_CH2_USART2_TX) ||                                    (REMAP == DMA1_CH2_USART3_TX) ||                                    (REMAP == DMA1_CH2_USART4_TX) ||                                    (REMAP == DMA1_CH2_USART5_TX) ||                                    (REMAP == DMA1_CH2_USART6_TX) ||                                    (REMAP == DMA1_CH2_USART7_TX) ||                                    (REMAP == DMA1_CH2_USART8_TX) ||                                    (REMAP == DMA1_CH3_DEFAULT)   ||                                    (REMAP == DMA1_CH3_TIM6_UP)   ||                                    (REMAP == DMA1_CH3_DAC_CH1)   ||                                    (REMAP == DMA1_CH3_I2C1_RX)   ||                                    (REMAP == DMA1_CH3_SPI1_TX)   ||                                    (REMAP == DMA1_CH3_TIM1_CH2)  ||                                    (REMAP == DMA1_CH3_TIM2_CH2)  ||                                    (REMAP == DMA1_CH3_TIM16_CH1) ||                                    (REMAP == DMA1_CH3_TIM16_UP)  ||                                    (REMAP == DMA1_CH3_USART1_RX) ||                                    (REMAP == DMA1_CH3_USART2_RX) ||                                    (REMAP == DMA1_CH3_USART3_RX) ||                                    (REMAP == DMA1_CH3_USART4_RX) ||                                    (REMAP == DMA1_CH3_USART5_RX) ||                                    (REMAP == DMA1_CH3_USART6_RX) ||                                    (REMAP == DMA1_CH3_USART7_RX) ||                                    (REMAP == DMA1_CH3_USART8_RX) ||                                    (REMAP == DMA1_CH4_DEFAULT)   ||                                    (REMAP == DMA1_CH4_TIM7_UP)   ||                                    (REMAP == DMA1_CH4_DAC_CH2)   ||                                    (REMAP == DMA1_CH4_I2C2_TX)   ||                                    (REMAP == DMA1_CH4_SPI2_RX)   ||                                    (REMAP == DMA1_CH4_TIM2_CH4)  ||                                    (REMAP == DMA1_CH4_TIM3_CH1)  ||                                    (REMAP == DMA1_CH4_TIM3_TRIG) ||                                    (REMAP == DMA1_CH4_TIM16_CH1) ||                                    (REMAP == DMA1_CH4_TIM16_UP)  ||                                    (REMAP == DMA1_CH4_USART1_TX) ||                                    (REMAP == DMA1_CH4_USART2_TX) ||                                    (REMAP == DMA1_CH4_USART3_TX) ||                                    (REMAP == DMA1_CH4_USART4_TX) ||                                    (REMAP == DMA1_CH4_USART5_TX) ||                                    (REMAP == DMA1_CH4_USART6_TX) ||                                    (REMAP == DMA1_CH4_USART7_TX) ||                                    (REMAP == DMA1_CH4_USART8_TX) ||                                    (REMAP == DMA1_CH5_DEFAULT)   ||                                    (REMAP == DMA1_CH5_I2C2_RX)   ||                                    (REMAP == DMA1_CH5_SPI2_TX)   ||                                    (REMAP == DMA1_CH5_TIM1_CH3)  ||                                    (REMAP == DMA1_CH5_USART1_RX) ||                                    (REMAP == DMA1_CH5_USART2_RX) ||                                    (REMAP == DMA1_CH5_USART3_RX) ||                                    (REMAP == DMA1_CH5_USART4_RX) ||                                    (REMAP == DMA1_CH5_USART5_RX) ||                                    (REMAP == DMA1_CH5_USART6_RX) ||                                    (REMAP == DMA1_CH5_USART7_RX) ||                                    (REMAP == DMA1_CH5_USART8_RX) ||                                    (REMAP == DMA1_CH6_DEFAULT)   ||                                    (REMAP == DMA1_CH6_I2C1_TX)   ||                                    (REMAP == DMA1_CH6_SPI2_RX)   ||                                    (REMAP == DMA1_CH6_TIM1_CH1)  ||                                    (REMAP == DMA1_CH6_TIM1_CH2)  ||                                    (REMAP == DMA1_CH6_TIM1_CH3)  ||                                    (REMAP == DMA1_CH6_TIM3_CH1)  ||                                    (REMAP == DMA1_CH6_TIM3_TRIG) ||                                    (REMAP == DMA1_CH6_TIM16_CH1) ||                                    (REMAP == DMA1_CH6_TIM16_UP)  ||                                    (REMAP == DMA1_CH6_USART1_RX) ||                                    (REMAP == DMA1_CH6_USART2_RX) ||                                    (REMAP == DMA1_CH6_USART3_RX) ||                                    (REMAP == DMA1_CH6_USART4_RX) ||                                    (REMAP == DMA1_CH6_USART5_RX) ||                                    (REMAP == DMA1_CH6_USART6_RX) ||                                    (REMAP == DMA1_CH6_USART7_RX) ||                                    (REMAP == DMA1_CH6_USART8_RX) ||                                    (REMAP == DMA1_CH7_DEFAULT)   ||                                    (REMAP == DMA1_CH7_I2C1_RX)   ||                                    (REMAP == DMA1_CH7_SPI2_TX)   ||                                    (REMAP == DMA1_CH7_TIM2_CH2)  ||                                    (REMAP == DMA1_CH7_TIM2_CH4)  ||                                    (REMAP == DMA1_CH7_TIM17_CH1) ||                                    (REMAP == DMA1_CH7_TIM17_UP)  ||                                    (REMAP == DMA1_CH7_USART1_TX) ||                                    (REMAP == DMA1_CH7_USART2_TX) ||                                    (REMAP == DMA1_CH7_USART3_TX) ||                                    (REMAP == DMA1_CH7_USART4_TX) ||                                    (REMAP == DMA1_CH7_USART5_TX) ||                                    (REMAP == DMA1_CH7_USART6_TX) ||                                    (REMAP == DMA1_CH7_USART7_TX) ||                                    (REMAP == DMA1_CH7_USART8_TX))
N
N/****************** DMA2 remap bit field definition********************/
N/* DMA2 - Channel 1 */
N#define DMA2_CH1_DEFAULT      (uint32_t) (DMAx_CHANNEL1_RMP | DMA_RMPCR2_DEFAULT)       /*!< Default remap position for DMA2 */   
N#define DMA2_CH1_I2C2_TX      (uint32_t) (DMAx_CHANNEL1_RMP | DMA_RMPCR2_CH1_I2C2_TX)   /*!< Remap I2C2 TX on DMA2 channel 1 */ 
N#define DMA2_CH1_USART1_TX    (uint32_t) (DMAx_CHANNEL1_RMP | DMA_RMPCR2_CH1_USART1_TX) /*!< Remap USART1 Tx on DMA2 channel 1 */ 
N#define DMA2_CH1_USART2_TX    (uint32_t) (DMAx_CHANNEL1_RMP | DMA_RMPCR2_CH1_USART2_TX) /*!< Remap USART2 Tx on DMA2 channel 1 */ 
N#define DMA2_CH1_USART3_TX    (uint32_t) (DMAx_CHANNEL1_RMP | DMA_RMPCR2_CH1_USART3_TX) /*!< Remap USART3 Tx on DMA2 channel 1 */ 
N#define DMA2_CH1_USART4_TX    (uint32_t) (DMAx_CHANNEL1_RMP | DMA_RMPCR2_CH1_USART4_TX) /*!< Remap USART4 Tx on DMA2 channel 1 */ 
N#define DMA2_CH1_USART5_TX    (uint32_t) (DMAx_CHANNEL1_RMP | DMA_RMPCR2_CH1_USART5_TX) /*!< Remap USART5 Tx on DMA2 channel 1 */ 
N#define DMA2_CH1_USART6_TX    (uint32_t) (DMAx_CHANNEL1_RMP | DMA_RMPCR2_CH1_USART6_TX) /*!< Remap USART6 Tx on DMA2 channel 1 */ 
N#define DMA2_CH1_USART7_TX    (uint32_t) (DMAx_CHANNEL1_RMP | DMA_RMPCR2_CH1_USART7_TX) /*!< Remap USART7 Tx on DMA2 channel 1 */ 
N#define DMA2_CH1_USART8_TX    (uint32_t) (DMAx_CHANNEL1_RMP | DMA_RMPCR2_CH1_USART8_TX) /*!< Remap USART8 Tx on DMA2 channel 1 */ 
N/* DMA2 - Channel 2 */
N#define DMA2_CH2_DEFAULT      (uint32_t) (DMAx_CHANNEL2_RMP | DMA_RMPCR2_DEFAULT)       /*!< Default remap position for DMA2 */   
N#define DMA2_CH2_I2C2_RX      (uint32_t) (DMAx_CHANNEL2_RMP | DMA_RMPCR2_CH2_I2C2_RX)   /*!< Remap I2C2 Rx on DMA2 channel 2 */ 
N#define DMA2_CH2_USART1_RX    (uint32_t) (DMAx_CHANNEL2_RMP | DMA_RMPCR2_CH2_USART1_RX) /*!< Remap USART1 Rx on DMA2 channel 2 */ 
N#define DMA2_CH2_USART2_RX    (uint32_t) (DMAx_CHANNEL2_RMP | DMA_RMPCR2_CH2_USART2_RX) /*!< Remap USART2 Rx on DMA2 channel 2 */ 
N#define DMA2_CH2_USART3_RX    (uint32_t) (DMAx_CHANNEL2_RMP | DMA_RMPCR2_CH2_USART3_RX) /*!< Remap USART3 Rx on DMA2 channel 2 */ 
N#define DMA2_CH2_USART4_RX    (uint32_t) (DMAx_CHANNEL2_RMP | DMA_RMPCR2_CH2_USART4_RX) /*!< Remap USART4 Rx on DMA2 channel 2 */ 
N#define DMA2_CH2_USART5_RX    (uint32_t) (DMAx_CHANNEL2_RMP | DMA_RMPCR2_CH2_USART5_RX) /*!< Remap USART5 Rx on DMA2 channel 2 */ 
N#define DMA2_CH2_USART6_RX    (uint32_t) (DMAx_CHANNEL2_RMP | DMA_RMPCR2_CH2_USART6_RX) /*!< Remap USART6 Rx on DMA2 channel 2 */ 
N#define DMA2_CH2_USART7_RX    (uint32_t) (DMAx_CHANNEL2_RMP | DMA_RMPCR2_CH2_USART7_RX) /*!< Remap USART7 Rx on DMA2 channel 2 */ 
N#define DMA2_CH2_USART8_RX    (uint32_t) (DMAx_CHANNEL2_RMP | DMA_RMPCR2_CH2_USART8_RX) /*!< Remap USART8 Rx on DMA2 channel 2 */ 
N/* DMA2 - Channel 3 */
N#define DMA2_CH3_DEFAULT      (uint32_t) (DMAx_CHANNEL3_RMP | DMA_RMPCR2_DEFAULT)       /*!< Default remap position for DMA2 */   
N#define DMA2_CH3_TIM6_UP      (uint32_t) (DMAx_CHANNEL3_RMP | DMA_RMPCR2_CH3_TIM6_UP)   /*!< Remap TIM6 up on DMA2 channel 3 */ 
N#define DMA2_CH3_DAC_CH1      (uint32_t) (DMAx_CHANNEL3_RMP | DMA_RMPCR2_CH3_DAC_CH1)   /*!< Remap DAC channel 1 on DMA2 channel 3 */
N#define DMA2_CH3_SPI1_RX      (uint32_t) (DMAx_CHANNEL3_RMP | DMA_RMPCR2_CH3_SPI1_RX)   /*!< Remap SPI1 Rx on DMA2 channel 3 */ 
N#define DMA2_CH3_USART1_RX    (uint32_t) (DMAx_CHANNEL3_RMP | DMA_RMPCR2_CH3_USART1_RX) /*!< Remap USART1 Rx on DMA2 channel 3 */ 
N#define DMA2_CH3_USART2_RX    (uint32_t) (DMAx_CHANNEL3_RMP | DMA_RMPCR2_CH3_USART2_RX) /*!< Remap USART2 Rx on DMA2 channel 3 */ 
N#define DMA2_CH3_USART3_RX    (uint32_t) (DMAx_CHANNEL3_RMP | DMA_RMPCR2_CH3_USART3_RX) /*!< Remap USART3 Rx on DMA2 channel 3 */ 
N#define DMA2_CH3_USART4_RX    (uint32_t) (DMAx_CHANNEL3_RMP | DMA_RMPCR2_CH3_USART4_RX) /*!< Remap USART4 Rx on DMA2 channel 3 */ 
N#define DMA2_CH3_USART5_RX    (uint32_t) (DMAx_CHANNEL3_RMP | DMA_RMPCR2_CH3_USART5_RX) /*!< Remap USART5 Rx on DMA2 channel 3 */ 
N#define DMA2_CH3_USART6_RX    (uint32_t) (DMAx_CHANNEL3_RMP | DMA_RMPCR2_CH3_USART6_RX) /*!< Remap USART6 Rx on DMA2 channel 3 */ 
N#define DMA2_CH3_USART7_RX    (uint32_t) (DMAx_CHANNEL3_RMP | DMA_RMPCR2_CH3_USART7_RX) /*!< Remap USART7 Rx on DMA2 channel 3 */ 
N#define DMA2_CH3_USART8_RX    (uint32_t) (DMAx_CHANNEL3_RMP | DMA_RMPCR2_CH3_USART8_RX) /*!< Remap USART8 Rx on DMA2 channel 3 */ 
N/* DMA2 - Channel 4 */
N#define DMA2_CH4_DEFAULT      (uint32_t) (DMAx_CHANNEL4_RMP | DMA_RMPCR2_DEFAULT)       /*!< Default remap position for DMA2 */   
N#define DMA2_CH4_TIM7_UP      (uint32_t) (DMAx_CHANNEL4_RMP | DMA_RMPCR2_CH4_TIM7_UP)   /*!< Remap TIM7 up on DMA2 channel 4 */ 
N#define DMA2_CH4_DAC_CH2      (uint32_t) (DMAx_CHANNEL4_RMP | DMA_RMPCR2_CH4_DAC_CH2)   /*!< Remap DAC channel 2 on DMA2 channel 4 */
N#define DMA2_CH4_SPI1_TX      (uint32_t) (DMAx_CHANNEL4_RMP | DMA_RMPCR2_CH4_SPI1_TX)   /*!< Remap SPI1 Tx on DMA2 channel 4 */ 
N#define DMA2_CH4_USART1_TX    (uint32_t) (DMAx_CHANNEL4_RMP | DMA_RMPCR2_CH4_USART1_TX) /*!< Remap USART1 Tx on DMA2 channel 4 */ 
N#define DMA2_CH4_USART2_TX    (uint32_t) (DMAx_CHANNEL4_RMP | DMA_RMPCR2_CH4_USART2_TX) /*!< Remap USART2 Tx on DMA2 channel 4 */ 
N#define DMA2_CH4_USART3_TX    (uint32_t) (DMAx_CHANNEL4_RMP | DMA_RMPCR2_CH4_USART3_TX) /*!< Remap USART3 Tx on DMA2 channel 4 */ 
N#define DMA2_CH4_USART4_TX    (uint32_t) (DMAx_CHANNEL4_RMP | DMA_RMPCR2_CH4_USART4_TX) /*!< Remap USART4 Tx on DMA2 channel 4 */ 
N#define DMA2_CH4_USART5_TX    (uint32_t) (DMAx_CHANNEL4_RMP | DMA_RMPCR2_CH4_USART5_TX) /*!< Remap USART5 Tx on DMA2 channel 4 */ 
N#define DMA2_CH4_USART6_TX    (uint32_t) (DMAx_CHANNEL4_RMP | DMA_RMPCR2_CH4_USART6_TX) /*!< Remap USART6 Tx on DMA2 channel 4 */ 
N#define DMA2_CH4_USART7_TX    (uint32_t) (DMAx_CHANNEL4_RMP | DMA_RMPCR2_CH4_USART7_TX) /*!< Remap USART7 Tx on DMA2 channel 4 */ 
N#define DMA2_CH4_USART8_TX    (uint32_t) (DMAx_CHANNEL4_RMP | DMA_RMPCR2_CH4_USART8_TX) /*!< Remap USART8 Tx on DMA2 channel 4 */ 
N/* DMA2 - Channel 5 */
N#define DMA2_CH5_DEFAULT      (uint32_t) (DMAx_CHANNEL5_RMP | DMA_RMPCR2_DEFAULT)       /*!< Default remap position for DMA2 */   
N#define DMA2_CH5_ADC          (uint32_t) (DMAx_CHANNEL5_RMP | DMA_RMPCR2_CH5_ADC)       /*!< Remap ADC on DMA2 channel 5 */  
N#define DMA2_CH5_USART1_TX    (uint32_t) (DMAx_CHANNEL5_RMP | DMA_RMPCR2_CH5_USART1_TX) /*!< Remap USART1 Tx on DMA2 channel 5 */ 
N#define DMA2_CH5_USART2_TX    (uint32_t) (DMAx_CHANNEL5_RMP | DMA_RMPCR2_CH5_USART2_TX) /*!< Remap USART2 Tx on DMA2 channel 5 */ 
N#define DMA2_CH5_USART3_TX    (uint32_t) (DMAx_CHANNEL5_RMP | DMA_RMPCR2_CH5_USART3_TX) /*!< Remap USART3 Tx on DMA2 channel 5 */ 
N#define DMA2_CH5_USART4_TX    (uint32_t) (DMAx_CHANNEL5_RMP | DMA_RMPCR2_CH5_USART4_TX) /*!< Remap USART4 Tx on DMA2 channel 5 */ 
N#define DMA2_CH5_USART5_TX    (uint32_t) (DMAx_CHANNEL5_RMP | DMA_RMPCR2_CH5_USART5_TX) /*!< Remap USART5 Tx on DMA2 channel 5 */ 
N#define DMA2_CH5_USART6_TX    (uint32_t) (DMAx_CHANNEL5_RMP | DMA_RMPCR2_CH5_USART6_TX) /*!< Remap USART6 Tx on DMA2 channel 5 */ 
N#define DMA2_CH5_USART7_TX    (uint32_t) (DMAx_CHANNEL5_RMP | DMA_RMPCR2_CH5_USART7_TX) /*!< Remap USART7 Tx on DMA2 channel 5 */ 
N#define DMA2_CH5_USART8_TX    (uint32_t) (DMAx_CHANNEL5_RMP | DMA_RMPCR2_CH5_USART8_TX) /*!< Remap USART8 Tx on DMA2 channel 5 */ 
N
N#define IS_DMA2_REMAP(REMAP)  ((REMAP == DMA2_CH1_DEFAULT)   ||\
N                                    (REMAP == DMA2_CH1_I2C2_TX)   ||\
N                                    (REMAP == DMA2_CH1_USART1_TX) ||\
N                                    (REMAP == DMA2_CH1_USART2_TX) ||\
N                                    (REMAP == DMA2_CH1_USART3_TX) ||\
N                                    (REMAP == DMA2_CH1_USART4_TX) ||\
N                                    (REMAP == DMA2_CH1_USART5_TX) ||\
N                                    (REMAP == DMA2_CH1_USART6_TX) ||\
N                                    (REMAP == DMA2_CH1_USART7_TX) ||\
N                                    (REMAP == DMA2_CH1_USART8_TX) ||\
N                                    (REMAP == DMA2_CH2_DEFAULT)   ||\
N                                    (REMAP == DMA2_CH2_I2C2_RX)   ||\
N                                    (REMAP == DMA2_CH2_USART1_RX) ||\
N                                    (REMAP == DMA2_CH2_USART2_RX) ||\
N                                    (REMAP == DMA2_CH2_USART3_RX) ||\
N                                    (REMAP == DMA2_CH2_USART4_RX) ||\
N                                    (REMAP == DMA2_CH2_USART5_RX) ||\
N                                    (REMAP == DMA2_CH2_USART6_RX) ||\
N                                    (REMAP == DMA2_CH2_USART7_RX) ||\
N                                    (REMAP == DMA2_CH2_USART8_RX) ||\
N                                    (REMAP == DMA2_CH3_DEFAULT)   ||\
N                                    (REMAP == DMA2_CH3_TIM6_UP)   ||\
N                                    (REMAP == DMA2_CH3_DAC_CH1)   ||\
N                                    (REMAP == DMA2_CH3_SPI1_RX)   ||\
N                                    (REMAP == DMA2_CH3_USART1_RX) ||\
N                                    (REMAP == DMA2_CH3_USART2_RX) ||\
N                                    (REMAP == DMA2_CH3_USART3_RX) ||\
N                                    (REMAP == DMA2_CH3_USART4_RX) ||\
N                                    (REMAP == DMA2_CH3_USART5_RX) ||\
N                                    (REMAP == DMA2_CH3_USART6_RX) ||\
N                                    (REMAP == DMA2_CH3_USART7_RX) ||\
N                                    (REMAP == DMA2_CH3_USART8_RX) ||\
N                                    (REMAP == DMA2_CH4_DEFAULT)   ||\
N                                    (REMAP == DMA2_CH4_TIM7_UP)   ||\
N                                    (REMAP == DMA2_CH4_DAC_CH2)   ||\
N                                    (REMAP == DMA2_CH4_SPI1_TX)   ||\
N                                    (REMAP == DMA2_CH4_USART1_TX) ||\
N                                    (REMAP == DMA2_CH4_USART2_TX) ||\
N                                    (REMAP == DMA2_CH4_USART3_TX) ||\
N                                    (REMAP == DMA2_CH4_USART4_TX) ||\
N                                    (REMAP == DMA2_CH4_USART5_TX) ||\
N                                    (REMAP == DMA2_CH4_USART6_TX) ||\
N                                    (REMAP == DMA2_CH4_USART7_TX) ||\
N                                    (REMAP == DMA2_CH4_USART8_TX) ||\
N                                    (REMAP == DMA2_CH5_DEFAULT)   ||\
N                                    (REMAP == DMA2_CH5_ADC)       ||\
N                                    (REMAP == DMA2_CH5_USART1_TX) ||\
N                                    (REMAP == DMA2_CH5_USART2_TX) ||\
N                                    (REMAP == DMA2_CH5_USART3_TX) ||\
N                                    (REMAP == DMA2_CH5_USART4_TX) ||\
N                                    (REMAP == DMA2_CH5_USART5_TX) ||\
N                                    (REMAP == DMA2_CH5_USART6_TX) ||\
N                                    (REMAP == DMA2_CH5_USART7_TX) ||\
N                                    (REMAP == DMA2_CH5_USART8_TX ))
X#define IS_DMA2_REMAP(REMAP)  ((REMAP == DMA2_CH1_DEFAULT)   ||                                    (REMAP == DMA2_CH1_I2C2_TX)   ||                                    (REMAP == DMA2_CH1_USART1_TX) ||                                    (REMAP == DMA2_CH1_USART2_TX) ||                                    (REMAP == DMA2_CH1_USART3_TX) ||                                    (REMAP == DMA2_CH1_USART4_TX) ||                                    (REMAP == DMA2_CH1_USART5_TX) ||                                    (REMAP == DMA2_CH1_USART6_TX) ||                                    (REMAP == DMA2_CH1_USART7_TX) ||                                    (REMAP == DMA2_CH1_USART8_TX) ||                                    (REMAP == DMA2_CH2_DEFAULT)   ||                                    (REMAP == DMA2_CH2_I2C2_RX)   ||                                    (REMAP == DMA2_CH2_USART1_RX) ||                                    (REMAP == DMA2_CH2_USART2_RX) ||                                    (REMAP == DMA2_CH2_USART3_RX) ||                                    (REMAP == DMA2_CH2_USART4_RX) ||                                    (REMAP == DMA2_CH2_USART5_RX) ||                                    (REMAP == DMA2_CH2_USART6_RX) ||                                    (REMAP == DMA2_CH2_USART7_RX) ||                                    (REMAP == DMA2_CH2_USART8_RX) ||                                    (REMAP == DMA2_CH3_DEFAULT)   ||                                    (REMAP == DMA2_CH3_TIM6_UP)   ||                                    (REMAP == DMA2_CH3_DAC_CH1)   ||                                    (REMAP == DMA2_CH3_SPI1_RX)   ||                                    (REMAP == DMA2_CH3_USART1_RX) ||                                    (REMAP == DMA2_CH3_USART2_RX) ||                                    (REMAP == DMA2_CH3_USART3_RX) ||                                    (REMAP == DMA2_CH3_USART4_RX) ||                                    (REMAP == DMA2_CH3_USART5_RX) ||                                    (REMAP == DMA2_CH3_USART6_RX) ||                                    (REMAP == DMA2_CH3_USART7_RX) ||                                    (REMAP == DMA2_CH3_USART8_RX) ||                                    (REMAP == DMA2_CH4_DEFAULT)   ||                                    (REMAP == DMA2_CH4_TIM7_UP)   ||                                    (REMAP == DMA2_CH4_DAC_CH2)   ||                                    (REMAP == DMA2_CH4_SPI1_TX)   ||                                    (REMAP == DMA2_CH4_USART1_TX) ||                                    (REMAP == DMA2_CH4_USART2_TX) ||                                    (REMAP == DMA2_CH4_USART3_TX) ||                                    (REMAP == DMA2_CH4_USART4_TX) ||                                    (REMAP == DMA2_CH4_USART5_TX) ||                                    (REMAP == DMA2_CH4_USART6_TX) ||                                    (REMAP == DMA2_CH4_USART7_TX) ||                                    (REMAP == DMA2_CH4_USART8_TX) ||                                    (REMAP == DMA2_CH5_DEFAULT)   ||                                    (REMAP == DMA2_CH5_ADC)       ||                                    (REMAP == DMA2_CH5_USART1_TX) ||                                    (REMAP == DMA2_CH5_USART2_TX) ||                                    (REMAP == DMA2_CH5_USART3_TX) ||                                    (REMAP == DMA2_CH5_USART4_TX) ||                                    (REMAP == DMA2_CH5_USART5_TX) ||                                    (REMAP == DMA2_CH5_USART6_TX) ||                                    (REMAP == DMA2_CH5_USART7_TX) ||                                    (REMAP == DMA2_CH5_USART8_TX ))
N
N/**
N  * @}
N  */
N  
N/** @defgroup DMA_interrupts_definition
N  * @{
N  */
N
N#define DMA_IT_TC                          DMA_CCR_TCIE
N#define DMA_IT_HT                          DMA_CCR_HTIE
N#define DMA_IT_TE                          DMA_CCR_TEIE
N
N#define IS_DMA_CONFIG_IT(IT) ((((IT) & 0xFFFFFFF1) == 0x00) && ((IT) != 0x00))
N
N#define DMA1_IT_GL1                        DMA_ISR_GIF1
N#define DMA1_IT_TC1                        DMA_ISR_TCIF1
N#define DMA1_IT_HT1                        DMA_ISR_HTIF1
N#define DMA1_IT_TE1                        DMA_ISR_TEIF1
N#define DMA1_IT_GL2                        DMA_ISR_GIF2
N#define DMA1_IT_TC2                        DMA_ISR_TCIF2
N#define DMA1_IT_HT2                        DMA_ISR_HTIF2
N#define DMA1_IT_TE2                        DMA_ISR_TEIF2
N#define DMA1_IT_GL3                        DMA_ISR_GIF3
N#define DMA1_IT_TC3                        DMA_ISR_TCIF3
N#define DMA1_IT_HT3                        DMA_ISR_HTIF3
N#define DMA1_IT_TE3                        DMA_ISR_TEIF3
N#define DMA1_IT_GL4                        DMA_ISR_GIF4
N#define DMA1_IT_TC4                        DMA_ISR_TCIF4
N#define DMA1_IT_HT4                        DMA_ISR_HTIF4
N#define DMA1_IT_TE4                        DMA_ISR_TEIF4
N#define DMA1_IT_GL5                        DMA_ISR_GIF5
N#define DMA1_IT_TC5                        DMA_ISR_TCIF5
N#define DMA1_IT_HT5                        DMA_ISR_HTIF5
N#define DMA1_IT_TE5                        DMA_ISR_TEIF5
N#define DMA1_IT_GL6                        DMA_ISR_GIF6   
N#define DMA1_IT_TC6                        DMA_ISR_TCIF6 
N#define DMA1_IT_HT6                        DMA_ISR_HTIF6 
N#define DMA1_IT_TE6                        DMA_ISR_TEIF6  
N#define DMA1_IT_GL7                        DMA_ISR_GIF7   
N#define DMA1_IT_TC7                        DMA_ISR_TCIF7  
N#define DMA1_IT_HT7                        DMA_ISR_HTIF7 
N#define DMA1_IT_TE7                        DMA_ISR_TEIF7 
N
N#define DMA2_IT_GL1                        ((uint32_t)0x10000001)  
N#define DMA2_IT_TC1                        ((uint32_t)0x10000002)  
N#define DMA2_IT_HT1                        ((uint32_t)0x10000004)  
N#define DMA2_IT_TE1                        ((uint32_t)0x10000008)  
N#define DMA2_IT_GL2                        ((uint32_t)0x10000010)  
N#define DMA2_IT_TC2                        ((uint32_t)0x10000020)  
N#define DMA2_IT_HT2                        ((uint32_t)0x10000040)  
N#define DMA2_IT_TE2                        ((uint32_t)0x10000080)  
N#define DMA2_IT_GL3                        ((uint32_t)0x10000100)  
N#define DMA2_IT_TC3                        ((uint32_t)0x10000200)  
N#define DMA2_IT_HT3                        ((uint32_t)0x10000400) 
N#define DMA2_IT_TE3                        ((uint32_t)0x10000800) 
N#define DMA2_IT_GL4                        ((uint32_t)0x10001000)  
N#define DMA2_IT_TC4                        ((uint32_t)0x10002000)  
N#define DMA2_IT_HT4                        ((uint32_t)0x10004000)  
N#define DMA2_IT_TE4                        ((uint32_t)0x10008000) 
N#define DMA2_IT_GL5                        ((uint32_t)0x10010000)  
N#define DMA2_IT_TC5                        ((uint32_t)0x10020000)  
N#define DMA2_IT_HT5                        ((uint32_t)0x10040000)
N#define DMA2_IT_TE5                        ((uint32_t)0x10080000)
N
N#define IS_DMA_CLEAR_IT(IT) (((((IT) & 0xF0000000) == 0x00) || (((IT) & 0xEFF00000) == 0x00)) && ((IT) != 0x00))
N
N#define IS_DMA_GET_IT(IT) (((IT) == DMA1_IT_GL1) || ((IT) == DMA1_IT_TC1) || \
N                           ((IT) == DMA1_IT_HT1) || ((IT) == DMA1_IT_TE1) || \
N                           ((IT) == DMA1_IT_GL2) || ((IT) == DMA1_IT_TC2) || \
N                           ((IT) == DMA1_IT_HT2) || ((IT) == DMA1_IT_TE2) || \
N                           ((IT) == DMA1_IT_GL3) || ((IT) == DMA1_IT_TC3) || \
N                           ((IT) == DMA1_IT_HT3) || ((IT) == DMA1_IT_TE3) || \
N                           ((IT) == DMA1_IT_GL4) || ((IT) == DMA1_IT_TC4) || \
N                           ((IT) == DMA1_IT_HT4) || ((IT) == DMA1_IT_TE4) || \
N                           ((IT) == DMA1_IT_GL5) || ((IT) == DMA1_IT_TC5) || \
N                           ((IT) == DMA1_IT_HT5) || ((IT) == DMA1_IT_TE5) || \
N                           ((IT) == DMA1_IT_GL6) || ((IT) == DMA1_IT_TC6) || \
N                           ((IT) == DMA1_IT_HT6) || ((IT) == DMA1_IT_TE6) || \
N                           ((IT) == DMA1_IT_GL7) || ((IT) == DMA1_IT_TC7) || \
N                           ((IT) == DMA1_IT_HT7) || ((IT) == DMA1_IT_TE7) || \
N                           ((IT) == DMA2_IT_GL1) || ((IT) == DMA2_IT_TC1) || \
N                           ((IT) == DMA2_IT_HT1) || ((IT) == DMA2_IT_TE1) || \
N                           ((IT) == DMA2_IT_GL2) || ((IT) == DMA2_IT_TC2) || \
N                           ((IT) == DMA2_IT_HT2) || ((IT) == DMA2_IT_TE2) || \
N                           ((IT) == DMA2_IT_GL3) || ((IT) == DMA2_IT_TC3) || \
N                           ((IT) == DMA2_IT_HT3) || ((IT) == DMA2_IT_TE3) || \
N                           ((IT) == DMA2_IT_GL4) || ((IT) == DMA2_IT_TC4) || \
N                           ((IT) == DMA2_IT_HT4) || ((IT) == DMA2_IT_TE4) || \
N                           ((IT) == DMA2_IT_GL5) || ((IT) == DMA2_IT_TC5) || \
N                           ((IT) == DMA2_IT_HT5) || ((IT) == DMA2_IT_TE5))
X#define IS_DMA_GET_IT(IT) (((IT) == DMA1_IT_GL1) || ((IT) == DMA1_IT_TC1) ||                            ((IT) == DMA1_IT_HT1) || ((IT) == DMA1_IT_TE1) ||                            ((IT) == DMA1_IT_GL2) || ((IT) == DMA1_IT_TC2) ||                            ((IT) == DMA1_IT_HT2) || ((IT) == DMA1_IT_TE2) ||                            ((IT) == DMA1_IT_GL3) || ((IT) == DMA1_IT_TC3) ||                            ((IT) == DMA1_IT_HT3) || ((IT) == DMA1_IT_TE3) ||                            ((IT) == DMA1_IT_GL4) || ((IT) == DMA1_IT_TC4) ||                            ((IT) == DMA1_IT_HT4) || ((IT) == DMA1_IT_TE4) ||                            ((IT) == DMA1_IT_GL5) || ((IT) == DMA1_IT_TC5) ||                            ((IT) == DMA1_IT_HT5) || ((IT) == DMA1_IT_TE5) ||                            ((IT) == DMA1_IT_GL6) || ((IT) == DMA1_IT_TC6) ||                            ((IT) == DMA1_IT_HT6) || ((IT) == DMA1_IT_TE6) ||                            ((IT) == DMA1_IT_GL7) || ((IT) == DMA1_IT_TC7) ||                            ((IT) == DMA1_IT_HT7) || ((IT) == DMA1_IT_TE7) ||                            ((IT) == DMA2_IT_GL1) || ((IT) == DMA2_IT_TC1) ||                            ((IT) == DMA2_IT_HT1) || ((IT) == DMA2_IT_TE1) ||                            ((IT) == DMA2_IT_GL2) || ((IT) == DMA2_IT_TC2) ||                            ((IT) == DMA2_IT_HT2) || ((IT) == DMA2_IT_TE2) ||                            ((IT) == DMA2_IT_GL3) || ((IT) == DMA2_IT_TC3) ||                            ((IT) == DMA2_IT_HT3) || ((IT) == DMA2_IT_TE3) ||                            ((IT) == DMA2_IT_GL4) || ((IT) == DMA2_IT_TC4) ||                            ((IT) == DMA2_IT_HT4) || ((IT) == DMA2_IT_TE4) ||                            ((IT) == DMA2_IT_GL5) || ((IT) == DMA2_IT_TC5) ||                            ((IT) == DMA2_IT_HT5) || ((IT) == DMA2_IT_TE5))
N
N/**
N  * @}
N  */
N
N/** @defgroup DMA_flags_definition 
N  * @{
N  */
N#define DMA1_FLAG_GL1                      DMA_ISR_GIF1
N#define DMA1_FLAG_TC1                      DMA_ISR_TCIF1
N#define DMA1_FLAG_HT1                      DMA_ISR_HTIF1
N#define DMA1_FLAG_TE1                      DMA_ISR_TEIF1
N#define DMA1_FLAG_GL2                      DMA_ISR_GIF2
N#define DMA1_FLAG_TC2                      DMA_ISR_TCIF2
N#define DMA1_FLAG_HT2                      DMA_ISR_HTIF2
N#define DMA1_FLAG_TE2                      DMA_ISR_TEIF2
N#define DMA1_FLAG_GL3                      DMA_ISR_GIF3
N#define DMA1_FLAG_TC3                      DMA_ISR_TCIF3
N#define DMA1_FLAG_HT3                      DMA_ISR_HTIF3
N#define DMA1_FLAG_TE3                      DMA_ISR_TEIF3
N#define DMA1_FLAG_GL4                      DMA_ISR_GIF4
N#define DMA1_FLAG_TC4                      DMA_ISR_TCIF4
N#define DMA1_FLAG_HT4                      DMA_ISR_HTIF4
N#define DMA1_FLAG_TE4                      DMA_ISR_TEIF4
N#define DMA1_FLAG_GL5                      DMA_ISR_GIF5
N#define DMA1_FLAG_TC5                      DMA_ISR_TCIF5
N#define DMA1_FLAG_HT5                      DMA_ISR_HTIF5
N#define DMA1_FLAG_TE5                      DMA_ISR_TEIF5
N#define DMA1_FLAG_GL6                      DMA_ISR_GIF6  
N#define DMA1_FLAG_TC6                      DMA_ISR_TCIF6  
N#define DMA1_FLAG_HT6                      DMA_ISR_HTIF6 
N#define DMA1_FLAG_TE6                      DMA_ISR_TEIF6 
N#define DMA1_FLAG_GL7                      DMA_ISR_GIF7   
N#define DMA1_FLAG_TC7                      DMA_ISR_TCIF7 
N#define DMA1_FLAG_HT7                      DMA_ISR_HTIF7 
N#define DMA1_FLAG_TE7                      DMA_ISR_TEIF7
N
N#define DMA2_FLAG_GL1                      ((uint32_t)0x10000001)
N#define DMA2_FLAG_TC1                      ((uint32_t)0x10000002)
N#define DMA2_FLAG_HT1                      ((uint32_t)0x10000004)
N#define DMA2_FLAG_TE1                      ((uint32_t)0x10000008)
N#define DMA2_FLAG_GL2                      ((uint32_t)0x10000010)
N#define DMA2_FLAG_TC2                      ((uint32_t)0x10000020)
N#define DMA2_FLAG_HT2                      ((uint32_t)0x10000040)
N#define DMA2_FLAG_TE2                      ((uint32_t)0x10000080)
N#define DMA2_FLAG_GL3                      ((uint32_t)0x10000100)
N#define DMA2_FLAG_TC3                      ((uint32_t)0x10000200)
N#define DMA2_FLAG_HT3                      ((uint32_t)0x10000400)
N#define DMA2_FLAG_TE3                      ((uint32_t)0x10000800)
N#define DMA2_FLAG_GL4                      ((uint32_t)0x10001000)
N#define DMA2_FLAG_TC4                      ((uint32_t)0x10002000)
N#define DMA2_FLAG_HT4                      ((uint32_t)0x10004000)
N#define DMA2_FLAG_TE4                      ((uint32_t)0x10008000)
N#define DMA2_FLAG_GL5                      ((uint32_t)0x10010000)
N#define DMA2_FLAG_TC5                      ((uint32_t)0x10020000)
N#define DMA2_FLAG_HT5                      ((uint32_t)0x10040000)
N#define DMA2_FLAG_TE5                      ((uint32_t)0x10080000)
N
N#define IS_DMA_CLEAR_FLAG(FLAG) (((((FLAG) & 0xF0000000) == 0x00) || (((FLAG) & 0xEFF00000) == 0x00)) && ((FLAG) != 0x00))
N
N#define IS_DMA_GET_FLAG(FLAG) (((FLAG) == DMA1_FLAG_GL1) || ((FLAG) == DMA1_FLAG_TC1) || \
N                               ((FLAG) == DMA1_FLAG_HT1) || ((FLAG) == DMA1_FLAG_TE1) || \
N                               ((FLAG) == DMA1_FLAG_GL2) || ((FLAG) == DMA1_FLAG_TC2) || \
N                               ((FLAG) == DMA1_FLAG_HT2) || ((FLAG) == DMA1_FLAG_TE2) || \
N                               ((FLAG) == DMA1_FLAG_GL3) || ((FLAG) == DMA1_FLAG_TC3) || \
N                               ((FLAG) == DMA1_FLAG_HT3) || ((FLAG) == DMA1_FLAG_TE3) || \
N                               ((FLAG) == DMA1_FLAG_GL4) || ((FLAG) == DMA1_FLAG_TC4) || \
N                               ((FLAG) == DMA1_FLAG_HT4) || ((FLAG) == DMA1_FLAG_TE4) || \
N                               ((FLAG) == DMA1_FLAG_GL5) || ((FLAG) == DMA1_FLAG_TC5) || \
N                               ((FLAG) == DMA1_FLAG_HT5) || ((FLAG) == DMA1_FLAG_TE5) || \
N                               ((FLAG) == DMA1_FLAG_GL6) || ((FLAG) == DMA1_FLAG_TC6) || \
N                               ((FLAG) == DMA1_FLAG_HT6) || ((FLAG) == DMA1_FLAG_TE6) || \
N                               ((FLAG) == DMA1_FLAG_GL7) || ((FLAG) == DMA1_FLAG_TC7) || \
N                               ((FLAG) == DMA1_FLAG_HT7) || ((FLAG) == DMA1_FLAG_TE7) || \
N                               ((FLAG) == DMA2_FLAG_GL1) || ((FLAG) == DMA2_FLAG_TC1) || \
N                               ((FLAG) == DMA2_FLAG_HT1) || ((FLAG) == DMA2_FLAG_TE1) || \
N                               ((FLAG) == DMA2_FLAG_GL2) || ((FLAG) == DMA2_FLAG_TC2) || \
N                               ((FLAG) == DMA2_FLAG_HT2) || ((FLAG) == DMA2_FLAG_TE2) || \
N                               ((FLAG) == DMA2_FLAG_GL3) || ((FLAG) == DMA2_FLAG_TC3) || \
N                               ((FLAG) == DMA2_FLAG_HT3) || ((FLAG) == DMA2_FLAG_TE3) || \
N                               ((FLAG) == DMA2_FLAG_GL4) || ((FLAG) == DMA2_FLAG_TC4) || \
N                               ((FLAG) == DMA2_FLAG_HT4) || ((FLAG) == DMA2_FLAG_TE4) || \
N                               ((FLAG) == DMA2_FLAG_GL5) || ((FLAG) == DMA2_FLAG_TC5) || \
N                               ((FLAG) == DMA2_FLAG_HT5) || ((FLAG) == DMA2_FLAG_TE5))
X#define IS_DMA_GET_FLAG(FLAG) (((FLAG) == DMA1_FLAG_GL1) || ((FLAG) == DMA1_FLAG_TC1) ||                                ((FLAG) == DMA1_FLAG_HT1) || ((FLAG) == DMA1_FLAG_TE1) ||                                ((FLAG) == DMA1_FLAG_GL2) || ((FLAG) == DMA1_FLAG_TC2) ||                                ((FLAG) == DMA1_FLAG_HT2) || ((FLAG) == DMA1_FLAG_TE2) ||                                ((FLAG) == DMA1_FLAG_GL3) || ((FLAG) == DMA1_FLAG_TC3) ||                                ((FLAG) == DMA1_FLAG_HT3) || ((FLAG) == DMA1_FLAG_TE3) ||                                ((FLAG) == DMA1_FLAG_GL4) || ((FLAG) == DMA1_FLAG_TC4) ||                                ((FLAG) == DMA1_FLAG_HT4) || ((FLAG) == DMA1_FLAG_TE4) ||                                ((FLAG) == DMA1_FLAG_GL5) || ((FLAG) == DMA1_FLAG_TC5) ||                                ((FLAG) == DMA1_FLAG_HT5) || ((FLAG) == DMA1_FLAG_TE5) ||                                ((FLAG) == DMA1_FLAG_GL6) || ((FLAG) == DMA1_FLAG_TC6) ||                                ((FLAG) == DMA1_FLAG_HT6) || ((FLAG) == DMA1_FLAG_TE6) ||                                ((FLAG) == DMA1_FLAG_GL7) || ((FLAG) == DMA1_FLAG_TC7) ||                                ((FLAG) == DMA1_FLAG_HT7) || ((FLAG) == DMA1_FLAG_TE7) ||                                ((FLAG) == DMA2_FLAG_GL1) || ((FLAG) == DMA2_FLAG_TC1) ||                                ((FLAG) == DMA2_FLAG_HT1) || ((FLAG) == DMA2_FLAG_TE1) ||                                ((FLAG) == DMA2_FLAG_GL2) || ((FLAG) == DMA2_FLAG_TC2) ||                                ((FLAG) == DMA2_FLAG_HT2) || ((FLAG) == DMA2_FLAG_TE2) ||                                ((FLAG) == DMA2_FLAG_GL3) || ((FLAG) == DMA2_FLAG_TC3) ||                                ((FLAG) == DMA2_FLAG_HT3) || ((FLAG) == DMA2_FLAG_TE3) ||                                ((FLAG) == DMA2_FLAG_GL4) || ((FLAG) == DMA2_FLAG_TC4) ||                                ((FLAG) == DMA2_FLAG_HT4) || ((FLAG) == DMA2_FLAG_TE4) ||                                ((FLAG) == DMA2_FLAG_GL5) || ((FLAG) == DMA2_FLAG_TC5) ||                                ((FLAG) == DMA2_FLAG_HT5) || ((FLAG) == DMA2_FLAG_TE5))
N/**
N  * @}
N  */
N
N/** @defgroup DMA_Buffer_Size 
N  * @{
N  */
N
N#define IS_DMA_BUFFER_SIZE(SIZE) (((SIZE) >= 0x1) && ((SIZE) < 0x10000))
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
N/* Function used to set the DMA configuration to the default reset state ******/
Nvoid DMA_DeInit(DMA_Channel_TypeDef* DMAy_Channelx);
N
N/* Initialization and Configuration functions *********************************/
Nvoid DMA_Init(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct);
Nvoid DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct);
Nvoid DMA_Cmd(DMA_Channel_TypeDef* DMAy_Channelx, FunctionalState NewState);
N
N/* Data Counter functions******************************************************/ 
Nvoid DMA_SetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx, uint16_t DataNumber);
Nuint16_t DMA_GetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx);
N
N/* Interrupts and flags management functions **********************************/
Nvoid DMA_ITConfig(DMA_Channel_TypeDef* DMAy_Channelx, uint32_t DMA_IT, FunctionalState NewState);
NFlagStatus DMA_GetFlagStatus(uint32_t DMAy_FLAG);
Nvoid DMA_ClearFlag(uint32_t DMAy_FLAG);
NITStatus DMA_GetITStatus(uint32_t DMAy_IT);
Nvoid DMA_ClearITPendingBit(uint32_t DMAy_IT);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__FT32F0XX_DMA_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT FMD *****END OF FILE****/
L 35 "..\user\main.h" 2
N#include "ft32f0xx_debug.h"
L 1 "..\FTLib\Inc\ft32f0xx_debug.h" 1
N/**
N  ******************************************************************************
N  * @file    			ft32f0xx_debug.h
N  * @author  			FMD AE
N  * @brief   			This file contains all the functions prototypes for the DBGMCU firmware 
N  *          			library.	
N  * @version 			V1.0.0           
N  * @data		 			2021-07-01
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __FT32F0XX_DBGMCU_H
N#define __FT32F0XX_DBGMCU_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "ft32f0xx.h"
N
N
N/** @addtogroup DBGMCU
N  * @{
N  */ 
N/* Exported types ------------------------------------------------------------*/ 
N/* Exported constants --------------------------------------------------------*/
N
N
N/** @defgroup DBGMCU_Exported_Constants
N  * @{
N  */
N
N#define DBGMCU_STOP                  DBGMCU_CR_DBG_STOP
N#define DBGMCU_STANDBY               DBGMCU_CR_DBG_STANDBY
N#define IS_DBGMCU_PERIPH(PERIPH) ((((PERIPH) & 0xFFFFFFF9) == 0x00) && ((PERIPH) != 0x00))
N
N#define DBGMCU_TIM2_STOP             DBGMCU_APB1_FZ_DBG_TIM2_STOP 
N#define DBGMCU_TIM3_STOP             DBGMCU_APB1_FZ_DBG_TIM3_STOP
N#define DBGMCU_TIM6_STOP             DBGMCU_APB1_FZ_DBG_TIM6_STOP
N#define DBGMCU_TIM7_STOP             DBGMCU_APB1_FZ_DBG_TIM7_STOP  
N#define DBGMCU_TIM14_STOP            DBGMCU_APB1_FZ_DBG_TIM14_STOP
N#define DBGMCU_RTC_STOP              DBGMCU_APB1_FZ_DBG_RTC_STOP
N#define DBGMCU_WWDG_STOP             DBGMCU_APB1_FZ_DBG_WWDG_STOP
N#define DBGMCU_IWDG_STOP             DBGMCU_APB1_FZ_DBG_IWDG_STOP
N#define DBGMCU_I2C1_SMBUS_TIMEOUT    DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT
N#define DBGMCU_CAN1_STOP             DBGMCU_APB1_FZ_DBG_CAN1_STOP 
N#define IS_DBGMCU_APB1PERIPH(PERIPH) ((((PERIPH) & 0xFDDFE2CC) == 0x00) && ((PERIPH) != 0x00))
N
N#define DBGMCU_TIM1_STOP             DBGMCU_APB2_FZ_DBG_TIM1_STOP
N#define DBGMCU_TIM15_STOP            DBGMCU_APB2_FZ_DBG_TIM15_STOP
N#define DBGMCU_TIM16_STOP            DBGMCU_APB2_FZ_DBG_TIM16_STOP
N#define DBGMCU_TIM17_STOP            DBGMCU_APB2_FZ_DBG_TIM17_STOP
N#define IS_DBGMCU_APB2PERIPH(PERIPH) ((((PERIPH) & 0xFFF8F7FF) == 0x00) && ((PERIPH) != 0x00))
N
N/**
N  * @}
N  */ 
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */ 
N
N/* Device and Revision ID management functions ********************************/ 
Nuint32_t DBGMCU_GetREVID(void);
Nuint32_t DBGMCU_GetDEVID(void);
N
N/* Peripherals Configuration functions ****************************************/ 
Nvoid DBGMCU_Config(uint32_t DBGMCU_Periph, FunctionalState NewState);
Nvoid DBGMCU_APB1PeriphConfig(uint32_t DBGMCU_Periph, FunctionalState NewState);
Nvoid DBGMCU_APB2PeriphConfig(uint32_t DBGMCU_Periph, FunctionalState NewState);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __FT32F0XX_DBGMCU_H */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/************************ (C) COPYRIGHT FMD *****END OF FILE****/
L 36 "..\user\main.h" 2
N#include "ft32f0xx_exti.h"
L 1 "..\FTLib\Inc\ft32f0xx_exti.h" 1
N/**
N  ******************************************************************************
N  * @file    			ft32f0xx_exti.h
N  * @author  			FMD AE
N  * @brief   			This file contains all the functions prototypes for the EXTI 
N  *               firmware library 	
N  * @version 			V1.0.0           
N  * @data		 			2021-07-01
N  ******************************************************************************
N  */
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __FT32F0XX_EXTI_H
N#define __FT32F0XX_EXTI_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "ft32f0xx.h"
N
N
N/** @addtogroup EXTI
N  * @{
N  */
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief  EXTI mode enumeration  
N  */
N
Ntypedef enum
N{
N  EXTI_Mode_Interrupt = 0x00,
N  EXTI_Mode_Event = 0x04
N}EXTIMode_TypeDef;
N
N#define IS_EXTI_MODE(MODE) (((MODE) == EXTI_Mode_Interrupt) || ((MODE) == EXTI_Mode_Event))
N
N/** 
N  * @brief  EXTI Trigger enumeration  
N  */
N
Ntypedef enum
N{
N  EXTI_Trigger_Rising = 0x08,
N  EXTI_Trigger_Falling = 0x0C,
N  EXTI_Trigger_Rising_Falling = 0x10
N}EXTITrigger_TypeDef;
N
N#define IS_EXTI_TRIGGER(TRIGGER) (((TRIGGER) == EXTI_Trigger_Rising) || \
N                                  ((TRIGGER) == EXTI_Trigger_Falling) || \
N                                  ((TRIGGER) == EXTI_Trigger_Rising_Falling))
X#define IS_EXTI_TRIGGER(TRIGGER) (((TRIGGER) == EXTI_Trigger_Rising) ||                                   ((TRIGGER) == EXTI_Trigger_Falling) ||                                   ((TRIGGER) == EXTI_Trigger_Rising_Falling))
N/**
N  * @brief  EXTI Init Structure definition
N  */
N
Ntypedef struct
N{
N  uint32_t EXTI_Line;               /*!< Specifies the EXTI lines to be enabled or disabled.
N                                         This parameter can be any combination of @ref EXTI_Lines */
N
N  EXTIMode_TypeDef EXTI_Mode;       /*!< Specifies the mode for the EXTI lines.
N                                         This parameter can be a value of @ref EXTIMode_TypeDef */
N
N  EXTITrigger_TypeDef EXTI_Trigger; /*!< Specifies the trigger signal active edge for the EXTI lines.
N                                         This parameter can be a value of @ref EXTIMode_TypeDef */
N
N  FunctionalState EXTI_LineCmd;     /*!< Specifies the new state of the selected EXTI lines.
N                                         This parameter can be set either to ENABLE or DISABLE */
N}EXTI_InitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup EXTI_Exported_Constants
N  * @{
N  */
N/** @defgroup EXTI_Lines 
N  * @{
N  */
N
N#define EXTI_Line0       ((uint32_t)0x00000001)  /*!< External interrupt line 0  */
N#define EXTI_Line1       ((uint32_t)0x00000002)  /*!< External interrupt line 1  */
N#define EXTI_Line2       ((uint32_t)0x00000004)  /*!< External interrupt line 2  */
N#define EXTI_Line3       ((uint32_t)0x00000008)  /*!< External interrupt line 3  */
N#define EXTI_Line4       ((uint32_t)0x00000010)  /*!< External interrupt line 4  */
N#define EXTI_Line5       ((uint32_t)0x00000020)  /*!< External interrupt line 5  */
N#define EXTI_Line6       ((uint32_t)0x00000040)  /*!< External interrupt line 6  */
N#define EXTI_Line7       ((uint32_t)0x00000080)  /*!< External interrupt line 7  */
N#define EXTI_Line8       ((uint32_t)0x00000100)  /*!< External interrupt line 8  */
N#define EXTI_Line9       ((uint32_t)0x00000200)  /*!< External interrupt line 9  */
N#define EXTI_Line10      ((uint32_t)0x00000400)  /*!< External interrupt line 10 */
N#define EXTI_Line11      ((uint32_t)0x00000800)  /*!< External interrupt line 11 */
N#define EXTI_Line12      ((uint32_t)0x00001000)  /*!< External interrupt line 12 */
N#define EXTI_Line13      ((uint32_t)0x00002000)  /*!< External interrupt line 13 */
N#define EXTI_Line14      ((uint32_t)0x00004000)  /*!< External interrupt line 14 */
N#define EXTI_Line15      ((uint32_t)0x00008000)  /*!< External interrupt line 15 */
N#define EXTI_Line16      ((uint32_t)0x00010000)  /*!< External interrupt line 16 */
N#define EXTI_Line17      ((uint32_t)0x00020000)  /*!< Internal interrupt line 17 
N                                                      Connected to the RTC Alarm 
N                                                      event */
N#define EXTI_Line18      ((uint32_t)0x00040000)  /*!< Internal interrupt line 18 
N                                                      Connected to the USB
N                                                      event*/
N#define EXTI_Line19      ((uint32_t)0x00080000)  /*!< Internal interrupt line 19
N                                                      Connected to the RTC Tamper
N                                                      and Time Stamp events */
N#define EXTI_Line20      ((uint32_t)0x00100000)   /*!< Internal interrupt line 20
N                                                      Connected to the RTC wakeup
N                                                      event */ 
N#define EXTI_Line21      ((uint32_t)0x00200000)  /*!< Internal interrupt line 21
N                                                      Connected to the Comparator 1
N                                                      event */
N#define EXTI_Line22      ((uint32_t)0x00400000)  /*!< Internal interrupt line 22
N                                                      Connected to the Comparator 2
N                                                      event*/
N#define EXTI_Line23      ((uint32_t)0x00800000)  /*!< Internal interrupt line 23
N                                                      Connected to the I2C1 wakeup
N                                                      event*/
N#define EXTI_Line25      ((uint32_t)0x02000000)  /*!< Internal interrupt line 25
N                                                      Connected to the USART1 wakeup
N                                                      event */
N#define EXTI_Line26      ((uint32_t)0x04000000)  /*!< Internal interrupt line 26
N                                                      Connected to the USART2 wakeup
N                                                      event*/
N#define EXTI_Line27      ((uint32_t)0x08000000)  /*!< Internal interrupt line 27
N                                                      Connected to the CEC wakeup
N                                                      event */
N#define EXTI_Line31      ((uint32_t)0x80000000)  /*!< Internal interrupt line 31
N                                                      Connected to the VDD USB monitor
N                                                      event */
N#define IS_EXTI_LINE(LINE) ((((LINE) & (uint32_t)0x71000000) == 0x00) && ((LINE) != (uint16_t)0x00))
N
N#define IS_GET_EXTI_LINE(LINE) (((LINE) == EXTI_Line0) || ((LINE) == EXTI_Line1) || \
N                                ((LINE) == EXTI_Line2) || ((LINE) == EXTI_Line3) || \
N                                ((LINE) == EXTI_Line4) || ((LINE) == EXTI_Line5) || \
N                                ((LINE) == EXTI_Line6) || ((LINE) == EXTI_Line7) || \
N                                ((LINE) == EXTI_Line8) || ((LINE) == EXTI_Line9) || \
N                                ((LINE) == EXTI_Line10) || ((LINE) == EXTI_Line11) || \
N                                ((LINE) == EXTI_Line12) || ((LINE) == EXTI_Line13) || \
N                                ((LINE) == EXTI_Line14) || ((LINE) == EXTI_Line15) || \
N                                ((LINE) == EXTI_Line16) || ((LINE) == EXTI_Line17) || \
N                                ((LINE) == EXTI_Line18) || ((LINE) == EXTI_Line19) || \
N                                ((LINE) == EXTI_Line20) || ((LINE) == EXTI_Line21) || \
N                                ((LINE) == EXTI_Line22) || ((LINE) == EXTI_Line23) || \
N                                ((LINE) == EXTI_Line25) || ((LINE) == EXTI_Line26) || \
N                                ((LINE) == EXTI_Line27) || ((LINE) == EXTI_Line31))
X#define IS_GET_EXTI_LINE(LINE) (((LINE) == EXTI_Line0) || ((LINE) == EXTI_Line1) ||                                 ((LINE) == EXTI_Line2) || ((LINE) == EXTI_Line3) ||                                 ((LINE) == EXTI_Line4) || ((LINE) == EXTI_Line5) ||                                 ((LINE) == EXTI_Line6) || ((LINE) == EXTI_Line7) ||                                 ((LINE) == EXTI_Line8) || ((LINE) == EXTI_Line9) ||                                 ((LINE) == EXTI_Line10) || ((LINE) == EXTI_Line11) ||                                 ((LINE) == EXTI_Line12) || ((LINE) == EXTI_Line13) ||                                 ((LINE) == EXTI_Line14) || ((LINE) == EXTI_Line15) ||                                 ((LINE) == EXTI_Line16) || ((LINE) == EXTI_Line17) ||                                 ((LINE) == EXTI_Line18) || ((LINE) == EXTI_Line19) ||                                 ((LINE) == EXTI_Line20) || ((LINE) == EXTI_Line21) ||                                 ((LINE) == EXTI_Line22) || ((LINE) == EXTI_Line23) ||                                 ((LINE) == EXTI_Line25) || ((LINE) == EXTI_Line26) ||                                 ((LINE) == EXTI_Line27) || ((LINE) == EXTI_Line31))
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N/* Function used to set the EXTI configuration to the default reset state *****/
Nvoid EXTI_DeInit(void);
N
N/* Initialization and Configuration functions *********************************/
Nvoid EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct);
Nvoid EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct);
Nvoid EXTI_GenerateSWInterrupt(uint32_t EXTI_Line);
N
N/* Interrupts and flags management functions **********************************/
NFlagStatus EXTI_GetFlagStatus(uint32_t EXTI_Line);
Nvoid EXTI_ClearFlag(uint32_t EXTI_Line);
NITStatus EXTI_GetITStatus(uint32_t EXTI_Line);
Nvoid EXTI_ClearITPendingBit(uint32_t EXTI_Line);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __FT32F0XX_EXTI_H */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT FMD *****END OF FILE****/
L 37 "..\user\main.h" 2
N#include "ft32f0xx_flash.h"
L 1 "..\FTLib\Inc\ft32f0xx_flash.h" 1
N/**
N  ******************************************************************************
N  * @file    			ft32f0xx_flash.h
N  * @author  			FMD AE
N  * @brief   			This file contains all the functions prototypes for the FLASH 
N  *          			firmware library. 	
N  * @version 			V1.0.0           
N  * @data		 			2021-07-01
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __FT32F0XX_FLASH_H
N#define __FT32F0XX_FLASH_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "ft32f0xx.h"
N
N
N/** @addtogroup FLASH
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief  FLASH Status
N  */ 
Ntypedef enum
N{
N  FLASH_BUSY = 1,
N  FLASH_ERROR_WRP,
N  FLASH_ERROR_PROGRAM,
N  FLASH_COMPLETE,
N  FLASH_TIMEOUT
N}FLASH_Status;
N
N/* Exported constants --------------------------------------------------------*/
N  
N/** @defgroup FLASH_Exported_Constants
N  * @{
N  */ 
N  
N/** @defgroup FLASH_Latency 
N  * @{
N  */ 
N#define FLASH_Latency_0                	((uint32_t)0x00000000)  /*!< FLASH Zero Latency cycle */
N#define FLASH_Latency_1                	((uint32_t)0x00000001)  /*!< FLASH One Latency cycle */
N#define FLASH_Latency_2                	((uint32_t)0x00000002)  
N#define FLASH_Latency_3                	((uint32_t)0x00000003)  
N#define FLASH_Latency_4                	((uint32_t)0x00000004)  
N#define FLASH_Latency_5                	((uint32_t)0x00000005)  
N#define FLASH_Latency_6               	((uint32_t)0x00000006)  
N#define FLASH_Latency_7                	((uint32_t)0x00000007)  
N#define FLASH_Latency_8                	((uint32_t)0x00000008)  
N#define FLASH_Latency_9                	((uint32_t)0x00000009)  
N#define FLASH_Latency_10                ((uint32_t)0x0000000a) 
N#define FLASH_Latency_11                ((uint32_t)0x0000000b) 
N#define FLASH_Latency_12                ((uint32_t)0x0000000c) 
N#define FLASH_Latency_13                ((uint32_t)0x0000000d) 
N#define FLASH_Latency_14                ((uint32_t)0x0000000e) 
N#define FLASH_Latency_15                ((uint32_t)0x0000000f) 
N
N#define IS_FLASH_LATENCY(LATENCY) (((LATENCY) == FLASH_Latency_0) || \
N                                   ((LATENCY) == FLASH_Latency_1) || \
N									((LATENCY) == FLASH_Latency_2 ) || \
N									((LATENCY) == FLASH_Latency_3 ) || \
N									((LATENCY) == FLASH_Latency_4 ) || \
N									((LATENCY) == FLASH_Latency_5 ) || \
N									((LATENCY) == FLASH_Latency_6 ) || \
N									((LATENCY) == FLASH_Latency_7 ) || \
N									((LATENCY) == FLASH_Latency_8 ) || \
N									((LATENCY) == FLASH_Latency_9 ) || \
N									((LATENCY) == FLASH_Latency_10) || \
N									((LATENCY) == FLASH_Latency_11) || \
N									((LATENCY) == FLASH_Latency_12) || \
N									((LATENCY) == FLASH_Latency_13) || \
N									((LATENCY) == FLASH_Latency_14) || \
N									((LATENCY) == FLASH_Latency_15))
X#define IS_FLASH_LATENCY(LATENCY) (((LATENCY) == FLASH_Latency_0) ||                                    ((LATENCY) == FLASH_Latency_1) || 									((LATENCY) == FLASH_Latency_2 ) || 									((LATENCY) == FLASH_Latency_3 ) || 									((LATENCY) == FLASH_Latency_4 ) || 									((LATENCY) == FLASH_Latency_5 ) || 									((LATENCY) == FLASH_Latency_6 ) || 									((LATENCY) == FLASH_Latency_7 ) || 									((LATENCY) == FLASH_Latency_8 ) || 									((LATENCY) == FLASH_Latency_9 ) || 									((LATENCY) == FLASH_Latency_10) || 									((LATENCY) == FLASH_Latency_11) || 									((LATENCY) == FLASH_Latency_12) || 									((LATENCY) == FLASH_Latency_13) || 									((LATENCY) == FLASH_Latency_14) || 									((LATENCY) == FLASH_Latency_15))
N/**
N  * @}
N  */ 
N
N/** @defgroup FLASH_Interrupts 
N  * @{
N  */
N   
N#define FLASH_IT_EOP                   FLASH_CR_EOPIE  /*!< End of programming interrupt source */
N#define FLASH_IT_ERR                   FLASH_CR_ERRIE  /*!< Error interrupt source */
N#define IS_FLASH_IT(IT) ((((IT) & (uint32_t)0xFFFFEBFF) == 0x00000000) && (((IT) != 0x00000000)))
N/**
N  * @}
N  */ 
N
N/** @defgroup FLASH_Address 
N  * @{
N  */
N
N#if defined(FT32F030X8)  /*64K devices */
X#if 0L   
S #define IS_FLASH_PROGRAM_ADDRESS(ADDRESS) (((ADDRESS) >= 0x08000000) && ((ADDRESS) <= 0x0800FFFF))
N#endif
N
N/**
N  * @}
N  */
N
N/** @defgroup FLASH_OB_DATA_ADDRESS 
N  * @{
N  */  
N#define IS_OB_DATA_ADDRESS(ADDRESS) (((ADDRESS) == 0x1FFFF804))
N
N/**
N  * @}
N  */
N
N/** @defgroup FLASH_Option_Bytes_Write_Protection 
N  * @{
N  */
N    
N#define OB_WRP_Pages0to7               ((uint32_t)0x00000001) /* Write protection of page 0		to	7     */
N#define OB_WRP_Pages8to15              ((uint32_t)0x00000002) /* Write protection of page 8		to	15    */
N#define OB_WRP_Pages16to23             ((uint32_t)0x00000004) /* Write protection of page 16	to	23    */
N#define OB_WRP_Pages24to31             ((uint32_t)0x00000008) /* Write protection of page 24	to	31    */
N#define OB_WRP_Pages32to39             ((uint32_t)0x00000010) /* Write protection of page 32	to	39    */
N#define OB_WRP_Pages40to47             ((uint32_t)0x00000020) /* Write protection of page 40	to	47    */
N#define OB_WRP_Pages48to55             ((uint32_t)0x00000040) /* Write protection of page 48	to	55    */
N#define OB_WRP_Pages56to63             ((uint32_t)0x00000080) /* Write protection of page 56	to	63    */
N#define OB_WRP_Pages64to71             ((uint32_t)0x00000100) /* Write protection of page 64	to	71    */
N#define OB_WRP_Pages72to79             ((uint32_t)0x00000200) /* Write protection of page 72	to	79    */
N#define OB_WRP_Pages80to87             ((uint32_t)0x00000400) /* Write protection of page 80	to	87    */
N#define OB_WRP_Pages88to95             ((uint32_t)0x00000800) /* Write protection of page 88	to	95    */
N#define OB_WRP_Pages96to103            ((uint32_t)0x00001000) /* Write protection of page 96	to	103   */
N#define OB_WRP_Pages104to111           ((uint32_t)0x00002000) /* Write protection of page 104	to	111   */
N#define OB_WRP_Pages112to119           ((uint32_t)0x00004000) /* Write protection of page 112	to	119   */
N#define OB_WRP_Pages120to127           ((uint32_t)0x00008000) /* Write protection of page 120	to	127   */
N
N#define OB_WRP_AllPages                ((uint32_t)0x0000FFFF) /*!< Write protection of all Sectors */
N
N#define IS_OB_WRP(PAGE) (((PAGE) != 0x0000000))
N
N/**
N  * @}
N  */
N
N/** @defgroup FLASH_Option_Bytes_Read_Protection 
N  * @{
N  */ 
N
N/** 
N  * @brief  FLASH_Read Protection Level  
N  */ 
N#define OB_RDP_Level_0   ((uint8_t)0xAA)
N#define OB_RDP_Level_1   ((uint8_t)0xBB)
N/*#define OB_RDP_Level_2   ((uint8_t)0xCC)*/ /* Warning: When enabling read protection level 2 
N                                                it's no more possible to go back to level 1 or 0 */
N
N#define IS_OB_RDP(LEVEL) (((LEVEL) == OB_RDP_Level_0)||\
N                          ((LEVEL) == OB_RDP_Level_1))/*||\
N                          ((LEVEL) == OB_RDP_Level_2))*/
X#define IS_OB_RDP(LEVEL) (((LEVEL) == OB_RDP_Level_0)||                          ((LEVEL) == OB_RDP_Level_1)) 
N/**
N  * @}
N  */ 
N
N/** @defgroup FLASH_Option_Bytes_IWatchdog 
N  * @{
N  */
N
N#define OB_IWDG_SW                     ((uint8_t)0x00)  /*!< Software IWDG selected */
N#define OB_IWDG_HW                     ((uint8_t)0x01)  /*!< Hardware IWDG selected */
N#define IS_OB_IWDG_SOURCE(SOURCE) (((SOURCE) == OB_IWDG_SW) || ((SOURCE) == OB_IWDG_HW))
N
N/**
N  * @}
N  */
N
N/** @defgroup FLASH_Option_Bytes_nRST_STOP 
N  * @{
N  */
N
N#define OB_STOP_NoRST                  ((uint8_t)0x02) /*!< No reset generated when entering in STOP */
N#define OB_STOP_RST                    ((uint8_t)0x00) /*!< Reset generated when entering in STOP */
N#define IS_OB_STOP_SOURCE(SOURCE) (((SOURCE) == OB_STOP_NoRST) || ((SOURCE) == OB_STOP_RST))
N
N/**
N  * @}
N  */
N
N/** @defgroup FLASH_Option_Bytes_nRST_STDBY 
N  * @{
N  */
N
N#define OB_STDBY_NoRST                 ((uint8_t)0x04) /*!< No reset generated when entering in STANDBY */
N#define OB_STDBY_RST                   ((uint8_t)0x00) /*!< Reset generated when entering in STANDBY */
N#define IS_OB_STDBY_SOURCE(SOURCE) (((SOURCE) == OB_STDBY_NoRST) || ((SOURCE) == OB_STDBY_RST))
N
N/**
N  * @}
N  */
N
N/** @defgroup FLASH_Option_Bytes_BOOT1
N  * @{
N  */
N
N#define OB_BOOT1_RESET                 ((uint8_t)0x00) /*!< BOOT1 Reset */
N#define OB_BOOT1_SET                   ((uint8_t)0x10) /*!< BOOT1 Set */
N#define IS_OB_BOOT1(BOOT1) (((BOOT1) == OB_BOOT1_RESET) || ((BOOT1) == OB_BOOT1_SET))
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N  
N/** @defgroup FLASH_Option_Bytes_VDDA_Analog_Monitoring
N  * @{
N  */
N
N#define OB_VDDA_ANALOG_ON              ((uint8_t)0x20) /*!< Analog monitoring on VDDA Power source ON */
N#define OB_VDDA_ANALOG_OFF             ((uint8_t)0x00) /*!< Analog monitoring on VDDA Power source OFF */
N
N#define IS_OB_VDDA_ANALOG(ANALOG) (((ANALOG) == OB_VDDA_ANALOG_ON) || ((ANALOG) == OB_VDDA_ANALOG_OFF))
N
N/**
N  * @}
N  */    
N
N/** @defgroup FLASH_Option_Bytes_SRAM_Parity_Enable 
N  * @{
N  */
N
N#define OB_SRAM_PARITY_SET              ((uint8_t)0x00) /*!< SRAM parity enable Set */
N#define OB_SRAM_PARITY_RESET            ((uint8_t)0x40) /*!< SRAM parity enable reset */
N
N#define IS_OB_SRAM_PARITY(PARITY) (((PARITY) == OB_SRAM_PARITY_SET) || ((PARITY) == OB_SRAM_PARITY_RESET))
N
N/**
N  * @}
N  */ 
N  
N/** @defgroup FLASH_Flags 
N  * @{
N  */ 
N
N#define FLASH_FLAG_BSY                 FLASH_SR_BSY     /*!< FLASH Busy flag */
N#define FLASH_FLAG_PGERR               FLASH_SR_PGERR   /*!< FLASH Programming error flag */
N#define FLASH_FLAG_WRPERR              FLASH_SR_WRPERR  /*!< FLASH Write protected error flag */
N#define FLASH_FLAG_EOP                 FLASH_SR_EOP     /*!< FLASH End of Programming flag */
N 
N#define IS_FLASH_CLEAR_FLAG(FLAG) ((((FLAG) & (uint32_t)0xFFFFFFCB) == 0x00000000) && ((FLAG) != 0x00000000))
N
N#define IS_FLASH_GET_FLAG(FLAG)  (((FLAG) == FLASH_FLAG_BSY) || ((FLAG) == FLASH_FLAG_PGERR) || \
N                                  ((FLAG) == FLASH_FLAG_WRPERR) || ((FLAG) == FLASH_FLAG_EOP))
X#define IS_FLASH_GET_FLAG(FLAG)  (((FLAG) == FLASH_FLAG_BSY) || ((FLAG) == FLASH_FLAG_PGERR) ||                                   ((FLAG) == FLASH_FLAG_WRPERR) || ((FLAG) == FLASH_FLAG_EOP))
N/**
N  * @}
N  */ 
N
N/** @defgroup FLASH_Timeout_definition 
N  * @{
N  */ 
N#define FLASH_ER_PRG_TIMEOUT         ((uint32_t)0x000B0000)
N
N/**
N  * @}
N  */ 
N
N/** @defgroup FLASH_Legacy 
N  * @{
N  */
N#define FLASH_WRProt_Pages0to7         OB_WRP_Pages0to7    
N#define FLASH_WRProt_Pages8to15        OB_WRP_Pages8to15   
N#define FLASH_WRProt_Pages16to23       OB_WRP_Pages16to23  
N#define FLASH_WRProt_Pages24to31  	   OB_WRP_Pages24to31  
N#define FLASH_WRProt_Pages32to39  	   OB_WRP_Pages32to39  
N#define FLASH_WRProt_Pages40to47  	   OB_WRP_Pages40to47  
N#define FLASH_WRProt_Pages48to55  	   OB_WRP_Pages48to55  
N#define FLASH_WRProt_Pages56to63  	   OB_WRP_Pages56to63  
N#define FLASH_WRProt_Pages64to71  	   OB_WRP_Pages64to71  
N#define FLASH_WRProt_Pages72to79  	   OB_WRP_Pages72to79  
N#define FLASH_WRProt_Pages80to87  	   OB_WRP_Pages80to87  
N#define FLASH_WRProt_Pages88to95  	   OB_WRP_Pages88to95  
N#define FLASH_WRProt_Pages96to103 	   OB_WRP_Pages96to103 
N#define FLASH_WRProt_Pages104to111	   OB_WRP_Pages104to111
N#define FLASH_WRProt_Pages112to119	   OB_WRP_Pages112to119
N#define FLASH_WRProt_Pages120to127	   OB_WRP_Pages120to127
N
N
N#define FLASH_WRProt_AllPages          OB_WRP_AllPages
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N  
N/** 
N  * @brief  FLASH memory functions that can be executed from FLASH.  
N  */  
N/* FLASH Interface configuration functions ************************************/
Nvoid FLASH_SetLatency(uint32_t FLASH_Latency);
Nvoid FLASH_PrefetchBufferCmd(FunctionalState NewState);
NFlagStatus FLASH_GetPrefetchBufferStatus(void);
N
N/* FLASH Memory Programming functions *****************************************/
Nvoid FLASH_Unlock(void);
Nvoid FLASH_Lock(void);
NFLASH_Status FLASH_ErasePage(uint32_t Page_Address);
NFLASH_Status FLASH_EraseAllPages(void);
NFLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data);
N
N/* FLASH Option Bytes Programming functions *****************************************/
Nvoid FLASH_OB_Unlock(void);
Nvoid FLASH_OB_Lock(void);
Nvoid FLASH_OB_Launch(void);
NFLASH_Status FLASH_OB_Erase(void);
NFLASH_Status FLASH_OB_EnableWRP(uint32_t OB_WRP);
NFLASH_Status FLASH_OB_RDPConfig(uint8_t OB_RDP);
NFLASH_Status FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY);
NFLASH_Status FLASH_OB_BOOTConfig(uint8_t OB_BOOT1);
NFLASH_Status FLASH_OB_VDDAConfig(uint8_t OB_VDDA_ANALOG);
NFLASH_Status FLASH_OB_SRAMParityConfig(uint8_t OB_SRAM_Parity);
NFLASH_Status FLASH_OB_WriteUser(uint8_t OB_USER);
NFLASH_Status FLASH_OB_ProgramData(uint32_t Address, uint32_t Data);
Nuint8_t FLASH_OB_GetUser(void);
Nuint32_t FLASH_OB_GetWRP(void);
NFlagStatus FLASH_OB_GetRDP(void);
N
N/* FLASH Interrupts and flags management functions **********************************/
Nvoid FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState);
NFlagStatus FLASH_GetFlagStatus(uint32_t FLASH_FLAG);
Nvoid FLASH_ClearFlag(uint32_t FLASH_FLAG);
NFLASH_Status FLASH_GetStatus(void);
NFLASH_Status FLASH_WaitForLastOperation(uint32_t Timeout);
N
N/** @defgroup FLASH_Legacy 
N  * @{
N  */
N#define FLASH_EraseOptionBytes               FLASH_OB_Erase
N#define FLASH_EnableWriteProtection	         FLASH_OB_EnableWRP
N#define FLASH_UserOptionByteConfig	         FLASH_OB_UserConfig
N#define FLASH_ProgramOption4ByteData         FLASH_OB_ProgramData
N#define FLASH_GetUserOptionByte	             FLASH_OB_GetUser
N#define FLASH_GetWriteProtectionOptionByte   FLASH_OB_GetWRP
N
N/**
N  * @}
N  */
N  
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __FT32F0XX_FLASH_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/************************ (C) COPYRIGHT FMD *****END OF FILE****/
L 38 "..\user\main.h" 2
N#include "ft32f0xx_gpio.h"
L 1 "..\FTLib\Inc\ft32f0xx_gpio.h" 1
N/**
N  ******************************************************************************
N  * @file    			ft32f0xx_gpio.h
N  * @author  			FMD AE
N  * @brief   			This file contains all the functions prototypes for the GPIO 
N  *          			firmware library. 	
N  * @version 			V1.0.0           
N  * @data		 			2021-07-01
N  ******************************************************************************
N  */
N
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __FT32F030X8_GPIO_H
N#define __FT32F030X8_GPIO_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "ft32f0xx.h"
N
N
N
N/** @addtogroup GPIO
N  * @{
N  */
N/* Exported types ------------------------------------------------------------*/
N
N#define IS_GPIO_ALL_PERIPH(PERIPH) (((PERIPH) == GPIOA) || \
N                                    ((PERIPH) == GPIOB) || \
N                                    ((PERIPH) == GPIOC) || \
N                                    ((PERIPH) == GPIOD) || \
N                                    ((PERIPH) == GPIOE) || \
N                                    ((PERIPH) == GPIOF))
X#define IS_GPIO_ALL_PERIPH(PERIPH) (((PERIPH) == GPIOA) ||                                     ((PERIPH) == GPIOB) ||                                     ((PERIPH) == GPIOC) ||                                     ((PERIPH) == GPIOD) ||                                     ((PERIPH) == GPIOE) ||                                     ((PERIPH) == GPIOF))
N
N#define IS_GPIO_LIST_PERIPH(PERIPH) (((PERIPH) == GPIOA) || \
N                                     ((PERIPH) == GPIOB))
X#define IS_GPIO_LIST_PERIPH(PERIPH) (((PERIPH) == GPIOA) ||                                      ((PERIPH) == GPIOB))
N
N/** @defgroup Configuration_Mode_enumeration 
N  * @{
N  */
Ntypedef enum
N{
N  GPIO_Mode_IN   = 0x00, /*!< GPIO Input Mode              */
N  GPIO_Mode_OUT  = 0x01, /*!< GPIO Output Mode             */
N  GPIO_Mode_AF   = 0x02, /*!< GPIO Alternate function Mode */
N  GPIO_Mode_AN   = 0x03  /*!< GPIO Analog In/Out Mode      */
N}GPIOMode_TypeDef;
N
N#define IS_GPIO_MODE(MODE) (((MODE) == GPIO_Mode_IN)|| ((MODE) == GPIO_Mode_OUT) || \
N                            ((MODE) == GPIO_Mode_AF)|| ((MODE) == GPIO_Mode_AN))
X#define IS_GPIO_MODE(MODE) (((MODE) == GPIO_Mode_IN)|| ((MODE) == GPIO_Mode_OUT) ||                             ((MODE) == GPIO_Mode_AF)|| ((MODE) == GPIO_Mode_AN))
N/**
N  * @}
N  */
N
N/** @defgroup Output_type_enumeration
N  * @{
N  */
Ntypedef enum
N{
N  GPIO_OType_PP = 0x00,
N  GPIO_OType_OD = 0x01
N}GPIOOType_TypeDef;
N
N#define IS_GPIO_OTYPE(OTYPE) (((OTYPE) == GPIO_OType_PP) || ((OTYPE) == GPIO_OType_OD))
N
N/**
N  * @}
N  */
N
N/** @defgroup Output_Maximum_frequency_enumeration 
N  * @{
N  */
Ntypedef enum
N{
N  GPIO_Speed_Level_1  = 0x00, /*!< I/O output speed: Low 2 MHz */
N  GPIO_Speed_Level_2  = 0x01, /*!< I/O output speed: Medium 10 MHz */
N  GPIO_Speed_Level_3  = 0x03  /*!< I/O output speed: High 50 MHz */
N}GPIOSpeed_TypeDef;
N
N#define IS_GPIO_SPEED(SPEED) (((SPEED) == GPIO_Speed_Level_1) || ((SPEED) == GPIO_Speed_Level_2) || \
N                              ((SPEED) == GPIO_Speed_Level_3))
X#define IS_GPIO_SPEED(SPEED) (((SPEED) == GPIO_Speed_Level_1) || ((SPEED) == GPIO_Speed_Level_2) ||                               ((SPEED) == GPIO_Speed_Level_3))
N/**
N  * @}
N  */
N
N/** @defgroup Configuration_Pull-Up_Pull-Down_enumeration 
N  * @{
N  */
Ntypedef enum
N{
N  GPIO_PuPd_NOPULL = 0x00,
N  GPIO_PuPd_UP     = 0x01,
N  GPIO_PuPd_DOWN   = 0x02
N}GPIOPuPd_TypeDef;
N
N#define IS_GPIO_PUPD(PUPD) (((PUPD) == GPIO_PuPd_NOPULL) || ((PUPD) == GPIO_PuPd_UP) || \
N                            ((PUPD) == GPIO_PuPd_DOWN))
X#define IS_GPIO_PUPD(PUPD) (((PUPD) == GPIO_PuPd_NOPULL) || ((PUPD) == GPIO_PuPd_UP) ||                             ((PUPD) == GPIO_PuPd_DOWN))
N/**
N  * @}
N  */
N
N/** @defgroup Bit_SET_and_Bit_RESET_enumeration
N  * @{
N  */
Ntypedef enum
N{ 
N  Bit_RESET = 0,
N  Bit_SET
N}BitAction;
N
N#define IS_GPIO_BIT_ACTION(ACTION) (((ACTION) == Bit_RESET) || ((ACTION) == Bit_SET))
N/**
N  * @}
N  */
N
N/**
N  * @brief  GPIO Init structure definition  
N  */
Ntypedef struct
N{
N  uint32_t GPIO_Pin;              /*!< Specifies the GPIO pins to be configured.
N                                       This parameter can be any value of @ref GPIO_pins_define */
N                                       
N  GPIOMode_TypeDef GPIO_Mode;     /*!< Specifies the operating mode for the selected pins.
N                                       This parameter can be a value of @ref GPIOMode_TypeDef   */
N
N  GPIOSpeed_TypeDef GPIO_Speed;   /*!< Specifies the speed for the selected pins.
N                                       This parameter can be a value of @ref GPIOSpeed_TypeDef  */
N
N  GPIOOType_TypeDef GPIO_OType;   /*!< Specifies the operating output type for the selected pins.
N                                       This parameter can be a value of @ref GPIOOType_TypeDef  */
N
N  GPIOPuPd_TypeDef GPIO_PuPd;     /*!< Specifies the operating Pull-up/Pull down for the selected pins.
N                                       This parameter can be a value of @ref GPIOPuPd_TypeDef   */
N}GPIO_InitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup GPIO_Exported_Constants
N  * @{
N  */
N
N/** @defgroup GPIO_pins_define 
N  * @{
N  */
N#define GPIO_Pin_0                 ((uint16_t)0x0001)  /*!< Pin 0 selected    */
N#define GPIO_Pin_1                 ((uint16_t)0x0002)  /*!< Pin 1 selected    */
N#define GPIO_Pin_2                 ((uint16_t)0x0004)  /*!< Pin 2 selected    */
N#define GPIO_Pin_3                 ((uint16_t)0x0008)  /*!< Pin 3 selected    */
N#define GPIO_Pin_4                 ((uint16_t)0x0010)  /*!< Pin 4 selected    */
N#define GPIO_Pin_5                 ((uint16_t)0x0020)  /*!< Pin 5 selected    */
N#define GPIO_Pin_6                 ((uint16_t)0x0040)  /*!< Pin 6 selected    */
N#define GPIO_Pin_7                 ((uint16_t)0x0080)  /*!< Pin 7 selected    */
N#define GPIO_Pin_8                 ((uint16_t)0x0100)  /*!< Pin 8 selected    */
N#define GPIO_Pin_9                 ((uint16_t)0x0200)  /*!< Pin 9 selected    */
N#define GPIO_Pin_10                ((uint16_t)0x0400)  /*!< Pin 10 selected   */
N#define GPIO_Pin_11                ((uint16_t)0x0800)  /*!< Pin 11 selected   */
N#define GPIO_Pin_12                ((uint16_t)0x1000)  /*!< Pin 12 selected   */
N#define GPIO_Pin_13                ((uint16_t)0x2000)  /*!< Pin 13 selected   */
N#define GPIO_Pin_14                ((uint16_t)0x4000)  /*!< Pin 14 selected   */
N#define GPIO_Pin_15                ((uint16_t)0x8000)  /*!< Pin 15 selected   */
N#define GPIO_Pin_All               ((uint16_t)0xFFFF)  /*!< All pins selected */
N
N#define IS_GPIO_PIN(PIN) ((PIN) != (uint16_t)0x00)
N
N#define IS_GET_GPIO_PIN(PIN) (((PIN) == GPIO_Pin_0) || \
N                              ((PIN) == GPIO_Pin_1) || \
N                              ((PIN) == GPIO_Pin_2) || \
N                              ((PIN) == GPIO_Pin_3) || \
N                              ((PIN) == GPIO_Pin_4) || \
N                              ((PIN) == GPIO_Pin_5) || \
N                              ((PIN) == GPIO_Pin_6) || \
N                              ((PIN) == GPIO_Pin_7) || \
N                              ((PIN) == GPIO_Pin_8) || \
N                              ((PIN) == GPIO_Pin_9) || \
N                              ((PIN) == GPIO_Pin_10) || \
N                              ((PIN) == GPIO_Pin_11) || \
N                              ((PIN) == GPIO_Pin_12) || \
N                              ((PIN) == GPIO_Pin_13) || \
N                              ((PIN) == GPIO_Pin_14) || \
N                              ((PIN) == GPIO_Pin_15))
X#define IS_GET_GPIO_PIN(PIN) (((PIN) == GPIO_Pin_0) ||                               ((PIN) == GPIO_Pin_1) ||                               ((PIN) == GPIO_Pin_2) ||                               ((PIN) == GPIO_Pin_3) ||                               ((PIN) == GPIO_Pin_4) ||                               ((PIN) == GPIO_Pin_5) ||                               ((PIN) == GPIO_Pin_6) ||                               ((PIN) == GPIO_Pin_7) ||                               ((PIN) == GPIO_Pin_8) ||                               ((PIN) == GPIO_Pin_9) ||                               ((PIN) == GPIO_Pin_10) ||                               ((PIN) == GPIO_Pin_11) ||                               ((PIN) == GPIO_Pin_12) ||                               ((PIN) == GPIO_Pin_13) ||                               ((PIN) == GPIO_Pin_14) ||                               ((PIN) == GPIO_Pin_15))
N
N/**
N  * @}
N  */
N
N/** @defgroup GPIO_Pin_sources 
N  * @{
N  */
N#define GPIO_PinSource0            ((uint8_t)0x00)
N#define GPIO_PinSource1            ((uint8_t)0x01)
N#define GPIO_PinSource2            ((uint8_t)0x02)
N#define GPIO_PinSource3            ((uint8_t)0x03)
N#define GPIO_PinSource4            ((uint8_t)0x04)
N#define GPIO_PinSource5            ((uint8_t)0x05)
N#define GPIO_PinSource6            ((uint8_t)0x06)
N#define GPIO_PinSource7            ((uint8_t)0x07)
N#define GPIO_PinSource8            ((uint8_t)0x08)
N#define GPIO_PinSource9            ((uint8_t)0x09)
N#define GPIO_PinSource10           ((uint8_t)0x0A)
N#define GPIO_PinSource11           ((uint8_t)0x0B)
N#define GPIO_PinSource12           ((uint8_t)0x0C)
N#define GPIO_PinSource13           ((uint8_t)0x0D)
N#define GPIO_PinSource14           ((uint8_t)0x0E)
N#define GPIO_PinSource15           ((uint8_t)0x0F)
N
N#define IS_GPIO_PIN_SOURCE(PINSOURCE) (((PINSOURCE) == GPIO_PinSource0) || \
N                                       ((PINSOURCE) == GPIO_PinSource1) || \
N                                       ((PINSOURCE) == GPIO_PinSource2) || \
N                                       ((PINSOURCE) == GPIO_PinSource3) || \
N                                       ((PINSOURCE) == GPIO_PinSource4) || \
N                                       ((PINSOURCE) == GPIO_PinSource5) || \
N                                       ((PINSOURCE) == GPIO_PinSource6) || \
N                                       ((PINSOURCE) == GPIO_PinSource7) || \
N                                       ((PINSOURCE) == GPIO_PinSource8) || \
N                                       ((PINSOURCE) == GPIO_PinSource9) || \
N                                       ((PINSOURCE) == GPIO_PinSource10) || \
N                                       ((PINSOURCE) == GPIO_PinSource11) || \
N                                       ((PINSOURCE) == GPIO_PinSource12) || \
N                                       ((PINSOURCE) == GPIO_PinSource13) || \
N                                       ((PINSOURCE) == GPIO_PinSource14) || \
N                                       ((PINSOURCE) == GPIO_PinSource15))
X#define IS_GPIO_PIN_SOURCE(PINSOURCE) (((PINSOURCE) == GPIO_PinSource0) ||                                        ((PINSOURCE) == GPIO_PinSource1) ||                                        ((PINSOURCE) == GPIO_PinSource2) ||                                        ((PINSOURCE) == GPIO_PinSource3) ||                                        ((PINSOURCE) == GPIO_PinSource4) ||                                        ((PINSOURCE) == GPIO_PinSource5) ||                                        ((PINSOURCE) == GPIO_PinSource6) ||                                        ((PINSOURCE) == GPIO_PinSource7) ||                                        ((PINSOURCE) == GPIO_PinSource8) ||                                        ((PINSOURCE) == GPIO_PinSource9) ||                                        ((PINSOURCE) == GPIO_PinSource10) ||                                        ((PINSOURCE) == GPIO_PinSource11) ||                                        ((PINSOURCE) == GPIO_PinSource12) ||                                        ((PINSOURCE) == GPIO_PinSource13) ||                                        ((PINSOURCE) == GPIO_PinSource14) ||                                        ((PINSOURCE) == GPIO_PinSource15))
N/**
N  * @}
N  */
N
N/** @defgroup GPIO_Alternate_function_selection_define 
N  * @{
N  */
N
N/** 
N  * @brief  AF 0 selection
N  */
N#define GPIO_AF_0            ((uint8_t)0x00) /* WKUP, EVENTOUT, TIM15, SPI1, TIM17,
N                                                MCO, SWDAT, SWCLK, TIM14, BOOT,
N                                                USART1, CEC, IR_OUT, SPI2, TS, TIM3,
N                                                USART4, CAN, TIM3, USART2, USART3, 
N                                                CRS, TIM16, TIM1 */
N/** 
N  * @brief  AF 1 selection
N  */
N#define GPIO_AF_1            ((uint8_t)0x01) /* USART2, CEC, TIM3, USART1, IR,
N                                                EVENTOUT, I2C1, I2C2, TIM15, SPI2,
N                                                USART3, TS, SPI1 */
N/** 
N  * @brief  AF 2 selection
N  */
N#define GPIO_AF_2            ((uint8_t)0x02) /* TIM2, TIM1, EVENTOUT, TIM16, TIM17,
N                                                USB */
N/** 
N  * @brief  AF 3 selection
N  */
N#define GPIO_AF_3            ((uint8_t)0x03) /* TS, I2C1, TIM15, EVENTOUT */
N
N/** 
N  * @brief  AF 4 selection
N  */
N#define GPIO_AF_4            ((uint8_t)0x04) /* TIM14, USART4, USART3, CRS, CAN,
N                                                I2C1 */
N
N/** 
N  * @brief  AF 5 selection
N  */
N#define GPIO_AF_5            ((uint8_t)0x05) /* TIM16, TIM17, TIM15, SPI2, I2C2, 
N                                                MCO, I2C1, USB */
N
N/** 
N  * @brief  AF 6 selection
N  */
N#define GPIO_AF_6            ((uint8_t)0x06) /* EVENTOUT */
N/** 
N  * @brief  AF 7 selection
N  */
N#define GPIO_AF_7            ((uint8_t)0x07) /* COMP1 OUT and COMP2 OUT */
N
N#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF_0) || ((AF) == GPIO_AF_1) || \
N                          ((AF) == GPIO_AF_2) || ((AF) == GPIO_AF_3) || \
N                          ((AF) == GPIO_AF_4) || ((AF) == GPIO_AF_5) || \
N                          ((AF) == GPIO_AF_6) || ((AF) == GPIO_AF_7))
X#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF_0) || ((AF) == GPIO_AF_1) ||                           ((AF) == GPIO_AF_2) || ((AF) == GPIO_AF_3) ||                           ((AF) == GPIO_AF_4) || ((AF) == GPIO_AF_5) ||                           ((AF) == GPIO_AF_6) || ((AF) == GPIO_AF_7))
N
N/**
N  * @}
N  */
N
N/** @defgroup GPIO_Speed_Legacy 
N  * @{
N  */
N
N#define GPIO_Speed_2MHz  GPIO_Speed_Level_1   /*!< I/O output speed: Low 2 MHz  */
N#define GPIO_Speed_10MHz GPIO_Speed_Level_2   /*!< I/O output speed: Medium 10 MHz */
N#define GPIO_Speed_50MHz GPIO_Speed_Level_3   /*!< I/O output speed: High 50 MHz */
N  
N/** @defgroup GPIO_LEDM Only Use in GPIOA and GPIOB
N  * @}
N  */
N#define	GPIO_LEDM_0			((uint32_t)(0x00000001))
N#define	GPIO_LEDM_1			((uint32_t)(0x00000002))
N#define	GPIO_LEDM_3			((uint32_t)(0x00000008))
N#define	GPIO_LEDM_4			((uint32_t)(0x00000010))
N#define	GPIO_LEDM_5			((uint32_t)(0x00000020))
N#define	GPIO_LEDM_6			((uint32_t)(0x00000040))
N#define	GPIO_LEDM_7			((uint32_t)(0x00000080))
N
N#define	GPIO_LEDM_8			((uint32_t)(0x00000100))
N#define	GPIO_LEDM_9			((uint32_t)(0x00000200))
N#define	GPIO_LEDM_10		((uint32_t)(0x00000400))
N#define	GPIO_LEDM_13		((uint32_t)(0x00002000))
N#define	GPIO_LEDM_14		((uint32_t)(0x00004000))
N#define	GPIO_LEDM_15		((uint32_t)(0x00008000))
N
N
N#define	IS_GPIO_LEDM(LEDM)		(((LEDM) == GPIO_LEDM_0) ||\
N																((LEDM) == GPIO_LEDM_1) ||\
N																((LEDM) == GPIO_LEDM_3) ||\
N																((LEDM) == GPIO_LEDM_4) ||\
N																((LEDM) == GPIO_LEDM_5) ||\
N																((LEDM) == GPIO_LEDM_6) ||\
N																((LEDM) == GPIO_LEDM_7) ||\
N																((LEDM) == GPIO_LEDM_8) ||\
N																((LEDM) == GPIO_LEDM_9) ||\
N																((LEDM) == GPIO_LEDM_10) ||\
N																((LEDM) == GPIO_LEDM_13) ||\
N																((LEDM) == GPIO_LEDM_14) ||\
N																((LEDM) == GPIO_LEDM_15))
X#define	IS_GPIO_LEDM(LEDM)		(((LEDM) == GPIO_LEDM_0) ||																((LEDM) == GPIO_LEDM_1) ||																((LEDM) == GPIO_LEDM_3) ||																((LEDM) == GPIO_LEDM_4) ||																((LEDM) == GPIO_LEDM_5) ||																((LEDM) == GPIO_LEDM_6) ||																((LEDM) == GPIO_LEDM_7) ||																((LEDM) == GPIO_LEDM_8) ||																((LEDM) == GPIO_LEDM_9) ||																((LEDM) == GPIO_LEDM_10) ||																((LEDM) == GPIO_LEDM_13) ||																((LEDM) == GPIO_LEDM_14) ||																((LEDM) == GPIO_LEDM_15))
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N/* Function used to set the GPIO configuration to the default reset state *****/
Nvoid GPIO_DeInit(GPIO_TypeDef* GPIOx);
N
N/* Initialization and Configuration functions *********************************/
Nvoid GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct);
Nvoid GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct);
Nvoid GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
N
N/* GPIO Read and Write functions **********************************************/
Nuint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
Nuint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx);
Nuint8_t GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
Nuint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx);
Nvoid GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
Nvoid GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
Nvoid GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal);
Nvoid GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal);
N
N/* GPIO Alternate functions configuration functions ***************************/
Nvoid GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF);
N/*GPIO LED*/
Nvoid GPIO_LedmConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_LEDMx);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __FT32F0XX_GPIO_H */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT FMD *****END OF FILE****/
L 39 "..\user\main.h" 2
N#include "ft32f0xx_i2c.h"
L 1 "..\FTLib\Inc\ft32f0xx_i2c.h" 1
N/**
N  ******************************************************************************
N  * @file    			ft32f0xx_i2c.h
N  * @author  			FMD AE
N  * @brief   			This file contains all the functions prototypes for the I2C firmware
N  *          			library 	
N  * @version 			V1.0.0           
N  * @data		 			2021-07-01
N  ******************************************************************************
N  */
N
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __FT32F0XX_I2C_H
N#define __FT32F0XX_I2C_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "ft32f0xx.h"
N
N
N/** @addtogroup I2C
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/**
N  * @brief  I2C Init structure definition
N  */
N
Ntypedef struct
N{
N  uint32_t I2C_Timing;              /*!< Specifies the I2C_TIMINGR_register value.
N                                         This parameter must be set by referring to I2C_Timing_Config_Tool*/
N
N  uint32_t I2C_AnalogFilter;        /*!< Enables or disables analog noise filter.
N                                         This parameter can be a value of @ref I2C_Analog_Filter*/
N
N  uint32_t I2C_DigitalFilter;       /*!< Configures the digital noise filter.
N                                         This parameter can be a number between 0x00 and 0x0F*/
N
N  uint32_t I2C_Mode;                /*!< Specifies the I2C mode.
N                                         This parameter can be a value of @ref I2C_mode*/
N
N  uint32_t I2C_OwnAddress1;         /*!< Specifies the device own address 1.
N                                         This parameter can be a 7-bit or 10-bit address*/
N
N  uint32_t I2C_Ack;                 /*!< Enables or disables the acknowledgement.
N                                         This parameter can be a value of @ref I2C_acknowledgement*/
N
N  uint32_t I2C_AcknowledgedAddress; /*!< Specifies if 7-bit or 10-bit address is acknowledged.
N                                         This parameter can be a value of @ref I2C_acknowledged_address*/
N}I2C_InitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N
N
N/** @defgroup I2C_Exported_Constants
N  * @{
N  */
N
N#define IS_I2C_ALL_PERIPH(PERIPH)       (((PERIPH) == I2C1) || \
N                                         ((PERIPH) == I2C2))
X#define IS_I2C_ALL_PERIPH(PERIPH)       (((PERIPH) == I2C1) ||                                          ((PERIPH) == I2C2))
N                                         
N#define IS_I2C_1_PERIPH(PERIPH)         ((PERIPH) == I2C1) 
N
N/** @defgroup I2C_Analog_Filter 
N  * @{
N  */
N
N#define I2C_AnalogFilter_Enable         ((uint32_t)0x00000000)
N#define I2C_AnalogFilter_Disable        I2C_CR1_ANFOFF
N
N#define IS_I2C_ANALOG_FILTER(FILTER)    (((FILTER) == I2C_AnalogFilter_Enable) || \
N                                         ((FILTER) == I2C_AnalogFilter_Disable))
X#define IS_I2C_ANALOG_FILTER(FILTER)    (((FILTER) == I2C_AnalogFilter_Enable) ||                                          ((FILTER) == I2C_AnalogFilter_Disable))
N/**
N  * @}
N  */
N
N/** @defgroup I2C_Digital_Filter
N  * @{
N  */
N
N#define IS_I2C_DIGITAL_FILTER(FILTER)   ((FILTER) <= 0x0000000F)
N/**
N  * @}
N  */
N
N/** @defgroup I2C_mode 
N  * @{
N  */
N
N#define I2C_Mode_I2C                    ((uint32_t)0x00000000)
N#define I2C_Mode_SMBusDevice            I2C_CR1_SMBDEN
N#define I2C_Mode_SMBusHost              I2C_CR1_SMBHEN
N
N#define IS_I2C_MODE(MODE)               (((MODE) == I2C_Mode_I2C) || \
N                                         ((MODE) == I2C_Mode_SMBusDevice) || \
N                                         ((MODE) == I2C_Mode_SMBusHost))
X#define IS_I2C_MODE(MODE)               (((MODE) == I2C_Mode_I2C) ||                                          ((MODE) == I2C_Mode_SMBusDevice) ||                                          ((MODE) == I2C_Mode_SMBusHost))
N/**
N  * @}
N  */
N
N/** @defgroup I2C_acknowledgement
N  * @{
N  */
N
N#define I2C_Ack_Enable                  ((uint32_t)0x00000000)
N#define I2C_Ack_Disable                 I2C_CR2_NACK
N
N#define IS_I2C_ACK(ACK)                 (((ACK) == I2C_Ack_Enable) || \
N                                         ((ACK) == I2C_Ack_Disable))
X#define IS_I2C_ACK(ACK)                 (((ACK) == I2C_Ack_Enable) ||                                          ((ACK) == I2C_Ack_Disable))
N/**
N  * @}
N  */
N
N/** @defgroup I2C_acknowledged_address
N  * @{
N  */
N
N#define I2C_AcknowledgedAddress_7bit    ((uint32_t)0x00000000)
N#define I2C_AcknowledgedAddress_10bit   I2C_OAR1_OA1MODE
N
N#define IS_I2C_ACKNOWLEDGE_ADDRESS(ADDRESS) (((ADDRESS) == I2C_AcknowledgedAddress_7bit) || \
N                                             ((ADDRESS) == I2C_AcknowledgedAddress_10bit))
X#define IS_I2C_ACKNOWLEDGE_ADDRESS(ADDRESS) (((ADDRESS) == I2C_AcknowledgedAddress_7bit) ||                                              ((ADDRESS) == I2C_AcknowledgedAddress_10bit))
N/**
N  * @}
N  */ 
N
N/** @defgroup I2C_own_address1
N  * @{
N  */
N
N#define IS_I2C_OWN_ADDRESS1(ADDRESS1)   ((ADDRESS1) <= (uint32_t)0x000003FF)
N/**
N  * @}
N  */
N
N/** @defgroup I2C_transfer_direction 
N  * @{
N  */
N
N#define I2C_Direction_Transmitter       ((uint16_t)0x0000)
N#define I2C_Direction_Receiver          ((uint16_t)0x0400)
N
N#define IS_I2C_DIRECTION(DIRECTION)     (((DIRECTION) == I2C_Direction_Transmitter) || \
N                                         ((DIRECTION) == I2C_Direction_Receiver))
X#define IS_I2C_DIRECTION(DIRECTION)     (((DIRECTION) == I2C_Direction_Transmitter) ||                                          ((DIRECTION) == I2C_Direction_Receiver))
N/**
N  * @}
N  */
N
N/** @defgroup I2C_DMA_transfer_requests 
N  * @{
N  */
N
N#define I2C_DMAReq_Tx                   I2C_CR1_TXDMAEN
N#define I2C_DMAReq_Rx                   I2C_CR1_RXDMAEN
N
N#define IS_I2C_DMA_REQ(REQ)             ((((REQ) & (uint32_t)0xFFFF3FFF) == 0x00) && ((REQ) != 0x00))
N/**
N  * @}
N  */
N
N/** @defgroup I2C_slave_address
N  * @{
N  */
N
N#define IS_I2C_SLAVE_ADDRESS(ADDRESS)   ((ADDRESS) <= (uint16_t)0x03FF)
N/**
N  * @}
N  */
N
N
N/** @defgroup I2C_own_address2
N  * @{
N  */
N
N#define IS_I2C_OWN_ADDRESS2(ADDRESS2)   ((ADDRESS2) <= (uint16_t)0x00FF)
N
N/**
N  * @}
N  */
N
N/** @defgroup I2C_own_address2_mask
N  * @{
N  */
N
N#define I2C_OA2_NoMask                  ((uint8_t)0x00)
N#define I2C_OA2_Mask01                  ((uint8_t)0x01)                 
N#define I2C_OA2_Mask02                  ((uint8_t)0x02)
N#define I2C_OA2_Mask03                  ((uint8_t)0x03)
N#define I2C_OA2_Mask04                  ((uint8_t)0x04)
N#define I2C_OA2_Mask05                  ((uint8_t)0x05)
N#define I2C_OA2_Mask06                  ((uint8_t)0x06)
N#define I2C_OA2_Mask07                  ((uint8_t)0x07)
N
N#define IS_I2C_OWN_ADDRESS2_MASK(MASK)  (((MASK) == I2C_OA2_NoMask) || \
N                                         ((MASK) == I2C_OA2_Mask01) || \
N                                         ((MASK) == I2C_OA2_Mask02) || \
N                                         ((MASK) == I2C_OA2_Mask03) || \
N                                         ((MASK) == I2C_OA2_Mask04) || \
N                                         ((MASK) == I2C_OA2_Mask05) || \
N                                         ((MASK) == I2C_OA2_Mask06) || \
N                                         ((MASK) == I2C_OA2_Mask07))  
X#define IS_I2C_OWN_ADDRESS2_MASK(MASK)  (((MASK) == I2C_OA2_NoMask) ||                                          ((MASK) == I2C_OA2_Mask01) ||                                          ((MASK) == I2C_OA2_Mask02) ||                                          ((MASK) == I2C_OA2_Mask03) ||                                          ((MASK) == I2C_OA2_Mask04) ||                                          ((MASK) == I2C_OA2_Mask05) ||                                          ((MASK) == I2C_OA2_Mask06) ||                                          ((MASK) == I2C_OA2_Mask07))  
N
N/**
N  * @}
N  */
N
N/** @defgroup I2C_timeout
N  * @{
N  */
N
N#define IS_I2C_TIMEOUT(TIMEOUT)   ((TIMEOUT) <= (uint16_t)0x0FFF)
N
N/**
N  * @}
N  */
N
N/** @defgroup I2C_registers 
N  * @{
N  */
N
N#define I2C_Register_CR1                ((uint8_t)0x00)
N#define I2C_Register_CR2                ((uint8_t)0x04)
N#define I2C_Register_OAR1               ((uint8_t)0x08)
N#define I2C_Register_OAR2               ((uint8_t)0x0C)
N#define I2C_Register_TIMINGR            ((uint8_t)0x10)
N#define I2C_Register_TIMEOUTR           ((uint8_t)0x14)
N#define I2C_Register_ISR                ((uint8_t)0x18)
N#define I2C_Register_ICR                ((uint8_t)0x1C)
N#define I2C_Register_PECR               ((uint8_t)0x20)
N#define I2C_Register_RXDR               ((uint8_t)0x24)
N#define I2C_Register_TXDR               ((uint8_t)0x28)
N
N#define IS_I2C_REGISTER(REGISTER)       (((REGISTER) == I2C_Register_CR1) || \
N                                         ((REGISTER) == I2C_Register_CR2) || \
N                                         ((REGISTER) == I2C_Register_OAR1) || \
N                                         ((REGISTER) == I2C_Register_OAR2) || \
N                                         ((REGISTER) == I2C_Register_TIMINGR) || \
N                                         ((REGISTER) == I2C_Register_TIMEOUTR) || \
N                                         ((REGISTER) == I2C_Register_ISR) || \
N                                         ((REGISTER) == I2C_Register_ICR) || \
N                                         ((REGISTER) == I2C_Register_PECR) || \
N                                         ((REGISTER) == I2C_Register_RXDR) || \
N                                         ((REGISTER) == I2C_Register_TXDR))
X#define IS_I2C_REGISTER(REGISTER)       (((REGISTER) == I2C_Register_CR1) ||                                          ((REGISTER) == I2C_Register_CR2) ||                                          ((REGISTER) == I2C_Register_OAR1) ||                                          ((REGISTER) == I2C_Register_OAR2) ||                                          ((REGISTER) == I2C_Register_TIMINGR) ||                                          ((REGISTER) == I2C_Register_TIMEOUTR) ||                                          ((REGISTER) == I2C_Register_ISR) ||                                          ((REGISTER) == I2C_Register_ICR) ||                                          ((REGISTER) == I2C_Register_PECR) ||                                          ((REGISTER) == I2C_Register_RXDR) ||                                          ((REGISTER) == I2C_Register_TXDR))
N/**
N  * @}
N  */
N
N/** @defgroup I2C_interrupts_definition 
N  * @{
N  */
N
N#define I2C_IT_ERRI                     I2C_CR1_ERRIE
N#define I2C_IT_TCI                      I2C_CR1_TCIE
N#define I2C_IT_STOPI                    I2C_CR1_STOPIE
N#define I2C_IT_NACKI                    I2C_CR1_NACKIE
N#define I2C_IT_ADDRI                    I2C_CR1_ADDRIE
N#define I2C_IT_RXI                      I2C_CR1_RXIE
N#define I2C_IT_TXI                      I2C_CR1_TXIE
N
N#define IS_I2C_CONFIG_IT(IT)            ((((IT) & (uint32_t)0xFFFFFF01) == 0x00) && ((IT) != 0x00))
N
N/**
N  * @}
N  */
N
N/** @defgroup I2C_flags_definition 
N  * @{
N  */
N
N#define  I2C_FLAG_TXE                   I2C_ISR_TXE
N#define  I2C_FLAG_TXIS                  I2C_ISR_TXIS
N#define  I2C_FLAG_RXNE                  I2C_ISR_RXNE
N#define  I2C_FLAG_ADDR                  I2C_ISR_ADDR
N#define  I2C_FLAG_NACKF                 I2C_ISR_NACKF
N#define  I2C_FLAG_STOPF                 I2C_ISR_STOPF
N#define  I2C_FLAG_TC                    I2C_ISR_TC
N#define  I2C_FLAG_TCR                   I2C_ISR_TCR
N#define  I2C_FLAG_BERR                  I2C_ISR_BERR
N#define  I2C_FLAG_ARLO                  I2C_ISR_ARLO
N#define  I2C_FLAG_OVR                   I2C_ISR_OVR
N#define  I2C_FLAG_PECERR                I2C_ISR_PECERR
N#define  I2C_FLAG_TIMEOUT               I2C_ISR_TIMEOUT
N#define  I2C_FLAG_ALERT                 I2C_ISR_ALERT
N#define  I2C_FLAG_BUSY                  I2C_ISR_BUSY
N
N#define IS_I2C_CLEAR_FLAG(FLAG)         ((((FLAG) & (uint32_t)0xFFFF4000) == 0x00) && ((FLAG) != 0x00))
N
N#define IS_I2C_GET_FLAG(FLAG)           (((FLAG) == I2C_FLAG_TXE) || ((FLAG) == I2C_FLAG_TXIS) || \
N                                         ((FLAG) == I2C_FLAG_RXNE) || ((FLAG) == I2C_FLAG_ADDR) || \
N                                         ((FLAG) == I2C_FLAG_NACKF) || ((FLAG) == I2C_FLAG_STOPF) || \
N                                         ((FLAG) == I2C_FLAG_TC) || ((FLAG) == I2C_FLAG_TCR) || \
N                                         ((FLAG) == I2C_FLAG_BERR) || ((FLAG) == I2C_FLAG_ARLO) || \
N                                         ((FLAG) == I2C_FLAG_OVR) || ((FLAG) == I2C_FLAG_PECERR) || \
N                                         ((FLAG) == I2C_FLAG_TIMEOUT) || ((FLAG) == I2C_FLAG_ALERT) || \
N                                         ((FLAG) == I2C_FLAG_BUSY))
X#define IS_I2C_GET_FLAG(FLAG)           (((FLAG) == I2C_FLAG_TXE) || ((FLAG) == I2C_FLAG_TXIS) ||                                          ((FLAG) == I2C_FLAG_RXNE) || ((FLAG) == I2C_FLAG_ADDR) ||                                          ((FLAG) == I2C_FLAG_NACKF) || ((FLAG) == I2C_FLAG_STOPF) ||                                          ((FLAG) == I2C_FLAG_TC) || ((FLAG) == I2C_FLAG_TCR) ||                                          ((FLAG) == I2C_FLAG_BERR) || ((FLAG) == I2C_FLAG_ARLO) ||                                          ((FLAG) == I2C_FLAG_OVR) || ((FLAG) == I2C_FLAG_PECERR) ||                                          ((FLAG) == I2C_FLAG_TIMEOUT) || ((FLAG) == I2C_FLAG_ALERT) ||                                          ((FLAG) == I2C_FLAG_BUSY))
N
N/**
N  * @}
N  */
N
N
N/** @defgroup I2C_interrupts_definition 
N  * @{
N  */
N
N#define  I2C_IT_TXIS                    I2C_ISR_TXIS
N#define  I2C_IT_RXNE                    I2C_ISR_RXNE
N#define  I2C_IT_ADDR                    I2C_ISR_ADDR
N#define  I2C_IT_NACKF                   I2C_ISR_NACKF
N#define  I2C_IT_STOPF                   I2C_ISR_STOPF
N#define  I2C_IT_TC                      I2C_ISR_TC
N#define  I2C_IT_TCR                     I2C_ISR_TCR
N#define  I2C_IT_BERR                    I2C_ISR_BERR
N#define  I2C_IT_ARLO                    I2C_ISR_ARLO
N#define  I2C_IT_OVR                     I2C_ISR_OVR
N#define  I2C_IT_PECERR                  I2C_ISR_PECERR
N#define  I2C_IT_TIMEOUT                 I2C_ISR_TIMEOUT
N#define  I2C_IT_ALERT                   I2C_ISR_ALERT
N
N#define IS_I2C_CLEAR_IT(IT)             ((((IT) & (uint32_t)0xFFFFC001) == 0x00) && ((IT) != 0x00))
N                               
N#define IS_I2C_GET_IT(IT)               (((IT) == I2C_IT_TXIS) || ((IT) == I2C_IT_RXNE) || \
N                                         ((IT) == I2C_IT_ADDR) || ((IT) == I2C_IT_NACKF) || \
N                                         ((IT) == I2C_IT_STOPF) || ((IT) == I2C_IT_TC) || \
N                                         ((IT) == I2C_IT_TCR) || ((IT) == I2C_IT_BERR) || \
N                                         ((IT) == I2C_IT_ARLO) || ((IT) == I2C_IT_OVR) || \
N                                         ((IT) == I2C_IT_PECERR) || ((IT) == I2C_IT_TIMEOUT) || \
N                                         ((IT) == I2C_IT_ALERT))
X#define IS_I2C_GET_IT(IT)               (((IT) == I2C_IT_TXIS) || ((IT) == I2C_IT_RXNE) ||                                          ((IT) == I2C_IT_ADDR) || ((IT) == I2C_IT_NACKF) ||                                          ((IT) == I2C_IT_STOPF) || ((IT) == I2C_IT_TC) ||                                          ((IT) == I2C_IT_TCR) || ((IT) == I2C_IT_BERR) ||                                          ((IT) == I2C_IT_ARLO) || ((IT) == I2C_IT_OVR) ||                                          ((IT) == I2C_IT_PECERR) || ((IT) == I2C_IT_TIMEOUT) ||                                          ((IT) == I2C_IT_ALERT))
N                               
N
N/**
N  * @}
N  */
N
N/** @defgroup I2C_ReloadEndMode_definition 
N  * @{
N  */
N
N#define  I2C_Reload_Mode                I2C_CR2_RELOAD
N#define  I2C_AutoEnd_Mode               I2C_CR2_AUTOEND
N#define  I2C_SoftEnd_Mode               ((uint32_t)0x00000000)
N
N                              
N#define IS_RELOAD_END_MODE(MODE)        (((MODE) == I2C_Reload_Mode) || \
N                                         ((MODE) == I2C_AutoEnd_Mode) || \
N                                         ((MODE) == I2C_SoftEnd_Mode))
X#define IS_RELOAD_END_MODE(MODE)        (((MODE) == I2C_Reload_Mode) ||                                          ((MODE) == I2C_AutoEnd_Mode) ||                                          ((MODE) == I2C_SoftEnd_Mode))
N                               
N
N/**
N  * @}
N  */
N
N/** @defgroup I2C_StartStopMode_definition 
N  * @{
N  */
N
N#define  I2C_No_StartStop                 ((uint32_t)0x00000000)
N#define  I2C_Generate_Stop                I2C_CR2_STOP
N#define  I2C_Generate_Start_Read          (uint32_t)(I2C_CR2_START | I2C_CR2_RD_WRN)
N#define  I2C_Generate_Start_Write         I2C_CR2_START
N
N                              
N#define IS_START_STOP_MODE(MODE)        (((MODE) == I2C_Generate_Stop) || \
N                                         ((MODE) == I2C_Generate_Start_Read) || \
N                                         ((MODE) == I2C_Generate_Start_Write) || \
N                                         ((MODE) == I2C_No_StartStop))
X#define IS_START_STOP_MODE(MODE)        (((MODE) == I2C_Generate_Stop) ||                                          ((MODE) == I2C_Generate_Start_Read) ||                                          ((MODE) == I2C_Generate_Start_Write) ||                                          ((MODE) == I2C_No_StartStop))
N                               
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
N
N/* Initialization and Configuration functions *********************************/
Nvoid I2C_DeInit(I2C_TypeDef* I2Cx);
Nvoid I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct);
Nvoid I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct);
Nvoid I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx);
Nvoid I2C_ITConfig(I2C_TypeDef* I2Cx, uint32_t I2C_IT, FunctionalState NewState);
Nvoid I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, uint16_t Address, uint8_t Mask);
Nvoid I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_SlaveByteControlCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_SlaveAddressConfig(I2C_TypeDef* I2Cx, uint16_t Address);
Nvoid I2C_10BitAddressingModeCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
N
N/* Communications handling functions ******************************************/
Nvoid I2C_AutoEndCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_ReloadCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_NumberOfBytesConfig(I2C_TypeDef* I2Cx, uint8_t Number_Bytes);
Nvoid I2C_MasterRequestConfig(I2C_TypeDef* I2Cx, uint16_t I2C_Direction);
Nvoid I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_10BitAddressHeaderCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nuint8_t I2C_GetAddressMatched(I2C_TypeDef* I2Cx);
Nuint16_t I2C_GetTransferDirection(I2C_TypeDef* I2Cx);
Nvoid I2C_TransferHandling(I2C_TypeDef* I2Cx, uint16_t Address, uint8_t Number_Bytes, uint32_t ReloadEndMode, uint32_t StartStopMode);
N
N/*  SMBUS management functions ************************************************/
Nvoid I2C_SMBusAlertCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_ClockTimeoutCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_ExtendedClockTimeoutCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_IdleClockTimeoutCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_TimeoutAConfig(I2C_TypeDef* I2Cx, uint16_t Timeout);
Nvoid I2C_TimeoutBConfig(I2C_TypeDef* I2Cx, uint16_t Timeout);
Nvoid I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_PECRequestCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nuint8_t I2C_GetPEC(I2C_TypeDef* I2Cx);
N
N/* I2C registers management functions *****************************************/
Nuint32_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register);
N
N/* Data transfers management functions ****************************************/
Nvoid I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data);
Nuint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx);
N
N/* DMA transfers management functions *****************************************/
Nvoid I2C_DMACmd(I2C_TypeDef* I2Cx, uint32_t I2C_DMAReq, FunctionalState NewState);
N
N/* Interrupts and flags management functions **********************************/
NFlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG);
Nvoid I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG);
NITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT);
Nvoid I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__FT32F0XX_I2C_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT FMD *****END OF FILE****/
L 40 "..\user\main.h" 2
N#include "ft32f0xx_iwdg.h"
L 1 "..\FTLib\Inc\ft32f0xx_iwdg.h" 1
N/**
N  ******************************************************************************
N  * @file    			ft32f0xx_iwdg.h
N  * @author  			FMD AE
N  * @brief   			This file contains all the functions prototypes for the IWDG 
N  *          			firmware library.
N  * @version 			V1.0.0           
N  * @data		 			2021-07-01
N  ******************************************************************************
N  */
N
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __FT32F030X8_IWDG_H
N#define __FT32F030X8_IWDG_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "ft32f0xx.h"
N
N
N/** @addtogroup IWDG
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup IWDG_Exported_Constants
N  * @{
N  */
N
N/** @defgroup IWDG_WriteAccess
N  * @{
N  */
N
N#define IWDG_WriteAccess_Enable     ((uint16_t)0x5555)
N#define IWDG_WriteAccess_Disable    ((uint16_t)0x0000)
N#define IS_IWDG_WRITE_ACCESS(ACCESS) (((ACCESS) == IWDG_WriteAccess_Enable) || \
N                                      ((ACCESS) == IWDG_WriteAccess_Disable))
X#define IS_IWDG_WRITE_ACCESS(ACCESS) (((ACCESS) == IWDG_WriteAccess_Enable) ||                                       ((ACCESS) == IWDG_WriteAccess_Disable))
N/**
N  * @}
N  */
N
N/** @defgroup IWDG_prescaler 
N  * @{
N  */
N
N#define IWDG_Prescaler_4            ((uint8_t)0x00)
N#define IWDG_Prescaler_8            ((uint8_t)0x01)
N#define IWDG_Prescaler_16           ((uint8_t)0x02)
N#define IWDG_Prescaler_32           ((uint8_t)0x03)
N#define IWDG_Prescaler_64           ((uint8_t)0x04)
N#define IWDG_Prescaler_128          ((uint8_t)0x05)
N#define IWDG_Prescaler_256          ((uint8_t)0x06)
N#define IS_IWDG_PRESCALER(PRESCALER) (((PRESCALER) == IWDG_Prescaler_4)  || \
N                                      ((PRESCALER) == IWDG_Prescaler_8)  || \
N                                      ((PRESCALER) == IWDG_Prescaler_16) || \
N                                      ((PRESCALER) == IWDG_Prescaler_32) || \
N                                      ((PRESCALER) == IWDG_Prescaler_64) || \
N                                      ((PRESCALER) == IWDG_Prescaler_128)|| \
N                                      ((PRESCALER) == IWDG_Prescaler_256))
X#define IS_IWDG_PRESCALER(PRESCALER) (((PRESCALER) == IWDG_Prescaler_4)  ||                                       ((PRESCALER) == IWDG_Prescaler_8)  ||                                       ((PRESCALER) == IWDG_Prescaler_16) ||                                       ((PRESCALER) == IWDG_Prescaler_32) ||                                       ((PRESCALER) == IWDG_Prescaler_64) ||                                       ((PRESCALER) == IWDG_Prescaler_128)||                                       ((PRESCALER) == IWDG_Prescaler_256))
N/**
N  * @}
N  */
N
N/** @defgroup IWDG_Flag 
N  * @{
N  */
N
N#define IWDG_FLAG_PVU               IWDG_SR_PVU
N#define IWDG_FLAG_RVU               IWDG_SR_RVU
N#define IWDG_FLAG_WVU               IWDG_SR_WVU
N#define IS_IWDG_FLAG(FLAG) (((FLAG) == IWDG_FLAG_PVU) || ((FLAG) == IWDG_FLAG_RVU)  || \
N                            ((FLAG) == IWDG_FLAG_WVU))
X#define IS_IWDG_FLAG(FLAG) (((FLAG) == IWDG_FLAG_PVU) || ((FLAG) == IWDG_FLAG_RVU)  ||                             ((FLAG) == IWDG_FLAG_WVU))
N
N#define IS_IWDG_RELOAD(RELOAD) ((RELOAD) <= 0xFFF)
N
N#define IS_IWDG_WINDOW_VALUE(VALUE) ((VALUE) <= 0xFFF)
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
N/* Prescaler and Counter configuration functions ******************************/
Nvoid IWDG_WriteAccessCmd(uint16_t IWDG_WriteAccess);
Nvoid IWDG_SetPrescaler(uint8_t IWDG_Prescaler);
Nvoid IWDG_SetReload(uint16_t Reload);
Nvoid IWDG_ReloadCounter(void);
Nvoid IWDG_SetWindowValue(uint16_t WindowValue);
N
N/* IWDG activation function ***************************************************/
Nvoid IWDG_Enable(void);
N
N/* Flag management function ***************************************************/
NFlagStatus IWDG_GetFlagStatus(uint16_t IWDG_FLAG);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __FT32F0XX_IWDG_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT FMD *****END OF FILE****/
L 41 "..\user\main.h" 2
N#include "ft32f0xx_misc.h"
L 1 "..\FTLib\Inc\ft32f0xx_misc.h" 1
N/**
N  ******************************************************************************
N  * @file    			ft32f0xx_misc.h
N  * @author  			FMD AE
N  * @brief   			This file contains all the functions prototypes for the miscellaneous
N  *          			firmware library functions (add-on to CMSIS functions).
N  * @version 			V1.0.0           
N  * @data		 			2021-07-01
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __FT32F0XX_MISC_H
N#define __FT32F0XX_MISC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "ft32f0xx.h"
N
N
N
N/** @addtogroup MISC
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief  NVIC Init Structure definition  
N  */
N
Ntypedef struct
N{
N  uint8_t NVIC_IRQChannel;             /*!< Specifies the IRQ channel to be enabled or disabled.
N                                            This parameter can be a value of @ref IRQn_Type 
N                                            (For the complete FT32 Devices IRQ Channels list, 
N                                            please refer to ft32f0xx.h file) */
N
N  uint8_t NVIC_IRQChannelPriority;     /*!< Specifies the priority level for the IRQ channel specified
N                                            in NVIC_IRQChannel. This parameter can be a value
N                                            between 0 and 3.  */
N
N  FunctionalState NVIC_IRQChannelCmd;  /*!< Specifies whether the IRQ channel defined in NVIC_IRQChannel
N                                            will be enabled or disabled. 
N                                            This parameter can be set either to ENABLE or DISABLE */   
N} NVIC_InitTypeDef;
N
N/**  
N  *
N@verbatim   
N
N@endverbatim
N*/
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup MISC_Exported_Constants
N  * @{
N  */
N
N/** @defgroup MISC_System_Low_Power 
N  * @{
N  */
N
N#define NVIC_LP_SEVONPEND            ((uint8_t)0x10)
N#define NVIC_LP_SLEEPDEEP            ((uint8_t)0x04)
N#define NVIC_LP_SLEEPONEXIT          ((uint8_t)0x02)
N#define IS_NVIC_LP(LP) (((LP) == NVIC_LP_SEVONPEND) || \
N                        ((LP) == NVIC_LP_SLEEPDEEP) || \
N                        ((LP) == NVIC_LP_SLEEPONEXIT))
X#define IS_NVIC_LP(LP) (((LP) == NVIC_LP_SEVONPEND) ||                         ((LP) == NVIC_LP_SLEEPDEEP) ||                         ((LP) == NVIC_LP_SLEEPONEXIT))
N/**
N  * @}
N  */
N
N/** @defgroup MISC_Preemption_Priority_Group 
N  * @{
N  */
N#define IS_NVIC_PRIORITY(PRIORITY)  ((PRIORITY) < 0x04)
N
N/**
N  * @}
N  */
N
N/** @defgroup MISC_SysTick_clock_source 
N  * @{
N  */
N
N#define SysTick_CLKSource_HCLK_Div8    ((uint32_t)0xFFFFFFFB)
N#define SysTick_CLKSource_HCLK         ((uint32_t)0x00000004)
N#define IS_SYSTICK_CLK_SOURCE(SOURCE) (((SOURCE) == SysTick_CLKSource_HCLK) || \
N                                       ((SOURCE) == SysTick_CLKSource_HCLK_Div8))
X#define IS_SYSTICK_CLK_SOURCE(SOURCE) (((SOURCE) == SysTick_CLKSource_HCLK) ||                                        ((SOURCE) == SysTick_CLKSource_HCLK_Div8))
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */ 
N
Nvoid NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct);
Nvoid NVIC_SystemLPConfig(uint8_t LowPowerMode, FunctionalState NewState);
Nvoid SysTick_CLKSourceConfig(uint32_t SysTick_CLKSource);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __FT32F0XX_MISC_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT FMD *****END OF FILE****/
L 42 "..\user\main.h" 2
N#include "ft32f0xx_opa.h"
L 1 "..\FTLib\Inc\ft32f0xx_opa.h" 1
N/**
N  ******************************************************************************
N  * @file    			ft32f0xx_opa.h
N  * @author  			FMD AE
N  * @brief   			This file contains all the functions prototypes for the OPA firmware 
N  *          			library.
N  * @version 			V1.0.0           
N  * @data		 			2021-07-01
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __FT32F0XX_OPA_H
N#define __FT32F0XX_OPA_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "ft32f0xx.h"
N
N
N
N/** @addtogroup OPA
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief  OPA Init structure definition  
N  */
N  
Ntypedef struct
N{
N
N  uint32_t OPA_OP0PSel;     /*!< Select the positive input of the OPA.
N                                          This parameter can be a value of @ref OPA_OP0PSel */
N
N  uint32_t OPA_OP0NSel;             /*!< Select the negative input of the OPA.
N                                          This parameter can be a value of @ref OPA_OP0NSel */
N
N  uint32_t OPA_OP0FR;          /*!< Selects The feedback resister of the OPA.
N                                          This parameter can be a value of @ref OPA_OP0FR */
N					  	
N  uint32_t OPA_OP0FCAPE;   /*!< Selects The compensate cap of the OPA.
N                                          This parameter can be a value of @ref OPA_OP0FCAPE */
N
N uint32_t OPA_OPTODIG;	/*!< Selects The output to REG of the OPA.
N                                          This parameter can be a value of @ref OPA_OPTODIG */
N
N uint32_t OPA_OPTOIO;	/*!< Selects The output to PA0 of the OPA.
N                                          This parameter can be a value of @ref OPA_OPTOIO */
N
N}OPA_InitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N   
N/** @defgroup OPA_Exported_Constants
N  * @{
N  */ 
N
N 
N/**
N  * @}
N  */ 
N
N/** @defgroup OPA_OP0PSel
N  * @{
N  */
N
N#define	OPA_VIP_SEL_PA1			((uint32_t)0x00000000)
N#define	OPA_VIP_SEL_GND			((uint32_t)0x00008000)
N#define 	IS_OPA_VIP_SEL(INPUT) 	(((INPUT) == OPA_VIP_SEL_PA1) || \
N                                       		 ((INPUT) == OPA_VIP_SEL_GND))
X#define 	IS_OPA_VIP_SEL(INPUT) 	(((INPUT) == OPA_VIP_SEL_PA1) ||                                        		 ((INPUT) == OPA_VIP_SEL_GND))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup OPA_OP0NSel
N  * @{
N  */
N#define	OPA_VIN_SEL_GND		((uint32_t)0x00000000)
N#define	OPA_VIN_SEL_PA2		((uint32_t)0x00002000)
N#define	OPA_VIN_SEL_R4K_PA2		((uint32_t)0x00004000)
N#define	OPA_VIN_SEL_R4K_GND		((uint32_t)0x00006000)
N#define IS_OPA_VIN_SEL(INPUT) 	(((INPUT) == OPA_VIN_SEL_GND) || \
N                                        ((INPUT) == OPA_VIN_SEL_PA2) 	|| \
N                                        ((INPUT) == OPA_VIN_SEL_R4K_PA2) 	|| \
N                                        ((INPUT) == OPA_VIN_SEL_R4K_GND) )	
X#define IS_OPA_VIN_SEL(INPUT) 	(((INPUT) == OPA_VIN_SEL_GND) ||                                         ((INPUT) == OPA_VIN_SEL_PA2) 	||                                         ((INPUT) == OPA_VIN_SEL_R4K_PA2) 	||                                         ((INPUT) == OPA_VIN_SEL_R4K_GND) )	
N
N/**
N  * @}
N  */ 
N
N/** @defgroup OPA_OP0FR
N  * @{
N  */
N
N#define	OPA_FR_SEL_NORES		((uint32_t)0x00000000)
N#define	OPA_FR_SEL_40K		((uint32_t)0x00001000)
N#define	OPA_FR_SEL_80K		((uint32_t)0x00001400)
N#define	OPA_FR_SEL_160K		((uint32_t)0x00001800)
N#define	OPA_FR_SEL_320K		((uint32_t)0x00001C00)
N#define 	IS_OPA_FR_SEL(INPUT) 	(((INPUT) == OPA_FR_SEL_NORES) || \
N				((INPUT) == OPA_FR_SEL_40K) || \
N				((INPUT) == OPA_FR_SEL_80K) || \
N				((INPUT) == OPA_FR_SEL_160K) || \
N                                       		 ((INPUT) == OPA_FR_SEL_320K))
X#define 	IS_OPA_FR_SEL(INPUT) 	(((INPUT) == OPA_FR_SEL_NORES) || 				((INPUT) == OPA_FR_SEL_40K) || 				((INPUT) == OPA_FR_SEL_80K) || 				((INPUT) == OPA_FR_SEL_160K) ||                                        		 ((INPUT) == OPA_FR_SEL_320K))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup OPA_OP0FCAPE
N  * @{
N  */
N
N#define	OPA_FCAP_SEL_EN			((uint32_t)0x00000000)
N#define	OPA_FCAP_SEL_DIS			((uint32_t)0x00000200)
N#define 	IS_OPA_FCAP_SEL(INPUT) 	(((INPUT) == OPA_FCAP_SEL_EN) || \
N                                       		 ((INPUT) == OPA_FCAP_SEL_DIS))
X#define 	IS_OPA_FCAP_SEL(INPUT) 	(((INPUT) == OPA_FCAP_SEL_EN) ||                                        		 ((INPUT) == OPA_FCAP_SEL_DIS))
N
N
N/**
N  * @}
N  */ 
N
N/** @defgroup OPA_OPTODIG
N  * @{
N  */
N
N#define	OPA_ODIG_SEL_DIS			((uint32_t)0x00000000)
N#define	OPA_ODIG_SEL_EN			((uint32_t)0x00000080)
N#define 	IS_OPA_ODIG_SEL(INPUT) 	(((INPUT) == OPA_ODIG_SEL_DIS) || \
N                                       		 ((INPUT) == OPA_ODIG_SEL_EN))
X#define 	IS_OPA_ODIG_SEL(INPUT) 	(((INPUT) == OPA_ODIG_SEL_DIS) ||                                        		 ((INPUT) == OPA_ODIG_SEL_EN))
N
N
N/**
N  * @}
N  */ 
N
N/** @defgroup OPA_OPTOIO
N  * @{
N  */
N
N#define	OPA_OIO_SEL_DIS			((uint32_t)0x00000000)
N#define	OPA_OIO_SEL_EN			((uint32_t)0x00000040)
N#define 	IS_OPA_OIO_SEL(INPUT) 	(((INPUT) == OPA_OIO_SEL_DIS) || \
N                                       		 ((INPUT) == OPA_OIO_SEL_EN))
X#define 	IS_OPA_OIO_SEL(INPUT) 	(((INPUT) == OPA_OIO_SEL_DIS) ||                                        		 ((INPUT) == OPA_OIO_SEL_EN))
N
N
N
N
N
N#define OPA_OutputLevel_High                   ((uint32_t)0x00010000)
N#define OPA_OutputLevel_Low                    ((uint32_t)0x00000000)
N
N
N#define	IS_OPA_OUTPUT_LEVEL(LEVEL)			(((LEVEL) == OPA_OutputLevel_High) || \
N							((LEVEL) == OPA_OutputLevel_Low))
X#define	IS_OPA_OUTPUT_LEVEL(LEVEL)			(((LEVEL) == OPA_OutputLevel_High) || 							((LEVEL) == OPA_OutputLevel_Low))
N
N
N
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
N/*  Function used to set the OPA configuration to the default reset state ****/
Nvoid OPA_DeInit(void);
N
N/* Initialization and Configuration functions *********************************/
Nvoid OPA_Init(OPA_InitTypeDef* OPA_InitStruct);
Nvoid OPA_StructInit(OPA_InitTypeDef* OPA_InitStruct);
Nvoid OPA_Cmd(FunctionalState NewState);
Nuint32_t OPA_GetOutputLevel(uint32_t OPA_Selection);
Nuint8_t OPA_Cali(void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__FT32F0XX_OPA_H */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT FMD *****END OF FILE****/
L 43 "..\user\main.h" 2
N#include "ft32f0xx_pwr.h"
L 1 "..\FTLib\Inc\ft32f0xx_pwr.h" 1
N/**
N  ******************************************************************************
N  * @file    			ft32f0xx_pwr.h
N  * @author  			FMD AE
N  * @brief   			This file contains all the functions prototypes for the PWR firmware 
N  *          			library.
N  * @version 			V1.0.0           
N  * @data		 			2021-07-01
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __FT32F0XX_PWR_H
N#define __FT32F0XX_PWR_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "ft32f0xx.h"
N
N
N
N/** @addtogroup PWR
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup PWR_Exported_Constants
N  * @{
N  */ 
N
N/** @defgroup PWR_PVD_detection_level 
N  * @brief    
N  * @{
N  */ 
N
N#define PWR_PVDLevel_0                  PWR_CR_PLS_LEV0
N#define PWR_PVDLevel_1                  PWR_CR_PLS_LEV1
N#define PWR_PVDLevel_2                  PWR_CR_PLS_LEV2
N#define PWR_PVDLevel_3                  PWR_CR_PLS_LEV3
N#define PWR_PVDLevel_4                  PWR_CR_PLS_LEV4
N#define PWR_PVDLevel_5                  PWR_CR_PLS_LEV5
N#define PWR_PVDLevel_6                  PWR_CR_PLS_LEV6
N#define PWR_PVDLevel_7                  PWR_CR_PLS_LEV7 
N#define PWR_PVDLevel_8                  PWR_CR_PLS_LEV8 
N#define PWR_PVDLevel_9                  PWR_CR_PLS_LEV9 
N#define PWR_PVDLevel_10                 PWR_CR_PLS_LEV10
N#define PWR_PVDLevel_11                 PWR_CR_PLS_LEV11
N#define PWR_PVDLevel_12                 PWR_CR_PLS_LEV12
N#define PWR_PVDLevel_13                 PWR_CR_PLS_LEV13
N#define PWR_PVDLevel_14                 PWR_CR_PLS_LEV14
N#define PWR_PVDLevel_15                 PWR_CR_PLS_LEV15 
N
N#define IS_PWR_PVD_LEVEL(LEVEL) (((LEVEL) == PWR_PVDLevel_0) || ((LEVEL) == PWR_PVDLevel_1)|| \
N                                 ((LEVEL) == PWR_PVDLevel_2) || ((LEVEL) == PWR_PVDLevel_3)|| \
N                                 ((LEVEL) == PWR_PVDLevel_4) || ((LEVEL) == PWR_PVDLevel_5)|| \
N                                 ((LEVEL) == PWR_PVDLevel_6) || ((LEVEL) == PWR_PVDLevel_7)|| \
N								 ((LEVEL) == PWR_PVDLevel_8) || ((LEVEL) == PWR_PVDLevel_9)|| \
N                                 ((LEVEL) == PWR_PVDLevel_10) || ((LEVEL) == PWR_PVDLevel_11)|| \
N                                 ((LEVEL) == PWR_PVDLevel_12) || ((LEVEL) == PWR_PVDLevel_13)|| \
N                                 ((LEVEL) == PWR_PVDLevel_14) || ((LEVEL) == PWR_PVDLevel_15))
X#define IS_PWR_PVD_LEVEL(LEVEL) (((LEVEL) == PWR_PVDLevel_0) || ((LEVEL) == PWR_PVDLevel_1)||                                  ((LEVEL) == PWR_PVDLevel_2) || ((LEVEL) == PWR_PVDLevel_3)||                                  ((LEVEL) == PWR_PVDLevel_4) || ((LEVEL) == PWR_PVDLevel_5)||                                  ((LEVEL) == PWR_PVDLevel_6) || ((LEVEL) == PWR_PVDLevel_7)|| 								 ((LEVEL) == PWR_PVDLevel_8) || ((LEVEL) == PWR_PVDLevel_9)||                                  ((LEVEL) == PWR_PVDLevel_10) || ((LEVEL) == PWR_PVDLevel_11)||                                  ((LEVEL) == PWR_PVDLevel_12) || ((LEVEL) == PWR_PVDLevel_13)||                                  ((LEVEL) == PWR_PVDLevel_14) || ((LEVEL) == PWR_PVDLevel_15))
N/**
N  * @}
N  */
N
N/** @defgroup PWR_WakeUp_Pins 
N  * @{
N  */
N
N#define PWR_WakeUpPin_1                 PWR_CSR_EWUP1
N#define PWR_WakeUpPin_2                 PWR_CSR_EWUP2
N#define PWR_WakeUpPin_3                 PWR_CSR_EWUP3 
N#define PWR_WakeUpPin_4                 PWR_CSR_EWUP4 
N#define PWR_WakeUpPin_5                 PWR_CSR_EWUP5 
N#define PWR_WakeUpPin_6                 PWR_CSR_EWUP6 
N#define PWR_WakeUpPin_7                 PWR_CSR_EWUP7 
N#define PWR_WakeUpPin_8                 PWR_CSR_EWUP8
N#define IS_PWR_WAKEUP_PIN(PIN) (((PIN) == PWR_WakeUpPin_1) || ((PIN) == PWR_WakeUpPin_2) || \
N                                ((PIN) == PWR_WakeUpPin_3) || ((PIN) == PWR_WakeUpPin_4) || \
N                                ((PIN) == PWR_WakeUpPin_5) || ((PIN) == PWR_WakeUpPin_6) || \
N                                ((PIN) == PWR_WakeUpPin_7) || ((PIN) == PWR_WakeUpPin_8))
X#define IS_PWR_WAKEUP_PIN(PIN) (((PIN) == PWR_WakeUpPin_1) || ((PIN) == PWR_WakeUpPin_2) ||                                 ((PIN) == PWR_WakeUpPin_3) || ((PIN) == PWR_WakeUpPin_4) ||                                 ((PIN) == PWR_WakeUpPin_5) || ((PIN) == PWR_WakeUpPin_6) ||                                 ((PIN) == PWR_WakeUpPin_7) || ((PIN) == PWR_WakeUpPin_8))
N/**
N  * @}
N  */
N
N 
N/** @defgroup PWR_Regulator_state_is_Sleep_STOP_mode 
N  * @{
N  */
N
N#define PWR_Regulator_ON                ((uint32_t)0x00000000)
N#define PWR_Regulator_LowPower          PWR_CR_LPSDSR
N#define IS_PWR_REGULATOR(REGULATOR) (((REGULATOR) == PWR_Regulator_ON) || \
N                                     ((REGULATOR) == PWR_Regulator_LowPower))
X#define IS_PWR_REGULATOR(REGULATOR) (((REGULATOR) == PWR_Regulator_ON) ||                                      ((REGULATOR) == PWR_Regulator_LowPower))
N/**
N  * @}
N  */
N
N/** @defgroup PWR_SLEEP_mode_entry 
N  * @{
N  */
N
N#define PWR_SLEEPEntry_WFI              ((uint8_t)0x01)
N#define PWR_SLEEPEntry_WFE              ((uint8_t)0x02)
N#define IS_PWR_SLEEP_ENTRY(ENTRY) (((ENTRY) == PWR_SLEEPEntry_WFI) || ((ENTRY) == PWR_SLEEPEntry_WFE))
N 
N/**
N  * @}
N  */
N
N/** @defgroup PWR_STOP_mode_entry 
N  * @{
N  */
N
N#define PWR_STOPEntry_WFI               ((uint8_t)0x01)
N#define PWR_STOPEntry_WFE               ((uint8_t)0x02)
N#define PWR_STOPEntry_SLEEPONEXIT       ((uint8_t)0x03)
N#define IS_PWR_STOP_ENTRY(ENTRY) (((ENTRY) == PWR_STOPEntry_WFI) || ((ENTRY) == PWR_STOPEntry_WFE) ||\
N                                  ((ENTRY) == PWR_STOPEntry_SLEEPONEXIT))
X#define IS_PWR_STOP_ENTRY(ENTRY) (((ENTRY) == PWR_STOPEntry_WFI) || ((ENTRY) == PWR_STOPEntry_WFE) ||                                  ((ENTRY) == PWR_STOPEntry_SLEEPONEXIT))
N 
N/**
N  * @}
N  */
N
N/** @defgroup PWR_Flag 
N  * @{
N  */
N
N#define PWR_FLAG_WU                     PWR_CSR_WUF
N#define PWR_FLAG_SB                     PWR_CSR_SBF
N#define PWR_FLAG_PVDO                   PWR_CSR_PVDO
N#define PWR_FLAG_VREFINTRDY             PWR_CSR_VREFINTRDYF 
N
N#define IS_PWR_GET_FLAG(FLAG) (((FLAG) == PWR_FLAG_WU) || ((FLAG) == PWR_FLAG_SB) || \
N                               ((FLAG) == PWR_FLAG_PVDO) || ((FLAG) == PWR_FLAG_VREFINTRDY))
X#define IS_PWR_GET_FLAG(FLAG) (((FLAG) == PWR_FLAG_WU) || ((FLAG) == PWR_FLAG_SB) ||                                ((FLAG) == PWR_FLAG_PVDO) || ((FLAG) == PWR_FLAG_VREFINTRDY))
N
N#define IS_PWR_CLEAR_FLAG(FLAG) (((FLAG) == PWR_FLAG_WU) || ((FLAG) == PWR_FLAG_SB))
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
N/* Function used to set the PWR configuration to the default reset state ******/
Nvoid PWR_DeInit(void);
N
N/* Backup Domain Access function **********************************************/
Nvoid PWR_BackupAccessCmd(FunctionalState NewState);
N
N/* PVD configuration functions ************************************************/
Nvoid PWR_PVDLevelConfig(uint32_t PWR_PVDLevel); 
Nvoid PWR_PVDCmd(FunctionalState NewState); 
N
N/* WakeUp pins configuration functions ****************************************/
Nvoid PWR_WakeUpPinCmd(uint32_t PWR_WakeUpPin, FunctionalState NewState);
N
N/* Low Power modes configuration functions ************************************/
Nvoid PWR_EnterSleepMode(uint8_t PWR_SLEEPEntry);
Nvoid PWR_EnterSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry);
Nvoid PWR_EnterSTANDBYMode(void);
N
N/* Flags management functions *************************************************/
NFlagStatus PWR_GetFlagStatus(uint32_t PWR_FLAG);
Nvoid PWR_ClearFlag(uint32_t PWR_FLAG);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __FT32F0XX_PWR_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT FMD *****END OF FILE****/
L 44 "..\user\main.h" 2
N#include "ft32f0xx_rcc.h"
L 1 "..\FTLib\Inc\ft32f0xx_rcc.h" 1
N/**
N  ******************************************************************************
N  * @file    			ft32f0xx_rcc.h
N  * @author  			FMD AE
N  * @brief   			This file contains all the functions prototypes for the RCC 
N  *          			firmware library.
N  * @version 			V1.0.0           
N  * @data		 			2021-07-01
N  ******************************************************************************
N  */
N
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __FT32F0XX_RCC_H
N#define __FT32F0XX_RCC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "ft32f0xx.h"
N
N
N/** @addtogroup RCC
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
Ntypedef struct
N{
N  uint32_t SYSCLK_Frequency;
N  uint32_t HCLK_Frequency;
N  uint32_t PCLK_Frequency;
N  uint32_t ADCCLK_Frequency;
N  uint32_t CECCLK_Frequency;
N  uint32_t I2C1CLK_Frequency;
N  uint32_t USART1CLK_Frequency;
N  uint32_t USART2CLK_Frequency; 
N  uint32_t USART3CLK_Frequency; 
N  uint32_t USBCLK_Frequency;  
N}RCC_ClocksTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup RCC_Exported_Constants
N  * @{
N  */
N
N/** @defgroup RCC_HSE_configuration 
N  * @{
N  */
N
N#define RCC_HSE_OFF                      ((uint8_t)0x00)
N#define RCC_HSE_ON                       ((uint8_t)0x01)
N#define RCC_HSE_Bypass                   ((uint8_t)0x05)
N#define IS_RCC_HSE(HSE) (((HSE) == RCC_HSE_OFF) || ((HSE) == RCC_HSE_ON) || \
N                         ((HSE) == RCC_HSE_Bypass))
X#define IS_RCC_HSE(HSE) (((HSE) == RCC_HSE_OFF) || ((HSE) == RCC_HSE_ON) ||                          ((HSE) == RCC_HSE_Bypass))
N
N/**
N  * @}
N  */ 
N 
N/** @defgroup RCC_PLL_Clock_Source 
N  * @{
N  */
N
N#define RCC_PLLSource_HSI_Div2           RCC_CFGR_PLLSRC_HSI_Div2
N#define RCC_PLLSource_PREDIV1            RCC_CFGR_PLLSRC_HSE_PREDIV /* Old HSEPREDIV1 bit definition, maintained for legacy purpose */
N#define RCC_PLLSource_HSE                RCC_CFGR_PLLSRC_HSE_PREDIV 
N#define RCC_PLLSource_HSI48              RCC_CFGR_PLLSRC_HSI48_PREDIV 
N#define RCC_PLLSource_HSI                RCC_CFGR_PLLSRC_HSI_PREDIV
N
N#define IS_RCC_PLL_SOURCE(SOURCE) (((SOURCE) == RCC_PLLSource_HSI_Div2) || \
N                                   ((SOURCE) == RCC_PLLSource_HSI48)    || \
N                                   ((SOURCE) == RCC_PLLSource_HSI)      || \
N                                   ((SOURCE) == RCC_PLLSource_HSE)      || \
N                                   ((SOURCE) == RCC_PLLSource_PREDIV1))
X#define IS_RCC_PLL_SOURCE(SOURCE) (((SOURCE) == RCC_PLLSource_HSI_Div2) ||                                    ((SOURCE) == RCC_PLLSource_HSI48)    ||                                    ((SOURCE) == RCC_PLLSource_HSI)      ||                                    ((SOURCE) == RCC_PLLSource_HSE)      ||                                    ((SOURCE) == RCC_PLLSource_PREDIV1))
N/**
N  * @}
N  */ 
N
N/** @defgroup RCC_PLL_Multiplication_Factor 
N  * @{
N  */
N
N#define RCC_PLLMul_2                    RCC_CFGR_PLLMULL2
N#define RCC_PLLMul_3                    RCC_CFGR_PLLMULL3
N#define RCC_PLLMul_4                    RCC_CFGR_PLLMULL4
N#define RCC_PLLMul_5                    RCC_CFGR_PLLMULL5
N#define RCC_PLLMul_6                    RCC_CFGR_PLLMULL6
N#define RCC_PLLMul_7                    RCC_CFGR_PLLMULL7
N#define RCC_PLLMul_8                    RCC_CFGR_PLLMULL8
N#define RCC_PLLMul_9                    RCC_CFGR_PLLMULL9
N#define RCC_PLLMul_10                   RCC_CFGR_PLLMULL10
N#define RCC_PLLMul_11                   RCC_CFGR_PLLMULL11
N#define RCC_PLLMul_12                   RCC_CFGR_PLLMULL12
N#define RCC_PLLMul_13                   RCC_CFGR_PLLMULL13
N#define RCC_PLLMul_14                   RCC_CFGR_PLLMULL14
N#define RCC_PLLMul_15                   RCC_CFGR_PLLMULL15
N#define RCC_PLLMul_16                   RCC_CFGR_PLLMULL16
N#define IS_RCC_PLL_MUL(MUL) (((MUL) == RCC_PLLMul_2) || ((MUL) == RCC_PLLMul_3)   || \
N                             ((MUL) == RCC_PLLMul_4) || ((MUL) == RCC_PLLMul_5)   || \
N                             ((MUL) == RCC_PLLMul_6) || ((MUL) == RCC_PLLMul_7)   || \
N                             ((MUL) == RCC_PLLMul_8) || ((MUL) == RCC_PLLMul_9)   || \
N                             ((MUL) == RCC_PLLMul_10) || ((MUL) == RCC_PLLMul_11) || \
N                             ((MUL) == RCC_PLLMul_12) || ((MUL) == RCC_PLLMul_13) || \
N                             ((MUL) == RCC_PLLMul_14) || ((MUL) == RCC_PLLMul_15) || \
N                             ((MUL) == RCC_PLLMul_16))
X#define IS_RCC_PLL_MUL(MUL) (((MUL) == RCC_PLLMul_2) || ((MUL) == RCC_PLLMul_3)   ||                              ((MUL) == RCC_PLLMul_4) || ((MUL) == RCC_PLLMul_5)   ||                              ((MUL) == RCC_PLLMul_6) || ((MUL) == RCC_PLLMul_7)   ||                              ((MUL) == RCC_PLLMul_8) || ((MUL) == RCC_PLLMul_9)   ||                              ((MUL) == RCC_PLLMul_10) || ((MUL) == RCC_PLLMul_11) ||                              ((MUL) == RCC_PLLMul_12) || ((MUL) == RCC_PLLMul_13) ||                              ((MUL) == RCC_PLLMul_14) || ((MUL) == RCC_PLLMul_15) ||                              ((MUL) == RCC_PLLMul_16))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_PREDIV1_division_factor
N  * @{
N  */
N#define  RCC_PREDIV1_Div1               RCC_CFGR2_PREDIV1_DIV1
N#define  RCC_PREDIV1_Div2               RCC_CFGR2_PREDIV1_DIV2
N#define  RCC_PREDIV1_Div3               RCC_CFGR2_PREDIV1_DIV3
N#define  RCC_PREDIV1_Div4               RCC_CFGR2_PREDIV1_DIV4
N#define  RCC_PREDIV1_Div5               RCC_CFGR2_PREDIV1_DIV5
N#define  RCC_PREDIV1_Div6               RCC_CFGR2_PREDIV1_DIV6
N#define  RCC_PREDIV1_Div7               RCC_CFGR2_PREDIV1_DIV7
N#define  RCC_PREDIV1_Div8               RCC_CFGR2_PREDIV1_DIV8
N#define  RCC_PREDIV1_Div9               RCC_CFGR2_PREDIV1_DIV9
N#define  RCC_PREDIV1_Div10              RCC_CFGR2_PREDIV1_DIV10
N#define  RCC_PREDIV1_Div11              RCC_CFGR2_PREDIV1_DIV11
N#define  RCC_PREDIV1_Div12              RCC_CFGR2_PREDIV1_DIV12
N#define  RCC_PREDIV1_Div13              RCC_CFGR2_PREDIV1_DIV13
N#define  RCC_PREDIV1_Div14              RCC_CFGR2_PREDIV1_DIV14
N#define  RCC_PREDIV1_Div15              RCC_CFGR2_PREDIV1_DIV15
N#define  RCC_PREDIV1_Div16              RCC_CFGR2_PREDIV1_DIV16
N
N#define IS_RCC_PREDIV1(PREDIV1) (((PREDIV1) == RCC_PREDIV1_Div1) || ((PREDIV1) == RCC_PREDIV1_Div2) || \
N                                 ((PREDIV1) == RCC_PREDIV1_Div3) || ((PREDIV1) == RCC_PREDIV1_Div4) || \
N                                 ((PREDIV1) == RCC_PREDIV1_Div5) || ((PREDIV1) == RCC_PREDIV1_Div6) || \
N                                 ((PREDIV1) == RCC_PREDIV1_Div7) || ((PREDIV1) == RCC_PREDIV1_Div8) || \
N                                 ((PREDIV1) == RCC_PREDIV1_Div9) || ((PREDIV1) == RCC_PREDIV1_Div10) || \
N                                 ((PREDIV1) == RCC_PREDIV1_Div11) || ((PREDIV1) == RCC_PREDIV1_Div12) || \
N                                 ((PREDIV1) == RCC_PREDIV1_Div13) || ((PREDIV1) == RCC_PREDIV1_Div14) || \
N                                 ((PREDIV1) == RCC_PREDIV1_Div15) || ((PREDIV1) == RCC_PREDIV1_Div16))
X#define IS_RCC_PREDIV1(PREDIV1) (((PREDIV1) == RCC_PREDIV1_Div1) || ((PREDIV1) == RCC_PREDIV1_Div2) ||                                  ((PREDIV1) == RCC_PREDIV1_Div3) || ((PREDIV1) == RCC_PREDIV1_Div4) ||                                  ((PREDIV1) == RCC_PREDIV1_Div5) || ((PREDIV1) == RCC_PREDIV1_Div6) ||                                  ((PREDIV1) == RCC_PREDIV1_Div7) || ((PREDIV1) == RCC_PREDIV1_Div8) ||                                  ((PREDIV1) == RCC_PREDIV1_Div9) || ((PREDIV1) == RCC_PREDIV1_Div10) ||                                  ((PREDIV1) == RCC_PREDIV1_Div11) || ((PREDIV1) == RCC_PREDIV1_Div12) ||                                  ((PREDIV1) == RCC_PREDIV1_Div13) || ((PREDIV1) == RCC_PREDIV1_Div14) ||                                  ((PREDIV1) == RCC_PREDIV1_Div15) || ((PREDIV1) == RCC_PREDIV1_Div16))
N/**
N  * @}
N  */
N 
N/** @defgroup RCC_System_Clock_Source 
N  * @{
N  */
N
N#define RCC_SYSCLKSource_HSI             RCC_CFGR_SW_HSI
N#define RCC_SYSCLKSource_HSE             RCC_CFGR_SW_HSE
N#define RCC_SYSCLKSource_PLLCLK          RCC_CFGR_SW_PLL
N#define RCC_SYSCLKSource_HSI48           RCC_CFGR_SW_HSI48 
N
N#define IS_RCC_SYSCLK_SOURCE(SOURCE) (((SOURCE) == RCC_SYSCLKSource_HSI)   || \
N                                      ((SOURCE) == RCC_SYSCLKSource_HSE)   || \
N                                      ((SOURCE) == RCC_SYSCLKSource_HSI48) || \
N                                      ((SOURCE) == RCC_SYSCLKSource_PLLCLK))
X#define IS_RCC_SYSCLK_SOURCE(SOURCE) (((SOURCE) == RCC_SYSCLKSource_HSI)   ||                                       ((SOURCE) == RCC_SYSCLKSource_HSE)   ||                                       ((SOURCE) == RCC_SYSCLKSource_HSI48) ||                                       ((SOURCE) == RCC_SYSCLKSource_PLLCLK))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_AHB_Clock_Source
N  * @{
N  */
N
N#define RCC_SYSCLK_Div1                  RCC_CFGR_HPRE_DIV1
N#define RCC_SYSCLK_Div2                  RCC_CFGR_HPRE_DIV2
N#define RCC_SYSCLK_Div4                  RCC_CFGR_HPRE_DIV4
N#define RCC_SYSCLK_Div8                  RCC_CFGR_HPRE_DIV8
N#define RCC_SYSCLK_Div16                 RCC_CFGR_HPRE_DIV16
N#define RCC_SYSCLK_Div64                 RCC_CFGR_HPRE_DIV64
N#define RCC_SYSCLK_Div128                RCC_CFGR_HPRE_DIV128
N#define RCC_SYSCLK_Div256                RCC_CFGR_HPRE_DIV256
N#define RCC_SYSCLK_Div512                RCC_CFGR_HPRE_DIV512
N#define IS_RCC_HCLK(HCLK) (((HCLK) == RCC_SYSCLK_Div1) || ((HCLK) == RCC_SYSCLK_Div2) || \
N                           ((HCLK) == RCC_SYSCLK_Div4) || ((HCLK) == RCC_SYSCLK_Div8) || \
N                           ((HCLK) == RCC_SYSCLK_Div16) || ((HCLK) == RCC_SYSCLK_Div64) || \
N                           ((HCLK) == RCC_SYSCLK_Div128) || ((HCLK) == RCC_SYSCLK_Div256) || \
N                           ((HCLK) == RCC_SYSCLK_Div512))
X#define IS_RCC_HCLK(HCLK) (((HCLK) == RCC_SYSCLK_Div1) || ((HCLK) == RCC_SYSCLK_Div2) ||                            ((HCLK) == RCC_SYSCLK_Div4) || ((HCLK) == RCC_SYSCLK_Div8) ||                            ((HCLK) == RCC_SYSCLK_Div16) || ((HCLK) == RCC_SYSCLK_Div64) ||                            ((HCLK) == RCC_SYSCLK_Div128) || ((HCLK) == RCC_SYSCLK_Div256) ||                            ((HCLK) == RCC_SYSCLK_Div512))
N/**
N  * @}
N  */ 
N
N/** @defgroup RCC_APB_Clock_Source
N  * @{
N  */
N
N#define RCC_HCLK_Div1                    RCC_CFGR_PPRE_DIV1
N#define RCC_HCLK_Div2                    RCC_CFGR_PPRE_DIV2
N#define RCC_HCLK_Div4                    RCC_CFGR_PPRE_DIV4
N#define RCC_HCLK_Div8                    RCC_CFGR_PPRE_DIV8
N#define RCC_HCLK_Div16                   RCC_CFGR_PPRE_DIV16
N#define IS_RCC_PCLK(PCLK) (((PCLK) == RCC_HCLK_Div1) || ((PCLK) == RCC_HCLK_Div2) || \
N                           ((PCLK) == RCC_HCLK_Div4) || ((PCLK) == RCC_HCLK_Div8) || \
N                           ((PCLK) == RCC_HCLK_Div16))
X#define IS_RCC_PCLK(PCLK) (((PCLK) == RCC_HCLK_Div1) || ((PCLK) == RCC_HCLK_Div2) ||                            ((PCLK) == RCC_HCLK_Div4) || ((PCLK) == RCC_HCLK_Div8) ||                            ((PCLK) == RCC_HCLK_Div16))
N/**
N  * @}
N  */
N  
N/** @defgroup RCC_ADC_clock_source 
N  * @{
N  */
N/* These defines are obsolete and kept for legacy purpose only.
NProper ADC clock selection is done within ADC driver by mean of the ADC_ClockModeConfig() function */
N#define RCC_ADCCLK_HSI14                 ((uint32_t)0x00000000)
N#define RCC_ADCCLK_PCLK_Div2             ((uint32_t)0x01000000)
N#define RCC_ADCCLK_PCLK_Div4             ((uint32_t)0x01004000)
N
N#define IS_RCC_ADCCLK(ADCCLK) (((ADCCLK) == RCC_ADCCLK_HSI14) || ((ADCCLK) == RCC_ADCCLK_PCLK_Div2) || \
N                               ((ADCCLK) == RCC_ADCCLK_PCLK_Div4))
X#define IS_RCC_ADCCLK(ADCCLK) (((ADCCLK) == RCC_ADCCLK_HSI14) || ((ADCCLK) == RCC_ADCCLK_PCLK_Div2) ||                                ((ADCCLK) == RCC_ADCCLK_PCLK_Div4))
N
N/**
N  * @}
N  */
N
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_I2C_clock_source 
N  * @{
N  */
N
N#define RCC_I2C1CLK_HSI                   ((uint32_t)0x00000000)
N#define RCC_I2C1CLK_SYSCLK                RCC_CFGR3_I2C1SW
N
N#define IS_RCC_I2CCLK(I2CCLK) (((I2CCLK) == RCC_I2C1CLK_HSI) || ((I2CCLK) == RCC_I2C1CLK_SYSCLK))
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_USB_clock_source
N  * @brief    
N  * @{
N  */
N
N#define RCC_USBCLK_HSI48                 ((uint32_t)0x00000000)
N#define RCC_USBCLK_PLLCLK                RCC_CFGR3_USBSW
N
N#define IS_RCC_USBCLK(USBCLK) (((USBCLK) == RCC_USBCLK_HSI48) || ((USBCLK) == RCC_USBCLK_PLLCLK))
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_USART_clock_source 
N  * @{
N  */
N
N#define RCC_USART1CLK_PCLK                  ((uint32_t)0x10000000)
N#define RCC_USART1CLK_SYSCLK                ((uint32_t)0x10000001)
N#define RCC_USART1CLK_LSE                   ((uint32_t)0x10000002)
N#define RCC_USART1CLK_HSI                   ((uint32_t)0x10000003)
N
N#define RCC_USART2CLK_PCLK                  ((uint32_t)0x20000000) 
N#define RCC_USART2CLK_SYSCLK                ((uint32_t)0x20010000) 
N#define RCC_USART2CLK_LSE                   ((uint32_t)0x20020000) 
N#define RCC_USART2CLK_HSI                   ((uint32_t)0x20030000) 
N
N#define RCC_USART3CLK_PCLK                  ((uint32_t)0x30000000)
N#define RCC_USART3CLK_SYSCLK                ((uint32_t)0x30040000) 
N#define RCC_USART3CLK_LSE                   ((uint32_t)0x30080000)
N#define RCC_USART3CLK_HSI                   ((uint32_t)0x300C0000)
N
N
N#define IS_RCC_USARTCLK(USARTCLK) (((USARTCLK) == RCC_USART1CLK_PCLK)   || \
N                                   ((USARTCLK) == RCC_USART1CLK_SYSCLK) || \
N                                   ((USARTCLK) == RCC_USART1CLK_LSE)    || \
N                                   ((USARTCLK) == RCC_USART1CLK_HSI)    || \
N                                   ((USARTCLK) == RCC_USART2CLK_PCLK)   || \
N                                   ((USARTCLK) == RCC_USART2CLK_SYSCLK) || \
N                                   ((USARTCLK) == RCC_USART2CLK_LSE)    || \
N                                   ((USARTCLK) == RCC_USART2CLK_HSI)|| \
N                                   ((USARTCLK) == RCC_USART3CLK_PCLK)   || \
N                                   ((USARTCLK) == RCC_USART3CLK_SYSCLK) || \
N                                   ((USARTCLK) == RCC_USART3CLK_LSE)    || \
N                                   ((USARTCLK) == RCC_USART3CLK_HSI))
X#define IS_RCC_USARTCLK(USARTCLK) (((USARTCLK) == RCC_USART1CLK_PCLK)   ||                                    ((USARTCLK) == RCC_USART1CLK_SYSCLK) ||                                    ((USARTCLK) == RCC_USART1CLK_LSE)    ||                                    ((USARTCLK) == RCC_USART1CLK_HSI)    ||                                    ((USARTCLK) == RCC_USART2CLK_PCLK)   ||                                    ((USARTCLK) == RCC_USART2CLK_SYSCLK) ||                                    ((USARTCLK) == RCC_USART2CLK_LSE)    ||                                    ((USARTCLK) == RCC_USART2CLK_HSI)||                                    ((USARTCLK) == RCC_USART3CLK_PCLK)   ||                                    ((USARTCLK) == RCC_USART3CLK_SYSCLK) ||                                    ((USARTCLK) == RCC_USART3CLK_LSE)    ||                                    ((USARTCLK) == RCC_USART3CLK_HSI))
N
N/**
N  * @}
N  */
N         
N/** @defgroup RCC_Interrupt_Source 
N  * @{
N  */
N
N#define RCC_IT_LSIRDY                    ((uint8_t)0x01)
N#define RCC_IT_LSERDY                    ((uint8_t)0x02)
N#define RCC_IT_HSIRDY                    ((uint8_t)0x04)
N#define RCC_IT_HSERDY                    ((uint8_t)0x08)
N#define RCC_IT_PLLRDY                    ((uint8_t)0x10)
N#define RCC_IT_HSI14RDY                  ((uint8_t)0x20)
N#define RCC_IT_HSI48RDY                  ((uint8_t)0x40)
N#define RCC_IT_CSS                       ((uint8_t)0x80)
N
N#define IS_RCC_IT(IT) ((((IT) & (uint8_t)0x80) == 0x00) && ((IT) != 0x00))
N
N#define IS_RCC_GET_IT(IT) (((IT) == RCC_IT_LSIRDY) || ((IT) == RCC_IT_LSERDY) || \
N                           ((IT) == RCC_IT_HSIRDY) || ((IT) == RCC_IT_HSERDY) || \
N                           ((IT) == RCC_IT_PLLRDY) || ((IT) == RCC_IT_HSI14RDY) || \
N                           ((IT) == RCC_IT_CSS)    || ((IT) == RCC_IT_HSI48RDY))
X#define IS_RCC_GET_IT(IT) (((IT) == RCC_IT_LSIRDY) || ((IT) == RCC_IT_LSERDY) ||                            ((IT) == RCC_IT_HSIRDY) || ((IT) == RCC_IT_HSERDY) ||                            ((IT) == RCC_IT_PLLRDY) || ((IT) == RCC_IT_HSI14RDY) ||                            ((IT) == RCC_IT_CSS)    || ((IT) == RCC_IT_HSI48RDY))
N
N#define IS_RCC_CLEAR_IT(IT) ((IT) != 0x00)
N
N/**
N  * @}
N  */
N  
N/** @defgroup RCC_LSE_Configuration 
N  * @{
N  */
N
N#define RCC_LSE_OFF                      ((uint32_t)0x00000000)
N#define RCC_LSE_ON                       RCC_BDCR_LSEON
N#define RCC_LSE_Bypass                   ((uint32_t)(RCC_BDCR_LSEON | RCC_BDCR_LSEBYP))
N#define IS_RCC_LSE(LSE) (((LSE) == RCC_LSE_OFF) || ((LSE) == RCC_LSE_ON) || \
N                         ((LSE) == RCC_LSE_Bypass))
X#define IS_RCC_LSE(LSE) (((LSE) == RCC_LSE_OFF) || ((LSE) == RCC_LSE_ON) ||                          ((LSE) == RCC_LSE_Bypass))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_RTC_Clock_Source
N  * @{
N  */
N
N#define RCC_RTCCLKSource_LSE             RCC_BDCR_RTCSEL_LSE
N#define RCC_RTCCLKSource_LSI             RCC_BDCR_RTCSEL_LSI
N#define RCC_RTCCLKSource_HSE_Div32       RCC_BDCR_RTCSEL_HSE
N
N#define IS_RCC_RTCCLK_SOURCE(SOURCE) (((SOURCE) == RCC_RTCCLKSource_LSE) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_LSI) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div32))
X#define IS_RCC_RTCCLK_SOURCE(SOURCE) (((SOURCE) == RCC_RTCCLKSource_LSE) ||                                       ((SOURCE) == RCC_RTCCLKSource_LSI) ||                                       ((SOURCE) == RCC_RTCCLKSource_HSE_Div32))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LSE_Drive_Configuration 
N  * @{
N  */
N
N#define RCC_LSEDrive_Low                 ((uint32_t)0x00000000)
N#define RCC_LSEDrive_MediumLow           RCC_BDCR_LSEDRV_0
N#define RCC_LSEDrive_MediumHigh          RCC_BDCR_LSEDRV_1
N#define RCC_LSEDrive_High                RCC_BDCR_LSEDRV
N#define IS_RCC_LSE_DRIVE(DRIVE) (((DRIVE) == RCC_LSEDrive_Low) || ((DRIVE) == RCC_LSEDrive_MediumLow) || \
N                                 ((DRIVE) == RCC_LSEDrive_MediumHigh) || ((DRIVE) == RCC_LSEDrive_High))
X#define IS_RCC_LSE_DRIVE(DRIVE) (((DRIVE) == RCC_LSEDrive_Low) || ((DRIVE) == RCC_LSEDrive_MediumLow) ||                                  ((DRIVE) == RCC_LSEDrive_MediumHigh) || ((DRIVE) == RCC_LSEDrive_High))
N/**
N  * @}
N  */
N  
N/** @defgroup RCC_AHB_Peripherals 
N  * @{
N  */
N
N#define RCC_AHBPeriph_GPIOA               RCC_AHBENR_GPIOAEN
N#define RCC_AHBPeriph_GPIOB               RCC_AHBENR_GPIOBEN
N#define RCC_AHBPeriph_GPIOC               RCC_AHBENR_GPIOCEN
N#define RCC_AHBPeriph_GPIOD               RCC_AHBENR_GPIODEN
N#define RCC_AHBPeriph_GPIOE               RCC_AHBENR_GPIOEEN
N#define RCC_AHBPeriph_GPIOF               RCC_AHBENR_GPIOFEN
N#define RCC_AHBPeriph_TS                  RCC_AHBENR_TSEN
N#define RCC_AHBPeriph_CRC                 RCC_AHBENR_CRCEN
N#define RCC_AHBPeriph_FLITF               RCC_AHBENR_FLITFEN
N#define RCC_AHBPeriph_SRAM                RCC_AHBENR_SRAMEN
N#define RCC_AHBPeriph_DMA1                RCC_AHBENR_DMA1EN
N#define RCC_AHBPeriph_DMA2                RCC_AHBENR_DMA2EN
N
N#define IS_RCC_AHB_PERIPH(PERIPH) ((((PERIPH) & 0xFE81FFA8) == 0x00) && ((PERIPH) != 0x00))
N#define IS_RCC_AHB_RST_PERIPH(PERIPH) ((((PERIPH) & 0xFE81FFA8) == 0x00) && ((PERIPH) != 0x00))
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_APB2_Peripherals 
N  * @{
N  */
N
N#define RCC_APB2Periph_SYSCFG            RCC_APB2ENR_SYSCFGEN
N#define RCC_APB2Periph_USART6            RCC_APB2ENR_USART6EN
N#define RCC_APB2Periph_USART7            RCC_APB2ENR_USART7EN
N#define RCC_APB2Periph_USART8            RCC_APB2ENR_USART8EN
N#define RCC_APB2Periph_ADC1              RCC_APB2ENR_ADC1EN
N#define RCC_APB2Periph_TIM1              RCC_APB2ENR_TIM1EN
N#define RCC_APB2Periph_SPI1              RCC_APB2ENR_SPI1EN
N#define RCC_APB2Periph_USART1            RCC_APB2ENR_USART1EN
N#define RCC_APB2Periph_TIM15             RCC_APB2ENR_TIM15EN
N#define RCC_APB2Periph_TIM16             RCC_APB2ENR_TIM16EN
N#define RCC_APB2Periph_TIM17             RCC_APB2ENR_TIM17EN
N#define RCC_APB2Periph_DBGMCU            RCC_APB2ENR_DBGMCUEN
N
N#define IS_RCC_APB2_PERIPH(PERIPH) ((((PERIPH) & 0xFFB8A51E) == 0x00) && ((PERIPH) != 0x00))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RCC_APB1_Peripherals 
N  * @{
N  */
N
N#define RCC_APB1Periph_TIM2              RCC_APB1ENR_TIM2EN   
N#define RCC_APB1Periph_TIM3              RCC_APB1ENR_TIM3EN
N#define RCC_APB1Periph_TIM6              RCC_APB1ENR_TIM6EN
N#define RCC_APB1Periph_TIM7              RCC_APB1ENR_TIM7EN   
N#define RCC_APB1Periph_TIM14             RCC_APB1ENR_TIM14EN
N#define RCC_APB1Periph_WWDG              RCC_APB1ENR_WWDGEN
N#define RCC_APB1Periph_SPI2              RCC_APB1ENR_SPI2EN
N#define RCC_APB1Periph_USART2            RCC_APB1ENR_USART2EN
N#define RCC_APB1Periph_USART3            RCC_APB1ENR_USART3EN  
N#define RCC_APB1Periph_USART4            RCC_APB1ENR_USART4EN 
N#define RCC_APB1Periph_USART5            RCC_APB1ENR_USART5EN 
N#define RCC_APB1Periph_I2C1              RCC_APB1ENR_I2C1EN
N#define RCC_APB1Periph_I2C2              RCC_APB1ENR_I2C2EN
N#define RCC_APB1Periph_USB               RCC_APB1ENR_USBEN    
N#define RCC_APB1Periph_CAN               RCC_APB1ENR_CANEN    
N#define RCC_APB1Periph_CRS               RCC_APB1ENR_CRSEN    
N#define RCC_APB1Periph_PWR               RCC_APB1ENR_PWREN
N#define RCC_APB1Periph_DAC               RCC_APB1ENR_DACEN     
N#define RCC_APB1Periph_CEC               RCC_APB1ENR_CECEN     
N
N#define IS_RCC_APB1_PERIPH(PERIPH) ((((PERIPH) & 0x8581B6CC) == 0x00) && ((PERIPH) != 0x00))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_MCO_Clock_Source
N  * @{
N  */
N
N#define RCC_MCOSource_NoClock            ((uint8_t)0x00)
N#define RCC_MCOSource_HSI14              ((uint8_t)0x01)
N#define RCC_MCOSource_LSI                ((uint8_t)0x02)
N#define RCC_MCOSource_LSE                ((uint8_t)0x03)
N#define RCC_MCOSource_SYSCLK             ((uint8_t)0x04)
N#define RCC_MCOSource_HSI                ((uint8_t)0x05)
N#define RCC_MCOSource_HSE                ((uint8_t)0x06)
N#define RCC_MCOSource_PLLCLK_Div2        ((uint8_t)0x07)
N#define RCC_MCOSource_HSI48              ((uint8_t)0x08)  
N#define RCC_MCOSource_PLLCLK             ((uint8_t)0x87)
N
N#define IS_RCC_MCO_SOURCE(SOURCE) (((SOURCE) == RCC_MCOSource_NoClock) || ((SOURCE) == RCC_MCOSource_HSI14)      || \
N                                   ((SOURCE) == RCC_MCOSource_SYSCLK)  || ((SOURCE) == RCC_MCOSource_HSI)        || \
N                                   ((SOURCE) == RCC_MCOSource_HSE)     || ((SOURCE) == RCC_MCOSource_PLLCLK_Div2)|| \
N                                   ((SOURCE) == RCC_MCOSource_LSI)     || ((SOURCE) == RCC_MCOSource_HSI48)      || \
N                                   ((SOURCE) == RCC_MCOSource_PLLCLK)  || ((SOURCE) == RCC_MCOSource_LSE))
X#define IS_RCC_MCO_SOURCE(SOURCE) (((SOURCE) == RCC_MCOSource_NoClock) || ((SOURCE) == RCC_MCOSource_HSI14)      ||                                    ((SOURCE) == RCC_MCOSource_SYSCLK)  || ((SOURCE) == RCC_MCOSource_HSI)        ||                                    ((SOURCE) == RCC_MCOSource_HSE)     || ((SOURCE) == RCC_MCOSource_PLLCLK_Div2)||                                    ((SOURCE) == RCC_MCOSource_LSI)     || ((SOURCE) == RCC_MCOSource_HSI48)      ||                                    ((SOURCE) == RCC_MCOSource_PLLCLK)  || ((SOURCE) == RCC_MCOSource_LSE))
N/**
N  * @}
N  */ 
N
N/** @defgroup RCC_MCOPrescaler
N  * @{
N  */
N#if !defined (FT32F051)
X#if !0L
N#define RCC_MCOPrescaler_1            RCC_CFGR_MCO_PRE_1
N#define RCC_MCOPrescaler_2            RCC_CFGR_MCO_PRE_2
N#define RCC_MCOPrescaler_4            RCC_CFGR_MCO_PRE_4
N#define RCC_MCOPrescaler_8            RCC_CFGR_MCO_PRE_8
N#define RCC_MCOPrescaler_16           RCC_CFGR_MCO_PRE_16
N#define RCC_MCOPrescaler_32           RCC_CFGR_MCO_PRE_32
N#define RCC_MCOPrescaler_64           RCC_CFGR_MCO_PRE_64
N#define RCC_MCOPrescaler_128          RCC_CFGR_MCO_PRE_128
N
N#define IS_RCC_MCO_PRESCALER(PRESCALER) (((PRESCALER) == RCC_MCOPrescaler_1)  || \
N                                         ((PRESCALER) == RCC_MCOPrescaler_2)  || \
N                                         ((PRESCALER) == RCC_MCOPrescaler_4)  || \
N                                         ((PRESCALER) == RCC_MCOPrescaler_8)  || \
N                                         ((PRESCALER) == RCC_MCOPrescaler_16) || \
N                                         ((PRESCALER) == RCC_MCOPrescaler_32) || \
N                                         ((PRESCALER) == RCC_MCOPrescaler_64) || \
N                                         ((PRESCALER) == RCC_MCOPrescaler_128))
X#define IS_RCC_MCO_PRESCALER(PRESCALER) (((PRESCALER) == RCC_MCOPrescaler_1)  ||                                          ((PRESCALER) == RCC_MCOPrescaler_2)  ||                                          ((PRESCALER) == RCC_MCOPrescaler_4)  ||                                          ((PRESCALER) == RCC_MCOPrescaler_8)  ||                                          ((PRESCALER) == RCC_MCOPrescaler_16) ||                                          ((PRESCALER) == RCC_MCOPrescaler_32) ||                                          ((PRESCALER) == RCC_MCOPrescaler_64) ||                                          ((PRESCALER) == RCC_MCOPrescaler_128))
N#endif /* FT32F051 */                                         
N/**
N  * @}
N  */ 
N
N/** @defgroup RCC_Flag 
N  * @{
N  */
N#define RCC_FLAG_HSIRDY                  ((uint8_t)0x01)
N#define RCC_FLAG_HSERDY                  ((uint8_t)0x11)
N#define RCC_FLAG_PLLRDY                  ((uint8_t)0x19)
N#define RCC_FLAG_LSERDY                  ((uint8_t)0x21)
N#define RCC_FLAG_LSIRDY                  ((uint8_t)0x41)
N#define RCC_FLAG_V18PWRRSTF              ((uint8_t)0x57)
N#define RCC_FLAG_OBLRST                  ((uint8_t)0x59)
N#define RCC_FLAG_PINRST                  ((uint8_t)0x5A)
N#define RCC_FLAG_PORRST                  ((uint8_t)0x5B)
N#define RCC_FLAG_SFTRST                  ((uint8_t)0x5C)
N#define RCC_FLAG_IWDGRST                 ((uint8_t)0x5D)
N#define RCC_FLAG_WWDGRST                 ((uint8_t)0x5E)
N#define RCC_FLAG_LPWRRST                 ((uint8_t)0x5F)
N#define RCC_FLAG_HSI14RDY                ((uint8_t)0x61)
N#define RCC_FLAG_HSI48RDY                ((uint8_t)0x71)
N
N#define IS_RCC_FLAG(FLAG) (((FLAG) == RCC_FLAG_HSIRDY)  || ((FLAG) == RCC_FLAG_HSERDY)  || \
N                           ((FLAG) == RCC_FLAG_PLLRDY)  || ((FLAG) == RCC_FLAG_LSERDY)  || \
N                           ((FLAG) == RCC_FLAG_LSIRDY)  || ((FLAG) == RCC_FLAG_OBLRST)  || \
N                           ((FLAG) == RCC_FLAG_PINRST)  || ((FLAG) == RCC_FLAG_PORRST)  || \
N                           ((FLAG) == RCC_FLAG_SFTRST)  || ((FLAG) == RCC_FLAG_IWDGRST) || \
N                           ((FLAG) == RCC_FLAG_WWDGRST) || ((FLAG) == RCC_FLAG_LPWRRST) || \
N                           ((FLAG) == RCC_FLAG_HSI14RDY)|| ((FLAG) == RCC_FLAG_HSI48RDY)|| \
N                           ((FLAG) == RCC_FLAG_V18PWRRSTF))
X#define IS_RCC_FLAG(FLAG) (((FLAG) == RCC_FLAG_HSIRDY)  || ((FLAG) == RCC_FLAG_HSERDY)  ||                            ((FLAG) == RCC_FLAG_PLLRDY)  || ((FLAG) == RCC_FLAG_LSERDY)  ||                            ((FLAG) == RCC_FLAG_LSIRDY)  || ((FLAG) == RCC_FLAG_OBLRST)  ||                            ((FLAG) == RCC_FLAG_PINRST)  || ((FLAG) == RCC_FLAG_PORRST)  ||                            ((FLAG) == RCC_FLAG_SFTRST)  || ((FLAG) == RCC_FLAG_IWDGRST) ||                            ((FLAG) == RCC_FLAG_WWDGRST) || ((FLAG) == RCC_FLAG_LPWRRST) ||                            ((FLAG) == RCC_FLAG_HSI14RDY)|| ((FLAG) == RCC_FLAG_HSI48RDY)||                            ((FLAG) == RCC_FLAG_V18PWRRSTF))
N
N#define IS_RCC_HSI_CALIBRATION_VALUE(VALUE) ((VALUE) <= 0x1F)
N#define IS_RCC_HSI14_CALIBRATION_VALUE(VALUE) ((VALUE) <= 0x1F)
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
N/* Function used to set the RCC clock configuration to the default reset state */
Nvoid RCC_DeInit(void);
N
N/* Internal/external clocks, PLL, CSS and MCO configuration functions *********/
Nvoid RCC_HSEConfig(uint8_t RCC_HSE);
NErrorStatus RCC_WaitForHSEStartUp(void);
Nvoid RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue);
Nvoid RCC_HSICmd(FunctionalState NewState);
Nvoid RCC_AdjustHSI14CalibrationValue(uint8_t HSI14CalibrationValue);
Nvoid RCC_HSI14Cmd(FunctionalState NewState);
Nvoid RCC_HSI14ADCRequestCmd(FunctionalState NewState);
Nvoid RCC_LSEConfig(uint32_t RCC_LSE);
Nvoid RCC_LSEDriveConfig(uint32_t RCC_LSEDrive);
Nvoid RCC_LSICmd(FunctionalState NewState);
Nvoid RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t RCC_PLLMul);
Nvoid RCC_PLLCmd(FunctionalState NewState);
Nvoid RCC_HSI48Cmd(FunctionalState NewState);
Nuint32_t RCC_GetHSI48CalibrationValue(void); 
Nvoid RCC_PREDIV1Config(uint32_t RCC_PREDIV1_Div);
Nvoid RCC_ClockSecuritySystemCmd(FunctionalState NewState);
N#ifdef FT32F051
Svoid RCC_MCOConfig(uint8_t RCC_MCOSource);
N#else
Nvoid RCC_MCOConfig(uint8_t RCC_MCOSource,uint32_t RCC_MCOPrescaler);
N#endif /* FT32F051 */
N
N/* System, AHB and APB busses clocks configuration functions ******************/
Nvoid RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource);
Nuint8_t RCC_GetSYSCLKSource(void);
Nvoid RCC_HCLKConfig(uint32_t RCC_SYSCLK);
Nvoid RCC_PCLKConfig(uint32_t RCC_HCLK);
Nvoid RCC_ADCCLKConfig(uint32_t RCC_ADCCLK); /* This function is obsolete.
N                                               For proper ADC clock selection, refer to
N                                               ADC_ClockModeConfig() in the ADC driver */
Nvoid RCC_CECCLKConfig(uint32_t RCC_CECCLK);
Nvoid RCC_I2CCLKConfig(uint32_t RCC_I2CCLK);
Nvoid RCC_USARTCLKConfig(uint32_t RCC_USARTCLK);
Nvoid RCC_USBCLKConfig(uint32_t RCC_USBCLK); 
Nvoid RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks);
N
N/* Peripheral clocks configuration functions **********************************/
Nvoid RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource);
Nvoid RCC_RTCCLKCmd(FunctionalState NewState);
Nvoid RCC_BackupResetCmd(FunctionalState NewState);
N
Nvoid RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState);
Nvoid RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState);
Nvoid RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState);
N
Nvoid RCC_AHBPeriphResetCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState);
Nvoid RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState);
Nvoid RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState);
N
N/* Interrupts and flags management functions **********************************/
Nvoid RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState);
NFlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG);
Nvoid RCC_ClearFlag(void);
NITStatus RCC_GetITStatus(uint8_t RCC_IT);
Nvoid RCC_ClearITPendingBit(uint8_t RCC_IT);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __FT32F0XX_RCC_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/************************ (C) COPYRIGHT FMD *****END OF FILE****/
L 45 "..\user\main.h" 2
N#include "ft32f0xx_rtc.h"
L 1 "..\FTLib\Inc\ft32f0xx_rtc.h" 1
N/**
N  ******************************************************************************
N  * @file    			ft32f0xx_rtc.h
N  * @author  			FMD AE
N  * @brief   			This file contains all the functions prototypes for the RTC firmware 
N  *          			library.
N  * @version 			V1.0.0           
N  * @data		 			2021-07-01
N  ******************************************************************************
N  */
N
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __FT32F0XX_RTC_H
N#define __FT32F0XX_RTC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "ft32f0xx.h"
N
N
N
N/** @addtogroup RTC
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief  RTC Init structures definition  
N  */ 
Ntypedef struct
N{
N  uint32_t RTC_HourFormat;   /*!< Specifies the RTC Hour Format.
N                             This parameter can be a value of @ref RTC_Hour_Formats */
N  
N  uint32_t RTC_AsynchPrediv; /*!< Specifies the RTC Asynchronous Predivider value.
N                             This parameter must be set to a value lower than 0x7F */
N  
N  uint32_t RTC_SynchPrediv;  /*!< Specifies the RTC Synchronous Predivider value.
N                             This parameter must be set to a value lower than 0x1FFF */
N}RTC_InitTypeDef;
N
N/** 
N  * @brief  RTC Time structure definition  
N  */
Ntypedef struct
N{
N  uint8_t RTC_Hours;    /*!< Specifies the RTC Time Hour.
N                        This parameter must be set to a value in the 0-12 range
N                        if the RTC_HourFormat_12 is selected or 0-23 range if
N                        the RTC_HourFormat_24 is selected. */
N
N  uint8_t RTC_Minutes;  /*!< Specifies the RTC Time Minutes.
N                        This parameter must be set to a value in the 0-59 range. */
N  
N  uint8_t RTC_Seconds;  /*!< Specifies the RTC Time Seconds.
N                        This parameter must be set to a value in the 0-59 range. */
N
N  uint8_t RTC_H12;      /*!< Specifies the RTC AM/PM Time.
N                        This parameter can be a value of @ref RTC_AM_PM_Definitions */
N}RTC_TimeTypeDef; 
N
N/** 
N  * @brief  RTC Date structure definition  
N  */
Ntypedef struct
N{
N  uint8_t RTC_WeekDay; /*!< Specifies the RTC Date WeekDay.
N                        This parameter can be a value of @ref RTC_WeekDay_Definitions */
N  
N  uint8_t RTC_Month;   /*!< Specifies the RTC Date Month.
N                        This parameter can be a value of @ref RTC_Month_Date_Definitions */
N
N  uint8_t RTC_Date;     /*!< Specifies the RTC Date.
N                        This parameter must be set to a value in the 1-31 range. */
N  
N  uint8_t RTC_Year;     /*!< Specifies the RTC Date Year.
N                        This parameter must be set to a value in the 0-99 range. */
N}RTC_DateTypeDef;
N
N/** 
N  * @brief  RTC Alarm structure definition  
N  */
Ntypedef struct
N{
N  RTC_TimeTypeDef RTC_AlarmTime;     /*!< Specifies the RTC Alarm Time members. */
N
N  uint32_t RTC_AlarmMask;            /*!< Specifies the RTC Alarm Masks.
N                                     This parameter can be a value of @ref RTC_AlarmMask_Definitions */
N
N  uint32_t RTC_AlarmDateWeekDaySel;  /*!< Specifies the RTC Alarm is on Date or WeekDay.
N                                     This parameter can be a value of @ref RTC_AlarmDateWeekDay_Definitions */
N  
N  uint8_t RTC_AlarmDateWeekDay;      /*!< Specifies the RTC Alarm Date/WeekDay.
N                                     This parameter must be set to a value in the 1-31 range 
N                                     if the Alarm Date is selected.
N                                     This parameter can be a value of @ref RTC_WeekDay_Definitions 
N                                     if the Alarm WeekDay is selected. */
N}RTC_AlarmTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup RTC_Exported_Constants
N  * @{
N  */ 
N
N
N/** @defgroup RTC_Hour_Formats 
N  * @{
N  */ 
N#define RTC_HourFormat_24              ((uint32_t)0x00000000)
N#define RTC_HourFormat_12              ((uint32_t)0x00000040)
N#define IS_RTC_HOUR_FORMAT(FORMAT)     (((FORMAT) == RTC_HourFormat_12) || \
N                                        ((FORMAT) == RTC_HourFormat_24))
X#define IS_RTC_HOUR_FORMAT(FORMAT)     (((FORMAT) == RTC_HourFormat_12) ||                                         ((FORMAT) == RTC_HourFormat_24))
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Asynchronous_Predivider 
N  * @{
N  */ 
N#define IS_RTC_ASYNCH_PREDIV(PREDIV)   ((PREDIV) <= 0x7F)
N 
N/**
N  * @}
N  */ 
N
N
N/** @defgroup RTC_Synchronous_Predivider 
N  * @{
N  */ 
N#define IS_RTC_SYNCH_PREDIV(PREDIV)    ((PREDIV) <= 0x7FFF)
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Time_Definitions 
N  * @{
N  */ 
N#define IS_RTC_HOUR12(HOUR)            (((HOUR) > 0) && ((HOUR) <= 12))
N#define IS_RTC_HOUR24(HOUR)            ((HOUR) <= 23)
N#define IS_RTC_MINUTES(MINUTES)        ((MINUTES) <= 59)
N#define IS_RTC_SECONDS(SECONDS)        ((SECONDS) <= 59)
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_AM_PM_Definitions 
N  * @{
N  */ 
N#define RTC_H12_AM                     ((uint8_t)0x00)
N#define RTC_H12_PM                     ((uint8_t)0x40)
N#define IS_RTC_H12(PM) (((PM) == RTC_H12_AM) || ((PM) == RTC_H12_PM))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Year_Date_Definitions 
N  * @{
N  */ 
N#define IS_RTC_YEAR(YEAR)              ((YEAR) <= 99)
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Month_Date_Definitions 
N  * @{
N  */ 
N#define RTC_Month_January              ((uint8_t)0x01)
N#define RTC_Month_February             ((uint8_t)0x02)
N#define RTC_Month_March                ((uint8_t)0x03)
N#define RTC_Month_April                ((uint8_t)0x04)
N#define RTC_Month_May                  ((uint8_t)0x05)
N#define RTC_Month_June                 ((uint8_t)0x06)
N#define RTC_Month_July                 ((uint8_t)0x07)
N#define RTC_Month_August               ((uint8_t)0x08)
N#define RTC_Month_September            ((uint8_t)0x09)
N#define RTC_Month_October              ((uint8_t)0x10)
N#define RTC_Month_November             ((uint8_t)0x11)
N#define RTC_Month_December             ((uint8_t)0x12)
N#define IS_RTC_MONTH(MONTH)            (((MONTH) >= 1) && ((MONTH) <= 12))
N#define IS_RTC_DATE(DATE)              (((DATE) >= 1) && ((DATE) <= 31))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_WeekDay_Definitions 
N  * @{
N  */ 
N  
N#define	RTC_Weekday_Monday             ((uint8_t)0x01)
N#define	RTC_Weekday_Tuesday            ((uint8_t)0x02)
N#define	RTC_Weekday_Wednesday          ((uint8_t)0x03)
N#define	RTC_Weekday_Thursday           ((uint8_t)0x04)
N#define	RTC_Weekday_Friday             ((uint8_t)0x05)
N#define	RTC_Weekday_Saturday           ((uint8_t)0x6)
N#define	RTC_Weekday_Sunday             ((uint8_t)0x07)
N#define IS_RTC_WEEKDAY(WEEKDAY) (((WEEKDAY) == RTC_Weekday_Monday) || \
N                                 ((WEEKDAY) == RTC_Weekday_Tuesday) || \
N                                 ((WEEKDAY) == RTC_Weekday_Wednesday) || \
N                                 ((WEEKDAY) == RTC_Weekday_Thursday) || \
N                                 ((WEEKDAY) == RTC_Weekday_Friday) || \
N                                 ((WEEKDAY) == RTC_Weekday_Saturday) || \
N                                 ((WEEKDAY) == RTC_Weekday_Sunday))
X#define IS_RTC_WEEKDAY(WEEKDAY) (((WEEKDAY) == RTC_Weekday_Monday) ||                                  ((WEEKDAY) == RTC_Weekday_Tuesday) ||                                  ((WEEKDAY) == RTC_Weekday_Wednesday) ||                                  ((WEEKDAY) == RTC_Weekday_Thursday) ||                                  ((WEEKDAY) == RTC_Weekday_Friday) ||                                  ((WEEKDAY) == RTC_Weekday_Saturday) ||                                  ((WEEKDAY) == RTC_Weekday_Sunday))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup RTC_Alarm_Definitions 
N  * @{
N  */ 
N#define IS_RTC_ALARM_DATE_WEEKDAY_DATE(DATE) (((DATE) > 0) && ((DATE) <= 31))
N#define IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(WEEKDAY) (((WEEKDAY) == RTC_Weekday_Monday) || \
N                                                    ((WEEKDAY) == RTC_Weekday_Tuesday) || \
N                                                    ((WEEKDAY) == RTC_Weekday_Wednesday) || \
N                                                    ((WEEKDAY) == RTC_Weekday_Thursday) || \
N                                                    ((WEEKDAY) == RTC_Weekday_Friday) || \
N                                                    ((WEEKDAY) == RTC_Weekday_Saturday) || \
N                                                    ((WEEKDAY) == RTC_Weekday_Sunday))
X#define IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(WEEKDAY) (((WEEKDAY) == RTC_Weekday_Monday) ||                                                     ((WEEKDAY) == RTC_Weekday_Tuesday) ||                                                     ((WEEKDAY) == RTC_Weekday_Wednesday) ||                                                     ((WEEKDAY) == RTC_Weekday_Thursday) ||                                                     ((WEEKDAY) == RTC_Weekday_Friday) ||                                                     ((WEEKDAY) == RTC_Weekday_Saturday) ||                                                     ((WEEKDAY) == RTC_Weekday_Sunday))
N
N/**
N  * @}
N  */ 
N
N
N/** @defgroup RTC_AlarmDateWeekDay_Definitions 
N  * @{
N  */ 
N#define RTC_AlarmDateWeekDaySel_Date      ((uint32_t)0x00000000)  
N#define RTC_AlarmDateWeekDaySel_WeekDay   ((uint32_t)0x40000000)  
N
N#define IS_RTC_ALARM_DATE_WEEKDAY_SEL(SEL) (((SEL) == RTC_AlarmDateWeekDaySel_Date) || \
N                                            ((SEL) == RTC_AlarmDateWeekDaySel_WeekDay))
X#define IS_RTC_ALARM_DATE_WEEKDAY_SEL(SEL) (((SEL) == RTC_AlarmDateWeekDaySel_Date) ||                                             ((SEL) == RTC_AlarmDateWeekDaySel_WeekDay))
N
N/**
N  * @}
N  */ 
N
N
N/** @defgroup RTC_AlarmMask_Definitions 
N  * @{
N  */ 
N#define RTC_AlarmMask_None                ((uint32_t)0x00000000)
N#define RTC_AlarmMask_DateWeekDay         ((uint32_t)0x80000000)  
N#define RTC_AlarmMask_Hours               ((uint32_t)0x00800000)
N#define RTC_AlarmMask_Minutes             ((uint32_t)0x00008000)
N#define RTC_AlarmMask_Seconds             ((uint32_t)0x00000080)
N#define RTC_AlarmMask_All                 ((uint32_t)0x80808080)
N#define IS_RTC_ALARM_MASK(MASK)  (((MASK) & 0x7F7F7F7F) == (uint32_t)RESET)
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Alarms_Definitions 
N  * @{
N  */ 
N#define RTC_Alarm_A                       ((uint32_t)0x00000100)
N#define IS_RTC_ALARM(ALARM)      ((ALARM) == RTC_Alarm_A)
N#define IS_RTC_CMD_ALARM(ALARM)  (((ALARM) & (RTC_Alarm_A)) != (uint32_t)RESET)
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Alarm_Sub_Seconds_Masks Definitions.
N  * @{
N  */ 
N#define RTC_AlarmSubSecondMask_All         ((uint8_t)0x00) /*!< All Alarm SS fields are masked. 
N                                                                There is no comparison on sub seconds 
N                                                                for Alarm */
N#define RTC_AlarmSubSecondMask_SS14_1      ((uint8_t)0x01) /*!< SS[14:1] are don't care in Alarm 
N                                                                comparison. Only SS[0] is compared. */
N#define RTC_AlarmSubSecondMask_SS14_2      ((uint8_t)0x02) /*!< SS[14:2] are don't care in Alarm 
N                                                                comparison. Only SS[1:0] are compared */
N#define RTC_AlarmSubSecondMask_SS14_3      ((uint8_t)0x03) /*!< SS[14:3] are don't care in Alarm 
N                                                                comparison. Only SS[2:0] are compared */
N#define RTC_AlarmSubSecondMask_SS14_4      ((uint8_t)0x04) /*!< SS[14:4] are don't care in Alarm 
N                                                                comparison. Only SS[3:0] are compared */
N#define RTC_AlarmSubSecondMask_SS14_5      ((uint8_t)0x05) /*!< SS[14:5] are don't care in Alarm 
N                                                                comparison. Only SS[4:0] are compared */
N#define RTC_AlarmSubSecondMask_SS14_6      ((uint8_t)0x06) /*!< SS[14:6] are don't care in Alarm 
N                                                                comparison. Only SS[5:0] are compared */
N#define RTC_AlarmSubSecondMask_SS14_7      ((uint8_t)0x07) /*!< SS[14:7] are don't care in Alarm 
N                                                                comparison. Only SS[6:0] are compared */
N#define RTC_AlarmSubSecondMask_SS14_8      ((uint8_t)0x08) /*!< SS[14:8] are don't care in Alarm 
N                                                                comparison. Only SS[7:0] are compared */
N#define RTC_AlarmSubSecondMask_SS14_9      ((uint8_t)0x09) /*!< SS[14:9] are don't care in Alarm 
N                                                                comparison. Only SS[8:0] are compared */
N#define RTC_AlarmSubSecondMask_SS14_10     ((uint8_t)0x0A) /*!< SS[14:10] are don't care in Alarm 
N                                                                comparison. Only SS[9:0] are compared */
N#define RTC_AlarmSubSecondMask_SS14_11     ((uint8_t)0x0B) /*!< SS[14:11] are don't care in Alarm 
N                                                                comparison. Only SS[10:0] are compared */
N#define RTC_AlarmSubSecondMask_SS14_12     ((uint8_t)0x0C) /*!< SS[14:12] are don't care in Alarm 
N                                                                comparison.Only SS[11:0] are compared */
N#define RTC_AlarmSubSecondMask_SS14_13     ((uint8_t)0x0D) /*!< SS[14:13] are don't care in Alarm 
N                                                                comparison. Only SS[12:0] are compared */
N#define RTC_AlarmSubSecondMask_SS14        ((uint8_t)0x0E) /*!< SS[14] is don't care in Alarm 
N                                                                comparison.Only SS[13:0] are compared */
N#define RTC_AlarmSubSecondMask_None        ((uint8_t)0x0F) /*!< SS[14:0] are compared and must match 
N                                                                to activate alarm. */
N#define IS_RTC_ALARM_SUB_SECOND_MASK(MASK)   (((MASK) == RTC_AlarmSubSecondMask_All) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_1) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_2) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_3) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_4) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_5) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_6) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_7) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_8) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_9) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_10) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_11) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_12) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_13) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_None))
X#define IS_RTC_ALARM_SUB_SECOND_MASK(MASK)   (((MASK) == RTC_AlarmSubSecondMask_All) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_1) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_2) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_3) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_4) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_5) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_6) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_7) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_8) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_9) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_10) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_11) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_12) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_13) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14) ||                                               ((MASK) == RTC_AlarmSubSecondMask_None))
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Alarm_Sub_Seconds_Value
N  * @{
N  */ 
N  
N#define IS_RTC_ALARM_SUB_SECOND_VALUE(VALUE) ((VALUE) <= 0x00007FFF)
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Time_Stamp_Edges_definitions 
N  * @{
N  */ 
N#define RTC_TimeStampEdge_Rising          ((uint32_t)0x00000000)
N#define RTC_TimeStampEdge_Falling         ((uint32_t)0x00000008)
N#define IS_RTC_TIMESTAMP_EDGE(EDGE) (((EDGE) == RTC_TimeStampEdge_Rising) || \
N                                     ((EDGE) == RTC_TimeStampEdge_Falling))
X#define IS_RTC_TIMESTAMP_EDGE(EDGE) (((EDGE) == RTC_TimeStampEdge_Rising) ||                                      ((EDGE) == RTC_TimeStampEdge_Falling))
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Output_selection_Definitions 
N  * @{
N  */ 
N#define RTC_Output_Disable             ((uint32_t)0x00000000)
N#define RTC_Output_AlarmA              ((uint32_t)0x00200000)
N#define RTC_Output_WakeUp              ((uint32_t)0x00600000)
N 
N#define IS_RTC_OUTPUT(OUTPUT) (((OUTPUT) == RTC_Output_Disable) || \
N                               ((OUTPUT) == RTC_Output_AlarmA)  || \
N                               ((OUTPUT) == RTC_Output_WakeUp))
X#define IS_RTC_OUTPUT(OUTPUT) (((OUTPUT) == RTC_Output_Disable) ||                                ((OUTPUT) == RTC_Output_AlarmA)  ||                                ((OUTPUT) == RTC_Output_WakeUp))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Output_Polarity_Definitions 
N  * @{
N  */ 
N#define RTC_OutputPolarity_High           ((uint32_t)0x00000000)
N#define RTC_OutputPolarity_Low            ((uint32_t)0x00100000)
N#define IS_RTC_OUTPUT_POL(POL) (((POL) == RTC_OutputPolarity_High) || \
N                                ((POL) == RTC_OutputPolarity_Low))
X#define IS_RTC_OUTPUT_POL(POL) (((POL) == RTC_OutputPolarity_High) ||                                 ((POL) == RTC_OutputPolarity_Low))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup RTC_Calib_Output_selection_Definitions 
N  * @{
N  */ 
N#define RTC_CalibOutput_512Hz            ((uint32_t)0x00000000) 
N#define RTC_CalibOutput_1Hz              ((uint32_t)0x00080000)
N#define IS_RTC_CALIB_OUTPUT(OUTPUT)  (((OUTPUT) == RTC_CalibOutput_512Hz) || \
N                                      ((OUTPUT) == RTC_CalibOutput_1Hz))
X#define IS_RTC_CALIB_OUTPUT(OUTPUT)  (((OUTPUT) == RTC_CalibOutput_512Hz) ||                                       ((OUTPUT) == RTC_CalibOutput_1Hz))
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Smooth_calib_period_Definitions 
N  * @{
N  */ 
N#define RTC_SmoothCalibPeriod_32sec   ((uint32_t)0x00000000) /*!<  if RTCCLK = 32768 Hz, Smooth calibation
N                                                             period is 32s,  else 2exp20 RTCCLK seconds */
N#define RTC_SmoothCalibPeriod_16sec   ((uint32_t)0x00002000) /*!<  if RTCCLK = 32768 Hz, Smooth calibation 
N                                                             period is 16s, else 2exp19 RTCCLK seconds */
N#define RTC_SmoothCalibPeriod_8sec    ((uint32_t)0x00004000) /*!<  if RTCCLK = 32768 Hz, Smooth calibation 
N                                                             period is 8s, else 2exp18 RTCCLK seconds */
N#define  IS_RTC_SMOOTH_CALIB_PERIOD(PERIOD) (((PERIOD) == RTC_SmoothCalibPeriod_32sec) || \
N                                             ((PERIOD) == RTC_SmoothCalibPeriod_16sec) || \
N                                             ((PERIOD) == RTC_SmoothCalibPeriod_8sec))
X#define  IS_RTC_SMOOTH_CALIB_PERIOD(PERIOD) (((PERIOD) == RTC_SmoothCalibPeriod_32sec) ||                                              ((PERIOD) == RTC_SmoothCalibPeriod_16sec) ||                                              ((PERIOD) == RTC_SmoothCalibPeriod_8sec))
N                                          
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Smooth_calib_Plus_pulses_Definitions 
N  * @{
N  */ 
N#define RTC_SmoothCalibPlusPulses_Set    ((uint32_t)0x00008000) /*!<  The number of RTCCLK pulses added  
N                                                                during a X -second window = Y - CALM[8:0]. 
N                                                                 with Y = 512, 256, 128 when X = 32, 16, 8 */
N#define RTC_SmoothCalibPlusPulses_Reset  ((uint32_t)0x00000000) /*!<  The number of RTCCLK pulses subbstited
N                                                                 during a 32-second window =   CALM[8:0]. */
N#define  IS_RTC_SMOOTH_CALIB_PLUS(PLUS) (((PLUS) == RTC_SmoothCalibPlusPulses_Set) || \
N                                         ((PLUS) == RTC_SmoothCalibPlusPulses_Reset))
X#define  IS_RTC_SMOOTH_CALIB_PLUS(PLUS) (((PLUS) == RTC_SmoothCalibPlusPulses_Set) ||                                          ((PLUS) == RTC_SmoothCalibPlusPulses_Reset))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Smooth_calib_Minus_pulses_Definitions 
N  * @{
N  */ 
N#define  IS_RTC_SMOOTH_CALIB_MINUS(VALUE) ((VALUE) <= 0x000001FF)
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_DayLightSaving_Definitions 
N  * @{
N  */ 
N#define RTC_DayLightSaving_SUB1H   ((uint32_t)0x00020000)
N#define RTC_DayLightSaving_ADD1H   ((uint32_t)0x00010000)
N#define IS_RTC_DAYLIGHT_SAVING(SAVING) (((SAVING) == RTC_DayLightSaving_SUB1H) || \
N                                        ((SAVING) == RTC_DayLightSaving_ADD1H))
X#define IS_RTC_DAYLIGHT_SAVING(SAVING) (((SAVING) == RTC_DayLightSaving_SUB1H) ||                                         ((SAVING) == RTC_DayLightSaving_ADD1H))
N
N#define RTC_StoreOperation_Reset        ((uint32_t)0x00000000)
N#define RTC_StoreOperation_Set          ((uint32_t)0x00040000)
N#define IS_RTC_STORE_OPERATION(OPERATION) (((OPERATION) == RTC_StoreOperation_Reset) || \
N                                           ((OPERATION) == RTC_StoreOperation_Set))
X#define IS_RTC_STORE_OPERATION(OPERATION) (((OPERATION) == RTC_StoreOperation_Reset) ||                                            ((OPERATION) == RTC_StoreOperation_Set))
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Tamper_Trigger_Definitions 
N  * @{
N  */ 
N#define RTC_TamperTrigger_RisingEdge            ((uint32_t)0x00000000)
N#define RTC_TamperTrigger_FallingEdge           ((uint32_t)0x00000001)
N#define RTC_TamperTrigger_LowLevel              ((uint32_t)0x00000000)
N#define RTC_TamperTrigger_HighLevel             ((uint32_t)0x00000001)
N#define IS_RTC_TAMPER_TRIGGER(TRIGGER) (((TRIGGER) == RTC_TamperTrigger_RisingEdge) || \
N                                        ((TRIGGER) == RTC_TamperTrigger_FallingEdge) || \
N                                        ((TRIGGER) == RTC_TamperTrigger_LowLevel) || \
N                                        ((TRIGGER) == RTC_TamperTrigger_HighLevel)) 
X#define IS_RTC_TAMPER_TRIGGER(TRIGGER) (((TRIGGER) == RTC_TamperTrigger_RisingEdge) ||                                         ((TRIGGER) == RTC_TamperTrigger_FallingEdge) ||                                         ((TRIGGER) == RTC_TamperTrigger_LowLevel) ||                                         ((TRIGGER) == RTC_TamperTrigger_HighLevel)) 
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Tamper_Filter_Definitions 
N  * @{
N  */ 
N#define RTC_TamperFilter_Disable   ((uint32_t)0x00000000) /*!< Tamper filter is disabled */
N
N#define RTC_TamperFilter_2Sample   ((uint32_t)0x00000800) /*!< Tamper is activated after 2 
N                                                          consecutive samples at the active level */
N#define RTC_TamperFilter_4Sample   ((uint32_t)0x00001000) /*!< Tamper is activated after 4 
N                                                          consecutive samples at the active level */
N#define RTC_TamperFilter_8Sample   ((uint32_t)0x00001800) /*!< Tamper is activated after 8 
N                                                          consecutive samples at the active leve. */
N#define IS_RTC_TAMPER_FILTER(FILTER) (((FILTER) == RTC_TamperFilter_Disable) || \
N                                      ((FILTER) == RTC_TamperFilter_2Sample) || \
N                                      ((FILTER) == RTC_TamperFilter_4Sample) || \
N                                      ((FILTER) == RTC_TamperFilter_8Sample))
X#define IS_RTC_TAMPER_FILTER(FILTER) (((FILTER) == RTC_TamperFilter_Disable) ||                                       ((FILTER) == RTC_TamperFilter_2Sample) ||                                       ((FILTER) == RTC_TamperFilter_4Sample) ||                                       ((FILTER) == RTC_TamperFilter_8Sample))
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Tamper_Sampling_Frequencies_Definitions 
N  * @{
N  */ 
N#define RTC_TamperSamplingFreq_RTCCLK_Div32768 ((uint32_t)0x00000000) /*!< Each of the tamper inputs are sampled
N                                                                      with a frequency =  RTCCLK / 32768 */
N#define RTC_TamperSamplingFreq_RTCCLK_Div16384 ((uint32_t)0x00000100) /*!< Each of the tamper inputs are sampled
N                                                                      with a frequency =  RTCCLK / 16384 */
N#define RTC_TamperSamplingFreq_RTCCLK_Div8192  ((uint32_t)0x00000200) /*!< Each of the tamper inputs are sampled
N                                                                      with a frequency =  RTCCLK / 8192  */
N#define RTC_TamperSamplingFreq_RTCCLK_Div4096  ((uint32_t)0x00000300) /*!< Each of the tamper inputs are sampled
N                                                                      with a frequency =  RTCCLK / 4096  */
N#define RTC_TamperSamplingFreq_RTCCLK_Div2048  ((uint32_t)0x00000400) /*!< Each of the tamper inputs are sampled
N                                                                      with a frequency =  RTCCLK / 2048  */
N#define RTC_TamperSamplingFreq_RTCCLK_Div1024  ((uint32_t)0x00000500) /*!< Each of the tamper inputs are sampled
N                                                                      with a frequency =  RTCCLK / 1024  */
N#define RTC_TamperSamplingFreq_RTCCLK_Div512   ((uint32_t)0x00000600) /*!< Each of the tamper inputs are sampled
N                                                                      with a frequency =  RTCCLK / 512   */
N#define RTC_TamperSamplingFreq_RTCCLK_Div256   ((uint32_t)0x00000700) /*!< Each of the tamper inputs are sampled
N                                                                      with a frequency =  RTCCLK / 256   */
N#define IS_RTC_TAMPER_SAMPLING_FREQ(FREQ) (((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div32768) || \
N                                           ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div16384) || \
N                                           ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div8192) || \
N                                           ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div4096) || \
N                                           ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div2048) || \
N                                           ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div1024) || \
N                                           ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div512) || \
N                                           ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div256))
X#define IS_RTC_TAMPER_SAMPLING_FREQ(FREQ) (((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div32768) ||                                            ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div16384) ||                                            ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div8192) ||                                            ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div4096) ||                                            ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div2048) ||                                            ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div1024) ||                                            ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div512) ||                                            ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div256))
N                                           
N/**
N  * @}
N  */
N
N  /** @defgroup RTC_Tamper_Pin_Precharge_Duration_Definitions 
N  * @{
N  */ 
N#define RTC_TamperPrechargeDuration_1RTCCLK ((uint32_t)0x00000000)  /*!< Tamper pins are pre-charged before 
N                                                                         sampling during 1 RTCCLK cycle */
N#define RTC_TamperPrechargeDuration_2RTCCLK ((uint32_t)0x00002000)  /*!< Tamper pins are pre-charged before 
N                                                                         sampling during 2 RTCCLK cycles */
N#define RTC_TamperPrechargeDuration_4RTCCLK ((uint32_t)0x00004000)  /*!< Tamper pins are pre-charged before 
N                                                                         sampling during 4 RTCCLK cycles */
N#define RTC_TamperPrechargeDuration_8RTCCLK ((uint32_t)0x00006000)  /*!< Tamper pins are pre-charged before 
N                                                                         sampling during 8 RTCCLK cycles */
N
N#define IS_RTC_TAMPER_PRECHARGE_DURATION(DURATION) (((DURATION) == RTC_TamperPrechargeDuration_1RTCCLK) || \
N                                                    ((DURATION) == RTC_TamperPrechargeDuration_2RTCCLK) || \
N                                                    ((DURATION) == RTC_TamperPrechargeDuration_4RTCCLK) || \
N                                                    ((DURATION) == RTC_TamperPrechargeDuration_8RTCCLK))
X#define IS_RTC_TAMPER_PRECHARGE_DURATION(DURATION) (((DURATION) == RTC_TamperPrechargeDuration_1RTCCLK) ||                                                     ((DURATION) == RTC_TamperPrechargeDuration_2RTCCLK) ||                                                     ((DURATION) == RTC_TamperPrechargeDuration_4RTCCLK) ||                                                     ((DURATION) == RTC_TamperPrechargeDuration_8RTCCLK))
N/**
N  * @}
N  */
N
N/** @defgroup RTC_Tamper_Pins_Definitions 
N  * @{
N  */ 
N#define RTC_Tamper_1            RTC_TAFCR_TAMP1E /*!< Tamper detection enable for 
N                                                 input tamper 1 */
N#define RTC_Tamper_2            RTC_TAFCR_TAMP2E /*!< Tamper detection enable for 
N                                                 input tamper 2 */
N#define RTC_Tamper_3            RTC_TAFCR_TAMP3E /*!< Tamper detection enable for 
N                                                 input tamper 3*/
N#define IS_RTC_TAMPER(TAMPER) ((((TAMPER) & (uint32_t)0xFFFFFFD6) == 0x00) && ((TAMPER) != (uint32_t)RESET))
N
N/**
N  * @}
N  */
N
N/** @defgroup RTC_Output_Type_ALARM_OUT 
N  * @{
N  */ 
N#define RTC_OutputType_OpenDrain           ((uint32_t)0x00000000)
N#define RTC_OutputType_PushPull            ((uint32_t)0x00040000)
N#define IS_RTC_OUTPUT_TYPE(TYPE) (((TYPE) == RTC_OutputType_OpenDrain) || \
N                                  ((TYPE) == RTC_OutputType_PushPull))
X#define IS_RTC_OUTPUT_TYPE(TYPE) (((TYPE) == RTC_OutputType_OpenDrain) ||                                   ((TYPE) == RTC_OutputType_PushPull))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Add_1_Second_Parameter_Definitions
N  * @{
N  */ 
N#define RTC_ShiftAdd1S_Reset      ((uint32_t)0x00000000)
N#define RTC_ShiftAdd1S_Set        ((uint32_t)0x80000000)
N#define IS_RTC_SHIFT_ADD1S(SEL) (((SEL) == RTC_ShiftAdd1S_Reset) || \
N                                 ((SEL) == RTC_ShiftAdd1S_Set))
X#define IS_RTC_SHIFT_ADD1S(SEL) (((SEL) == RTC_ShiftAdd1S_Reset) ||                                  ((SEL) == RTC_ShiftAdd1S_Set))
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Substract_Fraction_Of_Second_Value
N  * @{
N  */ 
N#define IS_RTC_SHIFT_SUBFS(FS) ((FS) <= 0x00007FFF)
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Input_parameter_format_definitions 
N  * @{
N  */ 
N#define RTC_Format_BIN                    ((uint32_t)0x000000000)
N#define RTC_Format_BCD                    ((uint32_t)0x000000001)
N#define IS_RTC_FORMAT(FORMAT) (((FORMAT) == RTC_Format_BIN) || ((FORMAT) == RTC_Format_BCD))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Flags_Definitions 
N  * @{
N  */ 
N#define RTC_FLAG_RECALPF                  RTC_ISR_RECALPF
N#define RTC_FLAG_TAMP3F                   RTC_ISR_TAMP3F 
N#define RTC_FLAG_TAMP2F                   RTC_ISR_TAMP2F
N#define RTC_FLAG_TAMP1F                   RTC_ISR_TAMP1F
N#define RTC_FLAG_TSOVF                    RTC_ISR_TSOVF
N#define RTC_FLAG_TSF                      RTC_ISR_TSF
N#define RTC_FLAG_WUTF                     RTC_ISR_WUTF 
N#define RTC_FLAG_ALRAF                    RTC_ISR_ALRAF
N#define RTC_FLAG_INITF                    RTC_ISR_INITF
N#define RTC_FLAG_RSF                      RTC_ISR_RSF
N#define RTC_FLAG_INITS                    RTC_ISR_INITS
N#define RTC_FLAG_SHPF                     RTC_ISR_SHPF
N#define RTC_FLAG_WUTWF                    RTC_ISR_WUTWF 
N#define RTC_FLAG_ALRAWF                   RTC_ISR_ALRAWF 
N
N#define IS_RTC_GET_FLAG(FLAG) (((FLAG) == RTC_FLAG_TSOVF)  || ((FLAG) == RTC_FLAG_TSF)     || \
N                               ((FLAG) == RTC_FLAG_WUTF)   || ((FLAG) == RTC_FLAG_ALRAWF)  || \
N                               ((FLAG) == RTC_FLAG_ALRAF)  || ((FLAG) == RTC_FLAG_INITF)   || \
N                               ((FLAG) == RTC_FLAG_RSF)    || ((FLAG) == RTC_FLAG_WUTWF)   || \
N                               ((FLAG) == RTC_FLAG_TAMP1F) || ((FLAG) == RTC_FLAG_TAMP2F)  || \
N                               ((FLAG) == RTC_FLAG_TAMP3F) || ((FLAG) == RTC_FLAG_RECALPF) || \
N                               ((FLAG) == RTC_FLAG_SHPF))
X#define IS_RTC_GET_FLAG(FLAG) (((FLAG) == RTC_FLAG_TSOVF)  || ((FLAG) == RTC_FLAG_TSF)     ||                                ((FLAG) == RTC_FLAG_WUTF)   || ((FLAG) == RTC_FLAG_ALRAWF)  ||                                ((FLAG) == RTC_FLAG_ALRAF)  || ((FLAG) == RTC_FLAG_INITF)   ||                                ((FLAG) == RTC_FLAG_RSF)    || ((FLAG) == RTC_FLAG_WUTWF)   ||                                ((FLAG) == RTC_FLAG_TAMP1F) || ((FLAG) == RTC_FLAG_TAMP2F)  ||                                ((FLAG) == RTC_FLAG_TAMP3F) || ((FLAG) == RTC_FLAG_RECALPF) ||                                ((FLAG) == RTC_FLAG_SHPF))
N#define IS_RTC_CLEAR_FLAG(FLAG) (((FLAG) != (uint32_t)RESET) && (((FLAG) & 0xFFFF02DF) == (uint32_t)RESET))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Interrupts_Definitions 
N  * @{
N  */ 
N#define RTC_IT_TS                         ((uint32_t)0x00008000)
N#define RTC_IT_WUT                        ((uint32_t)0x00004000) 
N#define RTC_IT_ALRA                       ((uint32_t)0x00001000)
N#define RTC_IT_TAMP                       ((uint32_t)0x00000004) /* Used only to Enable the Tamper Interrupt */
N#define RTC_IT_TAMP1                      ((uint32_t)0x00020000)
N#define RTC_IT_TAMP2                      ((uint32_t)0x00040000)
N#define RTC_IT_TAMP3                      ((uint32_t)0x00080000) 
N
N#define IS_RTC_CONFIG_IT(IT) (((IT) != (uint32_t)RESET) && (((IT) & 0xFFFF2FFB) == (uint32_t)RESET))
N#define IS_RTC_GET_IT(IT) (((IT) == RTC_IT_TS)    || ((IT) == RTC_IT_ALRA)  || \
N                           ((IT) == RTC_IT_TAMP1) || ((IT) == RTC_IT_WUT)   || \
N                           ((IT) == RTC_IT_TAMP2) || ((IT) == RTC_IT_TAMP3))                           
X#define IS_RTC_GET_IT(IT) (((IT) == RTC_IT_TS)    || ((IT) == RTC_IT_ALRA)  ||                            ((IT) == RTC_IT_TAMP1) || ((IT) == RTC_IT_WUT)   ||                            ((IT) == RTC_IT_TAMP2) || ((IT) == RTC_IT_TAMP3))                           
N
N#define IS_RTC_CLEAR_IT(IT) (((IT) != (uint32_t)RESET) && (((IT) & 0xFFF12FFF) == (uint32_t)RESET))
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N/*  Function used to set the RTC configuration to the default reset state *****/
NErrorStatus RTC_DeInit(void);
N
N
N/* Initialization and Configuration functions *********************************/
NErrorStatus RTC_Init(RTC_InitTypeDef* RTC_InitStruct);
Nvoid RTC_StructInit(RTC_InitTypeDef* RTC_InitStruct);
Nvoid RTC_WriteProtectionCmd(FunctionalState NewState);
NErrorStatus RTC_EnterInitMode(void);
Nvoid RTC_ExitInitMode(void);
NErrorStatus RTC_WaitForSynchro(void);
NErrorStatus RTC_RefClockCmd(FunctionalState NewState);
Nvoid RTC_BypassShadowCmd(FunctionalState NewState);
N
N/* Time and Date configuration functions **************************************/
NErrorStatus RTC_SetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct);
Nvoid RTC_TimeStructInit(RTC_TimeTypeDef* RTC_TimeStruct);
Nvoid RTC_GetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct);
Nuint32_t RTC_GetSubSecond(void);
NErrorStatus RTC_SetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct);
Nvoid RTC_DateStructInit(RTC_DateTypeDef* RTC_DateStruct);
Nvoid RTC_GetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct);
N
N/* Alarms (Alarm A) configuration functions  **********************************/
Nvoid RTC_SetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct);
Nvoid RTC_AlarmStructInit(RTC_AlarmTypeDef* RTC_AlarmStruct);
Nvoid RTC_GetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct);
NErrorStatus RTC_AlarmCmd(uint32_t RTC_Alarm, FunctionalState NewState);
Nvoid RTC_AlarmSubSecondConfig(uint32_t RTC_Alarm, uint32_t RTC_AlarmSubSecondValue, uint8_t RTC_AlarmSubSecondMask);
Nuint32_t RTC_GetAlarmSubSecond(uint32_t RTC_Alarm);
N
N/* Daylight Saving configuration functions ************************************/
Nvoid RTC_DayLightSavingConfig(uint32_t RTC_DayLightSaving, uint32_t RTC_StoreOperation);
Nuint32_t RTC_GetStoreOperation(void);
N
N/* Output pin Configuration function ******************************************/
Nvoid RTC_OutputConfig(uint32_t RTC_Output, uint32_t RTC_OutputPolarity);
N
N/* Digital Calibration configuration functions ********************************/
Nvoid RTC_CalibOutputCmd(FunctionalState NewState);
Nvoid RTC_CalibOutputConfig(uint32_t RTC_CalibOutput);
NErrorStatus RTC_SmoothCalibConfig(uint32_t RTC_SmoothCalibPeriod, 
N                                  uint32_t RTC_SmoothCalibPlusPulses,
N                                  uint32_t RTC_SmouthCalibMinusPulsesValue);
N
N/* TimeStamp configuration functions ******************************************/
Nvoid RTC_TimeStampCmd(uint32_t RTC_TimeStampEdge, FunctionalState NewState);
Nvoid RTC_GetTimeStamp(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_StampTimeStruct, RTC_DateTypeDef* RTC_StampDateStruct);
Nuint32_t RTC_GetTimeStampSubSecond(void);
N
N/* Tampers configuration functions ********************************************/
Nvoid RTC_TamperTriggerConfig(uint32_t RTC_Tamper, uint32_t RTC_TamperTrigger);
Nvoid RTC_TamperCmd(uint32_t RTC_Tamper, FunctionalState NewState);
Nvoid RTC_TamperFilterConfig(uint32_t RTC_TamperFilter);
Nvoid RTC_TamperSamplingFreqConfig(uint32_t RTC_TamperSamplingFreq);
Nvoid RTC_TamperPinsPrechargeDuration(uint32_t RTC_TamperPrechargeDuration);
Nvoid RTC_TimeStampOnTamperDetectionCmd(FunctionalState NewState);
Nvoid RTC_TamperPullUpCmd(FunctionalState NewState);
N
N/* Output Type Config configuration functions *********************************/
Nvoid RTC_OutputTypeConfig(uint32_t RTC_OutputType);
N 
N/* RTC_Shift_control_synchonisation_functions *********************************/
NErrorStatus RTC_SynchroShiftConfig(uint32_t RTC_ShiftAdd1S, uint32_t RTC_ShiftSubFS);
N
N/* Interrupts and flags management functions **********************************/
Nvoid RTC_ITConfig(uint32_t RTC_IT, FunctionalState NewState);
NFlagStatus RTC_GetFlagStatus(uint32_t RTC_FLAG);
Nvoid RTC_ClearFlag(uint32_t RTC_FLAG);
NITStatus RTC_GetITStatus(uint32_t RTC_IT);
Nvoid RTC_ClearITPendingBit(uint32_t RTC_IT);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__FT32F0XX_RTC_H */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/************************ (C) COPYRIGHT FMD *****END OF FILE****/
L 46 "..\user\main.h" 2
N#include "ft32f0xx_spi.h"
L 1 "..\FTLib\Inc\ft32f0xx_spi.h" 1
N/**
N  ******************************************************************************
N  * @file    			ft32f0xx_spi.h
N  * @author  			FMD AE
N  * @brief   			This file contains all the functions prototypes for the SPI 
N  *          			firmware library.
N  * @version 			V1.0.0           
N  * @data		 			2021-07-01
N  ******************************************************************************
N  */
N
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __FT32F0XX_SPI_H
N#define __FT32F0XX_SPI_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "ft32f0xx.h"
N
N
N/** @addtogroup SPI
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief  SPI Init structure definition  
N  */
N
Ntypedef struct
N{
N  uint16_t SPI_Direction;           /*!< Specifies the SPI unidirectional or bidirectional data mode.
N                                         This parameter can be a value of @ref SPI_data_direction */
N
N  uint16_t SPI_Mode;                /*!< Specifies the SPI mode (Master/Slave).
N                                         This parameter can be a value of @ref SPI_mode */
N  
N  uint16_t SPI_DataSize;            /*!< Specifies the SPI data size.
N                                         This parameter can be a value of @ref SPI_data_size */
N
N  uint16_t SPI_CPOL;                /*!< Specifies the serial clock steady state.
N                                         This parameter can be a value of @ref SPI_Clock_Polarity */
N
N  uint16_t SPI_CPHA;                /*!< Specifies the clock active edge for the bit capture.
N                                         This parameter can be a value of @ref SPI_Clock_Phase */
N
N  uint16_t SPI_NSS;                 /*!< Specifies whether the NSS signal is managed by
N                                         hardware (NSS pin) or by software using the SSI bit.
N                                         This parameter can be a value of @ref SPI_Slave_Select_management */
N 
N  uint16_t SPI_BaudRatePrescaler;   /*!< Specifies the Baud Rate prescaler value which will be
N                                         used to configure the transmit and receive SCK clock.
N                                         This parameter can be a value of @ref SPI_BaudRate_Prescaler
N                                         @note The communication clock is derived from the master
N                                               clock. The slave clock does not need to be set. */
N
N  uint16_t SPI_FirstBit;            /*!< Specifies whether data transfers start from MSB or LSB bit.
N                                         This parameter can be a value of @ref SPI_MSB_LSB_transmission */
N
N  uint16_t SPI_CRCPolynomial;       /*!< Specifies the polynomial used for the CRC calculation. */
N}SPI_InitTypeDef;
N
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup SPI_Exported_Constants
N  * @{
N  */
N
N#define IS_SPI_ALL_PERIPH(PERIPH) (((PERIPH) == SPI1) || \
N                                   ((PERIPH) == SPI2))
X#define IS_SPI_ALL_PERIPH(PERIPH) (((PERIPH) == SPI1) ||                                    ((PERIPH) == SPI2))
N                                   
N#define IS_SPI_1_PERIPH(PERIPH) (((PERIPH) == SPI1))
N
N/** @defgroup SPI_data_direction 
N  * @{
N  */
N  
N#define SPI_Direction_2Lines_FullDuplex ((uint16_t)0x0000)
N#define SPI_Direction_2Lines_RxOnly     ((uint16_t)0x0400)
N#define SPI_Direction_1Line_Rx          ((uint16_t)0x8000)
N#define SPI_Direction_1Line_Tx          ((uint16_t)0xC000)
N#define IS_SPI_DIRECTION_MODE(MODE) (((MODE) == SPI_Direction_2Lines_FullDuplex) || \
N                                     ((MODE) == SPI_Direction_2Lines_RxOnly) || \
N                                     ((MODE) == SPI_Direction_1Line_Rx) || \
N                                     ((MODE) == SPI_Direction_1Line_Tx))
X#define IS_SPI_DIRECTION_MODE(MODE) (((MODE) == SPI_Direction_2Lines_FullDuplex) ||                                      ((MODE) == SPI_Direction_2Lines_RxOnly) ||                                      ((MODE) == SPI_Direction_1Line_Rx) ||                                      ((MODE) == SPI_Direction_1Line_Tx))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_mode 
N  * @{
N  */
N
N#define SPI_Mode_Master                 ((uint16_t)0x0104)
N#define SPI_Mode_Slave                  ((uint16_t)0x0000)
N#define IS_SPI_MODE(MODE) (((MODE) == SPI_Mode_Master) || \
N                           ((MODE) == SPI_Mode_Slave))
X#define IS_SPI_MODE(MODE) (((MODE) == SPI_Mode_Master) ||                            ((MODE) == SPI_Mode_Slave))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_data_size
N  * @{
N  */
N
N#define SPI_DataSize_4b                 ((uint16_t)0x0300)
N#define SPI_DataSize_5b                 ((uint16_t)0x0400)
N#define SPI_DataSize_6b                 ((uint16_t)0x0500)
N#define SPI_DataSize_7b                 ((uint16_t)0x0600)
N#define SPI_DataSize_8b                 ((uint16_t)0x0700)
N#define SPI_DataSize_9b                 ((uint16_t)0x0800)
N#define SPI_DataSize_10b                ((uint16_t)0x0900)
N#define SPI_DataSize_11b                ((uint16_t)0x0A00)
N#define SPI_DataSize_12b                ((uint16_t)0x0B00)
N#define SPI_DataSize_13b                ((uint16_t)0x0C00)
N#define SPI_DataSize_14b                ((uint16_t)0x0D00)
N#define SPI_DataSize_15b                ((uint16_t)0x0E00)
N#define SPI_DataSize_16b                ((uint16_t)0x0F00)
N#define IS_SPI_DATA_SIZE(SIZE) (((SIZE) == SPI_DataSize_4b) || \
N                                 ((SIZE) == SPI_DataSize_5b) || \
N                                 ((SIZE) == SPI_DataSize_6b) || \
N                                 ((SIZE) == SPI_DataSize_7b) || \
N                                 ((SIZE) == SPI_DataSize_8b) || \
N                                 ((SIZE) == SPI_DataSize_9b) || \
N                                 ((SIZE) == SPI_DataSize_10b) || \
N                                 ((SIZE) == SPI_DataSize_11b) || \
N                                 ((SIZE) == SPI_DataSize_12b) || \
N                                 ((SIZE) == SPI_DataSize_13b) || \
N                                 ((SIZE) == SPI_DataSize_14b) || \
N                                 ((SIZE) == SPI_DataSize_15b) || \
N                                 ((SIZE) == SPI_DataSize_16b))
X#define IS_SPI_DATA_SIZE(SIZE) (((SIZE) == SPI_DataSize_4b) ||                                  ((SIZE) == SPI_DataSize_5b) ||                                  ((SIZE) == SPI_DataSize_6b) ||                                  ((SIZE) == SPI_DataSize_7b) ||                                  ((SIZE) == SPI_DataSize_8b) ||                                  ((SIZE) == SPI_DataSize_9b) ||                                  ((SIZE) == SPI_DataSize_10b) ||                                  ((SIZE) == SPI_DataSize_11b) ||                                  ((SIZE) == SPI_DataSize_12b) ||                                  ((SIZE) == SPI_DataSize_13b) ||                                  ((SIZE) == SPI_DataSize_14b) ||                                  ((SIZE) == SPI_DataSize_15b) ||                                  ((SIZE) == SPI_DataSize_16b))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_CRC_length
N  * @{
N  */
N
N#define SPI_CRCLength_8b                ((uint16_t)0x0000)
N#define SPI_CRCLength_16b               SPI_CR1_CRCL
N#define IS_SPI_CRC_LENGTH(LENGTH) (((LENGTH) == SPI_CRCLength_8b) || \
N                                   ((LENGTH) == SPI_CRCLength_16b))
X#define IS_SPI_CRC_LENGTH(LENGTH) (((LENGTH) == SPI_CRCLength_8b) ||                                    ((LENGTH) == SPI_CRCLength_16b))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_Clock_Polarity 
N  * @{
N  */
N
N#define SPI_CPOL_Low                    ((uint16_t)0x0000)
N#define SPI_CPOL_High                   SPI_CR1_CPOL
N#define IS_SPI_CPOL(CPOL) (((CPOL) == SPI_CPOL_Low) || \
N                           ((CPOL) == SPI_CPOL_High))
X#define IS_SPI_CPOL(CPOL) (((CPOL) == SPI_CPOL_Low) ||                            ((CPOL) == SPI_CPOL_High))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_Clock_Phase 
N  * @{
N  */
N
N#define SPI_CPHA_1Edge                  ((uint16_t)0x0000)
N#define SPI_CPHA_2Edge                  SPI_CR1_CPHA
N#define IS_SPI_CPHA(CPHA) (((CPHA) == SPI_CPHA_1Edge) || \
N                           ((CPHA) == SPI_CPHA_2Edge))
X#define IS_SPI_CPHA(CPHA) (((CPHA) == SPI_CPHA_1Edge) ||                            ((CPHA) == SPI_CPHA_2Edge))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_Slave_Select_management 
N  * @{
N  */
N
N#define SPI_NSS_Soft                    SPI_CR1_SSM
N#define SPI_NSS_Hard                    ((uint16_t)0x0000)
N#define IS_SPI_NSS(NSS) (((NSS) == SPI_NSS_Soft) || \
N                         ((NSS) == SPI_NSS_Hard))
X#define IS_SPI_NSS(NSS) (((NSS) == SPI_NSS_Soft) ||                          ((NSS) == SPI_NSS_Hard))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_BaudRate_Prescaler 
N  * @{
N  */
N
N#define SPI_BaudRatePrescaler_2         ((uint16_t)0x0000)
N#define SPI_BaudRatePrescaler_4         ((uint16_t)0x0008)
N#define SPI_BaudRatePrescaler_8         ((uint16_t)0x0010)
N#define SPI_BaudRatePrescaler_16        ((uint16_t)0x0018)
N#define SPI_BaudRatePrescaler_32        ((uint16_t)0x0020)
N#define SPI_BaudRatePrescaler_64        ((uint16_t)0x0028)
N#define SPI_BaudRatePrescaler_128       ((uint16_t)0x0030)
N#define SPI_BaudRatePrescaler_256       ((uint16_t)0x0038)
N#define IS_SPI_BAUDRATE_PRESCALER(PRESCALER) (((PRESCALER) == SPI_BaudRatePrescaler_2) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_4) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_8) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_16) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_32) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_64) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_128) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_256))
X#define IS_SPI_BAUDRATE_PRESCALER(PRESCALER) (((PRESCALER) == SPI_BaudRatePrescaler_2) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_4) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_8) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_16) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_32) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_64) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_128) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_256))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_MSB_LSB_transmission 
N  * @{
N  */
N
N#define SPI_FirstBit_MSB                ((uint16_t)0x0000)
N#define SPI_FirstBit_LSB                SPI_CR1_LSBFIRST
N#define IS_SPI_FIRST_BIT(BIT) (((BIT) == SPI_FirstBit_MSB) || \
N                               ((BIT) == SPI_FirstBit_LSB))
X#define IS_SPI_FIRST_BIT(BIT) (((BIT) == SPI_FirstBit_MSB) ||                                ((BIT) == SPI_FirstBit_LSB))
N/**
N  * @}
N  */
N  
N/** @defgroup SPI_I2S_Mode 
N  * @{
N  */
N
N#define I2S_Mode_SlaveTx                ((uint16_t)0x0000)
N#define I2S_Mode_SlaveRx                ((uint16_t)0x0100)
N#define I2S_Mode_MasterTx               ((uint16_t)0x0200)
N#define I2S_Mode_MasterRx               ((uint16_t)0x0300)
N#define IS_I2S_MODE(MODE) (((MODE) == I2S_Mode_SlaveTx) || \
N                           ((MODE) == I2S_Mode_SlaveRx) || \
N                           ((MODE) == I2S_Mode_MasterTx)|| \
N                           ((MODE) == I2S_Mode_MasterRx))
X#define IS_I2S_MODE(MODE) (((MODE) == I2S_Mode_SlaveTx) ||                            ((MODE) == I2S_Mode_SlaveRx) ||                            ((MODE) == I2S_Mode_MasterTx)||                            ((MODE) == I2S_Mode_MasterRx))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_I2S_Standard 
N  * @{
N  */
N
N#define I2S_Standard_Phillips           ((uint16_t)0x0000)
N#define I2S_Standard_MSB                ((uint16_t)0x0010)
N#define I2S_Standard_LSB                ((uint16_t)0x0020)
N#define I2S_Standard_PCMShort           ((uint16_t)0x0030)
N#define I2S_Standard_PCMLong            ((uint16_t)0x00B0)
N#define IS_I2S_STANDARD(STANDARD) (((STANDARD) == I2S_Standard_Phillips) || \
N                                   ((STANDARD) == I2S_Standard_MSB) || \
N                                   ((STANDARD) == I2S_Standard_LSB) || \
N                                   ((STANDARD) == I2S_Standard_PCMShort) || \
N                                   ((STANDARD) == I2S_Standard_PCMLong))
X#define IS_I2S_STANDARD(STANDARD) (((STANDARD) == I2S_Standard_Phillips) ||                                    ((STANDARD) == I2S_Standard_MSB) ||                                    ((STANDARD) == I2S_Standard_LSB) ||                                    ((STANDARD) == I2S_Standard_PCMShort) ||                                    ((STANDARD) == I2S_Standard_PCMLong))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_I2S_Data_Format 
N  * @{
N  */
N
N#define I2S_DataFormat_16b              ((uint16_t)0x0000)
N#define I2S_DataFormat_16bextended      ((uint16_t)0x0001)
N#define I2S_DataFormat_24b              ((uint16_t)0x0003)
N#define I2S_DataFormat_32b              ((uint16_t)0x0005)
N#define IS_I2S_DATA_FORMAT(FORMAT) (((FORMAT) == I2S_DataFormat_16b) || \
N                                    ((FORMAT) == I2S_DataFormat_16bextended) || \
N                                    ((FORMAT) == I2S_DataFormat_24b) || \
N                                    ((FORMAT) == I2S_DataFormat_32b))
X#define IS_I2S_DATA_FORMAT(FORMAT) (((FORMAT) == I2S_DataFormat_16b) ||                                     ((FORMAT) == I2S_DataFormat_16bextended) ||                                     ((FORMAT) == I2S_DataFormat_24b) ||                                     ((FORMAT) == I2S_DataFormat_32b))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_I2S_MCLK_Output 
N  * @{
N  */
N
N#define I2S_MCLKOutput_Enable           SPI_I2SPR_MCKOE
N#define I2S_MCLKOutput_Disable          ((uint16_t)0x0000)
N#define IS_I2S_MCLK_OUTPUT(OUTPUT) (((OUTPUT) == I2S_MCLKOutput_Enable) || \
N                                    ((OUTPUT) == I2S_MCLKOutput_Disable))
X#define IS_I2S_MCLK_OUTPUT(OUTPUT) (((OUTPUT) == I2S_MCLKOutput_Enable) ||                                     ((OUTPUT) == I2S_MCLKOutput_Disable))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_I2S_Audio_Frequency 
N  * @{
N  */
N
N#define I2S_AudioFreq_192k               ((uint32_t)192000)
N#define I2S_AudioFreq_96k                ((uint32_t)96000)
N#define I2S_AudioFreq_48k                ((uint32_t)48000)
N#define I2S_AudioFreq_44k                ((uint32_t)44100)
N#define I2S_AudioFreq_32k                ((uint32_t)32000)
N#define I2S_AudioFreq_22k                ((uint32_t)22050)
N#define I2S_AudioFreq_16k                ((uint32_t)16000)
N#define I2S_AudioFreq_11k                ((uint32_t)11025)
N#define I2S_AudioFreq_8k                 ((uint32_t)8000)
N#define I2S_AudioFreq_Default            ((uint32_t)2)
N
N#define IS_I2S_AUDIO_FREQ(FREQ) ((((FREQ) >= I2S_AudioFreq_8k) && \
N                                 ((FREQ) <= I2S_AudioFreq_192k)) || \
N                                 ((FREQ) == I2S_AudioFreq_Default))
X#define IS_I2S_AUDIO_FREQ(FREQ) ((((FREQ) >= I2S_AudioFreq_8k) &&                                  ((FREQ) <= I2S_AudioFreq_192k)) ||                                  ((FREQ) == I2S_AudioFreq_Default))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_I2S_Clock_Polarity 
N  * @{
N  */
N
N#define I2S_CPOL_Low                    ((uint16_t)0x0000)
N#define I2S_CPOL_High                   SPI_I2SCFGR_CKPOL
N#define IS_I2S_CPOL(CPOL) (((CPOL) == I2S_CPOL_Low) || \
N                           ((CPOL) == I2S_CPOL_High))
X#define IS_I2S_CPOL(CPOL) (((CPOL) == I2S_CPOL_Low) ||                            ((CPOL) == I2S_CPOL_High))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_FIFO_reception_threshold 
N  * @{
N  */
N
N#define SPI_RxFIFOThreshold_HF          ((uint16_t)0x0000)
N#define SPI_RxFIFOThreshold_QF          SPI_CR2_FRXTH
N#define IS_SPI_RX_FIFO_THRESHOLD(THRESHOLD) (((THRESHOLD) == SPI_RxFIFOThreshold_HF) || \
N                                             ((THRESHOLD) == SPI_RxFIFOThreshold_QF))
X#define IS_SPI_RX_FIFO_THRESHOLD(THRESHOLD) (((THRESHOLD) == SPI_RxFIFOThreshold_HF) ||                                              ((THRESHOLD) == SPI_RxFIFOThreshold_QF))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_I2S_DMA_transfer_requests 
N  * @{
N  */
N
N#define SPI_I2S_DMAReq_Tx               SPI_CR2_TXDMAEN
N#define SPI_I2S_DMAReq_Rx               SPI_CR2_RXDMAEN
N#define IS_SPI_I2S_DMA_REQ(REQ) ((((REQ) & (uint16_t)0xFFFC) == 0x00) && ((REQ) != 0x00))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_last_DMA_transfers
N  * @{
N  */
N
N#define SPI_LastDMATransfer_TxEvenRxEven   ((uint16_t)0x0000)
N#define SPI_LastDMATransfer_TxOddRxEven    ((uint16_t)0x4000)
N#define SPI_LastDMATransfer_TxEvenRxOdd    ((uint16_t)0x2000)
N#define SPI_LastDMATransfer_TxOddRxOdd     ((uint16_t)0x6000)
N#define IS_SPI_LAST_DMA_TRANSFER(TRANSFER) (((TRANSFER) == SPI_LastDMATransfer_TxEvenRxEven) || \
N                                            ((TRANSFER) == SPI_LastDMATransfer_TxOddRxEven) || \
N                                            ((TRANSFER) == SPI_LastDMATransfer_TxEvenRxOdd) || \
N                                            ((TRANSFER) == SPI_LastDMATransfer_TxOddRxOdd))
X#define IS_SPI_LAST_DMA_TRANSFER(TRANSFER) (((TRANSFER) == SPI_LastDMATransfer_TxEvenRxEven) ||                                             ((TRANSFER) == SPI_LastDMATransfer_TxOddRxEven) ||                                             ((TRANSFER) == SPI_LastDMATransfer_TxEvenRxOdd) ||                                             ((TRANSFER) == SPI_LastDMATransfer_TxOddRxOdd))
N/**
N  * @}
N  */
N/** @defgroup SPI_NSS_internal_software_management 
N  * @{
N  */
N
N#define SPI_NSSInternalSoft_Set         SPI_CR1_SSI
N#define SPI_NSSInternalSoft_Reset       ((uint16_t)0xFEFF)
N#define IS_SPI_NSS_INTERNAL(INTERNAL) (((INTERNAL) == SPI_NSSInternalSoft_Set) || \
N                                       ((INTERNAL) == SPI_NSSInternalSoft_Reset))
X#define IS_SPI_NSS_INTERNAL(INTERNAL) (((INTERNAL) == SPI_NSSInternalSoft_Set) ||                                        ((INTERNAL) == SPI_NSSInternalSoft_Reset))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_CRC_Transmit_Receive 
N  * @{
N  */
N
N#define SPI_CRC_Tx                      ((uint8_t)0x00)
N#define SPI_CRC_Rx                      ((uint8_t)0x01)
N#define IS_SPI_CRC(CRC) (((CRC) == SPI_CRC_Tx) || ((CRC) == SPI_CRC_Rx))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_direction_transmit_receive 
N  * @{
N  */
N
N#define SPI_Direction_Rx                ((uint16_t)0xBFFF)
N#define SPI_Direction_Tx                ((uint16_t)0x4000)
N#define IS_SPI_DIRECTION(DIRECTION) (((DIRECTION) == SPI_Direction_Rx) || \
N                                     ((DIRECTION) == SPI_Direction_Tx))
X#define IS_SPI_DIRECTION(DIRECTION) (((DIRECTION) == SPI_Direction_Rx) ||                                      ((DIRECTION) == SPI_Direction_Tx))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_I2S_interrupts_definition 
N  * @{
N  */
N
N#define SPI_I2S_IT_TXE                  ((uint8_t)0x71)
N#define SPI_I2S_IT_RXNE                 ((uint8_t)0x60)
N#define SPI_I2S_IT_ERR                  ((uint8_t)0x50)
N
N#define IS_SPI_I2S_CONFIG_IT(IT) (((IT) == SPI_I2S_IT_TXE) || \
N                                  ((IT) == SPI_I2S_IT_RXNE) || \
N                                  ((IT) == SPI_I2S_IT_ERR))
X#define IS_SPI_I2S_CONFIG_IT(IT) (((IT) == SPI_I2S_IT_TXE) ||                                   ((IT) == SPI_I2S_IT_RXNE) ||                                   ((IT) == SPI_I2S_IT_ERR))
N
N#define I2S_IT_UDR                      ((uint8_t)0x53)
N#define SPI_IT_MODF                     ((uint8_t)0x55)
N#define SPI_I2S_IT_OVR                  ((uint8_t)0x56)
N#define SPI_I2S_IT_FRE                  ((uint8_t)0x58)
N
N#define IS_SPI_I2S_GET_IT(IT) (((IT) == SPI_I2S_IT_RXNE) || ((IT) == SPI_I2S_IT_TXE) || \
N                               ((IT) == SPI_I2S_IT_OVR) || ((IT) == SPI_IT_MODF) || \
N                               ((IT) == SPI_I2S_IT_FRE)|| ((IT) == I2S_IT_UDR))
X#define IS_SPI_I2S_GET_IT(IT) (((IT) == SPI_I2S_IT_RXNE) || ((IT) == SPI_I2S_IT_TXE) ||                                ((IT) == SPI_I2S_IT_OVR) || ((IT) == SPI_IT_MODF) ||                                ((IT) == SPI_I2S_IT_FRE)|| ((IT) == I2S_IT_UDR))
N/**
N  * @}
N  */
N
N
N/** @defgroup SPI_transmission_fifo_status_level 
N  * @{
N  */ 
N
N#define SPI_TransmissionFIFOStatus_Empty           ((uint16_t)0x0000)
N#define SPI_TransmissionFIFOStatus_1QuarterFull    ((uint16_t)0x0800) 
N#define SPI_TransmissionFIFOStatus_HalfFull        ((uint16_t)0x1000) 
N#define SPI_TransmissionFIFOStatus_Full            ((uint16_t)0x1800)
N
N/**
N  * @}
N  */ 
N
N/** @defgroup SPI_reception_fifo_status_level 
N  * @{
N  */ 
N#define SPI_ReceptionFIFOStatus_Empty           ((uint16_t)0x0000)
N#define SPI_ReceptionFIFOStatus_1QuarterFull    ((uint16_t)0x0200) 
N#define SPI_ReceptionFIFOStatus_HalfFull        ((uint16_t)0x0400) 
N#define SPI_ReceptionFIFOStatus_Full            ((uint16_t)0x0600)
N
N/**
N  * @}
N  */ 
N
N
N/** @defgroup SPI_I2S_flags_definition 
N  * @{
N  */
N
N#define SPI_I2S_FLAG_RXNE               SPI_SR_RXNE
N#define SPI_I2S_FLAG_TXE                SPI_SR_TXE
N#define I2S_FLAG_CHSIDE                 SPI_SR_CHSIDE
N#define I2S_FLAG_UDR                    SPI_SR_UDR
N#define SPI_FLAG_CRCERR                 SPI_SR_CRCERR
N#define SPI_FLAG_MODF                   SPI_SR_MODF
N#define SPI_I2S_FLAG_OVR                SPI_SR_OVR
N#define SPI_I2S_FLAG_BSY                SPI_SR_BSY
N#define SPI_I2S_FLAG_FRE                SPI_SR_FRE
N
N
N
N#define IS_SPI_CLEAR_FLAG(FLAG) (((FLAG) == SPI_FLAG_CRCERR))
N#define IS_SPI_I2S_GET_FLAG(FLAG) (((FLAG) == SPI_I2S_FLAG_BSY) || ((FLAG) == SPI_I2S_FLAG_OVR) || \
N                                   ((FLAG) == SPI_FLAG_MODF) || ((FLAG) == SPI_FLAG_CRCERR) || \
N                                   ((FLAG) == SPI_I2S_FLAG_TXE) || ((FLAG) == SPI_I2S_FLAG_RXNE)|| \
N                                   ((FLAG) == SPI_I2S_FLAG_FRE)|| ((FLAG) == I2S_FLAG_CHSIDE)|| \
N                                   ((FLAG) == I2S_FLAG_UDR))
X#define IS_SPI_I2S_GET_FLAG(FLAG) (((FLAG) == SPI_I2S_FLAG_BSY) || ((FLAG) == SPI_I2S_FLAG_OVR) ||                                    ((FLAG) == SPI_FLAG_MODF) || ((FLAG) == SPI_FLAG_CRCERR) ||                                    ((FLAG) == SPI_I2S_FLAG_TXE) || ((FLAG) == SPI_I2S_FLAG_RXNE)||                                    ((FLAG) == SPI_I2S_FLAG_FRE)|| ((FLAG) == I2S_FLAG_CHSIDE)||                                    ((FLAG) == I2S_FLAG_UDR))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_CRC_polynomial 
N  * @{
N  */
N
N#define IS_SPI_CRC_POLYNOMIAL(POLYNOMIAL) ((POLYNOMIAL) >= 0x1)
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
N/* Initialization and Configuration functions *********************************/
Nvoid SPI_I2S_DeInit(SPI_TypeDef* SPIx);
Nvoid SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct);
Nvoid SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct);
Nvoid SPI_TIModeCmd(SPI_TypeDef* SPIx, FunctionalState NewState);
Nvoid SPI_NSSPulseModeCmd(SPI_TypeDef* SPIx, FunctionalState NewState);
Nvoid SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState);
Nvoid SPI_DataSizeConfig(SPI_TypeDef* SPIx, uint16_t SPI_DataSize);
Nvoid SPI_RxFIFOThresholdConfig(SPI_TypeDef* SPIx, uint16_t SPI_RxFIFOThreshold);
Nvoid SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction);
Nvoid SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft);
Nvoid SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState);
N
N/* Data transfers functions ***************************************************/
Nvoid SPI_SendData8(SPI_TypeDef* SPIx, uint8_t Data);
Nvoid SPI_I2S_SendData16(SPI_TypeDef* SPIx, uint16_t Data);
Nuint8_t SPI_ReceiveData8(SPI_TypeDef* SPIx);
Nuint16_t SPI_I2S_ReceiveData16(SPI_TypeDef* SPIx);
N
N/* Hardware CRC Calculation functions *****************************************/
Nvoid SPI_CRCLengthConfig(SPI_TypeDef* SPIx, uint16_t SPI_CRCLength);
Nvoid SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState);
Nvoid SPI_TransmitCRC(SPI_TypeDef* SPIx);
Nuint16_t SPI_GetCRC(SPI_TypeDef* SPIx, uint8_t SPI_CRC);
Nuint16_t SPI_GetCRCPolynomial(SPI_TypeDef* SPIx);
N
N/* DMA transfers management functions *****************************************/
Nvoid SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState);
Nvoid SPI_LastDMATransferCmd(SPI_TypeDef* SPIx, uint16_t SPI_LastDMATransfer);
N
N/* Interrupts and flags management functions **********************************/
Nvoid SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState);
Nuint16_t SPI_GetTransmissionFIFOStatus(SPI_TypeDef* SPIx);
Nuint16_t SPI_GetReceptionFIFOStatus(SPI_TypeDef* SPIx);
NFlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG);
Nvoid SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG);
NITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__FT32F0XX_SPI_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT FMD *****END OF FILE****/
L 47 "..\user\main.h" 2
N#include "ft32f0xx_syscfg.h"
L 1 "..\FTLib\Inc\ft32f0xx_syscfg.h" 1
N/**
N  ******************************************************************************
N  * @file    			ft32f0xx_syscfg.h
N  * @author  			FMD AE
N  * @brief   			This file contains all the functions prototypes for the SYSCFG firmware 
N  *          			library.
N  * @version 			V1.0.0           
N  * @data		 			2021-07-01
N  ******************************************************************************
N  */
N
N
N/*!< Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __FT32F0XX_SYSCFG_H
N#define __FT32F0XX_SYSCFG_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/*!< Includes ------------------------------------------------------------------*/
N#include "ft32f0xx.h"
N
N
N/** @addtogroup SYSCFG
N  * @{
N  */
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup SYSCFG_Exported_Constants
N  * @{
N  */ 
N  
N/** @defgroup SYSCFG_EXTI_Port_Sources 
N  * @{
N  */ 
N#define EXTI_PortSourceGPIOA       ((uint8_t)0x00)
N#define EXTI_PortSourceGPIOB       ((uint8_t)0x01)
N#define EXTI_PortSourceGPIOC       ((uint8_t)0x02)
N#define EXTI_PortSourceGPIOD       ((uint8_t)0x03) 
N#define EXTI_PortSourceGPIOE       ((uint8_t)0x04)
N#define EXTI_PortSourceGPIOF       ((uint8_t)0x05)
N
N#define IS_EXTI_PORT_SOURCE(PORTSOURCE) (((PORTSOURCE) == EXTI_PortSourceGPIOA) || \
N                                         ((PORTSOURCE) == EXTI_PortSourceGPIOB) || \
N                                         ((PORTSOURCE) == EXTI_PortSourceGPIOC) || \
N                                         ((PORTSOURCE) == EXTI_PortSourceGPIOD) || \
N                                         ((PORTSOURCE) == EXTI_PortSourceGPIOE) || \
N                                         ((PORTSOURCE) == EXTI_PortSourceGPIOF)) 
X#define IS_EXTI_PORT_SOURCE(PORTSOURCE) (((PORTSOURCE) == EXTI_PortSourceGPIOA) ||                                          ((PORTSOURCE) == EXTI_PortSourceGPIOB) ||                                          ((PORTSOURCE) == EXTI_PortSourceGPIOC) ||                                          ((PORTSOURCE) == EXTI_PortSourceGPIOD) ||                                          ((PORTSOURCE) == EXTI_PortSourceGPIOE) ||                                          ((PORTSOURCE) == EXTI_PortSourceGPIOF)) 
N/**
N  * @}
N  */
N
N/** @defgroup SYSCFG_EXTI_Pin_sources 
N  * @{
N  */ 
N#define EXTI_PinSource0            ((uint8_t)0x00)
N#define EXTI_PinSource1            ((uint8_t)0x01)
N#define EXTI_PinSource2            ((uint8_t)0x02)
N#define EXTI_PinSource3            ((uint8_t)0x03)
N#define EXTI_PinSource4            ((uint8_t)0x04)
N#define EXTI_PinSource5            ((uint8_t)0x05)
N#define EXTI_PinSource6            ((uint8_t)0x06)
N#define EXTI_PinSource7            ((uint8_t)0x07)
N#define EXTI_PinSource8            ((uint8_t)0x08)
N#define EXTI_PinSource9            ((uint8_t)0x09)
N#define EXTI_PinSource10           ((uint8_t)0x0A)
N#define EXTI_PinSource11           ((uint8_t)0x0B)
N#define EXTI_PinSource12           ((uint8_t)0x0C)
N#define EXTI_PinSource13           ((uint8_t)0x0D)
N#define EXTI_PinSource14           ((uint8_t)0x0E)
N#define EXTI_PinSource15           ((uint8_t)0x0F)
N
N#define IS_EXTI_PIN_SOURCE(PINSOURCE) (((PINSOURCE) == EXTI_PinSource0) || \
N                                       ((PINSOURCE) == EXTI_PinSource1) || \
N                                       ((PINSOURCE) == EXTI_PinSource2) || \
N                                       ((PINSOURCE) == EXTI_PinSource3) || \
N                                       ((PINSOURCE) == EXTI_PinSource4) || \
N                                       ((PINSOURCE) == EXTI_PinSource5) || \
N                                       ((PINSOURCE) == EXTI_PinSource6) || \
N                                       ((PINSOURCE) == EXTI_PinSource7) || \
N                                       ((PINSOURCE) == EXTI_PinSource8) || \
N                                       ((PINSOURCE) == EXTI_PinSource9) || \
N                                       ((PINSOURCE) == EXTI_PinSource10) || \
N                                       ((PINSOURCE) == EXTI_PinSource11) || \
N                                       ((PINSOURCE) == EXTI_PinSource12) || \
N                                       ((PINSOURCE) == EXTI_PinSource13) || \
N                                       ((PINSOURCE) == EXTI_PinSource14) || \
N                                       ((PINSOURCE) == EXTI_PinSource15))
X#define IS_EXTI_PIN_SOURCE(PINSOURCE) (((PINSOURCE) == EXTI_PinSource0) ||                                        ((PINSOURCE) == EXTI_PinSource1) ||                                        ((PINSOURCE) == EXTI_PinSource2) ||                                        ((PINSOURCE) == EXTI_PinSource3) ||                                        ((PINSOURCE) == EXTI_PinSource4) ||                                        ((PINSOURCE) == EXTI_PinSource5) ||                                        ((PINSOURCE) == EXTI_PinSource6) ||                                        ((PINSOURCE) == EXTI_PinSource7) ||                                        ((PINSOURCE) == EXTI_PinSource8) ||                                        ((PINSOURCE) == EXTI_PinSource9) ||                                        ((PINSOURCE) == EXTI_PinSource10) ||                                        ((PINSOURCE) == EXTI_PinSource11) ||                                        ((PINSOURCE) == EXTI_PinSource12) ||                                        ((PINSOURCE) == EXTI_PinSource13) ||                                        ((PINSOURCE) == EXTI_PinSource14) ||                                        ((PINSOURCE) == EXTI_PinSource15))
N/**
N  * @}
N  */
N
N/** @defgroup SYSCFG_Memory_Remap_Config 
N  * @{
N  */ 
N#define SYSCFG_MemoryRemap_Flash                ((uint8_t)0x00)
N#define SYSCFG_MemoryRemap_SystemMemory         ((uint8_t)0x01)
N#define SYSCFG_MemoryRemap_SRAM                 ((uint8_t)0x03)
N
N
N#define IS_SYSCFG_MEMORY_REMAP(REMAP) (((REMAP) == SYSCFG_MemoryRemap_Flash) || \
N                                       ((REMAP) == SYSCFG_MemoryRemap_SystemMemory) || \
N                                       ((REMAP) == SYSCFG_MemoryRemap_SRAM))
X#define IS_SYSCFG_MEMORY_REMAP(REMAP) (((REMAP) == SYSCFG_MemoryRemap_Flash) ||                                        ((REMAP) == SYSCFG_MemoryRemap_SystemMemory) ||                                        ((REMAP) == SYSCFG_MemoryRemap_SRAM))
N
N/**
N  * @}
N  */
N
N/** @defgroup SYSCFG_DMA_Remap_Config 
N  * @{
N  */ 
N#define SYSCFG_DMARemap_TIM3        SYSCFG_CFGR1_TIM3_DMA_RMP      /* Remap TIM3 DMA requests from channel4 to channel6*/
N#define SYSCFG_DMARemap_TIM2        SYSCFG_CFGR1_TIM2_DMA_RMP      /* Remap TIM2 DMA requests from channel3/4 to channel7*/ 
N#define SYSCFG_DMARemap_TIM1        SYSCFG_CFGR1_TIM1_DMA_RMP      /* Remap TIM1 DMA requests from channel2/3/4 to channel6*/
N#define SYSCFG_DMARemap_I2C1        SYSCFG_CFGR1_I2C1_DMA_RMP      /* Remap I2C1 DMA requests from channel3/2 to channel7/6*/
N#define SYSCFG_DMARemap_USART3      SYSCFG_CFGR1_USART3_DMA_RMP    /* Remap USART3 DMA requests from channel6/7 to channel3/2*/
N#define SYSCFG_DMARemap_USART2      SYSCFG_CFGR1_USART2_DMA_RMP    /* Remap USART2 DMA requests from channel4/5 to channel6/7*/
N#define SYSCFG_DMARemap_SPI2        SYSCFG_CFGR1_SPI2_DMA_RMP      /* Remap SPI2 DMA requests from channel4/5 to channel6/7*/
N#define SYSCFG_DMARemap_TIM17_2     SYSCFG_CFGR1_TIM17_DMA_RMP2    /* Remap TIM17 DMA requests from channel1/2 to channel7*/
N#define SYSCFG_DMARemap_TIM16_2     SYSCFG_CFGR1_TIM16_DMA_RMP2    /* Remap TIM16 DMA requests from channel3/4 to channel6*/
N#define SYSCFG_DMARemap_TIM17       SYSCFG_CFGR1_TIM17_DMA_RMP     /* Remap TIM17 DMA requests from channel1 to channel2*/
N#define SYSCFG_DMARemap_TIM16       SYSCFG_CFGR1_TIM16_DMA_RMP     /* Remap TIM16 DMA requests from channel3 to channel4*/
N#define SYSCFG_DMARemap_USART1Rx    SYSCFG_CFGR1_USART1RX_DMA_RMP  /* Remap USART1 Rx DMA requests from channel3 to channel5*/
N#define SYSCFG_DMARemap_USART1Tx    SYSCFG_CFGR1_USART1TX_DMA_RMP  /* Remap USART1 Tx DMA requests from channel2 to channel4*/
N#define SYSCFG_DMARemap_ADC1        SYSCFG_CFGR1_ADC_DMA_RMP       /* Remap ADC1 DMA requests from channel1 to channel2*/
N  
N#define IS_SYSCFG_DMA_REMAP(REMAP) (((REMAP) == SYSCFG_DMARemap_TIM17) || \
N                                    ((REMAP) == SYSCFG_DMARemap_TIM16) || \
N                                    ((REMAP) == SYSCFG_DMARemap_USART1Rx) || \
N                                    ((REMAP) == SYSCFG_DMARemap_USART1Tx) || \
N                                    ((REMAP) == SYSCFG_CFGR1_TIM3_DMA_RMP) || \
N                                    ((REMAP) == SYSCFG_CFGR1_TIM2_DMA_RMP) || \
N                                    ((REMAP) == SYSCFG_CFGR1_TIM1_DMA_RMP) || \
N                                    ((REMAP) == SYSCFG_CFGR1_I2C1_DMA_RMP) || \
N                                    ((REMAP) == SYSCFG_CFGR1_USART3_DMA_RMP) || \
N                                    ((REMAP) == SYSCFG_CFGR1_USART2_DMA_RMP) || \
N                                    ((REMAP) == SYSCFG_CFGR1_SPI2_DMA_RMP) || \
N                                    ((REMAP) == SYSCFG_CFGR1_TIM17_DMA_RMP2) || \
N                                    ((REMAP) == SYSCFG_CFGR1_TIM16_DMA_RMP2) || \
N                                    ((REMAP) == SYSCFG_DMARemap_ADC1))
X#define IS_SYSCFG_DMA_REMAP(REMAP) (((REMAP) == SYSCFG_DMARemap_TIM17) ||                                     ((REMAP) == SYSCFG_DMARemap_TIM16) ||                                     ((REMAP) == SYSCFG_DMARemap_USART1Rx) ||                                     ((REMAP) == SYSCFG_DMARemap_USART1Tx) ||                                     ((REMAP) == SYSCFG_CFGR1_TIM3_DMA_RMP) ||                                     ((REMAP) == SYSCFG_CFGR1_TIM2_DMA_RMP) ||                                     ((REMAP) == SYSCFG_CFGR1_TIM1_DMA_RMP) ||                                     ((REMAP) == SYSCFG_CFGR1_I2C1_DMA_RMP) ||                                     ((REMAP) == SYSCFG_CFGR1_USART3_DMA_RMP) ||                                     ((REMAP) == SYSCFG_CFGR1_USART2_DMA_RMP) ||                                     ((REMAP) == SYSCFG_CFGR1_SPI2_DMA_RMP) ||                                     ((REMAP) == SYSCFG_CFGR1_TIM17_DMA_RMP2) ||                                     ((REMAP) == SYSCFG_CFGR1_TIM16_DMA_RMP2) ||                                     ((REMAP) == SYSCFG_DMARemap_ADC1))
N
N/**
N  * @}
N  */
N
N/** @defgroup SYSCFG_I2C_FastModePlus_Config 
N  * @{
N  */ 
N#define SYSCFG_I2CFastModePlus_PB6       SYSCFG_CFGR1_I2C_FMP_PB6 /* Enable Fast Mode Plus on PB6 */
N#define SYSCFG_I2CFastModePlus_PB7       SYSCFG_CFGR1_I2C_FMP_PB7 /* Enable Fast Mode Plus on PB7 */
N#define SYSCFG_I2CFastModePlus_PB8       SYSCFG_CFGR1_I2C_FMP_PB8 /* Enable Fast Mode Plus on PB8 */
N#define SYSCFG_I2CFastModePlus_PB9       SYSCFG_CFGR1_I2C_FMP_PB9 /* Enable Fast Mode Plus on PB9 */
N#define SYSCFG_I2CFastModePlus_I2C1      SYSCFG_CFGR1_I2C_FMP_I2C1 /* Enable Fast Mode Plus on PB10, PB11, PF6 and PF7*/
N#define SYSCFG_I2CFastModePlus_I2C2      SYSCFG_CFGR1_I2C_FMP_I2C2 /* Enable Fast Mode Plus on I2C2 pins*/
N#define SYSCFG_I2CFastModePlus_PA9       SYSCFG_CFGR1_I2C_FMP_PA9 /* Enable Fast Mode Plus on PA9*/
N#define SYSCFG_I2CFastModePlus_PA10      SYSCFG_CFGR1_I2C_FMP_PA10/* Enable Fast Mode Plus on PA10*/
N
N#define IS_SYSCFG_I2C_FMP(PIN) (((PIN) == SYSCFG_I2CFastModePlus_PB6)  || \
N                                ((PIN) == SYSCFG_I2CFastModePlus_PB7)  || \
N                                ((PIN) == SYSCFG_I2CFastModePlus_PB8)  || \
N                                ((PIN) == SYSCFG_I2CFastModePlus_PB9)  || \
N                                ((PIN) == SYSCFG_I2CFastModePlus_I2C1) || \
N                                ((PIN) == SYSCFG_I2CFastModePlus_I2C2) || \
N                                ((PIN) == SYSCFG_I2CFastModePlus_PA9)  || \
N                                ((PIN) == SYSCFG_I2CFastModePlus_PA10))
X#define IS_SYSCFG_I2C_FMP(PIN) (((PIN) == SYSCFG_I2CFastModePlus_PB6)  ||                                 ((PIN) == SYSCFG_I2CFastModePlus_PB7)  ||                                 ((PIN) == SYSCFG_I2CFastModePlus_PB8)  ||                                 ((PIN) == SYSCFG_I2CFastModePlus_PB9)  ||                                 ((PIN) == SYSCFG_I2CFastModePlus_I2C1) ||                                 ((PIN) == SYSCFG_I2CFastModePlus_I2C2) ||                                 ((PIN) == SYSCFG_I2CFastModePlus_PA9)  ||                                 ((PIN) == SYSCFG_I2CFastModePlus_PA10))
N
N
N/**
N  * @}
N  */
N
N/** @defgroup SYSCFG_Lock_Config 
N  * @{
N  */ 
N#define SYSCFG_Break_PVD                     SYSCFG_CFGR2_PVD_LOCK       /*!< Connects the PVD event to the Break Input of TIM1 */
N#define SYSCFG_Break_Lockup                  SYSCFG_CFGR2_LOCKUP_LOCK       /*!< Connects Lockup output of CortexM0 to the break input of TIM1 */
N
N#define IS_SYSCFG_LOCK_CONFIG(CONFIG) (((CONFIG) == SYSCFG_Break_PVD)        || \
N                                       ((CONFIG) == SYSCFG_Break_Lockup))
X#define IS_SYSCFG_LOCK_CONFIG(CONFIG) (((CONFIG) == SYSCFG_Break_PVD)        ||                                        ((CONFIG) == SYSCFG_Break_Lockup))
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/** @defgroup SYSCFG_ISR_WRAPPER
N  * @{
N  */
N#define SYSCFG_ITLINE0                           ((uint32_t) 0x00000000)
N#define SYSCFG_ITLINE1                           ((uint32_t) 0x00000001)
N#define SYSCFG_ITLINE2                           ((uint32_t) 0x00000002)
N#define SYSCFG_ITLINE3                           ((uint32_t) 0x00000003)
N#define SYSCFG_ITLINE4                           ((uint32_t) 0x00000004)
N#define SYSCFG_ITLINE5                           ((uint32_t) 0x00000005)
N#define SYSCFG_ITLINE6                           ((uint32_t) 0x00000006)
N#define SYSCFG_ITLINE7                           ((uint32_t) 0x00000007)
N#define SYSCFG_ITLINE8                           ((uint32_t) 0x00000008)
N#define SYSCFG_ITLINE9                           ((uint32_t) 0x00000009)
N#define SYSCFG_ITLINE10                          ((uint32_t) 0x0000000A)
N#define SYSCFG_ITLINE11                          ((uint32_t) 0x0000000B)
N#define SYSCFG_ITLINE12                          ((uint32_t) 0x0000000C)
N#define SYSCFG_ITLINE13                          ((uint32_t) 0x0000000D)
N#define SYSCFG_ITLINE14                          ((uint32_t) 0x0000000E)
N#define SYSCFG_ITLINE15                          ((uint32_t) 0x0000000F)
N#define SYSCFG_ITLINE16                          ((uint32_t) 0x00000010)
N#define SYSCFG_ITLINE17                          ((uint32_t) 0x00000011)
N#define SYSCFG_ITLINE18                          ((uint32_t) 0x00000012)
N#define SYSCFG_ITLINE19                          ((uint32_t) 0x00000013)
N#define SYSCFG_ITLINE20                          ((uint32_t) 0x00000014)
N#define SYSCFG_ITLINE21                          ((uint32_t) 0x00000015)
N#define SYSCFG_ITLINE22                          ((uint32_t) 0x00000016)
N#define SYSCFG_ITLINE23                          ((uint32_t) 0x00000017)
N#define SYSCFG_ITLINE24                          ((uint32_t) 0x00000018)
N#define SYSCFG_ITLINE25                          ((uint32_t) 0x00000019)
N#define SYSCFG_ITLINE26                          ((uint32_t) 0x0000001A)
N#define SYSCFG_ITLINE27                          ((uint32_t) 0x0000001B)
N#define SYSCFG_ITLINE28                          ((uint32_t) 0x0000001C)
N#define SYSCFG_ITLINE29                          ((uint32_t) 0x0000001D)
N#define SYSCFG_ITLINE30                          ((uint32_t) 0x0000001E)
N#define SYSCFG_ITLINE31                          ((uint32_t) 0x0000001F)
N
N/**
N  * @}
N  */
N/** @defgroup IRDA_ENV_SEL
N  * @{
N  */
N#define SYSCFG_IRDA_ENV_SEL_TIM16     (SYSCFG_CFGR1_IRDA_ENV_SEL_0&SYSCFG_CFGR1_IRDA_ENV_SEL_1)    /* Timer16 is selected as IRDA Modulation envelope source */
N#define SYSCFG_IRDA_ENV_SEL_USART1    (SYSCFG_CFGR1_IRDA_ENV_SEL_0)  /* USART1 is selected as IRDA Modulation envelope source.*/
N#define SYSCFG_IRDA_ENV_SEL_USART2    (SYSCFG_CFGR1_IRDA_ENV_SEL_1)  /* USART2 is selected as IRDA Modulation envelope source.*/
N
N#define IS_SYSCFG_IRDA_ENV(ENV) (((ENV) == SYSCFG_IRDA_ENV_SEL_TIM16)      || \
N                                 ((ENV) == SYSCFG_IRDA_ENV_SEL_USART1)     || \
N                                 ((ENV) == SYSCFG_IRDA_ENV_SEL_USART2))
X#define IS_SYSCFG_IRDA_ENV(ENV) (((ENV) == SYSCFG_IRDA_ENV_SEL_TIM16)      ||                                  ((ENV) == SYSCFG_IRDA_ENV_SEL_USART1)     ||                                  ((ENV) == SYSCFG_IRDA_ENV_SEL_USART2))
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
N/*  Function used to set the SYSCFG configuration to the default reset state **/
Nvoid SYSCFG_DeInit(void);
N
N/* SYSCFG configuration functions *********************************************/ 
Nvoid SYSCFG_MemoryRemapConfig(uint32_t SYSCFG_MemoryRemap);
Nvoid SYSCFG_DMAChannelRemapConfig(uint32_t SYSCFG_DMARemap, FunctionalState NewState);
Nvoid SYSCFG_I2CFastModePlusConfig(uint32_t SYSCFG_I2CFastModePlus, FunctionalState NewState);
Nvoid SYSCFG_IRDAEnvSelection(uint32_t SYSCFG_IRDAEnv);
Nvoid SYSCFG_EXTILineConfig(uint8_t EXTI_PortSourceGPIOx, uint8_t EXTI_PinSourcex);
Nvoid SYSCFG_BreakConfig(uint32_t SYSCFG_Break);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__FT32F0XX_SYSCFG_H */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/************************ (C) COPYRIGHT FMD *****END OF FILE****/
L 48 "..\user\main.h" 2
N#include "ft32f0xx_tim.h"
L 1 "..\FTLib\Inc\ft32f0xx_tim.h" 1
N/**
N  ******************************************************************************
N  * @file    			ft32f0xx_tim.h
N  * @author  			FMD AE
N  * @brief   			This file contains all the functions prototypes for the TIM 
N  *          			firmware library. 
N  * @version 			V1.0.0           
N  * @data		 			2021-07-01
N  ******************************************************************************
N  */
N
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __FT32F0XX_TIM_H
N#define __FT32F0XX_TIM_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "ft32f0xx.h"
N
N
N/** @addtogroup TIM
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief  TIM Time Base Init structure definition
N  * @note   This sturcture is used with all TIMx.
N  */
N
Ntypedef struct
N{
N  uint16_t TIM_Prescaler;         /*!< Specifies the prescaler value used to divide the TIM clock.
N                                       This parameter can be a number between 0x0000 and 0xFFFF */
N
N  uint16_t TIM_CounterMode;       /*!< Specifies the counter mode.
N                                       This parameter can be a value of @ref TIM_Counter_Mode */
N
N  uint32_t TIM_Period;            /*!< Specifies the period value to be loaded into the active
N                                       Auto-Reload Register at the next update event.
N                                       This parameter must be a number between 0x0000 and 0xFFFF.  */ 
N
N  uint16_t TIM_ClockDivision;     /*!< Specifies the clock division.
N                                      This parameter can be a value of @ref TIM_Clock_Division_CKD */
N
N  uint8_t TIM_RepetitionCounter;  /*!< Specifies the repetition counter value. Each time the RCR downcounter
N                                       reaches zero, an update event is generated and counting restarts
N                                       from the RCR value (N).
N                                       This means in PWM mode that (N+1) corresponds to:
N                                          - the number of PWM periods in edge-aligned mode
N                                          - the number of half PWM period in center-aligned mode
N                                       This parameter must be a number between 0x00 and 0xFF. 
N                                       @note This parameter is valid only for TIM1. */
N} TIM_TimeBaseInitTypeDef;       
N
N/** 
N  * @brief  TIM Output Compare Init structure definition  
N  */
N
Ntypedef struct
N{
N  uint16_t TIM_OCMode;        /*!< Specifies the TIM mode.
N                                   This parameter can be a value of @ref TIM_Output_Compare_and_PWM_modes */
N
N  uint16_t TIM_OutputState;   /*!< Specifies the TIM Output Compare state.
N                                   This parameter can be a value of @ref TIM_Output_Compare_state */
N
N  uint16_t TIM_OutputNState;  /*!< Specifies the TIM complementary Output Compare state.
N                                   This parameter can be a value of @ref TIM_Output_Compare_N_state
N                                   @note This parameter is valid only for TIM1. */
N
N  uint32_t TIM_Pulse;         /*!< Specifies the pulse value to be loaded into the Capture Compare Register. 
N                                   This parameter can be a number between 0x0000 and 0xFFFF ( or 0xFFFFFFFF 
N                                   for TIM2) */
N
N  uint16_t TIM_OCPolarity;    /*!< Specifies the output polarity.
N                                   This parameter can be a value of @ref TIM_Output_Compare_Polarity */
N
N  uint16_t TIM_OCNPolarity;   /*!< Specifies the complementary output polarity.
N                                   This parameter can be a value of @ref TIM_Output_Compare_N_Polarity
N                                   @note This parameter is valid only for TIM1. */
N
N  uint16_t TIM_OCIdleState;   /*!< Specifies the TIM Output Compare pin state during Idle state.
N                                   This parameter can be a value of @ref TIM_Output_Compare_Idle_State
N                                   @note This parameter is valid only for TIM1. */
N
N  uint16_t TIM_OCNIdleState;  /*!< Specifies the TIM Output Compare pin state during Idle state.
N                                   This parameter can be a value of @ref TIM_Output_Compare_N_Idle_State
N                                   @note This parameter is valid only for TIM1. */
N} TIM_OCInitTypeDef;
N
N/** 
N  * @brief  TIM Input Capture Init structure definition  
N  */
N
Ntypedef struct
N{
N
N  uint16_t TIM_Channel;      /*!< Specifies the TIM channel.
N                                  This parameter can be a value of @ref TIM_Channel */
N
N  uint16_t TIM_ICPolarity;   /*!< Specifies the active edge of the input signal.
N                                  This parameter can be a value of @ref TIM_Input_Capture_Polarity */
N
N  uint16_t TIM_ICSelection;  /*!< Specifies the input.
N                                  This parameter can be a value of @ref TIM_Input_Capture_Selection */
N
N  uint16_t TIM_ICPrescaler;  /*!< Specifies the Input Capture Prescaler.
N                                  This parameter can be a value of @ref TIM_Input_Capture_Prescaler */
N
N  uint16_t TIM_ICFilter;     /*!< Specifies the input capture filter.
N                                  This parameter can be a number between 0x0 and 0xF */
N} TIM_ICInitTypeDef;
N
N/** 
N  * @brief  TIM_BDTR structure definition 
N  * @note   This sturcture is used only with TIM1.    
N  */
N
Ntypedef struct
N{
N
N  uint16_t TIM_OSSRState;        /*!< Specifies the Off-State selection used in Run mode.
N                                      This parameter can be a value of @ref TIM_OSSR_Off_State_Selection_for_Run_mode_state */
N
N  uint16_t TIM_OSSIState;        /*!< Specifies the Off-State used in Idle state.
N                                      This parameter can be a value of @ref TIM_OSSI_Off_State_Selection_for_Idle_mode_state */
N
N  uint16_t TIM_LOCKLevel;        /*!< Specifies the LOCK level parameters.
N                                      This parameter can be a value of @ref TIM_Lock_level */ 
N
N  uint16_t TIM_DeadTime;         /*!< Specifies the delay time between the switching-off and the
N                                      switching-on of the outputs.
N                                      This parameter can be a number between 0x00 and 0xFF  */
N
N  uint16_t TIM_Break;            /*!< Specifies whether the TIM Break input is enabled or not. 
N                                      This parameter can be a value of @ref TIM_Break_Input_enable_disable */
N
N  uint16_t TIM_BreakPolarity;    /*!< Specifies the TIM Break Input pin polarity.
N                                      This parameter can be a value of @ref TIM_Break_Polarity */
N
N  uint16_t TIM_AutomaticOutput;  /*!< Specifies whether the TIM Automatic Output feature is enabled or not. 
N                                      This parameter can be a value of @ref TIM_AOE_Bit_Set_Reset */
N} TIM_BDTRInitTypeDef;
N
N/** 
N  * @brief  TIM Input Capture Init structure definition  
N  */
N
N/* Exported constants --------------------------------------------------------*/
N
N  
N/** @defgroup TIM_Exported_constants 
N  * @{
N  */
N
N#define IS_TIM_ALL_PERIPH(PERIPH) (((PERIPH) == TIM1) || \
N                                   ((PERIPH) == TIM2) || \
N                                   ((PERIPH) == TIM3) || \
N                                   ((PERIPH) == TIM6) || \
N                                   ((PERIPH) == TIM7) || \
N                                   ((PERIPH) == TIM14)|| \
N                                   ((PERIPH) == TIM15)|| \
N                                   ((PERIPH) == TIM16)|| \
N                                   ((PERIPH) == TIM17))
X#define IS_TIM_ALL_PERIPH(PERIPH) (((PERIPH) == TIM1) ||                                    ((PERIPH) == TIM2) ||                                    ((PERIPH) == TIM3) ||                                    ((PERIPH) == TIM6) ||                                    ((PERIPH) == TIM7) ||                                    ((PERIPH) == TIM14)||                                    ((PERIPH) == TIM15)||                                    ((PERIPH) == TIM16)||                                    ((PERIPH) == TIM17))
N
N/* LIST1: TIM 1 */
N#define IS_TIM_LIST1_PERIPH(PERIPH)  ((PERIPH) == TIM1)
N
N/* LIST2: TIM 1, 15, 16 and 17 */
N#define IS_TIM_LIST2_PERIPH(PERIPH) (((PERIPH) == TIM1) || \
N                                     ((PERIPH) == TIM15)|| \
N                                     ((PERIPH) == TIM16)|| \
N                                     ((PERIPH) == TIM17)) 
X#define IS_TIM_LIST2_PERIPH(PERIPH) (((PERIPH) == TIM1) ||                                      ((PERIPH) == TIM15)||                                      ((PERIPH) == TIM16)||                                      ((PERIPH) == TIM17)) 
N
N/* LIST3: TIM 1, 2 and 3 */
N#define IS_TIM_LIST3_PERIPH(PERIPH) (((PERIPH) == TIM1) || \
N                                     ((PERIPH) == TIM2) || \
N                                     ((PERIPH) == TIM3)) 
X#define IS_TIM_LIST3_PERIPH(PERIPH) (((PERIPH) == TIM1) ||                                      ((PERIPH) == TIM2) ||                                      ((PERIPH) == TIM3)) 
N
N/* LIST4: TIM 1, 2, 3, 14, 15, 16 and 17 */
N#define IS_TIM_LIST4_PERIPH(PERIPH) (((PERIPH) == TIM1) || \
N                                     ((PERIPH) == TIM2) || \
N                                     ((PERIPH) == TIM3) || \
N                                     ((PERIPH) == TIM14) || \
N                                     ((PERIPH) == TIM15)|| \
N                                     ((PERIPH) == TIM16)|| \
N                                     ((PERIPH) == TIM17))
X#define IS_TIM_LIST4_PERIPH(PERIPH) (((PERIPH) == TIM1) ||                                      ((PERIPH) == TIM2) ||                                      ((PERIPH) == TIM3) ||                                      ((PERIPH) == TIM14) ||                                      ((PERIPH) == TIM15)||                                      ((PERIPH) == TIM16)||                                      ((PERIPH) == TIM17))
N
N/* LIST5: TIM 1, 2, 3, 15, 16 and 17 */
N#define IS_TIM_LIST5_PERIPH(PERIPH) (((PERIPH) == TIM1) || \
N                                     ((PERIPH) == TIM2) || \
N                                     ((PERIPH) == TIM3) || \
N                                     ((PERIPH) == TIM15)|| \
N                                     ((PERIPH) == TIM16)|| \
N                                     ((PERIPH) == TIM17))
X#define IS_TIM_LIST5_PERIPH(PERIPH) (((PERIPH) == TIM1) ||                                      ((PERIPH) == TIM2) ||                                      ((PERIPH) == TIM3) ||                                      ((PERIPH) == TIM15)||                                      ((PERIPH) == TIM16)||                                      ((PERIPH) == TIM17))
N
N/* LIST6: TIM 1, 2, 3 and 15 */
N#define IS_TIM_LIST6_PERIPH(PERIPH) (((PERIPH) == TIM1) || \
N                                     ((PERIPH) == TIM2) || \
N                                     ((PERIPH) == TIM3) || \
N                                     ((PERIPH) == TIM15)) 
X#define IS_TIM_LIST6_PERIPH(PERIPH) (((PERIPH) == TIM1) ||                                      ((PERIPH) == TIM2) ||                                      ((PERIPH) == TIM3) ||                                      ((PERIPH) == TIM15)) 
N
N/* LIST7: TIM 1, 2, 3, 6, 7 and 14 */
N#define IS_TIM_LIST7_PERIPH(PERIPH)  (((PERIPH) == TIM1) || \
N                                      ((PERIPH) == TIM2) || \
N                                      ((PERIPH) == TIM3) || \
N                                      ((PERIPH) == TIM6) || \
N                                      ((PERIPH) == TIM7) || \
N                                      ((PERIPH) == TIM14))
X#define IS_TIM_LIST7_PERIPH(PERIPH)  (((PERIPH) == TIM1) ||                                       ((PERIPH) == TIM2) ||                                       ((PERIPH) == TIM3) ||                                       ((PERIPH) == TIM6) ||                                       ((PERIPH) == TIM7) ||                                       ((PERIPH) == TIM14))
N                                      
N/* LIST8: TIM 1, 2, 3 and 14 */
N#define IS_TIM_LIST8_PERIPH(PERIPH)  (((PERIPH) == TIM1) || \
N                                      ((PERIPH) == TIM2) || \
N                                      ((PERIPH) == TIM3) || \
N                                      ((PERIPH) == TIM14))
X#define IS_TIM_LIST8_PERIPH(PERIPH)  (((PERIPH) == TIM1) ||                                       ((PERIPH) == TIM2) ||                                       ((PERIPH) == TIM3) ||                                       ((PERIPH) == TIM14))
N
N/* LIST9: TIM 1, 2, 3, 6, 7 and 15 */
N#define IS_TIM_LIST9_PERIPH(PERIPH)  (((PERIPH) == TIM1) || \
N                                      ((PERIPH) == TIM2) || \
N                                      ((PERIPH) == TIM3) || \
N                                      ((PERIPH) == TIM6) || \
N                                      ((PERIPH) == TIM7) || \
N                                      ((PERIPH) == TIM15))
X#define IS_TIM_LIST9_PERIPH(PERIPH)  (((PERIPH) == TIM1) ||                                       ((PERIPH) == TIM2) ||                                       ((PERIPH) == TIM3) ||                                       ((PERIPH) == TIM6) ||                                       ((PERIPH) == TIM7) ||                                       ((PERIPH) == TIM15))
N
N/* LIST10: TIM 1, 2, 3, 6, 7, 15, 16 and 17 */
N#define IS_TIM_LIST10_PERIPH(PERIPH) (((PERIPH) == TIM1) || \
N                                     ((PERIPH) == TIM2) || \
N                                     ((PERIPH) == TIM3) || \
N                                     ((PERIPH) == TIM6) || \
N                                     ((PERIPH) == TIM7) || \
N                                     ((PERIPH) == TIM15)|| \
N                                     ((PERIPH) == TIM16)|| \
N                                     ((PERIPH) == TIM17))
X#define IS_TIM_LIST10_PERIPH(PERIPH) (((PERIPH) == TIM1) ||                                      ((PERIPH) == TIM2) ||                                      ((PERIPH) == TIM3) ||                                      ((PERIPH) == TIM6) ||                                      ((PERIPH) == TIM7) ||                                      ((PERIPH) == TIM15)||                                      ((PERIPH) == TIM16)||                                      ((PERIPH) == TIM17))
N
N/* LIST1: TIM 11 */
N#define IS_TIM_LIST11_PERIPH(PERIPH)  ((PERIPH) == TIM14)
N                                     
N
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Output_Compare_and_PWM_modes 
N  * @{
N  */
N
N#define TIM_OCMode_Timing                  ((uint16_t)0x0000)
N#define TIM_OCMode_Active                  ((uint16_t)0x0010)
N#define TIM_OCMode_Inactive                ((uint16_t)0x0020)
N#define TIM_OCMode_Toggle                  ((uint16_t)0x0030)
N#define TIM_OCMode_PWM1                    ((uint16_t)0x0060)
N#define TIM_OCMode_PWM2                    ((uint16_t)0x0070)
N#define IS_TIM_OC_MODE(MODE) (((MODE) == TIM_OCMode_Timing) || \
N                              ((MODE) == TIM_OCMode_Active) || \
N                              ((MODE) == TIM_OCMode_Inactive) || \
N                              ((MODE) == TIM_OCMode_Toggle)|| \
N                              ((MODE) == TIM_OCMode_PWM1) || \
N                              ((MODE) == TIM_OCMode_PWM2))
X#define IS_TIM_OC_MODE(MODE) (((MODE) == TIM_OCMode_Timing) ||                               ((MODE) == TIM_OCMode_Active) ||                               ((MODE) == TIM_OCMode_Inactive) ||                               ((MODE) == TIM_OCMode_Toggle)||                               ((MODE) == TIM_OCMode_PWM1) ||                               ((MODE) == TIM_OCMode_PWM2))
N#define IS_TIM_OCM(MODE) (((MODE) == TIM_OCMode_Timing) || \
N                          ((MODE) == TIM_OCMode_Active) || \
N                          ((MODE) == TIM_OCMode_Inactive) || \
N                          ((MODE) == TIM_OCMode_Toggle)|| \
N                          ((MODE) == TIM_OCMode_PWM1) || \
N                          ((MODE) == TIM_OCMode_PWM2) ||	\
N                          ((MODE) == TIM_ForcedAction_Active) || \
N                          ((MODE) == TIM_ForcedAction_InActive))
X#define IS_TIM_OCM(MODE) (((MODE) == TIM_OCMode_Timing) ||                           ((MODE) == TIM_OCMode_Active) ||                           ((MODE) == TIM_OCMode_Inactive) ||                           ((MODE) == TIM_OCMode_Toggle)||                           ((MODE) == TIM_OCMode_PWM1) ||                           ((MODE) == TIM_OCMode_PWM2) ||	                          ((MODE) == TIM_ForcedAction_Active) ||                           ((MODE) == TIM_ForcedAction_InActive))
N/**
N  * @}
N  */
N
N/** @defgroup TIM_One_Pulse_Mode 
N  * @{
N  */
N
N#define TIM_OPMode_Single                  ((uint16_t)0x0008)
N#define TIM_OPMode_Repetitive              ((uint16_t)0x0000)
N#define IS_TIM_OPM_MODE(MODE) (((MODE) == TIM_OPMode_Single) || \
N                               ((MODE) == TIM_OPMode_Repetitive))
X#define IS_TIM_OPM_MODE(MODE) (((MODE) == TIM_OPMode_Single) ||                                ((MODE) == TIM_OPMode_Repetitive))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Channel 
N  * @{
N  */
N
N#define TIM_Channel_1                      ((uint16_t)0x0000)
N#define TIM_Channel_2                      ((uint16_t)0x0004)
N#define TIM_Channel_3                      ((uint16_t)0x0008)
N#define TIM_Channel_4                      ((uint16_t)0x000C)
N
N#define IS_TIM_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) || \
N                                 ((CHANNEL) == TIM_Channel_2) || \
N                                 ((CHANNEL) == TIM_Channel_3) || \
N                                 ((CHANNEL) == TIM_Channel_4))
X#define IS_TIM_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) ||                                  ((CHANNEL) == TIM_Channel_2) ||                                  ((CHANNEL) == TIM_Channel_3) ||                                  ((CHANNEL) == TIM_Channel_4))
N#define IS_TIM_COMPLEMENTARY_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) || \
N                                               ((CHANNEL) == TIM_Channel_2) || \
N                                               ((CHANNEL) == TIM_Channel_3))
X#define IS_TIM_COMPLEMENTARY_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) ||                                                ((CHANNEL) == TIM_Channel_2) ||                                                ((CHANNEL) == TIM_Channel_3))
N#define IS_TIM_PWMI_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) || \
N                                      ((CHANNEL) == TIM_Channel_2))
X#define IS_TIM_PWMI_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) ||                                       ((CHANNEL) == TIM_Channel_2))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Clock_Division_CKD 
N  * @{
N  */
N
N#define TIM_CKD_DIV1                       ((uint16_t)0x0000)
N#define TIM_CKD_DIV2                       ((uint16_t)0x0100)
N#define TIM_CKD_DIV4                       ((uint16_t)0x0200)
N#define IS_TIM_CKD_DIV(DIV) (((DIV) == TIM_CKD_DIV1) || \
N                             ((DIV) == TIM_CKD_DIV2) || \
N                             ((DIV) == TIM_CKD_DIV4))
X#define IS_TIM_CKD_DIV(DIV) (((DIV) == TIM_CKD_DIV1) ||                              ((DIV) == TIM_CKD_DIV2) ||                              ((DIV) == TIM_CKD_DIV4))
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Counter_Mode 
N  * @{
N  */
N
N#define TIM_CounterMode_Up                 ((uint16_t)0x0000)
N#define TIM_CounterMode_Down               ((uint16_t)0x0010)
N#define TIM_CounterMode_CenterAligned1     ((uint16_t)0x0020)
N#define TIM_CounterMode_CenterAligned2     ((uint16_t)0x0040)
N#define TIM_CounterMode_CenterAligned3     ((uint16_t)0x0060)
N#define IS_TIM_COUNTER_MODE(MODE) (((MODE) == TIM_CounterMode_Up) ||  \
N                                   ((MODE) == TIM_CounterMode_Down) || \
N                                   ((MODE) == TIM_CounterMode_CenterAligned1) || \
N                                   ((MODE) == TIM_CounterMode_CenterAligned2) || \
N                                   ((MODE) == TIM_CounterMode_CenterAligned3))
X#define IS_TIM_COUNTER_MODE(MODE) (((MODE) == TIM_CounterMode_Up) ||                                     ((MODE) == TIM_CounterMode_Down) ||                                    ((MODE) == TIM_CounterMode_CenterAligned1) ||                                    ((MODE) == TIM_CounterMode_CenterAligned2) ||                                    ((MODE) == TIM_CounterMode_CenterAligned3))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Output_Compare_Polarity 
N  * @{
N  */
N
N#define TIM_OCPolarity_High                ((uint16_t)0x0000)
N#define TIM_OCPolarity_Low                 ((uint16_t)0x0002)
N#define IS_TIM_OC_POLARITY(POLARITY) (((POLARITY) == TIM_OCPolarity_High) || \
N                                      ((POLARITY) == TIM_OCPolarity_Low))
X#define IS_TIM_OC_POLARITY(POLARITY) (((POLARITY) == TIM_OCPolarity_High) ||                                       ((POLARITY) == TIM_OCPolarity_Low))
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Output_Compare_N_Polarity 
N  * @{
N  */
N  
N#define TIM_OCNPolarity_High               ((uint16_t)0x0000)
N#define TIM_OCNPolarity_Low                ((uint16_t)0x0008)
N#define IS_TIM_OCN_POLARITY(POLARITY) (((POLARITY) == TIM_OCNPolarity_High) || \
N                                       ((POLARITY) == TIM_OCNPolarity_Low))
X#define IS_TIM_OCN_POLARITY(POLARITY) (((POLARITY) == TIM_OCNPolarity_High) ||                                        ((POLARITY) == TIM_OCNPolarity_Low))
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Output_Compare_state
N  * @{
N  */
N
N#define TIM_OutputState_Disable            ((uint16_t)0x0000)
N#define TIM_OutputState_Enable             ((uint16_t)0x0001)
N#define IS_TIM_OUTPUT_STATE(STATE) (((STATE) == TIM_OutputState_Disable) || \
N                                    ((STATE) == TIM_OutputState_Enable))
X#define IS_TIM_OUTPUT_STATE(STATE) (((STATE) == TIM_OutputState_Disable) ||                                     ((STATE) == TIM_OutputState_Enable))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Output_Compare_N_state 
N  * @{
N  */
N
N#define TIM_OutputNState_Disable           ((uint16_t)0x0000)
N#define TIM_OutputNState_Enable            ((uint16_t)0x0004)
N#define IS_TIM_OUTPUTN_STATE(STATE) (((STATE) == TIM_OutputNState_Disable) || \
N                                     ((STATE) == TIM_OutputNState_Enable))
X#define IS_TIM_OUTPUTN_STATE(STATE) (((STATE) == TIM_OutputNState_Disable) ||                                      ((STATE) == TIM_OutputNState_Enable))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Capture_Compare_state 
N  * @{
N  */
N
N#define TIM_CCx_Enable                      ((uint16_t)0x0001)
N#define TIM_CCx_Disable                     ((uint16_t)0x0000)
N#define IS_TIM_CCX(CCX) (((CCX) == TIM_CCx_Enable) || \
N                         ((CCX) == TIM_CCx_Disable))
X#define IS_TIM_CCX(CCX) (((CCX) == TIM_CCx_Enable) ||                          ((CCX) == TIM_CCx_Disable))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Capture_Compare_N_state 
N  * @{
N  */
N
N#define TIM_CCxN_Enable                     ((uint16_t)0x0004)
N#define TIM_CCxN_Disable                    ((uint16_t)0x0000)
N#define IS_TIM_CCXN(CCXN) (((CCXN) == TIM_CCxN_Enable) || \
N                           ((CCXN) == TIM_CCxN_Disable))
X#define IS_TIM_CCXN(CCXN) (((CCXN) == TIM_CCxN_Enable) ||                            ((CCXN) == TIM_CCxN_Disable))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Break_Input_enable_disable 
N  * @{
N  */
N
N#define TIM_Break_Enable                   ((uint16_t)0x1000)
N#define TIM_Break_Disable                  ((uint16_t)0x0000)
N#define IS_TIM_BREAK_STATE(STATE) (((STATE) == TIM_Break_Enable) || \
N                                   ((STATE) == TIM_Break_Disable))
X#define IS_TIM_BREAK_STATE(STATE) (((STATE) == TIM_Break_Enable) ||                                    ((STATE) == TIM_Break_Disable))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Break_Polarity 
N  * @{
N  */
N
N#define TIM_BreakPolarity_Low              ((uint16_t)0x0000)
N#define TIM_BreakPolarity_High             ((uint16_t)0x2000)
N#define IS_TIM_BREAK_POLARITY(POLARITY) (((POLARITY) == TIM_BreakPolarity_Low) || \
N                                         ((POLARITY) == TIM_BreakPolarity_High))
X#define IS_TIM_BREAK_POLARITY(POLARITY) (((POLARITY) == TIM_BreakPolarity_Low) ||                                          ((POLARITY) == TIM_BreakPolarity_High))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_AOE_Bit_Set_Reset 
N  * @{
N  */
N
N#define TIM_AutomaticOutput_Enable         ((uint16_t)0x4000)
N#define TIM_AutomaticOutput_Disable        ((uint16_t)0x0000)
N#define IS_TIM_AUTOMATIC_OUTPUT_STATE(STATE) (((STATE) == TIM_AutomaticOutput_Enable) || \
N                                              ((STATE) == TIM_AutomaticOutput_Disable))
X#define IS_TIM_AUTOMATIC_OUTPUT_STATE(STATE) (((STATE) == TIM_AutomaticOutput_Enable) ||                                               ((STATE) == TIM_AutomaticOutput_Disable))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Lock_level 
N  * @{
N  */
N
N#define TIM_LOCKLevel_OFF                  ((uint16_t)0x0000)
N#define TIM_LOCKLevel_1                    ((uint16_t)0x0100)
N#define TIM_LOCKLevel_2                    ((uint16_t)0x0200)
N#define TIM_LOCKLevel_3                    ((uint16_t)0x0300)
N#define IS_TIM_LOCK_LEVEL(LEVEL) (((LEVEL) == TIM_LOCKLevel_OFF) || \
N                                  ((LEVEL) == TIM_LOCKLevel_1) || \
N                                  ((LEVEL) == TIM_LOCKLevel_2) || \
N                                  ((LEVEL) == TIM_LOCKLevel_3))
X#define IS_TIM_LOCK_LEVEL(LEVEL) (((LEVEL) == TIM_LOCKLevel_OFF) ||                                   ((LEVEL) == TIM_LOCKLevel_1) ||                                   ((LEVEL) == TIM_LOCKLevel_2) ||                                   ((LEVEL) == TIM_LOCKLevel_3))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_OSSI_Off_State_Selection_for_Idle_mode_state 
N  * @{
N  */
N
N#define TIM_OSSIState_Enable               ((uint16_t)0x0400)
N#define TIM_OSSIState_Disable              ((uint16_t)0x0000)
N#define IS_TIM_OSSI_STATE(STATE) (((STATE) == TIM_OSSIState_Enable) || \
N                                  ((STATE) == TIM_OSSIState_Disable))
X#define IS_TIM_OSSI_STATE(STATE) (((STATE) == TIM_OSSIState_Enable) ||                                   ((STATE) == TIM_OSSIState_Disable))
N/**
N  * @}
N  */
N
N/** @defgroup TIM_OSSR_Off_State_Selection_for_Run_mode_state 
N  * @{
N  */
N
N#define TIM_OSSRState_Enable               ((uint16_t)0x0800)
N#define TIM_OSSRState_Disable              ((uint16_t)0x0000)
N#define IS_TIM_OSSR_STATE(STATE) (((STATE) == TIM_OSSRState_Enable) || \
N                                  ((STATE) == TIM_OSSRState_Disable))
X#define IS_TIM_OSSR_STATE(STATE) (((STATE) == TIM_OSSRState_Enable) ||                                   ((STATE) == TIM_OSSRState_Disable))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Output_Compare_Idle_State 
N  * @{
N  */
N
N#define TIM_OCIdleState_Set                ((uint16_t)0x0100)
N#define TIM_OCIdleState_Reset              ((uint16_t)0x0000)
N#define IS_TIM_OCIDLE_STATE(STATE) (((STATE) == TIM_OCIdleState_Set) || \
N                                    ((STATE) == TIM_OCIdleState_Reset))
X#define IS_TIM_OCIDLE_STATE(STATE) (((STATE) == TIM_OCIdleState_Set) ||                                     ((STATE) == TIM_OCIdleState_Reset))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Output_Compare_N_Idle_State 
N  * @{
N  */
N
N#define TIM_OCNIdleState_Set               ((uint16_t)0x0200)
N#define TIM_OCNIdleState_Reset             ((uint16_t)0x0000)
N#define IS_TIM_OCNIDLE_STATE(STATE) (((STATE) == TIM_OCNIdleState_Set) || \
N                                     ((STATE) == TIM_OCNIdleState_Reset))
X#define IS_TIM_OCNIDLE_STATE(STATE) (((STATE) == TIM_OCNIdleState_Set) ||                                      ((STATE) == TIM_OCNIdleState_Reset))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Input_Capture_Polarity 
N  * @{
N  */
N
N#define  TIM_ICPolarity_Rising             ((uint16_t)0x0000)
N#define  TIM_ICPolarity_Falling            ((uint16_t)0x0002)
N#define  TIM_ICPolarity_BothEdge           ((uint16_t)0x000A)
N#define IS_TIM_IC_POLARITY(POLARITY) (((POLARITY) == TIM_ICPolarity_Rising) || \
N                                      ((POLARITY) == TIM_ICPolarity_Falling)|| \
N                                      ((POLARITY) == TIM_ICPolarity_BothEdge)) 
X#define IS_TIM_IC_POLARITY(POLARITY) (((POLARITY) == TIM_ICPolarity_Rising) ||                                       ((POLARITY) == TIM_ICPolarity_Falling)||                                       ((POLARITY) == TIM_ICPolarity_BothEdge)) 
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Input_Capture_Selection 
N  * @{
N  */
N
N#define TIM_ICSelection_DirectTI           ((uint16_t)0x0001) /*!< TIM Input 1, 2, 3 or 4 is selected to be 
N                                                                   connected to IC1, IC2, IC3 or IC4, respectively */
N#define TIM_ICSelection_IndirectTI         ((uint16_t)0x0002) /*!< TIM Input 1, 2, 3 or 4 is selected to be
N                                                                   connected to IC2, IC1, IC4 or IC3, respectively. */
N#define TIM_ICSelection_TRC                ((uint16_t)0x0003) /*!< TIM Input 1, 2, 3 or 4 is selected to be connected to TRC. */
N#define IS_TIM_IC_SELECTION(SELECTION) (((SELECTION) == TIM_ICSelection_DirectTI) || \
N                                        ((SELECTION) == TIM_ICSelection_IndirectTI) || \
N                                        ((SELECTION) == TIM_ICSelection_TRC))
X#define IS_TIM_IC_SELECTION(SELECTION) (((SELECTION) == TIM_ICSelection_DirectTI) ||                                         ((SELECTION) == TIM_ICSelection_IndirectTI) ||                                         ((SELECTION) == TIM_ICSelection_TRC))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Input_Capture_Prescaler 
N  * @{
N  */
N
N#define TIM_ICPSC_DIV1                     ((uint16_t)0x0000) /*!< Capture performed each time an edge is detected on the capture input. */
N#define TIM_ICPSC_DIV2                     ((uint16_t)0x0004) /*!< Capture performed once every 2 events. */
N#define TIM_ICPSC_DIV4                     ((uint16_t)0x0008) /*!< Capture performed once every 4 events. */
N#define TIM_ICPSC_DIV8                     ((uint16_t)0x000C) /*!< Capture performed once every 8 events. */
N#define IS_TIM_IC_PRESCALER(PRESCALER) (((PRESCALER) == TIM_ICPSC_DIV1) || \
N                                        ((PRESCALER) == TIM_ICPSC_DIV2) || \
N                                        ((PRESCALER) == TIM_ICPSC_DIV4) || \
N                                        ((PRESCALER) == TIM_ICPSC_DIV8))
X#define IS_TIM_IC_PRESCALER(PRESCALER) (((PRESCALER) == TIM_ICPSC_DIV1) ||                                         ((PRESCALER) == TIM_ICPSC_DIV2) ||                                         ((PRESCALER) == TIM_ICPSC_DIV4) ||                                         ((PRESCALER) == TIM_ICPSC_DIV8))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_interrupt_sources 
N  * @{
N  */
N
N#define TIM_IT_Update                      ((uint16_t)0x0001)
N#define TIM_IT_CC1                         ((uint16_t)0x0002)
N#define TIM_IT_CC2                         ((uint16_t)0x0004)
N#define TIM_IT_CC3                         ((uint16_t)0x0008)
N#define TIM_IT_CC4                         ((uint16_t)0x0010)
N#define TIM_IT_COM                         ((uint16_t)0x0020)
N#define TIM_IT_Trigger                     ((uint16_t)0x0040)
N#define TIM_IT_Break                       ((uint16_t)0x0080)
N#define IS_TIM_IT(IT) ((((IT) & (uint16_t)0xFF00) == 0x0000) && ((IT) != 0x0000))
N
N#define IS_TIM_GET_IT(IT) (((IT) == TIM_IT_Update) || \
N                           ((IT) == TIM_IT_CC1) || \
N                           ((IT) == TIM_IT_CC2) || \
N                           ((IT) == TIM_IT_CC3) || \
N                           ((IT) == TIM_IT_CC4) || \
N                           ((IT) == TIM_IT_COM) || \
N                           ((IT) == TIM_IT_Trigger) || \
N                           ((IT) == TIM_IT_Break))
X#define IS_TIM_GET_IT(IT) (((IT) == TIM_IT_Update) ||                            ((IT) == TIM_IT_CC1) ||                            ((IT) == TIM_IT_CC2) ||                            ((IT) == TIM_IT_CC3) ||                            ((IT) == TIM_IT_CC4) ||                            ((IT) == TIM_IT_COM) ||                            ((IT) == TIM_IT_Trigger) ||                            ((IT) == TIM_IT_Break))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_DMA_Base_address 
N  * @{
N  */
N
N#define TIM_DMABase_CR1                    ((uint16_t)0x0000)
N#define TIM_DMABase_CR2                    ((uint16_t)0x0001)
N#define TIM_DMABase_SMCR                   ((uint16_t)0x0002)
N#define TIM_DMABase_DIER                   ((uint16_t)0x0003)
N#define TIM_DMABase_SR                     ((uint16_t)0x0004)
N#define TIM_DMABase_EGR                    ((uint16_t)0x0005)
N#define TIM_DMABase_CCMR1                  ((uint16_t)0x0006)
N#define TIM_DMABase_CCMR2                  ((uint16_t)0x0007)
N#define TIM_DMABase_CCER                   ((uint16_t)0x0008)
N#define TIM_DMABase_CNT                    ((uint16_t)0x0009)
N#define TIM_DMABase_PSC                    ((uint16_t)0x000A)
N#define TIM_DMABase_ARR                    ((uint16_t)0x000B)
N#define TIM_DMABase_RCR                    ((uint16_t)0x000C)
N#define TIM_DMABase_CCR1                   ((uint16_t)0x000D)
N#define TIM_DMABase_CCR2                   ((uint16_t)0x000E)
N#define TIM_DMABase_CCR3                   ((uint16_t)0x000F)
N#define TIM_DMABase_CCR4                   ((uint16_t)0x0010)
N#define TIM_DMABase_BDTR                   ((uint16_t)0x0011)
N#define TIM_DMABase_DCR                    ((uint16_t)0x0012)
N#define TIM_DMABase_OR                     ((uint16_t)0x0013)
N#define IS_TIM_DMA_BASE(BASE) (((BASE) == TIM_DMABase_CR1) || \
N                               ((BASE) == TIM_DMABase_CR2) || \
N                               ((BASE) == TIM_DMABase_SMCR) || \
N                               ((BASE) == TIM_DMABase_DIER) || \
N                               ((BASE) == TIM_DMABase_SR) || \
N                               ((BASE) == TIM_DMABase_EGR) || \
N                               ((BASE) == TIM_DMABase_CCMR1) || \
N                               ((BASE) == TIM_DMABase_CCMR2) || \
N                               ((BASE) == TIM_DMABase_CCER) || \
N                               ((BASE) == TIM_DMABase_CNT) || \
N                               ((BASE) == TIM_DMABase_PSC) || \
N                               ((BASE) == TIM_DMABase_ARR) || \
N                               ((BASE) == TIM_DMABase_RCR) || \
N                               ((BASE) == TIM_DMABase_CCR1) || \
N                               ((BASE) == TIM_DMABase_CCR2) || \
N                               ((BASE) == TIM_DMABase_CCR3) || \
N                               ((BASE) == TIM_DMABase_CCR4) || \
N                               ((BASE) == TIM_DMABase_BDTR) || \
N							   ((BASE) == TIM_DMABase_DCR) || \
N                               ((BASE) == TIM_DMABase_OR))
X#define IS_TIM_DMA_BASE(BASE) (((BASE) == TIM_DMABase_CR1) ||                                ((BASE) == TIM_DMABase_CR2) ||                                ((BASE) == TIM_DMABase_SMCR) ||                                ((BASE) == TIM_DMABase_DIER) ||                                ((BASE) == TIM_DMABase_SR) ||                                ((BASE) == TIM_DMABase_EGR) ||                                ((BASE) == TIM_DMABase_CCMR1) ||                                ((BASE) == TIM_DMABase_CCMR2) ||                                ((BASE) == TIM_DMABase_CCER) ||                                ((BASE) == TIM_DMABase_CNT) ||                                ((BASE) == TIM_DMABase_PSC) ||                                ((BASE) == TIM_DMABase_ARR) ||                                ((BASE) == TIM_DMABase_RCR) ||                                ((BASE) == TIM_DMABase_CCR1) ||                                ((BASE) == TIM_DMABase_CCR2) ||                                ((BASE) == TIM_DMABase_CCR3) ||                                ((BASE) == TIM_DMABase_CCR4) ||                                ((BASE) == TIM_DMABase_BDTR) || 							   ((BASE) == TIM_DMABase_DCR) ||                                ((BASE) == TIM_DMABase_OR))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup TIM_DMA_Burst_Length 
N  * @{
N  */
N
N#define TIM_DMABurstLength_1Transfer           ((uint16_t)0x0000)
N#define TIM_DMABurstLength_2Transfers          ((uint16_t)0x0100)
N#define TIM_DMABurstLength_3Transfers          ((uint16_t)0x0200)
N#define TIM_DMABurstLength_4Transfers          ((uint16_t)0x0300)
N#define TIM_DMABurstLength_5Transfers          ((uint16_t)0x0400)
N#define TIM_DMABurstLength_6Transfers          ((uint16_t)0x0500)
N#define TIM_DMABurstLength_7Transfers          ((uint16_t)0x0600)
N#define TIM_DMABurstLength_8Transfers          ((uint16_t)0x0700)
N#define TIM_DMABurstLength_9Transfers          ((uint16_t)0x0800)
N#define TIM_DMABurstLength_10Transfers         ((uint16_t)0x0900)
N#define TIM_DMABurstLength_11Transfers         ((uint16_t)0x0A00)
N#define TIM_DMABurstLength_12Transfers         ((uint16_t)0x0B00)
N#define TIM_DMABurstLength_13Transfers         ((uint16_t)0x0C00)
N#define TIM_DMABurstLength_14Transfers         ((uint16_t)0x0D00)
N#define TIM_DMABurstLength_15Transfers         ((uint16_t)0x0E00)
N#define TIM_DMABurstLength_16Transfers         ((uint16_t)0x0F00)
N#define TIM_DMABurstLength_17Transfers         ((uint16_t)0x1000)
N#define TIM_DMABurstLength_18Transfers         ((uint16_t)0x1100)
N#define IS_TIM_DMA_LENGTH(LENGTH) (((LENGTH) == TIM_DMABurstLength_1Transfer) || \
N                                   ((LENGTH) == TIM_DMABurstLength_2Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_3Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_4Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_5Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_6Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_7Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_8Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_9Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_10Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_11Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_12Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_13Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_14Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_15Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_16Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_17Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_18Transfers))
X#define IS_TIM_DMA_LENGTH(LENGTH) (((LENGTH) == TIM_DMABurstLength_1Transfer) ||                                    ((LENGTH) == TIM_DMABurstLength_2Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_3Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_4Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_5Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_6Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_7Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_8Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_9Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_10Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_11Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_12Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_13Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_14Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_15Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_16Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_17Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_18Transfers))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_DMA_sources 
N  * @{
N  */
N
N#define TIM_DMA_Update                     ((uint16_t)0x0100)
N#define TIM_DMA_CC1                        ((uint16_t)0x0200)
N#define TIM_DMA_CC2                        ((uint16_t)0x0400)
N#define TIM_DMA_CC3                        ((uint16_t)0x0800)
N#define TIM_DMA_CC4                        ((uint16_t)0x1000)
N#define TIM_DMA_COM                        ((uint16_t)0x2000)
N#define TIM_DMA_Trigger                    ((uint16_t)0x4000)
N#define IS_TIM_DMA_SOURCE(SOURCE) ((((SOURCE) & (uint16_t)0x80FF) == 0x0000) && ((SOURCE) != 0x0000))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_External_Trigger_Prescaler 
N  * @{
N  */
N
N#define TIM_ExtTRGPSC_OFF                  ((uint16_t)0x0000)
N#define TIM_ExtTRGPSC_DIV2                 ((uint16_t)0x1000)
N#define TIM_ExtTRGPSC_DIV4                 ((uint16_t)0x2000)
N#define TIM_ExtTRGPSC_DIV8                 ((uint16_t)0x3000)
N#define IS_TIM_EXT_PRESCALER(PRESCALER) (((PRESCALER) == TIM_ExtTRGPSC_OFF) || \
N                                         ((PRESCALER) == TIM_ExtTRGPSC_DIV2) || \
N                                         ((PRESCALER) == TIM_ExtTRGPSC_DIV4) || \
N                                         ((PRESCALER) == TIM_ExtTRGPSC_DIV8))
X#define IS_TIM_EXT_PRESCALER(PRESCALER) (((PRESCALER) == TIM_ExtTRGPSC_OFF) ||                                          ((PRESCALER) == TIM_ExtTRGPSC_DIV2) ||                                          ((PRESCALER) == TIM_ExtTRGPSC_DIV4) ||                                          ((PRESCALER) == TIM_ExtTRGPSC_DIV8))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Internal_Trigger_Selection 
N  * @{
N  */
N
N#define TIM_TS_ITR0                        ((uint16_t)0x0000)
N#define TIM_TS_ITR1                        ((uint16_t)0x0010)
N#define TIM_TS_ITR2                        ((uint16_t)0x0020)
N#define TIM_TS_ITR3                        ((uint16_t)0x0030)
N#define TIM_TS_TI1F_ED                     ((uint16_t)0x0040)
N#define TIM_TS_TI1FP1                      ((uint16_t)0x0050)
N#define TIM_TS_TI2FP2                      ((uint16_t)0x0060)
N#define TIM_TS_ETRF                        ((uint16_t)0x0070)
N#define IS_TIM_TRIGGER_SELECTION(SELECTION) (((SELECTION) == TIM_TS_ITR0) || \
N                                             ((SELECTION) == TIM_TS_ITR1) || \
N                                             ((SELECTION) == TIM_TS_ITR2) || \
N                                             ((SELECTION) == TIM_TS_ITR3) || \
N                                             ((SELECTION) == TIM_TS_TI1F_ED) || \
N                                             ((SELECTION) == TIM_TS_TI1FP1) || \
N                                             ((SELECTION) == TIM_TS_TI2FP2) || \
N                                             ((SELECTION) == TIM_TS_ETRF))
X#define IS_TIM_TRIGGER_SELECTION(SELECTION) (((SELECTION) == TIM_TS_ITR0) ||                                              ((SELECTION) == TIM_TS_ITR1) ||                                              ((SELECTION) == TIM_TS_ITR2) ||                                              ((SELECTION) == TIM_TS_ITR3) ||                                              ((SELECTION) == TIM_TS_TI1F_ED) ||                                              ((SELECTION) == TIM_TS_TI1FP1) ||                                              ((SELECTION) == TIM_TS_TI2FP2) ||                                              ((SELECTION) == TIM_TS_ETRF))
N#define IS_TIM_INTERNAL_TRIGGER_SELECTION(SELECTION) (((SELECTION) == TIM_TS_ITR0) || \
N                                                      ((SELECTION) == TIM_TS_ITR1) || \
N                                                      ((SELECTION) == TIM_TS_ITR2) || \
N                                                      ((SELECTION) == TIM_TS_ITR3))
X#define IS_TIM_INTERNAL_TRIGGER_SELECTION(SELECTION) (((SELECTION) == TIM_TS_ITR0) ||                                                       ((SELECTION) == TIM_TS_ITR1) ||                                                       ((SELECTION) == TIM_TS_ITR2) ||                                                       ((SELECTION) == TIM_TS_ITR3))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_TIx_External_Clock_Source 
N  * @{
N  */
N
N#define TIM_TIxExternalCLK1Source_TI1      ((uint16_t)0x0050)
N#define TIM_TIxExternalCLK1Source_TI2      ((uint16_t)0x0060)
N#define TIM_TIxExternalCLK1Source_TI1ED    ((uint16_t)0x0040)
N
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_External_Trigger_Polarity 
N  * @{
N  */ 
N#define TIM_ExtTRGPolarity_Inverted        ((uint16_t)0x8000)
N#define TIM_ExtTRGPolarity_NonInverted     ((uint16_t)0x0000)
N#define IS_TIM_EXT_POLARITY(POLARITY) (((POLARITY) == TIM_ExtTRGPolarity_Inverted) || \
N                                       ((POLARITY) == TIM_ExtTRGPolarity_NonInverted))
X#define IS_TIM_EXT_POLARITY(POLARITY) (((POLARITY) == TIM_ExtTRGPolarity_Inverted) ||                                        ((POLARITY) == TIM_ExtTRGPolarity_NonInverted))
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Prescaler_Reload_Mode 
N  * @{
N  */
N
N#define TIM_PSCReloadMode_Update           ((uint16_t)0x0000)
N#define TIM_PSCReloadMode_Immediate        ((uint16_t)0x0001)
N#define IS_TIM_PRESCALER_RELOAD(RELOAD) (((RELOAD) == TIM_PSCReloadMode_Update) || \
N                                         ((RELOAD) == TIM_PSCReloadMode_Immediate))
X#define IS_TIM_PRESCALER_RELOAD(RELOAD) (((RELOAD) == TIM_PSCReloadMode_Update) ||                                          ((RELOAD) == TIM_PSCReloadMode_Immediate))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Forced_Action 
N  * @{
N  */
N
N#define TIM_ForcedAction_Active            ((uint16_t)0x0050)
N#define TIM_ForcedAction_InActive          ((uint16_t)0x0040)
N#define IS_TIM_FORCED_ACTION(ACTION) (((ACTION) == TIM_ForcedAction_Active) || \
N                                      ((ACTION) == TIM_ForcedAction_InActive))
X#define IS_TIM_FORCED_ACTION(ACTION) (((ACTION) == TIM_ForcedAction_Active) ||                                       ((ACTION) == TIM_ForcedAction_InActive))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Encoder_Mode 
N  * @{
N  */
N
N#define TIM_EncoderMode_TI1                ((uint16_t)0x0001)
N#define TIM_EncoderMode_TI2                ((uint16_t)0x0002)
N#define TIM_EncoderMode_TI12               ((uint16_t)0x0003)
N#define IS_TIM_ENCODER_MODE(MODE) (((MODE) == TIM_EncoderMode_TI1) || \
N                                   ((MODE) == TIM_EncoderMode_TI2) || \
N                                   ((MODE) == TIM_EncoderMode_TI12))
X#define IS_TIM_ENCODER_MODE(MODE) (((MODE) == TIM_EncoderMode_TI1) ||                                    ((MODE) == TIM_EncoderMode_TI2) ||                                    ((MODE) == TIM_EncoderMode_TI12))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup TIM_Event_Source 
N  * @{
N  */
N
N#define TIM_EventSource_Update             ((uint16_t)0x0001)
N#define TIM_EventSource_CC1                ((uint16_t)0x0002)
N#define TIM_EventSource_CC2                ((uint16_t)0x0004)
N#define TIM_EventSource_CC3                ((uint16_t)0x0008)
N#define TIM_EventSource_CC4                ((uint16_t)0x0010)
N#define TIM_EventSource_COM                ((uint16_t)0x0020)
N#define TIM_EventSource_Trigger            ((uint16_t)0x0040)
N#define TIM_EventSource_Break              ((uint16_t)0x0080)
N#define IS_TIM_EVENT_SOURCE(SOURCE) ((((SOURCE) & (uint16_t)0xFF00) == 0x0000) && ((SOURCE) != 0x0000))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Update_Source 
N  * @{
N  */
N
N#define TIM_UpdateSource_Global            ((uint16_t)0x0000) /*!< Source of update is the counter overflow/underflow
N                                                                   or the setting of UG bit, or an update generation
N                                                                   through the slave mode controller. */
N#define TIM_UpdateSource_Regular           ((uint16_t)0x0001) /*!< Source of update is counter overflow/underflow. */
N#define IS_TIM_UPDATE_SOURCE(SOURCE) (((SOURCE) == TIM_UpdateSource_Global) || \
N                                      ((SOURCE) == TIM_UpdateSource_Regular))
X#define IS_TIM_UPDATE_SOURCE(SOURCE) (((SOURCE) == TIM_UpdateSource_Global) ||                                       ((SOURCE) == TIM_UpdateSource_Regular))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Output_Compare_Preload_State 
N  * @{
N  */
N
N#define TIM_OCPreload_Enable               ((uint16_t)0x0008)
N#define TIM_OCPreload_Disable              ((uint16_t)0x0000)
N#define IS_TIM_OCPRELOAD_STATE(STATE) (((STATE) == TIM_OCPreload_Enable) || \
N                                       ((STATE) == TIM_OCPreload_Disable))
X#define IS_TIM_OCPRELOAD_STATE(STATE) (((STATE) == TIM_OCPreload_Enable) ||                                        ((STATE) == TIM_OCPreload_Disable))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Output_Compare_Fast_State 
N  * @{
N  */
N
N#define TIM_OCFast_Enable                  ((uint16_t)0x0004)
N#define TIM_OCFast_Disable                 ((uint16_t)0x0000)
N#define IS_TIM_OCFAST_STATE(STATE) (((STATE) == TIM_OCFast_Enable) || \
N                                    ((STATE) == TIM_OCFast_Disable))
X#define IS_TIM_OCFAST_STATE(STATE) (((STATE) == TIM_OCFast_Enable) ||                                     ((STATE) == TIM_OCFast_Disable))
N                                     
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Output_Compare_Clear_State 
N  * @{
N  */
N
N#define TIM_OCClear_Enable                 ((uint16_t)0x0080)
N#define TIM_OCClear_Disable                ((uint16_t)0x0000)
N#define IS_TIM_OCCLEAR_STATE(STATE) (((STATE) == TIM_OCClear_Enable) || \
N                                     ((STATE) == TIM_OCClear_Disable))
X#define IS_TIM_OCCLEAR_STATE(STATE) (((STATE) == TIM_OCClear_Enable) ||                                      ((STATE) == TIM_OCClear_Disable))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Trigger_Output_Source 
N  * @{
N  */
N
N#define TIM_TRGOSource_Reset               ((uint16_t)0x0000)
N#define TIM_TRGOSource_Enable              ((uint16_t)0x0010)
N#define TIM_TRGOSource_Update              ((uint16_t)0x0020)
N#define TIM_TRGOSource_OC1                 ((uint16_t)0x0030)
N#define TIM_TRGOSource_OC1Ref              ((uint16_t)0x0040)
N#define TIM_TRGOSource_OC2Ref              ((uint16_t)0x0050)
N#define TIM_TRGOSource_OC3Ref              ((uint16_t)0x0060)
N#define TIM_TRGOSource_OC4Ref              ((uint16_t)0x0070)
N#define IS_TIM_TRGO_SOURCE(SOURCE) (((SOURCE) == TIM_TRGOSource_Reset) || \
N                                    ((SOURCE) == TIM_TRGOSource_Enable) || \
N                                    ((SOURCE) == TIM_TRGOSource_Update) || \
N                                    ((SOURCE) == TIM_TRGOSource_OC1) || \
N                                    ((SOURCE) == TIM_TRGOSource_OC1Ref) || \
N                                    ((SOURCE) == TIM_TRGOSource_OC2Ref) || \
N                                    ((SOURCE) == TIM_TRGOSource_OC3Ref) || \
N                                    ((SOURCE) == TIM_TRGOSource_OC4Ref))
X#define IS_TIM_TRGO_SOURCE(SOURCE) (((SOURCE) == TIM_TRGOSource_Reset) ||                                     ((SOURCE) == TIM_TRGOSource_Enable) ||                                     ((SOURCE) == TIM_TRGOSource_Update) ||                                     ((SOURCE) == TIM_TRGOSource_OC1) ||                                     ((SOURCE) == TIM_TRGOSource_OC1Ref) ||                                     ((SOURCE) == TIM_TRGOSource_OC2Ref) ||                                     ((SOURCE) == TIM_TRGOSource_OC3Ref) ||                                     ((SOURCE) == TIM_TRGOSource_OC4Ref))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Slave_Mode 
N  * @{
N  */
N
N#define TIM_SlaveMode_Reset                ((uint16_t)0x0004)
N#define TIM_SlaveMode_Gated                ((uint16_t)0x0005)
N#define TIM_SlaveMode_Trigger              ((uint16_t)0x0006)
N#define TIM_SlaveMode_External1            ((uint16_t)0x0007)
N#define IS_TIM_SLAVE_MODE(MODE) (((MODE) == TIM_SlaveMode_Reset) || \
N                                 ((MODE) == TIM_SlaveMode_Gated) || \
N                                 ((MODE) == TIM_SlaveMode_Trigger) || \
N                                 ((MODE) == TIM_SlaveMode_External1))
X#define IS_TIM_SLAVE_MODE(MODE) (((MODE) == TIM_SlaveMode_Reset) ||                                  ((MODE) == TIM_SlaveMode_Gated) ||                                  ((MODE) == TIM_SlaveMode_Trigger) ||                                  ((MODE) == TIM_SlaveMode_External1))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Master_Slave_Mode 
N  * @{
N  */
N
N#define TIM_MasterSlaveMode_Enable         ((uint16_t)0x0080)
N#define TIM_MasterSlaveMode_Disable        ((uint16_t)0x0000)
N#define IS_TIM_MSM_STATE(STATE) (((STATE) == TIM_MasterSlaveMode_Enable) || \
N                                 ((STATE) == TIM_MasterSlaveMode_Disable))
X#define IS_TIM_MSM_STATE(STATE) (((STATE) == TIM_MasterSlaveMode_Enable) ||                                  ((STATE) == TIM_MasterSlaveMode_Disable))
N/**
N  * @}
N  */ 
N  
N/** @defgroup TIM_Flags 
N  * @{
N  */
N
N#define TIM_FLAG_Update                    ((uint16_t)0x0001)
N#define TIM_FLAG_CC1                       ((uint16_t)0x0002)
N#define TIM_FLAG_CC2                       ((uint16_t)0x0004)
N#define TIM_FLAG_CC3                       ((uint16_t)0x0008)
N#define TIM_FLAG_CC4                       ((uint16_t)0x0010)
N#define TIM_FLAG_COM                       ((uint16_t)0x0020)
N#define TIM_FLAG_Trigger                   ((uint16_t)0x0040)
N#define TIM_FLAG_Break                     ((uint16_t)0x0080)
N#define TIM_FLAG_CC1OF                     ((uint16_t)0x0200)
N#define TIM_FLAG_CC2OF                     ((uint16_t)0x0400)
N#define TIM_FLAG_CC3OF                     ((uint16_t)0x0800)
N#define TIM_FLAG_CC4OF                     ((uint16_t)0x1000)
N#define IS_TIM_GET_FLAG(FLAG) (((FLAG) == TIM_FLAG_Update) || \
N                               ((FLAG) == TIM_FLAG_CC1) || \
N                               ((FLAG) == TIM_FLAG_CC2) || \
N                               ((FLAG) == TIM_FLAG_CC3) || \
N                               ((FLAG) == TIM_FLAG_CC4) || \
N                               ((FLAG) == TIM_FLAG_COM) || \
N                               ((FLAG) == TIM_FLAG_Trigger) || \
N                               ((FLAG) == TIM_FLAG_Break) || \
N                               ((FLAG) == TIM_FLAG_CC1OF) || \
N                               ((FLAG) == TIM_FLAG_CC2OF) || \
N                               ((FLAG) == TIM_FLAG_CC3OF) || \
N                               ((FLAG) == TIM_FLAG_CC4OF))
X#define IS_TIM_GET_FLAG(FLAG) (((FLAG) == TIM_FLAG_Update) ||                                ((FLAG) == TIM_FLAG_CC1) ||                                ((FLAG) == TIM_FLAG_CC2) ||                                ((FLAG) == TIM_FLAG_CC3) ||                                ((FLAG) == TIM_FLAG_CC4) ||                                ((FLAG) == TIM_FLAG_COM) ||                                ((FLAG) == TIM_FLAG_Trigger) ||                                ((FLAG) == TIM_FLAG_Break) ||                                ((FLAG) == TIM_FLAG_CC1OF) ||                                ((FLAG) == TIM_FLAG_CC2OF) ||                                ((FLAG) == TIM_FLAG_CC3OF) ||                                ((FLAG) == TIM_FLAG_CC4OF))
N                               
N                               
N#define IS_TIM_CLEAR_FLAG(TIM_FLAG) ((((TIM_FLAG) & (uint16_t)0xE100) == 0x0000) && ((TIM_FLAG) != 0x0000))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup TIM_Input_Capture_Filer_Value 
N  * @{
N  */
N
N#define IS_TIM_IC_FILTER(ICFILTER) ((ICFILTER) <= 0xF) 
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_External_Trigger_Filter 
N  * @{
N  */
N
N#define IS_TIM_EXT_FILTER(EXTFILTER) ((EXTFILTER) <= 0xF)
N/**
N  * @}
N  */
N
N/** @defgroup TIM_OCReferenceClear 
N  * @{
N  */
N#define TIM_OCReferenceClear_ETRF          ((uint16_t)0x0008)
N#define TIM_OCReferenceClear_OCREFCLR      ((uint16_t)0x0000)
N#define TIM_OCREFERENCECECLEAR_SOURCE(SOURCE) (((SOURCE) == TIM_OCReferenceClear_ETRF) || \
N                                              ((SOURCE) == TIM_OCReferenceClear_OCREFCLR)) 
X#define TIM_OCREFERENCECECLEAR_SOURCE(SOURCE) (((SOURCE) == TIM_OCReferenceClear_ETRF) ||                                               ((SOURCE) == TIM_OCReferenceClear_OCREFCLR)) 
N
N/**
N  * @}
N  */
N/** @defgroup TIM_Remap 
N  * @{
N  */
N#define TIM14_GPIO                      ((uint16_t)0x0000)
N#define TIM14_RTC_CLK                   ((uint16_t)0x0001)
N#define TIM14_HSEDiv32                  ((uint16_t)0x0002)
N#define TIM14_MCO                       ((uint16_t)0x0003)
N
N#define IS_TIM_REMAP(TIM_REMAP)  (((TIM_REMAP) == TIM14_GPIO)|| \
N                                  ((TIM_REMAP) == TIM14_RTC_CLK) || \
N                                  ((TIM_REMAP) == TIM14_HSEDiv32) || \
N                                  ((TIM_REMAP) == TIM14_MCO))
X#define IS_TIM_REMAP(TIM_REMAP)  (((TIM_REMAP) == TIM14_GPIO)||                                   ((TIM_REMAP) == TIM14_RTC_CLK) ||                                   ((TIM_REMAP) == TIM14_HSEDiv32) ||                                   ((TIM_REMAP) == TIM14_MCO))
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Legacy 
N  * @{
N  */
N
N#define TIM_DMABurstLength_1Byte           TIM_DMABurstLength_1Transfer
N#define TIM_DMABurstLength_2Bytes          TIM_DMABurstLength_2Transfers
N#define TIM_DMABurstLength_3Bytes          TIM_DMABurstLength_3Transfers
N#define TIM_DMABurstLength_4Bytes          TIM_DMABurstLength_4Transfers
N#define TIM_DMABurstLength_5Bytes          TIM_DMABurstLength_5Transfers
N#define TIM_DMABurstLength_6Bytes          TIM_DMABurstLength_6Transfers
N#define TIM_DMABurstLength_7Bytes          TIM_DMABurstLength_7Transfers
N#define TIM_DMABurstLength_8Bytes          TIM_DMABurstLength_8Transfers
N#define TIM_DMABurstLength_9Bytes          TIM_DMABurstLength_9Transfers
N#define TIM_DMABurstLength_10Bytes         TIM_DMABurstLength_10Transfers
N#define TIM_DMABurstLength_11Bytes         TIM_DMABurstLength_11Transfers
N#define TIM_DMABurstLength_12Bytes         TIM_DMABurstLength_12Transfers
N#define TIM_DMABurstLength_13Bytes         TIM_DMABurstLength_13Transfers
N#define TIM_DMABurstLength_14Bytes         TIM_DMABurstLength_14Transfers
N#define TIM_DMABurstLength_15Bytes         TIM_DMABurstLength_15Transfers
N#define TIM_DMABurstLength_16Bytes         TIM_DMABurstLength_16Transfers
N#define TIM_DMABurstLength_17Bytes         TIM_DMABurstLength_17Transfers
N#define TIM_DMABurstLength_18Bytes         TIM_DMABurstLength_18Transfers
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N  
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */ 
N
N/* TimeBase management ********************************************************/
Nvoid TIM_DeInit(TIM_TypeDef* TIMx);
Nvoid TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct);
Nvoid TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct);
Nvoid TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode);
Nvoid TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode);
Nvoid TIM_SetCounter(TIM_TypeDef* TIMx, uint32_t Counter);
Nvoid TIM_SetAutoreload(TIM_TypeDef* TIMx, uint32_t Autoreload);
Nuint32_t TIM_GetCounter(TIM_TypeDef* TIMx);
Nuint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx);
Nvoid TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState);
Nvoid TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource);
Nvoid TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState);
Nvoid TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode);
Nvoid TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD);
Nvoid TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState);
N
N/* Advanced-control timers (TIM1) specific features*******************/
Nvoid TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct);
Nvoid TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct);
Nvoid TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState);
N
N/* Output Compare management **************************************************/
Nvoid TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
Nvoid TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
Nvoid TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
Nvoid TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
Nvoid TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct);
Nvoid TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode);
Nvoid TIM_SetCompare1(TIM_TypeDef* TIMx, uint32_t Compare1);
Nvoid TIM_SetCompare2(TIM_TypeDef* TIMx, uint32_t Compare2);
Nvoid TIM_SetCompare3(TIM_TypeDef* TIMx, uint32_t Compare3);
Nvoid TIM_SetCompare4(TIM_TypeDef* TIMx, uint32_t Compare4);
Nvoid TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);
Nvoid TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);
Nvoid TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);
Nvoid TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);
Nvoid TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState);
Nvoid TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);
Nvoid TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);
Nvoid TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);
Nvoid TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);
Nvoid TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);
Nvoid TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);
Nvoid TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);
Nvoid TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);
Nvoid TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);
Nvoid TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);
Nvoid TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);
Nvoid TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);
Nvoid TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);
Nvoid TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity);
Nvoid TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);
Nvoid TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity);
Nvoid TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);
Nvoid TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity);
Nvoid TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);
Nvoid TIM_SelectOCREFClear(TIM_TypeDef* TIMx, uint16_t TIM_OCReferenceClear);
Nvoid TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx);
Nvoid TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN);
Nvoid TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState);
N
N/* Input Capture management ***************************************************/
Nvoid TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct);
Nvoid TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct);
Nvoid TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct);
Nuint32_t TIM_GetCapture1(TIM_TypeDef* TIMx);
Nuint32_t TIM_GetCapture2(TIM_TypeDef* TIMx);
Nuint32_t TIM_GetCapture3(TIM_TypeDef* TIMx);
Nuint32_t TIM_GetCapture4(TIM_TypeDef* TIMx);
Nvoid TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);
Nvoid TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);
Nvoid TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);
Nvoid TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);
N
N/* Interrupts, DMA and flags management ***************************************/
Nvoid TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState);
Nvoid TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource);
NFlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG);
Nvoid TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG);
NITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT);
Nvoid TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT);
Nvoid TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength);
Nvoid TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState);
Nvoid TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState);
N
N/* Clocks management **********************************************************/
Nvoid TIM_InternalClockConfig(TIM_TypeDef* TIMx);
Nvoid TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);
Nvoid TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
N                                uint16_t TIM_ICPolarity, uint16_t ICFilter);
Nvoid TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
N                             uint16_t ExtTRGFilter);
Nvoid TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
N                             uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter);
N
N
N/* Synchronization management *************************************************/
Nvoid TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);
Nvoid TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource);
Nvoid TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode);
Nvoid TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode);
Nvoid TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
N                   uint16_t ExtTRGFilter);
N
N/* Specific interface management **********************************************/                   
Nvoid TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
N                                uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity);
Nvoid TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState);
N
N/* Specific remapping management **********************************************/
Nvoid TIM_RemapConfig(TIM_TypeDef* TIMx, uint16_t TIM_Remap);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__FT32F0XX_TIM_H */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT FMD *****END OF FILE****/
L 49 "..\user\main.h" 2
N#include "ft32f0xx_usart.h"
L 1 "..\FTLib\Inc\ft32f0xx_usart.h" 1
N/**
N  ******************************************************************************
N  * @file    			ft32f0xx_usart.h
N  * @author  			FMD AE
N  * @brief   			This file contains all the functions prototypes for the USART 
N  *          			firmware library. 
N  * @version 			V1.0.0           
N  * @data		 			2021-07-01
N  ******************************************************************************
N  */
N
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __FT32F0XX_USART_H
N#define __FT32F0XX_USART_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "ft32f0xx.h"
N
N
N/** @addtogroup USART
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N
N   
N   
N/** 
N  * @brief  USART Init Structure definition  
N  */ 
N
Ntypedef struct
N{
N  uint32_t USART_BaudRate;            /*!< This member configures the USART communication baud rate.
N                                           The baud rate is computed using the following formula:
N                                            - IntegerDivider = ((PCLKx) / (16 * (USART_InitStruct->USART_BaudRate)))
N                                            - FractionalDivider = ((IntegerDivider - ((uint32_t) IntegerDivider)) * 16) + 0.5 */
N
N  uint32_t USART_WordLength;          /*!< Specifies the number of data bits transmitted or received in a frame.
N                                           This parameter can be a value of @ref USART_Word_Length */
N
N  uint32_t USART_StopBits;            /*!< Specifies the number of stop bits transmitted.
N                                           This parameter can be a value of @ref USART_Stop_Bits */
N
N  uint32_t USART_Parity;              /*!< Specifies the parity mode.
N                                           This parameter can be a value of @ref USART_Parity
N                                           @note When parity is enabled, the computed parity is inserted
N                                                 at the MSB position of the transmitted data (9th bit when
N                                                 the word length is set to 9 data bits; 8th bit when the
N                                                 word length is set to 8 data bits). */
N 
N  uint32_t USART_Mode;                /*!< Specifies wether the Receive or Transmit mode is enabled or disabled.
N                                           This parameter can be a value of @ref USART_Mode */
N
N  uint32_t USART_HardwareFlowControl; /*!< Specifies wether the hardware flow control mode is enabled
N                                           or disabled.
N                                           This parameter can be a value of @ref USART_Hardware_Flow_Control*/
N} USART_InitTypeDef;
N
N/** 
N  * @brief  USART Clock Init Structure definition
N  */ 
N
Ntypedef struct
N{
N  uint32_t USART_Clock;             /*!< Specifies whether the USART clock is enabled or disabled.
N                                         This parameter can be a value of @ref USART_Clock */
N
N  uint32_t USART_CPOL;              /*!< Specifies the steady state of the serial clock.
N                                         This parameter can be a value of @ref USART_Clock_Polarity */
N
N  uint32_t USART_CPHA;              /*!< Specifies the clock transition on which the bit capture is made.
N                                         This parameter can be a value of @ref USART_Clock_Phase */
N
N  uint32_t USART_LastBit;           /*!< Specifies whether the clock pulse corresponding to the last transmitted
N                                         data bit (MSB) has to be output on the SCLK pin in synchronous mode.
N                                         This parameter can be a value of @ref USART_Last_Bit */
N} USART_ClockInitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup USART_Exported_Constants
N  * @{
N  */ 
N
N#define IS_USART_ALL_PERIPH(PERIPH) (((PERIPH) == USART1) || \
N                                     ((PERIPH) == USART2))
X#define IS_USART_ALL_PERIPH(PERIPH) (((PERIPH) == USART1) ||                                      ((PERIPH) == USART2))
N
N#define IS_USART_123_PERIPH(PERIPH) (((PERIPH) == USART1) || \
N                                     ((PERIPH) == USART2) || \
N                                     ((PERIPH) == USART3))
X#define IS_USART_123_PERIPH(PERIPH) (((PERIPH) == USART1) ||                                      ((PERIPH) == USART2) ||                                      ((PERIPH) == USART3))
N
N/** @defgroup USART_Word_Length 
N  * @{
N  */ 
N
N#define USART_WordLength_8b                  ((uint32_t)0x00000000)
N#define USART_WordLength_9b                  USART_CR1_M /* should be ((uint32_t)0x00001000) */
N#define USART_WordLength_7b                  ((uint32_t)0x10001000) 
N#define IS_USART_WORD_LENGTH(LENGTH) (((LENGTH) == USART_WordLength_8b) || \
N                                      ((LENGTH) == USART_WordLength_9b) || \
N                                      ((LENGTH) == USART_WordLength_7b))
X#define IS_USART_WORD_LENGTH(LENGTH) (((LENGTH) == USART_WordLength_8b) ||                                       ((LENGTH) == USART_WordLength_9b) ||                                       ((LENGTH) == USART_WordLength_7b))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Stop_Bits 
N  * @{
N  */ 
N
N#define USART_StopBits_1                     ((uint32_t)0x00000000)
N#define USART_StopBits_2                     USART_CR2_STOP_1
N#define USART_StopBits_1_5                   (USART_CR2_STOP_0 | USART_CR2_STOP_1)
N#define IS_USART_STOPBITS(STOPBITS) (((STOPBITS) == USART_StopBits_1) || \
N                                     ((STOPBITS) == USART_StopBits_2) || \
N                                     ((STOPBITS) == USART_StopBits_1_5))
X#define IS_USART_STOPBITS(STOPBITS) (((STOPBITS) == USART_StopBits_1) ||                                      ((STOPBITS) == USART_StopBits_2) ||                                      ((STOPBITS) == USART_StopBits_1_5))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Parity 
N  * @{
N  */ 
N
N#define USART_Parity_No                      ((uint32_t)0x00000000)
N#define USART_Parity_Even                    USART_CR1_PCE
N#define USART_Parity_Odd                     (USART_CR1_PCE | USART_CR1_PS) 
N#define IS_USART_PARITY(PARITY) (((PARITY) == USART_Parity_No) || \
N                                 ((PARITY) == USART_Parity_Even) || \
N                                 ((PARITY) == USART_Parity_Odd))
X#define IS_USART_PARITY(PARITY) (((PARITY) == USART_Parity_No) ||                                  ((PARITY) == USART_Parity_Even) ||                                  ((PARITY) == USART_Parity_Odd))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Mode 
N  * @{
N  */ 
N
N#define USART_Mode_Rx                        USART_CR1_RE
N#define USART_Mode_Tx                        USART_CR1_TE
N#define IS_USART_MODE(MODE) ((((MODE) & (uint32_t)0xFFFFFFF3) == 0x00) && \
N                              ((MODE) != (uint32_t)0x00))
X#define IS_USART_MODE(MODE) ((((MODE) & (uint32_t)0xFFFFFFF3) == 0x00) &&                               ((MODE) != (uint32_t)0x00))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Hardware_Flow_Control 
N  * @{
N  */ 
N
N#define USART_HardwareFlowControl_None       ((uint32_t)0x00000000)
N#define USART_HardwareFlowControl_RTS        USART_CR3_RTSE
N#define USART_HardwareFlowControl_CTS        USART_CR3_CTSE
N#define USART_HardwareFlowControl_RTS_CTS    (USART_CR3_RTSE | USART_CR3_CTSE)
N#define IS_USART_HARDWARE_FLOW_CONTROL(CONTROL)\
N                              (((CONTROL) == USART_HardwareFlowControl_None) || \
N                               ((CONTROL) == USART_HardwareFlowControl_RTS) || \
N                               ((CONTROL) == USART_HardwareFlowControl_CTS) || \
N                               ((CONTROL) == USART_HardwareFlowControl_RTS_CTS))
X#define IS_USART_HARDWARE_FLOW_CONTROL(CONTROL)                              (((CONTROL) == USART_HardwareFlowControl_None) ||                                ((CONTROL) == USART_HardwareFlowControl_RTS) ||                                ((CONTROL) == USART_HardwareFlowControl_CTS) ||                                ((CONTROL) == USART_HardwareFlowControl_RTS_CTS))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Clock 
N  * @{
N  */ 
N  
N#define USART_Clock_Disable                  ((uint32_t)0x00000000)
N#define USART_Clock_Enable                   USART_CR2_CLKEN
N#define IS_USART_CLOCK(CLOCK) (((CLOCK) == USART_Clock_Disable) || \
N                               ((CLOCK) == USART_Clock_Enable))
X#define IS_USART_CLOCK(CLOCK) (((CLOCK) == USART_Clock_Disable) ||                                ((CLOCK) == USART_Clock_Enable))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Clock_Polarity 
N  * @{
N  */
N  
N#define USART_CPOL_Low                       ((uint32_t)0x00000000)
N#define USART_CPOL_High                      USART_CR2_CPOL
N#define IS_USART_CPOL(CPOL) (((CPOL) == USART_CPOL_Low) || ((CPOL) == USART_CPOL_High))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Clock_Phase
N  * @{
N  */
N
N#define USART_CPHA_1Edge                     ((uint32_t)0x00000000)
N#define USART_CPHA_2Edge                     USART_CR2_CPHA
N#define IS_USART_CPHA(CPHA) (((CPHA) == USART_CPHA_1Edge) || ((CPHA) == USART_CPHA_2Edge))
N
N/**
N  * @}
N  */
N
N/** @defgroup USART_Last_Bit
N  * @{
N  */
N
N#define USART_LastBit_Disable                ((uint32_t)0x00000000)
N#define USART_LastBit_Enable                 USART_CR2_LBCL
N#define IS_USART_LASTBIT(LASTBIT) (((LASTBIT) == USART_LastBit_Disable) || \
N                                   ((LASTBIT) == USART_LastBit_Enable))
X#define IS_USART_LASTBIT(LASTBIT) (((LASTBIT) == USART_LastBit_Disable) ||                                    ((LASTBIT) == USART_LastBit_Enable))
N/**
N  * @}
N  */
N  
N/** @defgroup USART_DMA_Requests 
N  * @{
N  */
N
N#define USART_DMAReq_Tx                      USART_CR3_DMAT
N#define USART_DMAReq_Rx                      USART_CR3_DMAR
N#define IS_USART_DMAREQ(DMAREQ) ((((DMAREQ) & (uint32_t)0xFFFFFF3F) == 0x00) && \
N                                  ((DMAREQ) != (uint32_t)0x00))
X#define IS_USART_DMAREQ(DMAREQ) ((((DMAREQ) & (uint32_t)0xFFFFFF3F) == 0x00) &&                                   ((DMAREQ) != (uint32_t)0x00))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_DMA_Recception_Error
N  * @{
N  */
N
N#define USART_DMAOnError_Enable              ((uint32_t)0x00000000)
N#define USART_DMAOnError_Disable             USART_CR3_DDRE
N#define IS_USART_DMAONERROR(DMAERROR) (((DMAERROR) == USART_DMAOnError_Disable)|| \
N                                       ((DMAERROR) == USART_DMAOnError_Enable))
X#define IS_USART_DMAONERROR(DMAERROR) (((DMAERROR) == USART_DMAOnError_Disable)||                                        ((DMAERROR) == USART_DMAOnError_Enable))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_MuteMode_WakeUp_methods
N  * @{
N  */
N
N#define USART_WakeUp_IdleLine                ((uint32_t)0x00000000)
N#define USART_WakeUp_AddressMark             USART_CR1_WAKE
N#define IS_USART_MUTEMODE_WAKEUP(WAKEUP) (((WAKEUP) == USART_WakeUp_IdleLine) || \
N                                          ((WAKEUP) == USART_WakeUp_AddressMark))
X#define IS_USART_MUTEMODE_WAKEUP(WAKEUP) (((WAKEUP) == USART_WakeUp_IdleLine) ||                                           ((WAKEUP) == USART_WakeUp_AddressMark))
N/**
N  * @}
N  */
N
N/** @defgroup USART_Address_Detection
N  * @{
N  */ 
N
N#define USART_AddressLength_4b               ((uint32_t)0x00000000)
N#define USART_AddressLength_7b               USART_CR2_ADDM7
N#define IS_USART_ADDRESS_DETECTION(ADDRESS) (((ADDRESS) == USART_AddressLength_4b) || \
N                                             ((ADDRESS) == USART_AddressLength_7b))
X#define IS_USART_ADDRESS_DETECTION(ADDRESS) (((ADDRESS) == USART_AddressLength_4b) ||                                              ((ADDRESS) == USART_AddressLength_7b))
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N/** @defgroup USART_IrDA_Low_Power 
N  * @{
N  */
N
N#define USART_IrDAMode_LowPower              USART_CR3_IRLP
N#define USART_IrDAMode_Normal                ((uint32_t)0x00000000)
N#define IS_USART_IRDA_MODE(MODE) (((MODE) == USART_IrDAMode_LowPower) || \
N                                  ((MODE) == USART_IrDAMode_Normal))
X#define IS_USART_IRDA_MODE(MODE) (((MODE) == USART_IrDAMode_LowPower) ||                                   ((MODE) == USART_IrDAMode_Normal))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_DE_Polarity 
N  * @{
N  */
N
N#define USART_DEPolarity_High                ((uint32_t)0x00000000)
N#define USART_DEPolarity_Low                 USART_CR3_DEP
N#define IS_USART_DE_POLARITY(POLARITY) (((POLARITY) == USART_DEPolarity_Low) || \
N                                        ((POLARITY) == USART_DEPolarity_High))
X#define IS_USART_DE_POLARITY(POLARITY) (((POLARITY) == USART_DEPolarity_Low) ||                                         ((POLARITY) == USART_DEPolarity_High))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Inversion_Pins 
N  * @{
N  */
N
N#define USART_InvPin_Tx                      USART_CR2_TXINV
N#define USART_InvPin_Rx                      USART_CR2_RXINV
N#define IS_USART_INVERSTION_PIN(PIN) ((((PIN) & (uint32_t)0xFFFCFFFF) == 0x00) && \
N                                       ((PIN) != (uint32_t)0x00))
X#define IS_USART_INVERSTION_PIN(PIN) ((((PIN) & (uint32_t)0xFFFCFFFF) == 0x00) &&                                        ((PIN) != (uint32_t)0x00))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_AutoBaudRate_Mode 
N  * @{
N  */
N
N#define USART_AutoBaudRate_StartBit          ((uint32_t)0x00000000)
N#define USART_AutoBaudRate_FallingEdge       USART_CR2_ABRMODE_0
N#define IS_USART_AUTOBAUDRATE_MODE(MODE) (((MODE) == USART_AutoBaudRate_StartBit) || \
N                                          ((MODE) == USART_AutoBaudRate_FallingEdge))
X#define IS_USART_AUTOBAUDRATE_MODE(MODE) (((MODE) == USART_AutoBaudRate_StartBit) ||                                           ((MODE) == USART_AutoBaudRate_FallingEdge))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_OVR_DETECTION
N  * @{
N  */
N
N#define USART_OVRDetection_Enable            ((uint32_t)0x00000000)
N#define USART_OVRDetection_Disable           USART_CR3_OVRDIS
N#define IS_USART_OVRDETECTION(OVR) (((OVR) == USART_OVRDetection_Enable)|| \
N                                    ((OVR) == USART_OVRDetection_Disable))
X#define IS_USART_OVRDETECTION(OVR) (((OVR) == USART_OVRDetection_Enable)||                                     ((OVR) == USART_OVRDetection_Disable))
N/**
N  * @}
N  */ 
N/** @defgroup USART_Request 
N  * @{
N  */
N
N#define USART_Request_ABRRQ                  USART_RQR_ABRRQ
N#define USART_Request_SBKRQ                  USART_RQR_SBKRQ
N#define USART_Request_MMRQ                   USART_RQR_MMRQ
N#define USART_Request_RXFRQ                  USART_RQR_RXFRQ
N#define USART_Request_TXFRQ                  USART_RQR_TXFRQ
N
N#define IS_USART_REQUEST(REQUEST) (((REQUEST) == USART_Request_TXFRQ) || \
N                                   ((REQUEST) == USART_Request_RXFRQ) || \
N                                   ((REQUEST) == USART_Request_MMRQ) || \
N                                   ((REQUEST) == USART_Request_SBKRQ) || \
N                                   ((REQUEST) == USART_Request_ABRRQ))
X#define IS_USART_REQUEST(REQUEST) (((REQUEST) == USART_Request_TXFRQ) ||                                    ((REQUEST) == USART_Request_RXFRQ) ||                                    ((REQUEST) == USART_Request_MMRQ) ||                                    ((REQUEST) == USART_Request_SBKRQ) ||                                    ((REQUEST) == USART_Request_ABRRQ))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Flags 
N  * @{
N  */
N#define USART_FLAG_REACK                     USART_ISR_REACK
N#define USART_FLAG_TEACK                     USART_ISR_TEACK
N#define USART_FLAG_WU                        USART_ISR_WUF 
N#define USART_FLAG_RWU                       USART_ISR_RWU
N#define USART_FLAG_SBK                       USART_ISR_SBKF
N#define USART_FLAG_CM                        USART_ISR_CMF
N#define USART_FLAG_BUSY                      USART_ISR_BUSY
N#define USART_FLAG_ABRF                      USART_ISR_ABRF
N#define USART_FLAG_ABRE                      USART_ISR_ABRE
N#define USART_FLAG_EOB                       USART_ISR_EOBF 
N#define USART_FLAG_RTO                       USART_ISR_RTOF
N#define USART_FLAG_nCTSS                     USART_ISR_CTS 
N#define USART_FLAG_CTS                       USART_ISR_CTSIF
N#define USART_FLAG_LBD                       USART_ISR_LBD 
N#define USART_FLAG_TXE                       USART_ISR_TXE
N#define USART_FLAG_TC                        USART_ISR_TC
N#define USART_FLAG_RXNE                      USART_ISR_RXNE
N#define USART_FLAG_IDLE                      USART_ISR_IDLE
N#define USART_FLAG_ORE                       USART_ISR_ORE
N#define USART_FLAG_NE                        USART_ISR_NE
N#define USART_FLAG_FE                        USART_ISR_FE
N#define USART_FLAG_PE                        USART_ISR_PE
N#define IS_USART_FLAG(FLAG) (((FLAG) == USART_FLAG_PE) || ((FLAG) == USART_FLAG_TXE) || \
N                             ((FLAG) == USART_FLAG_TC) || ((FLAG) == USART_FLAG_RXNE) || \
N                             ((FLAG) == USART_FLAG_IDLE) || ((FLAG) == USART_FLAG_LBD) || \
N                             ((FLAG) == USART_FLAG_CTS) || ((FLAG) == USART_FLAG_ORE) || \
N                             ((FLAG) == USART_FLAG_NE) || ((FLAG) == USART_FLAG_FE) || \
N                             ((FLAG) == USART_FLAG_nCTSS) || ((FLAG) == USART_FLAG_RTO) || \
N                             ((FLAG) == USART_FLAG_EOB) || ((FLAG) == USART_FLAG_ABRE) || \
N                             ((FLAG) == USART_FLAG_ABRF) || ((FLAG) == USART_FLAG_BUSY) || \
N                             ((FLAG) == USART_FLAG_CM) || ((FLAG) == USART_FLAG_SBK) || \
N                             ((FLAG) == USART_FLAG_RWU) || ((FLAG) == USART_FLAG_WU) || \
N                             ((FLAG) == USART_FLAG_TEACK)|| ((FLAG) == USART_FLAG_REACK))
X#define IS_USART_FLAG(FLAG) (((FLAG) == USART_FLAG_PE) || ((FLAG) == USART_FLAG_TXE) ||                              ((FLAG) == USART_FLAG_TC) || ((FLAG) == USART_FLAG_RXNE) ||                              ((FLAG) == USART_FLAG_IDLE) || ((FLAG) == USART_FLAG_LBD) ||                              ((FLAG) == USART_FLAG_CTS) || ((FLAG) == USART_FLAG_ORE) ||                              ((FLAG) == USART_FLAG_NE) || ((FLAG) == USART_FLAG_FE) ||                              ((FLAG) == USART_FLAG_nCTSS) || ((FLAG) == USART_FLAG_RTO) ||                              ((FLAG) == USART_FLAG_EOB) || ((FLAG) == USART_FLAG_ABRE) ||                              ((FLAG) == USART_FLAG_ABRF) || ((FLAG) == USART_FLAG_BUSY) ||                              ((FLAG) == USART_FLAG_CM) || ((FLAG) == USART_FLAG_SBK) ||                              ((FLAG) == USART_FLAG_RWU) || ((FLAG) == USART_FLAG_WU) ||                              ((FLAG) == USART_FLAG_TEACK)|| ((FLAG) == USART_FLAG_REACK))
N
N#define IS_USART_CLEAR_FLAG(FLAG) (((FLAG) == USART_FLAG_WU) || ((FLAG) == USART_FLAG_TC) || \
N                                   ((FLAG) == USART_FLAG_IDLE) || ((FLAG) == USART_FLAG_ORE) || \
N                                   ((FLAG) == USART_FLAG_NE) || ((FLAG) == USART_FLAG_FE) || \
N                                   ((FLAG) == USART_FLAG_LBD) || ((FLAG) == USART_FLAG_CTS) || \
N                                   ((FLAG) == USART_FLAG_RTO) || ((FLAG) == USART_FLAG_EOB) || \
N                                   ((FLAG) == USART_FLAG_CM) || ((FLAG) == USART_FLAG_PE))
X#define IS_USART_CLEAR_FLAG(FLAG) (((FLAG) == USART_FLAG_WU) || ((FLAG) == USART_FLAG_TC) ||                                    ((FLAG) == USART_FLAG_IDLE) || ((FLAG) == USART_FLAG_ORE) ||                                    ((FLAG) == USART_FLAG_NE) || ((FLAG) == USART_FLAG_FE) ||                                    ((FLAG) == USART_FLAG_LBD) || ((FLAG) == USART_FLAG_CTS) ||                                    ((FLAG) == USART_FLAG_RTO) || ((FLAG) == USART_FLAG_EOB) ||                                    ((FLAG) == USART_FLAG_CM) || ((FLAG) == USART_FLAG_PE))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Interrupt_definition 
N  * @brief USART Interrupt definition
N  * USART_IT possible values
N  * Elements values convention: 0xZZZZYYXX
N  *   XX: Position of the corresponding Interrupt
N  *   YY: Register index
N  *   ZZZZ: Flag position
N  * @{
N  */
N
N#define USART_IT_WU                          ((uint32_t)0x00140316) 
N#define USART_IT_CM                          ((uint32_t)0x0011010E)
N#define USART_IT_EOB                         ((uint32_t)0x000C011B)
N#define USART_IT_RTO                         ((uint32_t)0x000B011A)
N#define USART_IT_PE                          ((uint32_t)0x00000108)
N#define USART_IT_TXE                         ((uint32_t)0x00070107)
N#define USART_IT_TC                          ((uint32_t)0x00060106)
N#define USART_IT_RXNE                        ((uint32_t)0x00050105)
N#define USART_IT_IDLE                        ((uint32_t)0x00040104)
N#define USART_IT_LBD                         ((uint32_t)0x00080206)
N#define USART_IT_CTS                         ((uint32_t)0x0009030A) 
N#define USART_IT_ERR                         ((uint32_t)0x00000300)
N#define USART_IT_ORE                         ((uint32_t)0x00030300)
N#define USART_IT_NE                          ((uint32_t)0x00020300)
N#define USART_IT_FE                          ((uint32_t)0x00010300)
N
N#define IS_USART_CONFIG_IT(IT) (((IT) == USART_IT_PE) || ((IT) == USART_IT_TXE) || \
N                                ((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) || \
N                                ((IT) == USART_IT_IDLE) || ((IT) == USART_IT_LBD) || \
N                                ((IT) == USART_IT_CTS) || ((IT) == USART_IT_ERR) || \
N                                ((IT) == USART_IT_RTO) || ((IT) == USART_IT_EOB) || \
N                                ((IT) == USART_IT_CM) || ((IT) == USART_IT_WU))
X#define IS_USART_CONFIG_IT(IT) (((IT) == USART_IT_PE) || ((IT) == USART_IT_TXE) ||                                 ((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) ||                                 ((IT) == USART_IT_IDLE) || ((IT) == USART_IT_LBD) ||                                 ((IT) == USART_IT_CTS) || ((IT) == USART_IT_ERR) ||                                 ((IT) == USART_IT_RTO) || ((IT) == USART_IT_EOB) ||                                 ((IT) == USART_IT_CM) || ((IT) == USART_IT_WU))
N
N#define IS_USART_GET_IT(IT) (((IT) == USART_IT_PE) || ((IT) == USART_IT_TXE) || \
N                             ((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) || \
N                             ((IT) == USART_IT_IDLE) || ((IT) == USART_IT_LBD) || \
N                             ((IT) == USART_IT_CTS) || ((IT) == USART_IT_ORE) || \
N                             ((IT) == USART_IT_NE) || ((IT) == USART_IT_FE) || \
N                             ((IT) == USART_IT_RTO) || ((IT) == USART_IT_EOB) || \
N                             ((IT) == USART_IT_CM) || ((IT) == USART_IT_WU))
X#define IS_USART_GET_IT(IT) (((IT) == USART_IT_PE) || ((IT) == USART_IT_TXE) ||                              ((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) ||                              ((IT) == USART_IT_IDLE) || ((IT) == USART_IT_LBD) ||                              ((IT) == USART_IT_CTS) || ((IT) == USART_IT_ORE) ||                              ((IT) == USART_IT_NE) || ((IT) == USART_IT_FE) ||                              ((IT) == USART_IT_RTO) || ((IT) == USART_IT_EOB) ||                              ((IT) == USART_IT_CM) || ((IT) == USART_IT_WU))
N
N#define IS_USART_CLEAR_IT(IT) (((IT) == USART_IT_TC) || ((IT) == USART_IT_PE) || \
N                               ((IT) == USART_IT_FE) || ((IT) == USART_IT_NE) || \
N                               ((IT) == USART_IT_ORE) || ((IT) == USART_IT_IDLE) || \
N                               ((IT) == USART_IT_LBD) || ((IT) == USART_IT_CTS) || \
N                               ((IT) == USART_IT_RTO) || ((IT) == USART_IT_EOB) || \
N                               ((IT) == USART_IT_CM) || ((IT) == USART_IT_WU))
X#define IS_USART_CLEAR_IT(IT) (((IT) == USART_IT_TC) || ((IT) == USART_IT_PE) ||                                ((IT) == USART_IT_FE) || ((IT) == USART_IT_NE) ||                                ((IT) == USART_IT_ORE) || ((IT) == USART_IT_IDLE) ||                                ((IT) == USART_IT_LBD) || ((IT) == USART_IT_CTS) ||                                ((IT) == USART_IT_RTO) || ((IT) == USART_IT_EOB) ||                                ((IT) == USART_IT_CM) || ((IT) == USART_IT_WU))
N/**
N  * @}
N  */
N
N/** @defgroup USART_Global_definition 
N  * @{
N  */
N
N#define IS_USART_BAUDRATE(BAUDRATE) (((BAUDRATE) > 0) && ((BAUDRATE) < 0x005B8D81))
N#define IS_USART_DE_ASSERTION_DEASSERTION_TIME(TIME) ((TIME) <= 0x1F)
N#define IS_USART_AUTO_RETRY_COUNTER(COUNTER) ((COUNTER) <= 0x7)
N#define IS_USART_TIMEOUT(TIMEOUT) ((TIMEOUT) <= 0x00FFFFFF)
N#define IS_USART_DATA(DATA) ((DATA) <= 0x1FF)
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
N/* Initialization and Configuration functions *********************************/
Nvoid USART_DeInit(USART_TypeDef* USARTx);
Nvoid USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct);
Nvoid USART_StructInit(USART_InitTypeDef* USART_InitStruct);
Nvoid USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct);
Nvoid USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct);
Nvoid USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_DirectionModeCmd(USART_TypeDef* USARTx, uint32_t USART_DirectionMode, FunctionalState NewState);
Nvoid USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_MSBFirstCmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_DataInvCmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_InvPinCmd(USART_TypeDef* USARTx, uint32_t USART_InvPin, FunctionalState NewState);
Nvoid USART_SWAPPinCmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_ReceiverTimeOutCmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_SetReceiverTimeOut(USART_TypeDef* USARTx, uint32_t USART_ReceiverTimeOut);
N
N/* AutoBaudRate functions *****************************************************/
Nvoid USART_AutoBaudRateCmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_AutoBaudRateConfig(USART_TypeDef* USARTx, uint32_t USART_AutoBaudRate);
N
N/* Data transfers functions ***************************************************/
Nvoid USART_SendData(USART_TypeDef* USARTx, uint16_t Data);
Nuint16_t USART_ReceiveData(USART_TypeDef* USARTx);
N
N/* Multi-Processor Communication functions ************************************/
Nvoid USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address);
Nvoid USART_MuteModeWakeUpConfig(USART_TypeDef* USARTx, uint32_t USART_WakeUp);
Nvoid USART_MuteModeCmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_AddressDetectionConfig(USART_TypeDef* USARTx, uint32_t USART_AddressLength);
N
N/* Half-duplex mode function **************************************************/
Nvoid USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState);
N
N/* RS485 mode functions *******************************************************/
Nvoid USART_DECmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_DEPolarityConfig(USART_TypeDef* USARTx, uint32_t USART_DEPolarity);
Nvoid USART_SetDEAssertionTime(USART_TypeDef* USARTx, uint32_t USART_DEAssertionTime);
Nvoid USART_SetDEDeassertionTime(USART_TypeDef* USARTx, uint32_t USART_DEDeassertionTime);
N
N/* DMA transfers management functions *****************************************/
Nvoid USART_DMACmd(USART_TypeDef* USARTx, uint32_t USART_DMAReq, FunctionalState NewState);
Nvoid USART_DMAReceptionErrorConfig(USART_TypeDef* USARTx, uint32_t USART_DMAOnError);
N
N/* Interrupts and flags management functions **********************************/
Nvoid USART_ITConfig(USART_TypeDef* USARTx, uint32_t USART_IT, FunctionalState NewState);
Nvoid USART_RequestCmd(USART_TypeDef* USARTx, uint32_t USART_Request, FunctionalState NewState);
Nvoid USART_OverrunDetectionConfig(USART_TypeDef* USARTx, uint32_t USART_OVRDetection);
NFlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint32_t USART_FLAG);
Nvoid USART_ClearFlag(USART_TypeDef* USARTx, uint32_t USART_FLAG);
NITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint32_t USART_IT);
Nvoid USART_ClearITPendingBit(USART_TypeDef* USARTx, uint32_t USART_IT);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __FT32F0XX_USART_H */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/************************ (C) COPYRIGHT FMD *****END OF FILE****/
L 50 "..\user\main.h" 2
N#include "ft32f0xx_wwdg.h"
L 1 "..\FTLib\Inc\ft32f0xx_wwdg.h" 1
N/**
N  ******************************************************************************
N  * @file    ft32f030x8_wwdg.h
N  * @author  MCD Application Team
N  * @version V1.0.0
N  * @date    2020-06-22
N  * @brief   This file contains all the functions prototypes for the WWDG 
N  *          firmware library.
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __FT32F030X8_WWDG_H
N#define __FT32F030X8_WWDG_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "ft32f0xx.h"
N
N/** @addtogroup FT32F030X8_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup WWDG
N  * @{
N  */ 
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup WWDG_Exported_Constants
N  * @{
N  */ 
N  
N/** @defgroup WWDG_Prescaler 
N  * @{
N  */ 
N  
N#define WWDG_Prescaler_1    ((uint32_t)0x00000000)
N#define WWDG_Prescaler_2    ((uint32_t)0x00000080)
N#define WWDG_Prescaler_4    ((uint32_t)0x00000100)
N#define WWDG_Prescaler_8    ((uint32_t)0x00000180)
N#define IS_WWDG_PRESCALER(PRESCALER) (((PRESCALER) == WWDG_Prescaler_1) || \
N                                      ((PRESCALER) == WWDG_Prescaler_2) || \
N                                      ((PRESCALER) == WWDG_Prescaler_4) || \
N                                      ((PRESCALER) == WWDG_Prescaler_8))
X#define IS_WWDG_PRESCALER(PRESCALER) (((PRESCALER) == WWDG_Prescaler_1) ||                                       ((PRESCALER) == WWDG_Prescaler_2) ||                                       ((PRESCALER) == WWDG_Prescaler_4) ||                                       ((PRESCALER) == WWDG_Prescaler_8))
N#define IS_WWDG_WINDOW_VALUE(VALUE) ((VALUE) <= 0x7F)
N#define IS_WWDG_COUNTER(COUNTER) (((COUNTER) >= 0x40) && ((COUNTER) <= 0x7F))
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N/*  Function used to set the WWDG configuration to the default reset state ****/  
Nvoid WWDG_DeInit(void);
N
N/* Prescaler, Refresh window and Counter configuration functions **************/
Nvoid WWDG_SetPrescaler(uint32_t WWDG_Prescaler);
Nvoid WWDG_SetWindowValue(uint8_t WindowValue);
Nvoid WWDG_EnableIT(void);
Nvoid WWDG_SetCounter(uint8_t Counter);
N
N/* WWDG activation functions **************************************************/
Nvoid WWDG_Enable(uint8_t Counter);
N
N/* Interrupts and flags management functions **********************************/
NFlagStatus WWDG_GetFlagStatus(void);
Nvoid WWDG_ClearFlag(void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __FT32F030X8_WWDG_H */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/************************ (C) COPYRIGHT FMD *****END OF FILE****/
L 51 "..\user\main.h" 2
N#include "ft32f072x8.h"
N
N
N
N
N#include "usb_core.h"
L 1 "..\usb\inc\usb_core.h" 1
N/**
N  ******************************************************************************
N  * @file    	    usb_core.h
N  * @author  	    FMD AE
N  * @brief   		This file contains all the functions prototypes for the usb firmware
N  *                 library.  	
N  * @version 	    V1.0.0           
N  * @data		    2022-01-13
N  ******************************************************************************
N  * @attention
N  * COPYRIGHT (C) 2021 Fremont Micro Devices Corporation All rights reserved.
N  *    This software is provided by the copyright holders and contributors,and the
N  *software is believed to be accurate and reliable. However, Fremont Micro Devices
N  * Corporation assumes no responsibility for the consequences of use of such
N  *software or for any infringement of patents of other rights of third parties,
N  *which may result from its use. No license is granted by implication or otherwise
N  *under any patent rights of Fremont Micro Devices Corporation.
N  *  ******************************************************************************
N  */
N#ifndef _USB_CORE_H_
N#define _USB_CORE_H_
N
N/* Includes ---------------------------------------------------------------------*/
N#include "ft32f0xx.h"
N#include "usb_desc.h"
L 1 "..\usb\inc\usb_desc.h" 1
N/**
N  ******************************************************************************
N  * @file    	    usb_desc.h
N  * @author  	    FMD AE
N  * @brief   		This file contains all the functions prototypes for the usb_desc 
N  * @version 	    V1.0.0           
N  * @data		    2022-01-13
N  ******************************************************************************
N  * @attention
N  * COPYRIGHT (C) 2021 Fremont Micro Devices Corporation All rights reserved.
N  *    This software is provided by the copyright holders and contributors,and the
N  *software is believed to be accurate and reliable. However, Fremont Micro Devices
N  * Corporation assumes no responsibility for the consequences of use of such
N  *software or for any infringement of patents of other rights of third parties,
N  *which may result from its use. No license is granted by implication or otherwise
N  *under any patent rights of Fremont Micro Devices Corporation.
N  *  ******************************************************************************
N  */
N#ifndef _DESCRIPT_H_
N#define _DESCRIPT_H_
N/* Includes ---------------------------------------------------------------------*/
N#include "ft32f0xx.h"
N
N/* Public Constant prototypes----------------------------------------------------*/
N
N/* Public typedef ---------------------------------------------------------------*/
N#ifndef BYTE
Ntypedef unsigned char BYTE;
N#endif
N#ifndef WORD
Ntypedef unsigned short WORD;
N#endif
N
N#pragma pack(1)
N
Ntypedef union
N{
N	uint16_t w;
N	struct BW
N	{
N	uint8_t bb0;
N	uint8_t bb1;
N	}
N	bw;
N} uint16_t_uint8_t;
N/* Command structure */
Ntypedef struct COMMAND {
N	BYTE  bmRequestType;
N	BYTE  bRequest;
N	uint16_t_uint8_t  wValue;
N	uint16_t_uint8_t  wIndex;
N	uint16_t_uint8_t  wLength;
N  } COMMAND;	
Ntypedef COMMAND*  PCOMMAND;
N/* Standard Device Descriptor */
Ntypedef struct STD_DEV_DSCR 
N{
N	BYTE  bLength;
N	BYTE  bDescriptorType;
N	WORD  bcdUSB;
N	BYTE  bDeviceClass;
N	BYTE  bDeviceSubClass;
N	BYTE  bDeviceProtocol;
N	BYTE  bMaxPacketSize0;
N	WORD  idVendor;
N	WORD  idProduct;
N	WORD  bcdDevice;
N	BYTE  iManufacturer;
N	BYTE  iProduct;
N	BYTE  iSerialNumber;
N	BYTE  bNumConfigurations;
N} STD_DEV_DSCR;
Ntypedef STD_DEV_DSCR* PSTD_DEV_DSCR;
N
N/* Standard Configuration Descriptor */
Ntypedef struct STD_CFG_DSCR 
N{
N	BYTE  bLength;
N	BYTE  bDescriptorType;
N	WORD  wTotalLength;
N	BYTE  bNumInterfaces;
N	BYTE  bConfigurationValue;
N	BYTE  iConfiguration;
N	BYTE  bmAttributes;
N	BYTE  bMaxPower;
N} STD_CFG_DSCR;
Ntypedef STD_CFG_DSCR* PSTD_CFG_DSCR;
N
N/* Standard Interface Descriptor */
Ntypedef struct STD_IF_DSCR 
N{
N	BYTE  bLength;
N	BYTE  bDescriptorType;
N	BYTE  bInterfaceNumber;
N	BYTE  bAlternateSetting;
N	BYTE  bNumEndpoints;
N	BYTE  bInterfaceClass;
N	BYTE  bInterfaceSubClass;
N	BYTE  bInterfaceProtocol;
N	BYTE  iInterface;
N} STD_IF_DSCR;
Ntypedef STD_IF_DSCR* PSTD_IF_DSCR;
N
N/* Standard Endpoint Descriptor */
Ntypedef struct STD_EP_DSCR 
N{
N	BYTE  bLength;
N	BYTE  bDescriptorType;
N	BYTE  bEndpointAddress;
N	BYTE  bmAttributes;
N	WORD  wMaxPacketSize;
N	BYTE  bInterval;
N} STD_EP_DSCR;
Ntypedef STD_EP_DSCR* PSTD_EP_DSCR;
N		
Ntypedef struct STD_HID_DSCR 
N{
N	BYTE  bLength;
N	BYTE  bDescriptorTypeHid;
N	WORD  bcdHID;
N	BYTE	CountryCode;
N	BYTE	bNumDescriptors;
N	BYTE  bDescriptorType;
N	WORD	wDescriptorLength;
N} STD_HID_DSCR;
Ntypedef STD_HID_DSCR* PSTD_HID_DSCR;  
N
N/*HID CLASS REQUEST DATA*/
Ntypedef struct
N{
N	uint8_t	wHID_SetRptByte[16];
N	uint8_t	wHID_IdleTimeIf0ID;
N	uint8_t	wHID_Protocol;
N	uint8_t	wHID_SetReportFeature;
N	uint32_t	wHID_Setreportfeature[16];
N	uint32_t	wHID_Status;
N}CLASS_HID_DATA;
N/*
N  Define configuration structures
N  The configuration structures need to be modified to match the required configuration
N  Each configuration should start with a configuration descriptor
N  followed by 1 or more interface descriptors (each of which is followed by
N  endpoint descriptors for all the endpoints in that interface).
N  The interface descriptors should start with interface 0, alternate setting 0.
N  Followed by any alternate settings for interface 0.
N  Then interface 1 (if more than 1 interface in the configuration), followed
N  by any alternate settings for interface 1.
N  This arrangement should be repeated for all interfaces in the configuration.
N*/
N
N/* Configuration 1 */
Ntypedef struct M_CFG_1 {
N	STD_CFG_DSCR  stdcfg;			/* Required Standard Configuration Descriptor */
N	STD_IF_DSCR   stdif00;			/* Interface 0 Descriptor */
N	STD_HID_DSCR	stdhid;			/* HID Descriptor*/
N	STD_EP_DSCR   stdep00_0;		/* 1st Endpoint Descriptor for Interface 0 */
N} M_CFG_1;
Ntypedef M_CFG_1* PM_CFG_1;
N
N/* Configuration 2 */
Ntypedef struct M_CFG_2 {
N	STD_CFG_DSCR  stdcfg;			/* Required Standard Configuration Descriptor */
N	STD_IF_DSCR   stdif00;			/* Interface 0 Descriptor */
N	STD_EP_DSCR   stdep00_0;		/* 1st Endpoint Descriptor for Interface 0 */
N	STD_EP_DSCR   stdep00_1;		/* 2nd Endpoint Descriptor for Interface 0 */
N	STD_IF_DSCR   stdif10;			/* Interface 1 Descriptor */
N	STD_EP_DSCR   stdep10_0;		/* 1st Endpoint Descriptor for Interface 1 */
N	STD_EP_DSCR   stdep10_1;		/* 2nd Endpoint Descriptor for Interface 1 */
N} M_CFG_2;
Ntypedef M_CFG_2* PM_CFG_2;
N
N/* Top level structure containing pointers to each configuration */
Ntypedef struct M_CFG {
N	PM_CFG_1      pcfg1;			/* Pointer to M_CFG_1 */
N	PM_CFG_2      pcfg2;			/* Pointer to M_CFG_2 */
N  } M_CFG;
Ntypedef M_CFG* PM_CFG;
N  
N
N
N
N/* Public define ----------------------------------------------------------------*/
N#define StatusInfo0 			StatusInfo.bw.bb1 /* Reverse bb0 & bb1 */
N#define StatusInfo1 			StatusInfo.bw.bb0
N		
N#define USBwValue 				wValue.w
N#define USBwValue0 				wValue.bw.bb0
N#define USBwValue1 				wValue.bw.bb1
N#define USBwIndex 				wIndex.w
N#define USBwIndex0 				wIndex.bw.bb0
N#define USBwIndex1 				wIndex.bw.bb1
N#define USBwLength 				wLength.w
N#define USBwLength0				wLength.bw.bb0
N#define USBwLength1 			wLength.bw.bb1
N	
N/* Command bit fields */
N#define M_CMD_DATADIR   		0x80
N
N/* Request Type Field */
N#define M_CMD_TYPEMASK  		0x60
N#define M_CMD_STDREQ    		0x00
N#define M_CMD_CLASSREQ  		0x20
N#define M_CMD_VENDREQ   		0x40
N#define M_CMD_STDDEVIN  		0x80
N#define M_CMD_STDDEVOUT 		0x00
N#define M_CMD_STDIFIN   		0x81
N#define M_CMD_STDIFOUT  		0x01
N#define M_CMD_STDEPIN   		0x82
N#define M_CMD_STDEPOUT  		0x02
N
N/* Standard Request Codes */
N#define GET_STATUS              0x00
N#define CLEAR_FEATURE           0x01
N#define SET_FEATURE             0x03
N#define SET_ADDRESS             0x05
N#define GET_DESCRIPTOR          0x06
N#define SET_DESCRIPTOR          0x07
N#define GET_CONFIGURATION       0x08
N#define SET_CONFIGURATION       0x09
N#define GET_INTERFACE           0x0A
N#define SET_INTERFACE           0x0B
N#define SYNCH_FRAME             0x0C
N
N/* Standard Descriptor Types */
N#define M_DST_DEVICE     		  0x01
N#define M_DST_CONFIG     		  0x02
N#define M_DST_STRING     		  0x03
N#define M_DST_INTERFACE  		  0x04
N#define M_DST_ENDPOINT   		  0x05
N#define M_DST_DEVQUAL    		  0x06
N#define M_DST_OTHERSPEED 		  0x07
N#define M_DST_POWER      		  0x08
N#define	M_DST_HID_REPORT_DESC	0x22
N#define M_CMD_DESCMASK   		  0xFF00
N#define M_CMD_DEVICE			    (M_DST_DEVICE<<8)
N#define M_CMD_CONFIG			    (M_DST_CONFIG<<8)
N#define M_CMD_STRING			    (M_DST_STRING<<8)
N#define M_CMD_DEVQUAL			    (M_DST_DEVQUAL<<8)
N#define M_CMD_OTHERSPEED		  (M_DST_OTHERSPEED<<8)
N#define	M_CMD_HID_REPORT_DESC	(M_DST_HID_REPORT_DESC<<8)
N
N/* Endpoint transfer types */
N#define M_EP_TFMASK     		0x03
N#define M_EP_CONTROL    		0x00
N#define M_EP_ISO        		0x01
N#define M_EP_BULK       		0x10
N#define M_EP_INTR       		0x11
N
N/* Standard Device Feature Selectors */
N#define M_FTR_EPHALT			  0x0000
N#define M_FTR_DEVREMWAKE 		0x0001
N#define M_FTR_TESTMODE 			0x0002
N
N
N#define RPT_TOUCHPAD        0x01  // report id for touchpad
N#define RPT_CONSUMER        0x03  // report id for consumer
N#define RPT_SYSCTRL         0x02  // report id for system control
N#define RPT_HID_KEYBOARD    0x06  // report id for 
N
N/* Public variables prototypes --------------------------------------------------*/
Nextern uint16_t_uint8_t StatusInfo; 
Nextern const uint8_t LanguageId[];
Nextern const uint8_t ManufacturerStringDescriptor[];
Nextern const uint8_t ProductStringDescriptor[];
Nextern const uint8_t SerialNumberSringDescriptor[];
Nextern const uint8_t USB_FSDeviceDescriptor[];
Nextern const uint8_t USB_FSConfigDescriptor[];
Nextern const uint8_t USB_HID_FSReportDescriptor_1[]; 
Nextern const uint8_t USB_HID_FSReportDescriptor_2[];
Nextern const uint8_t USB_HID_FSReportDescriptor_3[];
Nextern const uint8_t USB_HID_FSReportDescriptor_4[];
Nextern const uint8_t USB_HID_FSReportDescriptor_5[];
N	
Nextern const uint16_t USB_FSDeviceDescriptorSize;
Nextern const uint16_t USB_FSConfigDescriptorSize;
Nextern const uint16_t LanguageIdSize;
Nextern const uint16_t ManufacturerStringDescriptorSize;
Nextern const uint16_t ProductStringDescriptorSize;
Nextern const uint16_t SerialNumberSringDescriptorSize;
Nextern const uint16_t USB_HID_FSReportDescriptor_1Size;
Nextern const uint16_t USB_HID_FSReportDescriptor_2Size;
Nextern const uint16_t USB_HID_FSReportDescriptor_3Size;
Nextern const uint16_t USB_HID_FSReportDescriptor_4Size;
Nextern const uint16_t USB_HID_FSReportDescriptor_5Size;
N/* Public function prototypes----------------------------------------------------*/
N
N#endif /* _DESCRIPT_H_ */
N/************************* (C) COPYRIGHT FMD *****END OF FILE*********************/
N
L 26 "..\usb\inc\usb_core.h" 2
N#include "main.h"
L 1 "..\user\main.h" 1
N/**
N  ******************************************************************************
N  * @file    	    main.h
N  * @author  	    FMD AE
N  * @brief   		This file contains all the functions prototypes for the main 
N  * @version 	    V1.0.0           
N  * @data		    2022-01-13
N  ******************************************************************************
N  * @attention
N  * COPYRIGHT (C) 2021 Fremont Micro Devices Corporation All rights reserved.
N  *    This software is provided by the copyright holders and contributors,and the
N  *software is believed to be accurate and reliable. However, Fremont Micro Devices
N  * Corporation assumes no responsibility for the consequences of use of such
N  *software or for any infringement of patents of other rights of third parties,
N  *which may result from its use. No license is granted by implication or otherwise
N  *under any patent rights of Fremont Micro Devices Corporation.
N  *  ******************************************************************************
N  */
N#ifndef __MAIN_H
S#define __MAIN_H
S
S/* Includes ---------------------------------------------------------------------*/
S#include <stdio.h>
S#include <stdlib.h>
S#include <stdint.h>
S#include <string.h>
S#include "ft32f0xx.h"
S
S#include "ft32f0xx_adc.h"
S#include "ft32f0xx_comp.h"
S#include "ft32f0xx_crc.h"
S#include "ft32f0xx_crs.h"
S#include "ft32f0xx_dac.h"
S#include "ft32f0xx_dma.h"
S#include "ft32f0xx_debug.h"
S#include "ft32f0xx_exti.h"
S#include "ft32f0xx_flash.h"
S#include "ft32f0xx_gpio.h"
S#include "ft32f0xx_i2c.h"
S#include "ft32f0xx_iwdg.h"
S#include "ft32f0xx_misc.h"
S#include "ft32f0xx_opa.h"
S#include "ft32f0xx_pwr.h"
S#include "ft32f0xx_rcc.h"
S#include "ft32f0xx_rtc.h"
S#include "ft32f0xx_spi.h"
S#include "ft32f0xx_syscfg.h"
S#include "ft32f0xx_tim.h"
S#include "ft32f0xx_usart.h"
S#include "ft32f0xx_wwdg.h"
S#include "ft32f072x8.h"
S
S
S
S
S#include "usb_core.h"
S#include "keyboard.h"
S#include "RgbEffect.h"
S#include "Matrix.h"
S#include "SEGGER_RTT.h"
S#include "SysTick.h"
S#include "online.h"
S
S
S
S
S
S/* Public Constant prototypes----------------------------------------------------*/
S
S/* Public typedef ---------------------------------------------------------------*/
S
S#define _debug_
S
S/* Public define ----------------------------------------------------------------*/
S
S//#define ApplicationAddress    ((uint32_t)0x08002000)   //APP
S//#define IaplicationAddress    ((uint32_t)0x08000000)   //IAP
S//#define ApplicaflagAddress    ((uint32_t)0x08002E00)   //APP
S
S/* Public variables prototypes --------------------------------------------------*/
Sextern uint32_t test_usb;
S
Sextern CLASS_HID_DATA	c_hid_data;
S
S
S/* Public function prototypes----------------------------------------------------*/
Svoid Systick_Init(void);
S
N#endif /* __MAIN_H */
N
N/************************** (C) COPYRIGHT FMD **********************END OF FILE****/
L 27 "..\usb\inc\usb_core.h" 2
N#include "online.h"
L 1 "..\user\online.h" 1
N#ifndef __online_h__
N#define __online_h__
N
N
N
N#include "main.h"
N#include "queue.h"
L 1 "..\user\queue.h" 1
N#ifndef __QUEUE_H__
N#define __QUEUE_H__
N
N
N
N#include <stdio.h>
N#include <string.h>
N#include <stdlib.h>
N#include <stdint.h>
N
N
N
N
Ntypedef struct{
N    size_t write_point;
N    size_t read_point;
N    uint8_t* memory;
N    size_t item_len;
N    size_t item_qty;
N    size_t num;
N}queue_t;
N
N
N
N
N
N
N
Nint queue_init(queue_t* queue, uint8_t* mem_pool, size_t item_len, size_t item_qty);
Nint queue_push(queue_t* queue, void* data);
Nint queue_pop(queue_t* queue, void* recv, size_t len);
Nint queue_length(queue_t* queue);
Nint queue_peek(queue_t* queue, void* recv, size_t len);
Nint queue_free(queue_t* queue);
N
N
N
Nextern queue_t queue;
N
N
N
N
N
N#endif
N
N
N
N
L 8 "..\user\online.h" 2
N#include "SysTick.h"
L 1 "..\user\SysTick.h" 1
N#ifndef __SysTick_h__
N#define __SysTick_h__
N
N#include "main.h"
N
N
N
N
Nvoid Systick_Init(void);
Nuint32_t GetTime(void);
N
N#endif
N
N
N
N
N
L 9 "..\user\online.h" 2
N
N
N#define ARG_MAX_LEN 60
N#define CMD_WAIT_TIMEOUT 5000
N
N
N
N
N
Ntypedef enum
N{
N    em_adjust_backlight = 0x01,     //01
N    em_adjust_speed,                //02
N    em_toggle_effect,               //03
N    em_get_current_seb,             //04
N    em_get_effect_table,            //05
N    em_get_macro_table,             //06
N    em_get_keyremap_table,          //07
N    em_send_macro,                  //08
N    em_send_keyremap,               //09
N    em_reset,                       //12
N    em_answer,                      //13
N}command_em;
N
N
N
N
N
N
N	
N
Ntypedef struct
N{
N    uint8_t buffer[ARG_MAX_LEN];    //
X    uint8_t buffer[60];    
N    uint8_t cmd;                    //
N    uint8_t sn;                     //
N    uint8_t qty;                    //
N    uint8_t len;                    //
N}pkg_st;	
N
N
N
N
N
N
N
N
Nuint8_t host_recv_online(queue_t* queue, uint8_t* cmd, uint8_t* recv, size_t* len);
Nuint8_t host_send_online(uint8_t cmd, const uint8_t* send, size_t len);
N
N
N
N
N
N
N
N
N
N#endif
N
N
N
N
N
N
N
N
L 28 "..\usb\inc\usb_core.h" 2
N/* Public Constant prototypes----------------------------------------------------*/
N
N/* Public typedef ---------------------------------------------------------------*/
Ntypedef enum _RESULT
N{
N	USB_SUCCESS = 0,			/* Process successfully */
N	USB_ERROR,
N	USB_UNSUPPORT,
N	USB_NOT_READY				/* The process has not been finished, endpoint will be
N								NAK to further request */
N} RESULT;
N
Ntypedef struct
N{
N  /* When send data out of the device,
N	CopyData() is used to get data buffer 'Length' bytes data
N	if Length is 0,
N	CopyData() returns the total length of the data
N	if the request is not supported, returns 0
N	(NEW Feature )
N	if CopyData() returns -1, the calling routine should not proceed
N	further and will resume the SETUP process by the class device
N	if Length is not 0,
N	CopyData() returns a pointer to indicate the data location
N	Usb_wLength is the data remain to be sent,
N	Usb_wOffset is the Offset of original data
N	When receive data from the host,
N	CopyData() is used to get user data buffer which is capable
N	of Length bytes data to copy data from the endpoint buffer.
N	if Length is 0,
N	CopyData() returns the available data length,
N	if Length is not 0,
N	CopyData() returns user buffer address
N	Usb_rLength is the data remain to be received,
N	Usb_rPointer is the Offset of data buffer
N  */
N	uint16_t  Usb_wLength;
N	uint16_t  Usb_wOffset;
N	uint16_t  PacketSize;
N	uint8_t   *(*CopyData)(uint16_t Length);
N}ENDPOINT_INFO;	
N	
Ntypedef struct{
N	uint8_t ControlState;				/* of type CONTROL_STATE */
N	uint8_t Current_Feature;
N	uint8_t Current_Configuration;		/* Selected configuration */
N	uint8_t Current_Interface;			/* Selected interface of current configuration */
N	uint8_t Current_AlternateSetting;	/* Selected Alternate Setting of current                                    interface*/
N	ENDPOINT_INFO Ctrl_Info;	
N}DEVICE_INFO;
N
N
Ntypedef	struct
N{
N	uint32_t	bit0:	1;
N	uint32_t	bit1:	1;
N	uint32_t	bit2:	1;
N	uint32_t	bit3:	1;
N	uint32_t	bit4:	1;
N	uint32_t	bit5:	1;
N	uint32_t	bit6:	1;
N	uint32_t	bit7:	1;
N	uint32_t	bit8:	1;
N	uint32_t	bit9:	1;
N	uint32_t	bit10:	1;
N	uint32_t	bit11:	1;
N	uint32_t	bit12:	1;
N	uint32_t	bit13:	1;
N	uint32_t	bit14:	1;
N	uint32_t	bit15:	1;	
N	uint32_t	bit16:	1;
N	uint32_t	bit17:	1;
N	uint32_t	bit18:	1;
N	uint32_t	bit19:	1;
N	uint32_t	bit20:	1;
N	uint32_t	bit21:	1;
N	uint32_t	bit22:	1;
N	uint32_t	bit23:	1;
N	uint32_t	bit24:	1;
N	uint32_t	bit25:	1;
N	uint32_t	bit26:	1;
N	uint32_t	bit27:	1;
N	uint32_t	bit28:	1;
N	uint32_t	bit29:	1;
N	uint32_t	bit30:	1;
N	uint32_t	bit31:	1;
N}VarBit;
N
N
N/* Bulk In Endpoint status structure */
Ntypedef struct M_EPBIN_STATUS {
N	void *pData;     		/* Pointer to data to transmit */
N	int   nBytesLeft;		/* Number of bytes left to send */
N	BYTE  byEP;      		/* Endpoint number */
N} M_EPBIN_STATUS;
Ntypedef M_EPBIN_STATUS* PM_EPBIN_STATUS;
N
N/* Bulk Out Endpoint status structure */
Ntypedef struct M_EPBOUT_STATUS {
N  void *pData;     			/* Pointer to data buffer */
N  int   nBuffLen;  			/* Length of data buffer */
N  int   nBytesRecv;			/* Number of bytes received */
N  BYTE  byEP;      			/* Endpoint number */
N  } M_EPBOUT_STATUS;
Ntypedef M_EPBOUT_STATUS* PM_EPBOUT_STATUS;
N	
N/* Public define ----------------------------------------------------------------*/
N#define TRUE  1
N#define FALSE 0
N#ifndef NULL
S#define NULL 0
N#endif
N
N/* Define MUSBFSFC register addresses */
N#define BASE_ADDR 0x40005c00
N
N#define M_REG_FADDR     			BASE_ADDR
N#define M_REG_POWER     			BASE_ADDR+1
N#define M_REG_INTRIN1   			BASE_ADDR+2
N#define M_REG_INTRIN2   			BASE_ADDR+3
N#define M_REG_INTROUT1  			BASE_ADDR+4
N#define M_REG_INTROUT2  			BASE_ADDR+5
N#define M_REG_INTRUSB   			BASE_ADDR+6
N#define M_REG_INTRIN1E  			BASE_ADDR+7
N#define M_REG_INTRIN2E  			BASE_ADDR+8
N#define M_REG_INTROUT1E 			BASE_ADDR+9
N#define M_REG_INTROUT2E 			BASE_ADDR+10
N#define M_REG_INTRUSBE  			BASE_ADDR+11
N#define M_REG_FRAME1    			BASE_ADDR+12
N#define M_REG_FRAME2    			BASE_ADDR+13
N#define M_REG_INDEX     			BASE_ADDR+14			
N			
N#define M_REG_CSR0      			BASE_ADDR+17
N#define M_REG_INMAXP    			BASE_ADDR+16
N#define M_REG_INCSR1    			BASE_ADDR+17
N#define M_REG_INCSR2    			BASE_ADDR+18
N#define M_REG_OUTMAXP   			BASE_ADDR+19
N#define M_REG_OUTCSR1   			BASE_ADDR+20
N#define M_REG_OUTCSR2   			BASE_ADDR+21
N#define M_REG_OUTCOUNT1 			BASE_ADDR+22
N#define M_REG_OUTCOUNT2 			BASE_ADDR+23
N			
N#define M_FIFO_EP0      			BASE_ADDR+32
N
N
N/* Interrupt register bit masks */
N#define M_INTR_SUSPEND  			0x01
N#define M_INTR_RESUME   			0x02
N#define M_INTR_RESET    			0x04
N#define M_INTR_EP0      			0x0001
N	
N/* CSR0 bit masks */	
N#define M_CSR0_OUTPKTRDY        	0x01
N#define M_CSR0_INPKTRDY         	0x02
N#define M_CSR0_SENTSTALL        	0x04
N#define M_CSR0_DATAEND          	0x08
N#define M_CSR0_SETUPEND         	0x10
N#define M_CSR0_SENDSTALL        	0x20
N#define M_CSR0_SVDOUTPKTRDY     	0x40
N#define M_CSR0_SVDSETUPEND      	0x80
N
N/* Endpoint CSR register bits */
N#define M_INCSR2_ISO    			0x40
N#define M_INCSR2_MODE   			0x20
N#define M_INCSR_CDT     			0x40
N#define M_INCSR_FF      			0x08
N#define M_INCSR_IPR     			0x01
N#define M_OUTCSR2_ISO   			0x40
N#define M_OUTCSR_CDT    			0x80
N#define M_OUTCSR_FF     			0x10
N#define M_OUTCSR_OPR    			0x01
N
N/**
N  * @brief USB_PDCTRL
N  */
N#define	USB_PDCTRL_FLAG 			((uint8_t)(0x03))	
N	
N#define	USB_PDCTRL_PD_DISABLE		((uint8_t)(0x00))
N#define	USB_PDCTRL_PD_ENABLE		((uint8_t)(0x02))
N	
N#define	USB_PDCTRL_PU_DISABLE		((uint8_t)(0x00))
N#define	USB_PDCTRL_PU_ENABLE		((uint8_t)(0x01))
N	
N#define	IS_USB_PDCTRL(PDCTRL)		(((PDCTRL) == USB_PDCTRL_PD_DISABLE) || \
N									((PDCTRL) == USB_PDCTRL_PD_ENABLE) || \
N									((PDCTRL) == USB_PDCTRL_PU_DISABLE) || \
N									((PDCTRL) == USB_PDCTRL_PU_ENABLE))
X#define	IS_USB_PDCTRL(PDCTRL)		(((PDCTRL) == USB_PDCTRL_PD_DISABLE) || 									((PDCTRL) == USB_PDCTRL_PD_ENABLE) || 									((PDCTRL) == USB_PDCTRL_PU_DISABLE) || 									((PDCTRL) == USB_PDCTRL_PU_ENABLE))
N
N/**
N  * @brief   USB_IT_FLAG
N  */
N#define	USB_IT_IN_EP0_FLAG			((uint32_t) 0x00000101)
N#define	USB_IT_IN_EP1_FLAG			((uint32_t) 0x00000102)
N#define	USB_IT_IN_EP2_FLAG			((uint32_t) 0x00000104)
N#define	USB_IT_IN_EP3_FLAG			((uint32_t) 0x00000108)
N#define	USB_IT_IN_EP4_FLAG			((uint32_t) 0x00000110)
N#define	USB_IT_IN_EP5_FLAG			((uint32_t) 0x00000120)
N#define	USB_IT_IN_EP6_FLAG			((uint32_t) 0x00000140)
N#define	USB_IT_IN_EP7_FLAG			((uint32_t) 0x00000180)
N
N#define	USB_IT_OUT_EP1_FLAG			((uint32_t) 0x00000202)
N#define	USB_IT_OUT_EP2_FLAG			((uint32_t) 0x00000204)
N#define	USB_IT_OUT_EP3_FLAG			((uint32_t) 0x00000208)
N#define	USB_IT_OUT_EP4_FLAG			((uint32_t) 0x00000210)
N#define	USB_IT_OUT_EP5_FLAG			((uint32_t) 0x00000220)
N#define	USB_IT_OUT_EP6_FLAG			((uint32_t) 0x00000240)
N#define	USB_IT_OUT_EP7_FLAG			((uint32_t) 0x00000280)
N
N#define	USB_IT_USB_SUSPEND_FLAG		((uint32_t) 0x00000401)
N#define	USB_IT_USB_RESUME_FLAG		((uint32_t) 0x00000402)
N#define	USB_IT_USB_RESET_FLAG		((uint32_t) 0x00000404)
N#define	USB_IT_USB_SOF_FLAG			((uint32_t) 0x00000408)
N
N
N/* Register read/write macros */
N#define MREAD_BYTE(addr) *((BYTE *)(addr))
N#define MWRITE_BYTE(addr,data) *((BYTE *)(addr)) = data
N
N
N/* Endpoint 0 states */
N#define M_EP0_IDLE      			0  	//
N#define M_EP0_RX        			1  
N#define M_EP0_TX        			2
N
N/* Define maximum packet size for endpoint 0 */
N#define M_EP0_MAXP      			64
N
N/* Define maximum number of interfaces in a configuration */
N#define M_MAXIFS        			7
N
N/* HID Request Types */
N#define HID_REQUEST_SET				0x21
N#define HID_REQUEST_GET				0xA1
N
N/* HID Request Codes */
N#define HID_REQUEST_GET_REPORT		0x01
N#define HID_REQUEST_GET_IDLE		  0x02
N#define HID_REQUEST_GET_PROTOCOL	0x03
N#define HID_REQUEST_SET_REPORT		0x09
N#define HID_REQUEST_SET_IDLE		  0x0A
N#define HID_REQUEST_SET_PROTOCOL	0x0B
N
N/* HID Report Types */
N#define HID_REPORT_INPUT			  0x01
N#define HID_REPORT_OUTPUT			  0x02
N#define HID_REPORT_FEATURE			0x03
N
N/* Define device states */
N#define DEVSTATE_DEFAULT        	0		//
N#define DEVSTATE_ADDRESS        	1		//
N#define DEVSTATE_CONFIG         	2		//
N/* Define endpoint call status values */
N#define M_EP_NORMAL     			0
N#define M_EP_RESET      			1
N
N
N#define	usb_ep1_flag				flag1.bit0
N#define	f_send_kb					  flag1.bit2
N#define	f_usb_suspend				flag1.bit3
N#define	f_sof_flag					flag1.bit4
N		
N/*usb_state FLAG*/		
N#define	USB_NORMAL					  0x00
N#define	USB_SUSPEND_FLAG			0x01
N#define	USB_RESUME_FLAG				0x02
N
N/**
N  * @brief   USB_FLAG
N  */
N//#define	USB_FADDR_UPDATE_FLAG		  ((uint32_t) 0x00000180)
N
N//#define	USB_POWER_RESET_FLAG		  ((uint32_t) 0x00000208)
N//#define	USB_POWER_SUSPENDM_FLAG		((uint32_t) 0x00000202)
N	
N
N#define ep_boot_keyboard  0x01
N#define ep_touchpad       0x02
N#define ep_consumer       0x02
N#define ep_sysctrl        0x02
N#define ep_hid_keyboard   0x02
N#define ep_hid_vendor_tx  0x04
N#define ep_hid_vendor_rx  0x05
N
N#define LEN_BOOT_KEYBOARD_DATA   8
N#define LEN_TOUCHPAD_DATA        5
N#define LEN_CONSUMER_DATA        2
N#define LEN_SYSCTRL_DATA         2
N#define LEN_HID_KEYBOARD_DATA    15
N
N
N#define M_EP_NODATA    		-1
N/* Define maximum packet size for bulk endpoints */
N#define M_EP_MAXP       	64
N
N/* Public variables prototypes --------------------------------------------------*/
N
Nextern DEVICE_INFO *pInformation;	
Nextern uint32_t		gnDevState;
Nextern PSTD_IF_DSCR	gpCurIf[M_MAXIFS];
Xextern PSTD_IF_DSCR	gpCurIf[7];
N
N/* Public function prototypes----------------------------------------------------*/
N
Nvoid USB_Init(void);
Nvoid USB_FS_IRQHandler(void);
Nvoid USB_Suspend(void);
Nvoid USB_Reset(void);
Nvoid EndpointBulkIn(M_EPBIN_STATUS, int);
Nvoid EndpointBulkOut(M_EPBOUT_STATUS, int);
N
Nvoid USB_Endpoint0(int);
Nvoid USB_Remote_Wakeup(void);
NErrorStatus USB_EP_Tx(uint8_t Ep,uint8_t *ptr,uint8_t data_len);
Nvoid USB_EP_Rx(uint8_t Ep,uint8_t *ptr,uint8_t data_len);
N
Nuint8_t USB_ReadRegister(uint8_t USB_Refister);
Nvoid USB_PDCTRLConfig(uint8_t PDCT);
Nvoid FIFORead(int, int, void*);
Nvoid FIFOWrite(int, int, void*);
Nvoid USB_ITConfig(uint32_t USB_IT, FunctionalState NewState);
NITStatus USB_GetITStatus(uint32_t USB_IT);
N
N#endif /* _USB_CORE_H_ */
N
N/************************* (C) COPYRIGHT JD-DZ.COM *****END OF FILE*********************/
N
L 57 "..\user\main.h" 2
N#include "keyboard.h"
L 1 "..\user\keyboard.h" 1
N#ifndef __KEYBOARD_H
N#define __KEYBOARD_H
N
N
Nextern uint8_t Vendor_data_Buffer[];
Nextern uint8_t	ep2_send_buf[];
N
N
N
N
N
N
Nvoid send_boot_keyboard_code(uint8_t* dat, uint8_t len);
N//void send_touchpad_code(uint8_t* dat, uint8_t len);
N//void send_consumer_code(uint8_t* dat, uint8_t len);
N//void send_sysctrl_code(uint8_t* dat, uint8_t len);
N
N
Nvoid send_hid_keyboard_code(uint8_t* dat, uint8_t len);
N
Nvoid ep2_send_data(uint8_t rpt_type, uint8_t* dat, uint8_t len);
Nvoid USB_Transmit_VendorData(uint8_t* dat, uint8_t len);
Nvoid USB_Receive_VendorData(uint8_t* dat, uint8_t len);
N
N
N
N
N#endif /* __KEYBOARD_H */
N
N/************************** (C) COPYRIGHT JD-DZ.COM **********************END OF FILE****/
L 58 "..\user\main.h" 2
N#include "RgbEffect.h"
L 1 "..\user\RgbEffect.h" 1
N#ifndef __RgbEffect_h__
N#define __RgbEffect_h__
N
N
N#include "main.h"
N
N
N
N
N
Nextern uint8_t gCurrentEffect;			/**/
Nextern uint8_t gCurrentBacklight;		/**/
Nextern uint8_t gCurrentSpeed;			/**/
N
N
N
N
N#endif
N
N
L 59 "..\user\main.h" 2
N#include "Matrix.h"
L 1 "..\user\Matrix.h" 1
N/**
N * @file ScanMatrix.h
N * @author Tom.Guo (guotao168@163.com)
N * @brief 
N * @version 0.1
N * @date 2022-04-08
N * 
N * @copyright Copyright (c) 2022
N * 
N */
N
N#ifndef __SCANMATRIX_H__
N#define __SCANMATRIX_H__
N
N
N
N
N#include "main.h"
N
N
N
N
N#define MAX_COL 21
N#define MAX_ROW 6
N#define MAX_COM 28
N#define MAX_PWM 12
N
N
N
N
N
N#define MASK_BIT0 0x0001
N#define MASK_BIT1 0x0002
N#define MASK_BIT2 0x0004
N#define MASK_BIT3 0x0008
N#define MASK_BIT4 0x0010
N#define MASK_BIT5 0x0020
N#define MASK_BIT6 0x0040
N#define MASK_BIT7 0x0080
N#define MASK_BIT8 0x0100
N#define MASK_BIT9 0x0200
N#define MASK_BITA 0x0400
N#define MASK_BITB 0x0800
N#define MASK_BITC 0x1000
N#define MASK_BITD 0x2000
N#define MASK_BITE 0x4000
N#define MASK_BITF 0x8000
N
N
N
N
N
N
N
N
N
N
N/**
N * @brief 
N * 
N */
Nvoid InitMatrixRcc(void);
N
N/**
N * @brief ROW
N * 
N */
Nvoid RowInit(void);
N
N/**
N * @brief COL
N * 
N */
Nvoid ColSet(void);
N
N/**
N * @brief COL
N * 
N */
Nvoid ColReset(void);
N
N/**
N * @brief COL
N * 
N * @param index COL
N */
Nvoid ColOffset(uint8_t index);
N
N/**
N * @brief COL
N * 
N */
Nvoid ColInit(void);
N
N/**
N * @brief COM
N * 
N */
Nvoid ComSet(void);
N
N/**
N * @brief COM
N * 
N */
Nvoid ComReset(void);
N
N/**
N * @brief COM
N * 
N * @param index COM
N */
Nvoid ComOffset(uint8_t index);
N
N/**
N * @brief COM
N * 
N */
Nvoid ComInit(void);
N
N
N
N
Nvoid ScanKey(void);
Nvoid ScanRgb(void);
N
N
N
Nvoid PwmInit(void);
Nvoid SetReload(uint8_t index);
N
N
N#endif
N
N
N
L 60 "..\user\main.h" 2
N#include "SEGGER_RTT.h"
L 1 "..\RTT\SEGGER_RTT.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*                        The Embedded Experts                        *
N**********************************************************************
N*                                                                    *
N*            (c) 1995 - 2019 SEGGER Microcontroller GmbH             *
N*                                                                    *
N*       www.segger.com     Support: support@segger.com               *
N*                                                                    *
N**********************************************************************
N*                                                                    *
N*       SEGGER RTT * Real Time Transfer for embedded targets         *
N*                                                                    *
N**********************************************************************
N*                                                                    *
N* All rights reserved.                                               *
N*                                                                    *
N* SEGGER strongly recommends to not make any changes                 *
N* to or modify the source code of this software in order to stay     *
N* compatible with the RTT protocol and J-Link.                       *
N*                                                                    *
N* Redistribution and use in source and binary forms, with or         *
N* without modification, are permitted provided that the following    *
N* condition is met:                                                  *
N*                                                                    *
N* o Redistributions of source code must retain the above copyright   *
N*   notice, this condition and the following disclaimer.             *
N*                                                                    *
N* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
N* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
N* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
N* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
N* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
N* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
N* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
N* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
N* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
N* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
N* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
N* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
N* DAMAGE.                                                            *
N*                                                                    *
N**********************************************************************
N*                                                                    *
N*       RTT version: 6.60a                                           *
N*                                                                    *
N**********************************************************************
N
N---------------------------END-OF-HEADER------------------------------
NFile    : SEGGER_RTT.h
NPurpose : Implementation of SEGGER real-time transfer which allows
N          real-time communication on targets which support debugger 
N          memory accesses while the CPU is running.
NRevision: $Rev: 17066 $
N----------------------------------------------------------------------
N*/
N
N#ifndef SEGGER_RTT_H
N#define SEGGER_RTT_H
N
N#include "SEGGER_RTT_Conf.h"
L 1 "..\RTT\SEGGER_RTT_Conf.h" 1
N/*********************************************************************
N*                    SEGGER Microcontroller GmbH                     *
N*                        The Embedded Experts                        *
N**********************************************************************
N*                                                                    *
N*            (c) 1995 - 2019 SEGGER Microcontroller GmbH             *
N*                                                                    *
N*       www.segger.com     Support: support@segger.com               *
N*                                                                    *
N**********************************************************************
N*                                                                    *
N*       SEGGER RTT * Real Time Transfer for embedded targets         *
N*                                                                    *
N**********************************************************************
N*                                                                    *
N* All rights reserved.                                               *
N*                                                                    *
N* SEGGER strongly recommends to not make any changes                 *
N* to or modify the source code of this software in order to stay     *
N* compatible with the RTT protocol and J-Link.                       *
N*                                                                    *
N* Redistribution and use in source and binary forms, with or         *
N* without modification, are permitted provided that the following    *
N* condition is met:                                                  *
N*                                                                    *
N* o Redistributions of source code must retain the above copyright   *
N*   notice, this condition and the following disclaimer.             *
N*                                                                    *
N* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
N* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
N* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
N* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
N* DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
N* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
N* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
N* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
N* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
N* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
N* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
N* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
N* DAMAGE.                                                            *
N*                                                                    *
N**********************************************************************
N*                                                                    *
N*       RTT version: 6.60a                                           *
N*                                                                    *
N**********************************************************************
N
N---------------------------END-OF-HEADER------------------------------
NFile    : SEGGER_RTT_Conf.h
NPurpose : Implementation of SEGGER real-time transfer (RTT) which
N          allows real-time communication on targets which support
N          debugger memory accesses while the CPU is running.
NRevision: $Rev: 17066 $
N
N*/
N
N#ifndef SEGGER_RTT_CONF_H
N#define SEGGER_RTT_CONF_H
N
N#ifdef __IAR_SYSTEMS_ICC__
S  #include <intrinsics.h>
N#endif
N
N/*********************************************************************
N*
N*       Defines, configurable
N*
N**********************************************************************
N*/
N#ifndef   SEGGER_RTT_MAX_NUM_UP_BUFFERS
N  #define SEGGER_RTT_MAX_NUM_UP_BUFFERS             (3)     // Max. number of up-buffers (T->H) available on this target    (Default: 3)
N#endif
N
N#ifndef   SEGGER_RTT_MAX_NUM_DOWN_BUFFERS
N  #define SEGGER_RTT_MAX_NUM_DOWN_BUFFERS           (3)     // Max. number of down-buffers (H->T) available on this target  (Default: 3)
N#endif
N
N#ifndef   BUFFER_SIZE_UP
N  #define BUFFER_SIZE_UP                            (1024)  // Size of the buffer for terminal output of target, up to host (Default: 1k)
N#endif
N
N#ifndef   BUFFER_SIZE_DOWN
N  #define BUFFER_SIZE_DOWN                          (16)    // Size of the buffer for terminal input to target from host (Usually keyboard input) (Default: 16)
N#endif
N
N#ifndef   SEGGER_RTT_PRINTF_BUFFER_SIZE
N  #define SEGGER_RTT_PRINTF_BUFFER_SIZE             (64u)    // Size of buffer for RTT printf to bulk-send chars via RTT     (Default: 64)
N#endif
N
N#ifndef   SEGGER_RTT_MODE_DEFAULT
N  #define SEGGER_RTT_MODE_DEFAULT                   SEGGER_RTT_MODE_NO_BLOCK_SKIP // Mode for pre-initialized terminal channel (buffer 0)
N#endif
N
N/*********************************************************************
N*
N*       RTT memcpy configuration
N*
N*       memcpy() is good for large amounts of data, 
N*       but the overhead is big for small amounts, which are usually stored via RTT.
N*       With SEGGER_RTT_MEMCPY_USE_BYTELOOP a simple byte loop can be used instead.
N*
N*       SEGGER_RTT_MEMCPY() can be used to replace standard memcpy() in RTT functions.
N*       This is may be required with memory access restrictions, 
N*       such as on Cortex-A devices with MMU.
N*/
N#ifndef   SEGGER_RTT_MEMCPY_USE_BYTELOOP
N  #define SEGGER_RTT_MEMCPY_USE_BYTELOOP              0 // 0: Use memcpy/SEGGER_RTT_MEMCPY, 1: Use a simple byte-loop
N#endif
N//
N// Example definition of SEGGER_RTT_MEMCPY to external memcpy with GCC toolchains and Cortex-A targets
N//
N//#if ((defined __SES_ARM) || (defined __CROSSWORKS_ARM) || (defined __GNUC__)) && (defined (__ARM_ARCH_7A__))  
N//  #define SEGGER_RTT_MEMCPY(pDest, pSrc, NumBytes)      SEGGER_memcpy((pDest), (pSrc), (NumBytes))
N//#endif
N
N//
N// Target is not allowed to perform other RTT operations while string still has not been stored completely.
N// Otherwise we would probably end up with a mixed string in the buffer.
N// If using  RTT from within interrupts, multiple tasks or multi processors, define the SEGGER_RTT_LOCK() and SEGGER_RTT_UNLOCK() function here.
N//
N// SEGGER_RTT_MAX_INTERRUPT_PRIORITY can be used in the sample lock routines on Cortex-M3/4.
N// Make sure to mask all interrupts which can send RTT data, i.e. generate SystemView events, or cause task switches.
N// When high-priority interrupts must not be masked while sending RTT data, SEGGER_RTT_MAX_INTERRUPT_PRIORITY needs to be adjusted accordingly.
N// (Higher priority = lower priority number)
N// Default value for embOS: 128u
N// Default configuration in FreeRTOS: configMAX_SYSCALL_INTERRUPT_PRIORITY: ( configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY << (8 - configPRIO_BITS) )
N// In case of doubt mask all interrupts: 1 << (8 - BASEPRI_PRIO_BITS) i.e. 1 << 5 when 3 bits are implemented in NVIC
N// or define SEGGER_RTT_LOCK() to completely disable interrupts.
N//
N#ifndef   SEGGER_RTT_MAX_INTERRUPT_PRIORITY
N  #define SEGGER_RTT_MAX_INTERRUPT_PRIORITY         (0x20)   // Interrupt priority to lock on SEGGER_RTT_LOCK on Cortex-M3/4 (Default: 0x20)
N#endif
N
N/*********************************************************************
N*
N*       RTT lock configuration for SEGGER Embedded Studio,
N*       Rowley CrossStudio and GCC
N*/
N#if (defined(__SES_ARM) || defined(__CROSSWORKS_ARM) || defined(__GNUC__) || defined(__clang__)) && !defined (__CC_ARM)
X#if (0L || 0L || 1L || 0L) && !1L
S  #if (defined(__ARM_ARCH_6M__) || defined(__ARM_ARCH_8M_BASE__))
S    #define SEGGER_RTT_LOCK()   {                                                                   \
S                                    unsigned int LockState;                                         \
S                                  __asm volatile ("mrs   %0, primask  \n\t"                         \
S                                                  "movs  r1, $1       \n\t"                         \
S                                                  "msr   primask, r1  \n\t"                         \
S                                                  : "=r" (LockState)                                \
S                                                  :                                                 \
S                                                  : "r1"                                            \
S                                                  );
X    #define SEGGER_RTT_LOCK()   {                                                                                                       unsigned int LockState;                                                                           __asm volatile ("mrs   %0, primask  \n\t"                                                                           "movs  r1, $1       \n\t"                                                                           "msr   primask, r1  \n\t"                                                                           : "=r" (LockState)                                                                                  :                                                                                                   : "r1"                                                                                              );
S
S    #define SEGGER_RTT_UNLOCK()   __asm volatile ("msr   primask, %0  \n\t"                         \
S                                                  :                                                 \
S                                                  : "r" (LockState)                                 \
S                                                  :                                                 \
S                                                  );                                                \
S                                }
X    #define SEGGER_RTT_UNLOCK()   __asm volatile ("msr   primask, %0  \n\t"                                                                           :                                                                                                   : "r" (LockState)                                                                                   :                                                                                                   );                                                                                }
S  #elif (defined(__ARM_ARCH_7M__) || defined(__ARM_ARCH_7EM__) || defined(__ARM_ARCH_8M_MAIN__))
S    #ifndef   SEGGER_RTT_MAX_INTERRUPT_PRIORITY
S      #define SEGGER_RTT_MAX_INTERRUPT_PRIORITY   (0x20)
S    #endif
S    #define SEGGER_RTT_LOCK()   {                                                                   \
S                                    unsigned int LockState;                                         \
S                                  __asm volatile ("mrs   %0, basepri  \n\t"                         \
S                                                  "mov   r1, %1       \n\t"                         \
S                                                  "msr   basepri, r1  \n\t"                         \
S                                                  : "=r" (LockState)                                \
S                                                  : "i"(SEGGER_RTT_MAX_INTERRUPT_PRIORITY)          \
S                                                  : "r1"                                            \
S                                                  );
X    #define SEGGER_RTT_LOCK()   {                                                                                                       unsigned int LockState;                                                                           __asm volatile ("mrs   %0, basepri  \n\t"                                                                           "mov   r1, %1       \n\t"                                                                           "msr   basepri, r1  \n\t"                                                                           : "=r" (LockState)                                                                                  : "i"(SEGGER_RTT_MAX_INTERRUPT_PRIORITY)                                                            : "r1"                                                                                              );
S
S    #define SEGGER_RTT_UNLOCK()   __asm volatile ("msr   basepri, %0  \n\t"                         \
S                                                  :                                                 \
S                                                  : "r" (LockState)                                 \
S                                                  :                                                 \
S                                                  );                                                \
S                                }
X    #define SEGGER_RTT_UNLOCK()   __asm volatile ("msr   basepri, %0  \n\t"                                                                           :                                                                                                   : "r" (LockState)                                                                                   :                                                                                                   );                                                                                }
S
S  #elif defined(__ARM_ARCH_7A__)
S    #define SEGGER_RTT_LOCK() {                                                \
S                                 unsigned int LockState;                       \
S                                 __asm volatile ("mrs r1, CPSR \n\t"           \
S                                                 "mov %0, r1 \n\t"             \
S                                                 "orr r1, r1, #0xC0 \n\t"      \
S                                                 "msr CPSR_c, r1 \n\t"         \
S                                                 : "=r" (LockState)            \
S                                                 :                             \
S                                                 : "r1"                        \
S                                                 );
X    #define SEGGER_RTT_LOCK() {                                                                                 unsigned int LockState;                                                        __asm volatile ("mrs r1, CPSR \n\t"                                                            "mov %0, r1 \n\t"                                                              "orr r1, r1, #0xC0 \n\t"                                                       "msr CPSR_c, r1 \n\t"                                                          : "=r" (LockState)                                                             :                                                                              : "r1"                                                                         );
S
S    #define SEGGER_RTT_UNLOCK() __asm volatile ("mov r0, %0 \n\t"              \
S                                                "mrs r1, CPSR \n\t"            \
S                                                "bic r1, r1, #0xC0 \n\t"       \
S                                                "and r0, r0, #0xC0 \n\t"       \
S                                                "orr r1, r1, r0 \n\t"          \
S                                                "msr CPSR_c, r1 \n\t"          \
S                                                :                              \
S                                                : "r" (LockState)              \
S                                                : "r0", "r1"                   \
S                                                );                             \
S                            }
X    #define SEGGER_RTT_UNLOCK() __asm volatile ("mov r0, %0 \n\t"                                                              "mrs r1, CPSR \n\t"                                                            "bic r1, r1, #0xC0 \n\t"                                                       "and r0, r0, #0xC0 \n\t"                                                       "orr r1, r1, r0 \n\t"                                                          "msr CPSR_c, r1 \n\t"                                                          :                                                                              : "r" (LockState)                                                              : "r0", "r1"                                                                   );                                                         }
S  #endif
N#endif
N
N/*********************************************************************
N*
N*       RTT lock configuration for IAR EWARM
N*/
N#ifdef __ICCARM__
S  #if (defined (__ARM6M__) && (__CORE__ == __ARM6M__))
S    #define SEGGER_RTT_LOCK()   {                                                                   \
S                                  unsigned int LockState;                                           \
S                                  LockState = __get_PRIMASK();                                      \
S                                  __set_PRIMASK(1);
X    #define SEGGER_RTT_LOCK()   {                                                                                                     unsigned int LockState;                                                                             LockState = __get_PRIMASK();                                                                        __set_PRIMASK(1);
S
S    #define SEGGER_RTT_UNLOCK()   __set_PRIMASK(LockState);                                         \
S                                }
X    #define SEGGER_RTT_UNLOCK()   __set_PRIMASK(LockState);                                                                         }
S  #elif ((defined (__ARM7EM__) && (__CORE__ == __ARM7EM__)) || (defined (__ARM7M__) && (__CORE__ == __ARM7M__)))
S    #ifndef   SEGGER_RTT_MAX_INTERRUPT_PRIORITY
S      #define SEGGER_RTT_MAX_INTERRUPT_PRIORITY   (0x20)
S    #endif
S    #define SEGGER_RTT_LOCK()   {                                                                   \
S                                  unsigned int LockState;                                           \
S                                  LockState = __get_BASEPRI();                                      \
S                                  __set_BASEPRI(SEGGER_RTT_MAX_INTERRUPT_PRIORITY);
X    #define SEGGER_RTT_LOCK()   {                                                                                                     unsigned int LockState;                                                                             LockState = __get_BASEPRI();                                                                        __set_BASEPRI(SEGGER_RTT_MAX_INTERRUPT_PRIORITY);
S
S    #define SEGGER_RTT_UNLOCK()   __set_BASEPRI(LockState);                                         \
S                                }
X    #define SEGGER_RTT_UNLOCK()   __set_BASEPRI(LockState);                                                                         }
S  #endif
N#endif
N
N/*********************************************************************
N*
N*       RTT lock configuration for IAR RX
N*/
N#ifdef __ICCRX__
S  #define SEGGER_RTT_LOCK()   {                                                                     \
S                                unsigned long LockState;                                            \
S                                LockState = __get_interrupt_state();                                \
S                                __disable_interrupt();
X  #define SEGGER_RTT_LOCK()   {                                                                                                     unsigned long LockState;                                                                            LockState = __get_interrupt_state();                                                                __disable_interrupt();
S
S  #define SEGGER_RTT_UNLOCK()   __set_interrupt_state(LockState);                                   \
S                              }
X  #define SEGGER_RTT_UNLOCK()   __set_interrupt_state(LockState);                                                                 }
N#endif
N
N/*********************************************************************
N*
N*       RTT lock configuration for IAR RL78
N*/
N#ifdef __ICCRL78__
S  #define SEGGER_RTT_LOCK()   {                                                                     \
S                                __istate_t LockState;                                               \
S                                LockState = __get_interrupt_state();                                \
S                                __disable_interrupt();
X  #define SEGGER_RTT_LOCK()   {                                                                                                     __istate_t LockState;                                                                               LockState = __get_interrupt_state();                                                                __disable_interrupt();
S
S  #define SEGGER_RTT_UNLOCK()   __set_interrupt_state(LockState);                                   \
S                              }
X  #define SEGGER_RTT_UNLOCK()   __set_interrupt_state(LockState);                                                                 }
N#endif
N
N/*********************************************************************
N*
N*       RTT lock configuration for KEIL ARM
N*/
N#ifdef __CC_ARM
N  #if (defined __TARGET_ARCH_6S_M)
X  #if (1L)
N    #define SEGGER_RTT_LOCK()   {                                                                   \
N                                  unsigned int LockState;                                           \
N                                  register unsigned char PRIMASK __asm( "primask");                 \
N                                  LockState = PRIMASK;                                              \
N                                  PRIMASK = 1u;                                                     \
N                                  __schedule_barrier();
X    #define SEGGER_RTT_LOCK()   {                                                                                                     unsigned int LockState;                                                                             register unsigned char PRIMASK __asm( "primask");                                                   LockState = PRIMASK;                                                                                PRIMASK = 1u;                                                                                       __schedule_barrier();
N
N    #define SEGGER_RTT_UNLOCK()   PRIMASK = LockState;                                              \
N                                  __schedule_barrier();                                             \
N                                }
X    #define SEGGER_RTT_UNLOCK()   PRIMASK = LockState;                                                                                __schedule_barrier();                                                                             }
N  #elif (defined(__TARGET_ARCH_7_M) || defined(__TARGET_ARCH_7E_M))
X  #elif (0L || 0L)
S    #ifndef   SEGGER_RTT_MAX_INTERRUPT_PRIORITY
S      #define SEGGER_RTT_MAX_INTERRUPT_PRIORITY   (0x20)
S    #endif
S    #define SEGGER_RTT_LOCK()   {                                                                   \
S                                  unsigned int LockState;                                           \
S                                  register unsigned char BASEPRI __asm( "basepri");                 \
S                                  LockState = BASEPRI;                                              \
S                                  BASEPRI = SEGGER_RTT_MAX_INTERRUPT_PRIORITY;                      \
S                                  __schedule_barrier();
X    #define SEGGER_RTT_LOCK()   {                                                                                                     unsigned int LockState;                                                                             register unsigned char BASEPRI __asm( "basepri");                                                   LockState = BASEPRI;                                                                                BASEPRI = SEGGER_RTT_MAX_INTERRUPT_PRIORITY;                                                        __schedule_barrier();
S
S    #define SEGGER_RTT_UNLOCK()   BASEPRI = LockState;                                              \
S                                  __schedule_barrier();                                             \
S                                }
X    #define SEGGER_RTT_UNLOCK()   BASEPRI = LockState;                                                                                __schedule_barrier();                                                                             }
N  #endif
N#endif
N
N/*********************************************************************
N*
N*       RTT lock configuration for TI ARM
N*/
N#ifdef __TI_ARM__
S  #if defined (__TI_ARM_V6M0__)
S    #define SEGGER_RTT_LOCK()   {                                                                   \
S                                  unsigned int LockState;                                           \
S                                  LockState = __get_PRIMASK();                                      \
S                                  __set_PRIMASK(1);
X    #define SEGGER_RTT_LOCK()   {                                                                                                     unsigned int LockState;                                                                             LockState = __get_PRIMASK();                                                                        __set_PRIMASK(1);
S
S    #define SEGGER_RTT_UNLOCK()   __set_PRIMASK(LockState);                                         \
S                                }
X    #define SEGGER_RTT_UNLOCK()   __set_PRIMASK(LockState);                                                                         }
S  #elif (defined (__TI_ARM_V7M3__) || defined (__TI_ARM_V7M4__))
S    #ifndef   SEGGER_RTT_MAX_INTERRUPT_PRIORITY
S      #define SEGGER_RTT_MAX_INTERRUPT_PRIORITY   (0x20)
S    #endif
S    #define SEGGER_RTT_LOCK()   {                                                                   \
S                                  unsigned int LockState;                                           \
S                                  LockState = _set_interrupt_priority(SEGGER_RTT_MAX_INTERRUPT_PRIORITY);
X    #define SEGGER_RTT_LOCK()   {                                                                                                     unsigned int LockState;                                                                             LockState = _set_interrupt_priority(SEGGER_RTT_MAX_INTERRUPT_PRIORITY);
S
S    #define SEGGER_RTT_UNLOCK()   _set_interrupt_priority(LockState);                               \
S                                }
X    #define SEGGER_RTT_UNLOCK()   _set_interrupt_priority(LockState);                                                               }
S  #endif
N#endif
N
N/*********************************************************************
N*
N*       RTT lock configuration for CCRX
N*/
N#ifdef __RX
S  #define SEGGER_RTT_LOCK()   {                                                                     \
S                                unsigned long LockState;                                            \
S                                LockState = get_psw() & 0x010000;                                   \
S                                clrpsw_i();                           
X  #define SEGGER_RTT_LOCK()   {                                                                                                     unsigned long LockState;                                                                            LockState = get_psw() & 0x010000;                                                                   clrpsw_i();                           
S                                    
S  #define SEGGER_RTT_UNLOCK()   set_psw(get_psw() | LockState);                                     \
S                              }
X  #define SEGGER_RTT_UNLOCK()   set_psw(get_psw() | LockState);                                                                   }
N#endif
N
N/*********************************************************************
N*
N*       RTT lock configuration for embOS Simulation on Windows
N*       (Can also be used for generic RTT locking with embOS)
N*/
N#if defined(WIN32) || defined(SEGGER_RTT_LOCK_EMBOS)
X#if 0L || 0L
S
Svoid OS_SIM_EnterCriticalSection(void);
Svoid OS_SIM_LeaveCriticalSection(void);
S
S#define SEGGER_RTT_LOCK()       {                                                                   \
S                                  OS_SIM_EnterCriticalSection();
X#define SEGGER_RTT_LOCK()       {                                                                                                     OS_SIM_EnterCriticalSection();
S
S#define SEGGER_RTT_UNLOCK()       OS_SIM_LeaveCriticalSection();                                    \
S                                }
X#define SEGGER_RTT_UNLOCK()       OS_SIM_LeaveCriticalSection();                                                                    }
N#endif
N
N/*********************************************************************
N*
N*       RTT lock configuration fallback
N*/
N#ifndef   SEGGER_RTT_LOCK
S  #define SEGGER_RTT_LOCK()                // Lock RTT (nestable)   (i.e. disable interrupts)
N#endif
N
N#ifndef   SEGGER_RTT_UNLOCK
S  #define SEGGER_RTT_UNLOCK()              // Unlock RTT (nestable) (i.e. enable previous interrupt lock state)
N#endif
N
N#endif
N/*************************** End of file ****************************/
L 62 "..\RTT\SEGGER_RTT.h" 2
N
N
N
N/*********************************************************************
N*
N*       Defines, defaults
N*
N**********************************************************************
N*/
N#ifndef RTT_USE_ASM
N  #if (defined __SES_ARM)                       // SEGGER Embedded Studio
X  #if (0L)                       
S    #define _CC_HAS_RTT_ASM_SUPPORT 1
S  #elif (defined __CROSSWORKS_ARM)              // Rowley Crossworks
X  #elif (0L)              
S    #define _CC_HAS_RTT_ASM_SUPPORT 1
N  #elif (defined __GNUC__)                      // GCC
X  #elif (1L)                      
N    #define _CC_HAS_RTT_ASM_SUPPORT 1
N  #elif (defined __clang__)                     // Clang compiler
X  #elif (0L)                     
S    #define _CC_HAS_RTT_ASM_SUPPORT 1
S  #elif (defined __IASMARM__)                   // IAR assembler
S    #define _CC_HAS_RTT_ASM_SUPPORT 1
S  #elif (defined __ICCARM__)                    // IAR compiler
S    #define _CC_HAS_RTT_ASM_SUPPORT 1
S  #else
S    #define _CC_HAS_RTT_ASM_SUPPORT 0
N  #endif
N  #if (defined __ARM_ARCH_7M__)                 // Cortex-M3/4
X  #if (0L)                 
S    #define _CORE_HAS_RTT_ASM_SUPPORT 1
S  #elif (defined __ARM_ARCH_7EM__)              // Cortex-M7
X  #elif (0L)              
S    #define _CORE_HAS_RTT_ASM_SUPPORT 1
S  #elif (defined __ARM_ARCH_8M_MAIN__)          // Cortex-M33
X  #elif (0L)          
S    #define _CORE_HAS_RTT_ASM_SUPPORT 1
S  #elif (defined __ARM7M__)                     // IAR Cortex-M3/4
X  #elif (0L)                     
S    #if (__CORE__ == __ARM7M__)
S      #define _CORE_HAS_RTT_ASM_SUPPORT 1
S    #else
S      #define _CORE_HAS_RTT_ASM_SUPPORT 0
S    #endif
S  #elif (defined __ARM7EM__)                    // IAR Cortex-M7
X  #elif (0L)                    
S    #if (__CORE__ == __ARM7EM__)
S      #define _CORE_HAS_RTT_ASM_SUPPORT 1
S    #else
S      #define _CORE_HAS_RTT_ASM_SUPPORT 0
S    #endif
N  #else
N    #define _CORE_HAS_RTT_ASM_SUPPORT 0
N  #endif
N  //
N  // If IDE and core support the ASM version, enable ASM version by default
N  //
N  #if (_CC_HAS_RTT_ASM_SUPPORT && _CORE_HAS_RTT_ASM_SUPPORT)
X  #if (1 && 0)
S    #define RTT_USE_ASM                           (1)
N  #else
N    #define RTT_USE_ASM                           (0)
N  #endif
N#endif
N
N#ifndef SEGGER_RTT_ASM  // defined when SEGGER_RTT.h is included from assembly file
N#include <stdlib.h>
N#include <stdarg.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdarg.h" 1
N/* stdarg.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.8 */
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright (C) ARM Ltd., 1991-1999. All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdarg_h
N#define __stdarg_h
N#define __ARMCLIB_VERSION 5060044
N
N  #ifndef __STDARG_DECLS
N  #define __STDARG_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N/*
N * stdarg.h declares a type and defines macros for advancing through a
N * list of arguments whose number and types are not known to the called
N * function when it is translated. A function may be called with a variable
N * number of arguments of differing types. Its parameter list contains one or
N * more parameters. The rightmost parameter plays a special role in the access
N * mechanism, and will be called parmN in this description.
N */
N
N/* N.B. <stdio.h> is required to declare vfprintf() without defining      */
N/* va_list.  Clearly the type __va_list there must keep in step.          */
N#ifdef __clang__
S  typedef __builtin_va_list va_list;
S  #define va_start(ap, param) __builtin_va_start(ap, param)
S  #define va_end(ap)          __builtin_va_end(ap)
S  #define va_arg(ap, type)    __builtin_va_arg(ap, type)
S  #if __STDC_VERSION__ >= 199900L || __cplusplus >= 201103L || !defined(__STRICT_ANSI__)
S  #define va_copy(dest, src)  __builtin_va_copy(dest, src)
S  #endif
N#else
N  #ifdef __TARGET_ARCH_AARCH64
S    typedef struct __va_list {
S      void *__stack;
S      void *__gr_top;
S      void *__vr_top;
S      int __gr_offs;
S      int __vr_offs;
S    } va_list;
N  #else
N    typedef struct __va_list { void *__ap; } va_list;
N  #endif
N   /*
N    * an array type suitable for holding information needed by the macro va_arg
N    * and the function va_end. The called function shall declare a variable
N    * (referred to as ap) having type va_list. The variable ap may be passed as
N    * an argument to another function.
N    * Note: va_list is an array type so that when an object of that type
N    * is passed as an argument it gets passed by reference.
N    */
N  #define va_start(ap, parmN) __va_start(ap, parmN)
N
N   /*
N    * The va_start macro shall be executed before any access to the unnamed
N    * arguments. The parameter ap points to an object that has type va_list.
N    * The va_start macro initialises ap for subsequent use by va_arg and
N    * va_end. The parameter parmN is the identifier of the rightmost parameter
N    * in the variable parameter list in the function definition (the one just
N    * before the '...'). If the parameter parmN is declared with the register
N    * storage class an error is given.
N    * If parmN is a narrow type (char, short, float) an error is given in
N    * strict ANSI mode, or a warning otherwise.
N    * Returns: no value.
N    */
N  #define va_arg(ap, type) __va_arg(ap, type)
N
N   /*
N    * The va_arg macro expands to an expression that has the type and value of
N    * the next argument in the call. The parameter ap shall be the same as the
N    * va_list ap initialised by va_start. Each invocation of va_arg modifies
N    * ap so that successive arguments are returned in turn. The parameter
N    * 'type' is a type name such that the type of a pointer to an object that
N    * has the specified type can be obtained simply by postfixing a * to
N    * 'type'. If type is a narrow type, an error is given in strict ANSI
N    * mode, or a warning otherwise. If the type is an array or function type,
N    * an error is given.
N    * In non-strict ANSI mode, 'type' is allowed to be any expression.
N    * Returns: The first invocation of the va_arg macro after that of the
N    *          va_start macro returns the value of the argument after that
N    *          specified by parmN. Successive invocations return the values of
N    *          the remaining arguments in succession.
N    *          The result is cast to 'type', even if 'type' is narrow.
N    */
N
N#define __va_copy(dest, src) ((void)((dest) = (src)))
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N   /* va_copy is in C99 and non-strict C90 and non-strict C++
N    * __va_copy is always present.
N    */
N  #define va_copy(dest, src) ((void)((dest) = (src)))
N
N   /* The va_copy macro makes the va_list dest be a copy of
N    * the va_list src, as if the va_start macro had been applied
N    * to it followed by the same sequence of uses of the va_arg
N    * macro as had previously been used to reach the present state
N    * of src.
N    */
N#endif
N
N#define va_end(ap) __va_end(ap)
N   /*
N    * The va_end macro facilitates a normal return from the function whose
N    * variable argument list was referenced by the expansion of va_start that
N    * initialised the va_list ap. If the va_end macro is not invoked before
N    * the return, the behaviour is undefined.
N    * Returns: no value.
N    */
N#endif /* __clang__ */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N
N    #ifdef __GNUC__
N     /* be cooperative with glibc */
N     typedef __CLIBNS va_list __gnuc_va_list;
X     typedef  va_list __gnuc_va_list;
N     #define __GNUC_VA_LIST
N     #undef __need___va_list
N    #endif
N
N  #endif /* __STDARG_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDARG_NO_EXPORTS
S      using ::std::va_list;
S    #endif
N  #endif /* __cplusplus */
N#endif
N
N/* end of stdarg.h */
N
L 121 "..\RTT\SEGGER_RTT.h" 2
N
N/*********************************************************************
N*
N*       Defines, fixed
N*
N**********************************************************************
N*/
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
N
N//
N// Description for a circular buffer (also called "ring buffer")
N// which is used as up-buffer (T->H)
N//
Ntypedef struct {
N  const     char*    sName;         // Optional name. Standard names so far are: "Terminal", "SysView", "J-Scope_t4i4"
N            char*    pBuffer;       // Pointer to start of buffer
N            unsigned SizeOfBuffer;  // Buffer size in bytes. Note that one byte is lost, as this implementation does not fill up the buffer in order to avoid the problem of being unable to distinguish between full and empty.
N            unsigned WrOff;         // Position of next item to be written by either target.
N  volatile  unsigned RdOff;         // Position of next item to be read by host. Must be volatile since it may be modified by host.
N            unsigned Flags;         // Contains configuration flags
N} SEGGER_RTT_BUFFER_UP;
N
N//
N// Description for a circular buffer (also called "ring buffer")
N// which is used as down-buffer (H->T)
N//
Ntypedef struct {
N  const     char*    sName;         // Optional name. Standard names so far are: "Terminal", "SysView", "J-Scope_t4i4"
N            char*    pBuffer;       // Pointer to start of buffer
N            unsigned SizeOfBuffer;  // Buffer size in bytes. Note that one byte is lost, as this implementation does not fill up the buffer in order to avoid the problem of being unable to distinguish between full and empty.
N  volatile  unsigned WrOff;         // Position of next item to be written by host. Must be volatile since it may be modified by host.
N            unsigned RdOff;         // Position of next item to be read by target (down-buffer).
N            unsigned Flags;         // Contains configuration flags
N} SEGGER_RTT_BUFFER_DOWN;
N
N//
N// RTT control block which describes the number of buffers available
N// as well as the configuration for each buffer
N//
N//
Ntypedef struct {
N  char                    acID[16];                                 // Initialized to "SEGGER RTT"
N  int                     MaxNumUpBuffers;                          // Initialized to SEGGER_RTT_MAX_NUM_UP_BUFFERS (type. 2)
N  int                     MaxNumDownBuffers;                        // Initialized to SEGGER_RTT_MAX_NUM_DOWN_BUFFERS (type. 2)
N  SEGGER_RTT_BUFFER_UP    aUp[SEGGER_RTT_MAX_NUM_UP_BUFFERS];       // Up buffers, transferring information up from target via debug probe to host
X  SEGGER_RTT_BUFFER_UP    aUp[(3)];       
N  SEGGER_RTT_BUFFER_DOWN  aDown[SEGGER_RTT_MAX_NUM_DOWN_BUFFERS];   // Down buffers, transferring information down from host via debug probe to target
X  SEGGER_RTT_BUFFER_DOWN  aDown[(3)];   
N} SEGGER_RTT_CB;
N
N/*********************************************************************
N*
N*       Global data
N*
N**********************************************************************
N*/
Nextern SEGGER_RTT_CB _SEGGER_RTT;
N
N/*********************************************************************
N*
N*       RTT API functions
N*
N**********************************************************************
N*/
N#ifdef __cplusplus
S  extern "C" {
N#endif
Nint          SEGGER_RTT_AllocDownBuffer         (const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags);
Nint          SEGGER_RTT_AllocUpBuffer           (const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags);
Nint          SEGGER_RTT_ConfigUpBuffer          (unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags);
Nint          SEGGER_RTT_ConfigDownBuffer        (unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags);
Nint          SEGGER_RTT_GetKey                  (void);
Nunsigned     SEGGER_RTT_HasData                 (unsigned BufferIndex);
Nint          SEGGER_RTT_HasKey                  (void);
Nunsigned     SEGGER_RTT_HasDataUp               (unsigned BufferIndex);
Nvoid         SEGGER_RTT_Init                    (void);
Nunsigned     SEGGER_RTT_Read                    (unsigned BufferIndex,       void* pBuffer, unsigned BufferSize);
Nunsigned     SEGGER_RTT_ReadNoLock              (unsigned BufferIndex,       void* pData,   unsigned BufferSize);
Nint          SEGGER_RTT_SetNameDownBuffer       (unsigned BufferIndex, const char* sName);
Nint          SEGGER_RTT_SetNameUpBuffer         (unsigned BufferIndex, const char* sName);
Nint          SEGGER_RTT_SetFlagsDownBuffer      (unsigned BufferIndex, unsigned Flags);
Nint          SEGGER_RTT_SetFlagsUpBuffer        (unsigned BufferIndex, unsigned Flags);
Nint          SEGGER_RTT_WaitKey                 (void);
Nunsigned     SEGGER_RTT_Write                   (unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);
Nunsigned     SEGGER_RTT_WriteNoLock             (unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);
Nunsigned     SEGGER_RTT_WriteSkipNoLock         (unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);
Nunsigned     SEGGER_RTT_ASM_WriteSkipNoLock     (unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);
Nunsigned     SEGGER_RTT_WriteString             (unsigned BufferIndex, const char* s);
Nvoid         SEGGER_RTT_WriteWithOverwriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);
Nunsigned     SEGGER_RTT_PutChar                 (unsigned BufferIndex, char c);
Nunsigned     SEGGER_RTT_PutCharSkip             (unsigned BufferIndex, char c);
Nunsigned     SEGGER_RTT_PutCharSkipNoLock       (unsigned BufferIndex, char c);
Nunsigned     SEGGER_RTT_GetAvailWriteSpace      (unsigned BufferIndex);
Nunsigned     SEGGER_RTT_GetBytesInBuffer        (unsigned BufferIndex);
N//
N// Function macro for performance optimization
N//
N#define      SEGGER_RTT_HASDATA(n)       (_SEGGER_RTT.aDown[n].WrOff - _SEGGER_RTT.aDown[n].RdOff)
N
N#if RTT_USE_ASM
X#if (0)
S  #define SEGGER_RTT_WriteSkipNoLock  SEGGER_RTT_ASM_WriteSkipNoLock
N#endif
N
N/*********************************************************************
N*
N*       RTT transfer functions to send RTT data via other channels.
N*
N**********************************************************************
N*/
Nunsigned     SEGGER_RTT_ReadUpBuffer            (unsigned BufferIndex, void* pBuffer, unsigned BufferSize);
Nunsigned     SEGGER_RTT_ReadUpBufferNoLock      (unsigned BufferIndex, void* pData, unsigned BufferSize);
Nunsigned     SEGGER_RTT_WriteDownBuffer         (unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);
Nunsigned     SEGGER_RTT_WriteDownBufferNoLock   (unsigned BufferIndex, const void* pBuffer, unsigned NumBytes);
N
N#define      SEGGER_RTT_HASDATA_UP(n)    (_SEGGER_RTT.aUp[n].WrOff - _SEGGER_RTT.aUp[n].RdOff)
N
N/*********************************************************************
N*
N*       RTT "Terminal" API functions
N*
N**********************************************************************
N*/
Nint     SEGGER_RTT_SetTerminal        (unsigned char TerminalId);
Nint     SEGGER_RTT_TerminalOut        (unsigned char TerminalId, const char* s);
N
N/*********************************************************************
N*
N*       RTT printf functions (require SEGGER_RTT_printf.c)
N*
N**********************************************************************
N*/
Nint SEGGER_RTT_printf(unsigned BufferIndex, const char * sFormat, ...);
Nint SEGGER_RTT_vprintf(unsigned BufferIndex, const char * sFormat, va_list * pParamList);
N
N#ifdef __cplusplus
S  }
N#endif
N
N#endif // ifndef(SEGGER_RTT_ASM)
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N
N//
N// Operating modes. Define behavior if buffer is full (not enough space for entire message)
N//
N#define SEGGER_RTT_MODE_NO_BLOCK_SKIP         (0)     // Skip. Do not block, output nothing. (Default)
N#define SEGGER_RTT_MODE_NO_BLOCK_TRIM         (1)     // Trim: Do not block, output as much as fits.
N#define SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL    (2)     // Block: Wait until there is space in the buffer.
N#define SEGGER_RTT_MODE_MASK                  (3)
N
N//
N// Control sequences, based on ANSI.
N// Can be used to control color, and clear the screen
N//
N#define RTT_CTRL_RESET                "\x1B[0m"         // Reset to default colors
N#define RTT_CTRL_CLEAR                "\x1B[2J"         // Clear screen, reposition cursor to top left
N
N#define RTT_CTRL_TEXT_BLACK           "\x1B[2;30m"
N#define RTT_CTRL_TEXT_RED             "\x1B[2;31m"
N#define RTT_CTRL_TEXT_GREEN           "\x1B[2;32m"
N#define RTT_CTRL_TEXT_YELLOW          "\x1B[2;33m"
N#define RTT_CTRL_TEXT_BLUE            "\x1B[2;34m"
N#define RTT_CTRL_TEXT_MAGENTA         "\x1B[2;35m"
N#define RTT_CTRL_TEXT_CYAN            "\x1B[2;36m"
N#define RTT_CTRL_TEXT_WHITE           "\x1B[2;37m"
N
N#define RTT_CTRL_TEXT_BRIGHT_BLACK    "\x1B[1;30m"
N#define RTT_CTRL_TEXT_BRIGHT_RED      "\x1B[1;31m"
N#define RTT_CTRL_TEXT_BRIGHT_GREEN    "\x1B[1;32m"
N#define RTT_CTRL_TEXT_BRIGHT_YELLOW   "\x1B[1;33m"
N#define RTT_CTRL_TEXT_BRIGHT_BLUE     "\x1B[1;34m"
N#define RTT_CTRL_TEXT_BRIGHT_MAGENTA  "\x1B[1;35m"
N#define RTT_CTRL_TEXT_BRIGHT_CYAN     "\x1B[1;36m"
N#define RTT_CTRL_TEXT_BRIGHT_WHITE    "\x1B[1;37m"
N
N#define RTT_CTRL_BG_BLACK             "\x1B[24;40m"
N#define RTT_CTRL_BG_RED               "\x1B[24;41m"
N#define RTT_CTRL_BG_GREEN             "\x1B[24;42m"
N#define RTT_CTRL_BG_YELLOW            "\x1B[24;43m"
N#define RTT_CTRL_BG_BLUE              "\x1B[24;44m"
N#define RTT_CTRL_BG_MAGENTA           "\x1B[24;45m"
N#define RTT_CTRL_BG_CYAN              "\x1B[24;46m"
N#define RTT_CTRL_BG_WHITE             "\x1B[24;47m"
N
N#define RTT_CTRL_BG_BRIGHT_BLACK      "\x1B[4;40m"
N#define RTT_CTRL_BG_BRIGHT_RED        "\x1B[4;41m"
N#define RTT_CTRL_BG_BRIGHT_GREEN      "\x1B[4;42m"
N#define RTT_CTRL_BG_BRIGHT_YELLOW     "\x1B[4;43m"
N#define RTT_CTRL_BG_BRIGHT_BLUE       "\x1B[4;44m"
N#define RTT_CTRL_BG_BRIGHT_MAGENTA    "\x1B[4;45m"
N#define RTT_CTRL_BG_BRIGHT_CYAN       "\x1B[4;46m"
N#define RTT_CTRL_BG_BRIGHT_WHITE      "\x1B[4;47m"
N
N
N#endif
N
N/*************************** End of file ****************************/
L 61 "..\user\main.h" 2
N#include "SysTick.h"
N#include "online.h"
N
N
N
N
N
N/* Public Constant prototypes----------------------------------------------------*/
N
N/* Public typedef ---------------------------------------------------------------*/
N
N#define _debug_
N
N/* Public define ----------------------------------------------------------------*/
N
N//#define ApplicationAddress    ((uint32_t)0x08002000)   //APP
N//#define IaplicationAddress    ((uint32_t)0x08000000)   //IAP
N//#define ApplicaflagAddress    ((uint32_t)0x08002E00)   //APP
N
N/* Public variables prototypes --------------------------------------------------*/
Nextern uint32_t test_usb;
N
Nextern CLASS_HID_DATA	c_hid_data;
N
N
N/* Public function prototypes----------------------------------------------------*/
Nvoid Systick_Init(void);
N
N#endif /* __MAIN_H */
N
N/************************** (C) COPYRIGHT FMD **********************END OF FILE****/
L 7 "..\user\eeprom.h" 2
N
N
N#define EEPROM_PAGE_SIZE	512				//512
N#define EEPROM_MAX_LEN		20480			//20480
N#define EEPROM_START_ADDR 	0x800B000		//EEPROM0x800B000~0x8010000   20480   
N#define FLASH_START_ADDR	0x8000000		//main0x800000064K
N
N
Ntypedef void (*erase_t)(uint32_t addr);
Ntypedef uint8_t (*write_t)(size_t addr, size_t data);
N
N
N
N
Ntypedef struct
N{
N	size_t page_size;		//
N	size_t start;			//EEPROM
N	size_t size;			//EEPROM
N	size_t flash_start;		//flash
N	uint8_t* buffer;		//
N	uint8_t init;			//
N	erase_t erase;			//
N	write_t write;			//
N}eeprom_t;
N
Nuint8_t read_byte(size_t eeprom_start, size_t addr);
N
Nvoid erase_page(uint32_t addr);
Nuint8_t write_word(size_t addr, size_t data);
N
N
Nvoid eeprom_init(eeprom_t* eeprom, uint8_t* buffer, size_t len);
Nvoid eeprom_config(eeprom_t* eeprom, size_t start, size_t size, size_t flash_start);
Nvoid eeprom_register(eeprom_t* eeprom, erase_t erase, write_t write);
Nsize_t eeprom_read(eeprom_t* eeprom, size_t addr, uint8_t* data, size_t len); 
Nvoid eeprom_write(eeprom_t* eeprom, size_t addr, const uint8_t* data, size_t len);
Nvoid eeprom_free(eeprom_t* eeprom);
N
N
N
N
N
N
N
N#endif
N
N
N
N
N
L 2 "..\user\eeprom.c" 2
N
N
N
N
N
N
N
Ntypedef struct
N{
N	size_t addr;
N	size_t len;
N	uint8_t* data;
N}page_data_t;
N
N
N
N
N
N
N
N
N
Nvoid erase_page(uint32_t addr)
N{
N	FLASH_Unlock();
N	FLASH_ClearFlag(FLASH_FLAG_EOP | FLASH_FLAG_PGERR | FLASH_FLAG_WRPERR);
X	FLASH_ClearFlag(((uint32_t)0x00000020) | ((uint32_t)0x00000004) | ((uint32_t)0x00000010));
N	while(FLASH_ErasePage(addr) != FLASH_COMPLETE);
N	FLASH_Lock();
N}
N
N
N
N
N
N
N
N
Nuint8_t write_word(size_t addr, size_t data)
N{
N	
N	FLASH_Status status;
N	
N	FLASH_Unlock();
N	FLASH_ClearFlag(FLASH_FLAG_EOP | FLASH_FLAG_PGERR | FLASH_FLAG_WRPERR);
X	FLASH_ClearFlag(((uint32_t)0x00000020) | ((uint32_t)0x00000004) | ((uint32_t)0x00000010));
N	status = FLASH_ProgramWord(addr, data);
N	FLASH_Lock();
N	
N	return status;
N}
N
N
N
N
N
N
N
N
N
Nvoid eeprom_init(eeprom_t* eeprom, uint8_t* buffer, size_t len)
N{
N	if(eeprom != NULL)
X	if(eeprom != 0)
N	{
N		if(buffer != NULL)
X		if(buffer != 0)
N		{
N			memset(buffer, 0xFF, len);
N			eeprom->buffer = buffer;
N			eeprom->page_size = len;
N			eeprom->init = 0xAA;
N		}
N	}
N}
N
N
N
N
N
N
N
N
Nvoid eeprom_config(eeprom_t* eeprom, size_t start, size_t size, size_t flash_start)
N{
N	if( eeprom != NULL && (eeprom->init == 0xBB || eeprom->init == 0xAA) )
X	if( eeprom != 0 && (eeprom->init == 0xBB || eeprom->init == 0xAA) )
N	{
N		eeprom->size = size;
N		eeprom->start = start;
N		eeprom->flash_start = flash_start;
N		eeprom->init = 0xBB;
N	}
N}
N
N
N
N
N
N
N
N
Nvoid eeprom_register(eeprom_t* eeprom, erase_t erase, write_t write)
N{
N	if( eeprom != NULL && (eeprom->init == 0xBB || eeprom->init == 0xAA) )
X	if( eeprom != 0 && (eeprom->init == 0xBB || eeprom->init == 0xAA) )
N	{
N		eeprom->write = write;
N		eeprom->erase = erase;
N		eeprom->init = 0xCC;
N	}
N}
N
N
N
N
N
N
N
N
Ninline uint8_t read_byte(size_t eeprom_start, size_t addr)
N{
N
N	uint8_t byte = addr % 4;
N	uint32_t byte4 = addr / 4;
N	uint32_t d = 0x00;
N
N	d = *(uint32_t*)(eeprom_start + (byte4 * 4));
N	return d >> (byte * 8) & 0xFF;
N}
N
N
N
N
N
N
N
N
Nsize_t eeprom_read(eeprom_t* eeprom, size_t addr, uint8_t* data, size_t len)
N{
N	
N	size_t i;
N	size_t conut = 0;
N	
N	if( eeprom != NULL && eeprom->init == 0xCC )
X	if( eeprom != 0 && eeprom->init == 0xCC )
N	{	
N		if( data == NULL || ( addr + len ) > ( eeprom->start + eeprom->size ) )
X		if( data == 0 || ( addr + len ) > ( eeprom->start + eeprom->size ) )
N		{
N			return 0;
N		}
N
N		for( i = addr; i < addr + len; ++i )
N		{
N			data[conut++] = read_byte( eeprom->start, i );
N		}
N		
N	}
N	return conut;
N}
N
N
N
N
N//
Nstatic void eeprom_write_page(eeprom_t* eeprom, uint32_t addr)
N{
N	size_t i; 
N	size_t write_addr = addr - addr % eeprom->page_size;
N	uint32_t data = 0x00;
N
N	for(i = 0; i < eeprom->page_size; ++i)
N	{	
N		if(i % 4 == 0)
N		{
N			data |= eeprom->buffer[i + 3];
N			data <<= 8;
N			data |= eeprom->buffer[i + 2];
N			data <<= 8;
N			data |= eeprom->buffer[i + 1];
N			data <<= 8;
N			data |= eeprom->buffer[i];
N			
N			write_word( write_addr + i, data); 
N			data = 0;
N		}
N	}	
N}
N
N
N
N
N
N
N
N
Nstatic void eeprom_write_nverify(eeprom_t* eeprom, uint32_t addr, const uint8_t* data, size_t len)
N{
N	int i;
N	uint32_t tdata;
N	size_t offset, page_addr;
N	
N	
N	/**/
N	page_addr = eeprom->start + ( ( (addr - eeprom->start) / eeprom->page_size ) * eeprom->page_size );	
N	for(int i = 0; i < eeprom->page_size; ++i)
N	{
N		eeprom->buffer[i] = read_byte(page_addr, i);
N	}
N	
N	/**/
N	offset = addr % eeprom->page_size;
N	memcpy( eeprom->buffer + offset, data, len );
N	
N	
N	/*Flash*/
N	eeprom->erase( addr );
N	eeprom_write_page( eeprom, addr);
N	
N	//
N	memset(eeprom->buffer, 0xFF, eeprom->page_size);
N	
W "..\user\eeprom.c" 193 6 variable "i"  was declared but never referenced
W "..\user\eeprom.c" 194 11 variable "tdata"  was declared but never referenced
N}
N
N
N
N
N
N
N
Nstatic int verify_data(eeprom_t* eeprom, size_t addr, const uint8_t* data, size_t len, page_data_t* pdata)
N{
N	
N	uint8_t exit = 0;
N	size_t write_len = 0;
N	size_t page_count = 0;
N	size_t current_len = len;
N	uint8_t* current_data = (uint8_t*)data;
N	size_t current_addr = addr;
N	size_t offset = ( addr / eeprom->page_size ) * eeprom->page_size;
N
N	/**/
N	while(1)
N	{
N		// = flash + 
N		current_addr = offset + ( eeprom->start + (page_count * eeprom->page_size) ) + ( current_addr % eeprom->page_size );	
N		pdata[page_count].addr = current_addr;
N		
N		//
N		pdata[page_count].data = current_data;	
N		
N		// =  - 
N		current_len = eeprom->page_size - current_addr % eeprom->page_size;	
N		write_len += current_len;
N		if(write_len >= len)
N		{
N			if(write_len > len)
N			{
N				current_len -= write_len - len;
N			}
N			exit = 1;
N		}
N		pdata[page_count].len = current_len;
N		page_count++;
N		
N		if(exit)
N		{
N			break;
N		}
N		
N		current_addr += current_len;
N		current_data += current_len;
N	}
N
N	return page_count;
N}
N
N
N
N
N
N
N
N
N
N
Nvoid eeprom_write(eeprom_t* eeprom, size_t addr, const uint8_t* data, size_t len)
N{
N	int i, page_num = 0;
N	page_data_t pdata[64];
N	
N	if(eeprom != NULL && eeprom->init == 0xCC)
X	if(eeprom != 0 && eeprom->init == 0xCC)
N	{	
N		page_num = verify_data(eeprom, addr, data, len, pdata);
N		if(page_num > 1)
N		{
N			/**/
N			for(i = 0; i < page_num; ++i)
N			{
N				eeprom_write_nverify(eeprom, pdata[i].addr, pdata[i].data, pdata[i].len);
N			}
N		}
N		else
N		{
N			/**/
N			eeprom_write_nverify(eeprom, pdata[0].addr, pdata[0].data, pdata[0].len);
N		}
N	}
N}
N
N
N
N
N
N
N
Nvoid eeprom_free(eeprom_t* eeprom)
N{
N	if(eeprom != NULL && eeprom->init == 0xCC)
X	if(eeprom != 0 && eeprom->init == 0xCC)
N	{
N		memset(eeprom, 0x00, sizeof(eeprom_t));
N	}
N}
N
N
N
N
N
N
N
N
