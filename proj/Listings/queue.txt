; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\queue.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\queue.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\FTLib\CMSIS\inc -I..\FTLib\Inc -I..\FTLib\Lib -I..\usb\inc -I..\user -I..\RTT -IC:\Users\Tom\AppData\Local\Arm\Packs\FMD\FT32F0xx_DFP\1.0.2\Drivers\CMSIS\FT32F0xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=533 -DFT32F072x8 -DFT32F072x8 --omf_browse=.\objects\queue.crf ..\user\queue.c]
                          THUMB

                          AREA ||i.is_empty||, CODE, READONLY, ALIGN=1

                  is_empty PROC
;;;29     
;;;30     static int is_empty(queue_t* queue)
000000  4601              MOV      r1,r0
;;;31     {
;;;32         if(queue->read_point == queue->write_point)
000002  680a              LDR      r2,[r1,#0]
000004  6848              LDR      r0,[r1,#4]
000006  4290              CMP      r0,r2
000008  d101              BNE      |L1.14|
;;;33         {
;;;34             return 1;
00000a  2001              MOVS     r0,#1
                  |L1.12|
;;;35         }
;;;36         return 0;
;;;37     }
00000c  4770              BX       lr
                  |L1.14|
00000e  2000              MOVS     r0,#0                 ;36
000010  e7fc              B        |L1.12|
;;;38     
                          ENDP


                          AREA ||i.is_full||, CODE, READONLY, ALIGN=1

                  is_full PROC
;;;45     
;;;46     static int is_full(queue_t* queue)
000000  b510              PUSH     {r4,lr}
;;;47     {
000002  4604              MOV      r4,r0
;;;48         if((queue->write_point + 1) % queue->item_qty == queue->read_point)
000004  6822              LDR      r2,[r4,#0]
000006  1c50              ADDS     r0,r2,#1
000008  6921              LDR      r1,[r4,#0x10]
00000a  f7fffffe          BL       __aeabi_uidivmod
00000e  6860              LDR      r0,[r4,#4]
000010  4281              CMP      r1,r0
000012  d101              BNE      |L2.24|
;;;49         {
;;;50             return 1;
000014  2001              MOVS     r0,#1
                  |L2.22|
;;;51         }
;;;52         return 0;
;;;53     }
000016  bd10              POP      {r4,pc}
                  |L2.24|
000018  2000              MOVS     r0,#0                 ;52
00001a  e7fc              B        |L2.22|
;;;54     
                          ENDP


                          AREA ||i.move_read_point||, CODE, READONLY, ALIGN=1

                  move_read_point PROC
;;;17     
;;;18     static void move_read_point(queue_t* queue)
000000  b510              PUSH     {r4,lr}
;;;19     {
000002  4604              MOV      r4,r0
;;;20         queue->read_point = (queue->read_point + 1) % queue->item_qty;
000004  6862              LDR      r2,[r4,#4]
000006  1c50              ADDS     r0,r2,#1
000008  6921              LDR      r1,[r4,#0x10]
00000a  f7fffffe          BL       __aeabi_uidivmod
00000e  6061              STR      r1,[r4,#4]
;;;21     }
000010  bd10              POP      {r4,pc}
;;;22     
                          ENDP


                          AREA ||i.move_write_point||, CODE, READONLY, ALIGN=1

                  move_write_point PROC
;;;7      
;;;8      static void move_write_point(queue_t* queue)
000000  b510              PUSH     {r4,lr}
;;;9      {
000002  4604              MOV      r4,r0
;;;10         queue->write_point = (queue->write_point + 1) % queue->item_qty;
000004  6822              LDR      r2,[r4,#0]
000006  1c50              ADDS     r0,r2,#1
000008  6921              LDR      r1,[r4,#0x10]
00000a  f7fffffe          BL       __aeabi_uidivmod
00000e  6021              STR      r1,[r4,#0]
;;;11     }
000010  bd10              POP      {r4,pc}
;;;12     
                          ENDP


                          AREA ||i.queue_free||, CODE, READONLY, ALIGN=1

                  queue_free PROC
;;;181    
;;;182    int queue_free(queue_t* queue)
000000  b510              PUSH     {r4,lr}
;;;183    {
000002  4604              MOV      r4,r0
;;;184        //参数合法性检查
;;;185        if(queue == NULL)
000004  2c00              CMP      r4,#0
000006  d101              BNE      |L5.12|
;;;186        {
;;;187            return -1;
000008  1e40              SUBS     r0,r0,#1
                  |L5.10|
;;;188        }
;;;189    
;;;190        memset(queue, 0, sizeof(queue_t));
;;;191    
;;;192        return 0;
;;;193    }
00000a  bd10              POP      {r4,pc}
                  |L5.12|
00000c  2118              MOVS     r1,#0x18              ;190
00000e  4620              MOV      r0,r4                 ;190
000010  f7fffffe          BL       __aeabi_memclr4
000014  2000              MOVS     r0,#0                 ;192
000016  e7f8              B        |L5.10|
;;;194    
                          ENDP


                          AREA ||i.queue_init||, CODE, READONLY, ALIGN=1

                  queue_init PROC
;;;61     
;;;62     int queue_init(queue_t* queue, uint8_t* mem_pool, size_t item_len, size_t item_qty)
000000  b5f8              PUSH     {r3-r7,lr}
;;;63     {
000002  4604              MOV      r4,r0
000004  460f              MOV      r7,r1
000006  4615              MOV      r5,r2
000008  461e              MOV      r6,r3
;;;64         //参数合法性检查
;;;65         if(queue == NULL)
00000a  2c00              CMP      r4,#0
00000c  d101              BNE      |L6.18|
;;;66         {
;;;67             return -1;
00000e  1e40              SUBS     r0,r0,#1
                  |L6.16|
;;;68         }
;;;69         memset(queue, 0, sizeof(queue_t));
;;;70         queue->item_len = item_len;
;;;71         queue->item_qty = item_qty;
;;;72         queue->memory = mem_pool;
;;;73         if(queue->memory == NULL)
;;;74         {
;;;75             return -2;
;;;76         }
;;;77         memset(queue->memory, 0, item_len * item_qty);
;;;78     
;;;79         return 0;
;;;80     }
000010  bdf8              POP      {r3-r7,pc}
                  |L6.18|
000012  2118              MOVS     r1,#0x18              ;69
000014  4620              MOV      r0,r4                 ;69
000016  f7fffffe          BL       __aeabi_memclr4
00001a  60e5              STR      r5,[r4,#0xc]          ;70
00001c  6126              STR      r6,[r4,#0x10]         ;71
00001e  60a7              STR      r7,[r4,#8]            ;72
000020  68a0              LDR      r0,[r4,#8]            ;73
000022  2800              CMP      r0,#0                 ;73
000024  d101              BNE      |L6.42|
000026  1e80              SUBS     r0,r0,#2              ;75
000028  e7f2              B        |L6.16|
                  |L6.42|
00002a  462a              MOV      r2,r5                 ;77
00002c  4372              MULS     r2,r6,r2              ;77
00002e  4611              MOV      r1,r2                 ;77
000030  68a0              LDR      r0,[r4,#8]            ;77
000032  f7fffffe          BL       __aeabi_memclr
000036  2000              MOVS     r0,#0                 ;79
000038  e7ea              B        |L6.16|
;;;81     
                          ENDP


                          AREA ||i.queue_length||, CODE, READONLY, ALIGN=1

                  queue_length PROC
;;;148    
;;;149    int queue_length(queue_t* queue)
000000  4601              MOV      r1,r0
;;;150    {   
;;;151        return queue->num;
000002  6948              LDR      r0,[r1,#0x14]
;;;152    }
000004  4770              BX       lr
;;;153    
                          ENDP


                          AREA ||i.queue_peek||, CODE, READONLY, ALIGN=1

                  queue_peek PROC
;;;156    
;;;157    int queue_peek(queue_t* queue, void* recv, size_t len)
000000  b5fe              PUSH     {r1-r7,lr}
;;;158    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;159        //参数合法性检查
;;;160        if(queue == NULL || recv == NULL || len < queue->item_len)
000008  2c00              CMP      r4,#0
00000a  d004              BEQ      |L8.22|
00000c  2d00              CMP      r5,#0
00000e  d002              BEQ      |L8.22|
000010  68e0              LDR      r0,[r4,#0xc]
000012  42b0              CMP      r0,r6
000014  d902              BLS      |L8.28|
                  |L8.22|
;;;161        {
;;;162            return -1;
000016  2000              MOVS     r0,#0
000018  43c0              MVNS     r0,r0
                  |L8.26|
;;;163        }
;;;164    
;;;165        //确定对列是否为空
;;;166        if(is_empty(queue))
;;;167        {
;;;168            return -2;
;;;169        }
;;;170    
;;;171        //从队列中拷贝数到到RecvBuff指向的内存中
;;;172        uint8_t(*p)[queue->item_len] = (uint8_t(*)[queue->item_len])queue->memory;
;;;173        memcpy(recv, p[queue->read_point], queue->item_len);
;;;174    
;;;175        return 0;
;;;176    }
00001a  bdfe              POP      {r1-r7,pc}
                  |L8.28|
00001c  4620              MOV      r0,r4                 ;166
00001e  f7fffffe          BL       is_empty
000022  2800              CMP      r0,#0                 ;166
000024  d002              BEQ      |L8.44|
000026  2001              MOVS     r0,#1                 ;168
000028  43c0              MVNS     r0,r0                 ;168
00002a  e7f6              B        |L8.26|
                  |L8.44|
00002c  68e7              LDR      r7,[r4,#0xc]          ;172
00002e  68e0              LDR      r0,[r4,#0xc]          ;172
000030  9001              STR      r0,[sp,#4]            ;172
000032  68a0              LDR      r0,[r4,#8]            ;172
000034  9000              STR      r0,[sp,#0]            ;172
000036  6863              LDR      r3,[r4,#4]            ;173
000038  437b              MULS     r3,r7,r3              ;173
00003a  68e2              LDR      r2,[r4,#0xc]          ;173
00003c  9800              LDR      r0,[sp,#0]            ;173
00003e  1819              ADDS     r1,r3,r0              ;173
000040  4628              MOV      r0,r5                 ;173
000042  f7fffffe          BL       __aeabi_memcpy
000046  2000              MOVS     r0,#0                 ;175
000048  e7e7              B        |L8.26|
;;;177    
                          ENDP


                          AREA ||i.queue_pop||, CODE, READONLY, ALIGN=1

                  queue_pop PROC
;;;118    
;;;119    int queue_pop(queue_t* queue, void* recv, size_t len)
000000  b5fe              PUSH     {r1-r7,lr}
;;;120    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;121         //参数合法性检查
;;;122        if(queue == NULL || recv == NULL || len < queue->item_len)
000008  2c00              CMP      r4,#0
00000a  d004              BEQ      |L9.22|
00000c  2d00              CMP      r5,#0
00000e  d002              BEQ      |L9.22|
000010  68e0              LDR      r0,[r4,#0xc]
000012  42b0              CMP      r0,r6
000014  d902              BLS      |L9.28|
                  |L9.22|
;;;123        {
;;;124            return -1;
000016  2000              MOVS     r0,#0
000018  43c0              MVNS     r0,r0
                  |L9.26|
;;;125        }
;;;126    
;;;127        //确定对列是否为空
;;;128        if(is_empty(queue))
;;;129        {
;;;130            return -2;
;;;131        }
;;;132    
;;;133        //从队列中拷贝数到到recv指向的内存中
;;;134        uint8_t(*p)[queue->item_len] = (uint8_t(*)[queue->item_len])queue->memory;
;;;135        memcpy(recv, p[queue->read_point], queue->item_len);
;;;136    
;;;137        //将读取索引向后偏移一个单位
;;;138        move_read_point(queue);
;;;139    
;;;140        //当前单位数减1
;;;141        queue->num--;
;;;142    
;;;143        return 0;
;;;144    }
00001a  bdfe              POP      {r1-r7,pc}
                  |L9.28|
00001c  4620              MOV      r0,r4                 ;128
00001e  f7fffffe          BL       is_empty
000022  2800              CMP      r0,#0                 ;128
000024  d002              BEQ      |L9.44|
000026  2001              MOVS     r0,#1                 ;130
000028  43c0              MVNS     r0,r0                 ;130
00002a  e7f6              B        |L9.26|
                  |L9.44|
00002c  68e7              LDR      r7,[r4,#0xc]          ;134
00002e  68e0              LDR      r0,[r4,#0xc]          ;134
000030  9001              STR      r0,[sp,#4]            ;134
000032  68a0              LDR      r0,[r4,#8]            ;134
000034  9000              STR      r0,[sp,#0]            ;134
000036  6863              LDR      r3,[r4,#4]            ;135
000038  437b              MULS     r3,r7,r3              ;135
00003a  68e2              LDR      r2,[r4,#0xc]          ;135
00003c  9800              LDR      r0,[sp,#0]            ;135
00003e  1819              ADDS     r1,r3,r0              ;135
000040  4628              MOV      r0,r5                 ;135
000042  f7fffffe          BL       __aeabi_memcpy
000046  4620              MOV      r0,r4                 ;138
000048  f7fffffe          BL       move_read_point
00004c  6960              LDR      r0,[r4,#0x14]         ;141
00004e  1e40              SUBS     r0,r0,#1              ;141
000050  6160              STR      r0,[r4,#0x14]         ;141
000052  2000              MOVS     r0,#0                 ;143
000054  e7e1              B        |L9.26|
;;;145    
                          ENDP


                          AREA ||i.queue_push||, CODE, READONLY, ALIGN=1

                  queue_push PROC
;;;87     
;;;88     int queue_push(queue_t* queue, void* data)
000000  b5f8              PUSH     {r3-r7,lr}
;;;89     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;90         //参数合法性检查
;;;91         if(queue == NULL || data == NULL)
000006  2c00              CMP      r4,#0
000008  d001              BEQ      |L10.14|
00000a  2d00              CMP      r5,#0
00000c  d102              BNE      |L10.20|
                  |L10.14|
;;;92         {
;;;93             return -1;
00000e  2000              MOVS     r0,#0
000010  43c0              MVNS     r0,r0
                  |L10.18|
;;;94         }
;;;95     
;;;96         //确定对列是否已满
;;;97         if(is_full(queue))
;;;98         {
;;;99             return -2;
;;;100        }
;;;101    
;;;102        //将数据写入队列
;;;103        uint8_t(*p)[queue->item_len] = (uint8_t(*)[queue->item_len])queue->memory;
;;;104        memcpy(p[queue->write_point], data, queue->item_len);
;;;105    
;;;106        //将写入索引向后偏移一个单位
;;;107        move_write_point(queue);
;;;108    
;;;109        //当前单位数加1
;;;110        queue->num++;
;;;111    
;;;112        return 0;
;;;113    }
000012  bdf8              POP      {r3-r7,pc}
                  |L10.20|
000014  4620              MOV      r0,r4                 ;97
000016  f7fffffe          BL       is_full
00001a  2800              CMP      r0,#0                 ;97
00001c  d002              BEQ      |L10.36|
00001e  2001              MOVS     r0,#1                 ;99
000020  43c0              MVNS     r0,r0                 ;99
000022  e7f6              B        |L10.18|
                  |L10.36|
000024  68e6              LDR      r6,[r4,#0xc]          ;103
000026  68e0              LDR      r0,[r4,#0xc]          ;103
000028  9000              STR      r0,[sp,#0]            ;103
00002a  68a7              LDR      r7,[r4,#8]            ;103
00002c  6821              LDR      r1,[r4,#0]            ;104
00002e  4371              MULS     r1,r6,r1              ;104
000030  19c8              ADDS     r0,r1,r7              ;104
000032  4629              MOV      r1,r5                 ;104
000034  68e2              LDR      r2,[r4,#0xc]          ;104
000036  f7fffffe          BL       __aeabi_memcpy
00003a  4620              MOV      r0,r4                 ;107
00003c  f7fffffe          BL       move_write_point
000040  6960              LDR      r0,[r4,#0x14]         ;110
000042  1c40              ADDS     r0,r0,#1              ;110
000044  6160              STR      r0,[r4,#0x14]         ;110
000046  2000              MOVS     r0,#0                 ;112
000048  e7e3              B        |L10.18|
;;;114    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  queue
                          %        24
