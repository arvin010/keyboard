; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\ft32f0xx_pwr.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\ft32f0xx_pwr.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\FTLib\CMSIS\inc -I..\FTLib\Inc -I..\FTLib\Lib -I..\usb\inc -I..\user -I..\RTT -I..\iap2 -IC:\Users\dell1\AppData\Local\Arm\Packs\FMD\FT32F0xx_DFP\1.0.6\Drivers\CMSIS\FT32F0xx\Include -D__UVISION_VERSION=534 -DFT32F072x8 -DFT32F072x8 --omf_browse=.\objects\ft32f0xx_pwr.crf ..\FTLib\Src\ft32f0xx_pwr.c]
                          THUMB

                          AREA ||i.PWR_BackupAccessCmd||, CODE, READONLY, ALIGN=2

                  PWR_BackupAccessCmd PROC
;;;47       */
;;;48     void PWR_BackupAccessCmd(FunctionalState NewState)
000000  2800              CMP      r0,#0
;;;49     {
;;;50       /* Check the parameters */
;;;51       assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;52       
;;;53       if (NewState != DISABLE)
000002  d007              BEQ      |L1.20|
;;;54       {
;;;55         /* Enable the Backup Domain Access */
;;;56         PWR->CR |= PWR_CR_DBP;
000004  4907              LDR      r1,|L1.36|
000006  6809              LDR      r1,[r1,#0]
000008  22ff              MOVS     r2,#0xff
00000a  3201              ADDS     r2,#1
00000c  4311              ORRS     r1,r1,r2
00000e  4a05              LDR      r2,|L1.36|
000010  6011              STR      r1,[r2,#0]
000012  e006              B        |L1.34|
                  |L1.20|
;;;57       }
;;;58       else
;;;59       {
;;;60         /* Disable the Backup Domain Access */
;;;61         PWR->CR &= (uint32_t)~((uint32_t)PWR_CR_DBP);
000014  4903              LDR      r1,|L1.36|
000016  6809              LDR      r1,[r1,#0]
000018  22ff              MOVS     r2,#0xff
00001a  3201              ADDS     r2,#1
00001c  4391              BICS     r1,r1,r2
00001e  4a01              LDR      r2,|L1.36|
000020  6011              STR      r1,[r2,#0]
                  |L1.34|
;;;62       } 
;;;63     }
000022  4770              BX       lr
;;;64     
                          ENDP

                  |L1.36|
                          DCD      0x40007000

                          AREA ||i.PWR_ClearFlag||, CODE, READONLY, ALIGN=2

                  PWR_ClearFlag PROC
;;;341      */
;;;342    void PWR_ClearFlag(uint32_t PWR_FLAG)
000000  4903              LDR      r1,|L2.16|
;;;343    {
;;;344      /* Check the parameters */
;;;345      assert_param(IS_PWR_CLEAR_FLAG(PWR_FLAG));
;;;346    
;;;347      PWR->CR |=  PWR_FLAG << 2;
000002  6809              LDR      r1,[r1,#0]
000004  0082              LSLS     r2,r0,#2
000006  4311              ORRS     r1,r1,r2
000008  4a01              LDR      r2,|L2.16|
00000a  6011              STR      r1,[r2,#0]
;;;348    }
00000c  4770              BX       lr
;;;349    
                          ENDP

00000e  0000              DCW      0x0000
                  |L2.16|
                          DCD      0x40007000

                          AREA ||i.PWR_DeInit||, CODE, READONLY, ALIGN=1

                  PWR_DeInit PROC
;;;33       */
;;;34     void PWR_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;35     {
;;;36       RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, ENABLE);
000002  2101              MOVS     r1,#1
000004  0708              LSLS     r0,r1,#28
000006  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;37       RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, DISABLE);
00000a  2100              MOVS     r1,#0
00000c  2001              MOVS     r0,#1
00000e  0700              LSLS     r0,r0,#28
000010  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;38     }
000014  bd10              POP      {r4,pc}
;;;39     
                          ENDP


                          AREA ||i.PWR_EnterSTANDBYMode||, CODE, READONLY, ALIGN=2

                  PWR_EnterSTANDBYMode PROC
;;;283      */
;;;284    void PWR_EnterSTANDBYMode(void)
000000  4806              LDR      r0,|L4.28|
;;;285    {
;;;286      /* Select STANDBY mode */
;;;287      PWR->CR |= PWR_CR_PDDS;
000002  6800              LDR      r0,[r0,#0]
000004  2102              MOVS     r1,#2
000006  4308              ORRS     r0,r0,r1
000008  4904              LDR      r1,|L4.28|
00000a  6008              STR      r0,[r1,#0]
;;;288    
;;;289      /* Set SLEEPDEEP bit of Cortex-M0 System Control Register */
;;;290      SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
00000c  4804              LDR      r0,|L4.32|
00000e  6900              LDR      r0,[r0,#0x10]
000010  2104              MOVS     r1,#4
000012  4308              ORRS     r0,r0,r1
000014  4902              LDR      r1,|L4.32|
000016  6108              STR      r0,[r1,#0x10]
;;;291    
;;;292      /* Request Wait For Interrupt */
;;;293      __WFI();
000018  bf30              WFI      
;;;294    }
00001a  4770              BX       lr
;;;295    
                          ENDP

                  |L4.28|
                          DCD      0x40007000
                  |L4.32|
                          DCD      0xe000ed00

                          AREA ||i.PWR_EnterSTOPMode||, CODE, READONLY, ALIGN=2

                  PWR_EnterSTOPMode PROC
;;;228      */
;;;229    void PWR_EnterSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry)
000000  b510              PUSH     {r4,lr}
;;;230    {
000002  4602              MOV      r2,r0
;;;231      uint32_t tmpreg = 0;
000004  2000              MOVS     r0,#0
;;;232      
;;;233      /* Check the parameters */
;;;234      assert_param(IS_PWR_REGULATOR(PWR_Regulator));
;;;235      assert_param(IS_PWR_STOP_ENTRY(PWR_STOPEntry));
;;;236      
;;;237      /* Select the regulator state in STOP mode ---------------------------------*/
;;;238      tmpreg = PWR->CR;
000006  4b15              LDR      r3,|L5.92|
000008  6818              LDR      r0,[r3,#0]
;;;239      /* Clear PDDS and LPDSR bits */
;;;240      tmpreg &= CR_DS_MASK;
00000a  0880              LSRS     r0,r0,#2
00000c  0080              LSLS     r0,r0,#2
;;;241      
;;;242      /* Set LPDSR bit according to PWR_Regulator value */
;;;243      tmpreg |= PWR_Regulator;
00000e  4603              MOV      r3,r0
000010  4313              ORRS     r3,r3,r2
000012  4618              MOV      r0,r3
;;;244      
;;;245      /* Store the new value */
;;;246      PWR->CR = tmpreg;
000014  4b11              LDR      r3,|L5.92|
000016  6018              STR      r0,[r3,#0]
;;;247      
;;;248      /* Set SLEEPDEEP bit of Cortex-M0 System Control Register */
;;;249      SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
000018  4b11              LDR      r3,|L5.96|
00001a  691b              LDR      r3,[r3,#0x10]
00001c  2404              MOVS     r4,#4
00001e  4323              ORRS     r3,r3,r4
000020  4c0f              LDR      r4,|L5.96|
000022  6123              STR      r3,[r4,#0x10]
;;;250      
;;;251      /* Select STOP mode entry --------------------------------------------------*/
;;;252      if(PWR_STOPEntry == PWR_STOPEntry_WFI)
000024  2901              CMP      r1,#1
000026  d107              BNE      |L5.56|
;;;253      {
;;;254        /* Request Wait For Interrupt */
;;;255        __WFI();
000028  bf30              WFI      
;;;256        /* Reset SLEEPDEEP bit of Cortex System Control Register */
;;;257        SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk); 
00002a  4623              MOV      r3,r4
00002c  691b              LDR      r3,[r3,#0x10]
00002e  2404              MOVS     r4,#4
000030  43a3              BICS     r3,r3,r4
000032  4c0b              LDR      r4,|L5.96|
000034  6123              STR      r3,[r4,#0x10]
000036  e00f              B        |L5.88|
                  |L5.56|
;;;258      }
;;;259      else if (PWR_STOPEntry == PWR_STOPEntry_WFE)
000038  2902              CMP      r1,#2
00003a  d107              BNE      |L5.76|
;;;260      {
;;;261        /* Request Wait For Event */
;;;262        __WFE();
00003c  bf20              WFE      
;;;263        /* Reset SLEEPDEEP bit of Cortex System Control Register */
;;;264        SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);   
00003e  4b08              LDR      r3,|L5.96|
000040  691b              LDR      r3,[r3,#0x10]
000042  2404              MOVS     r4,#4
000044  43a3              BICS     r3,r3,r4
000046  4c06              LDR      r4,|L5.96|
000048  6123              STR      r3,[r4,#0x10]
00004a  e005              B        |L5.88|
                  |L5.76|
;;;265      }
;;;266      else
;;;267      {
;;;268        /* Set SLEEP on exit bit of Cortex-M0 System Control Register */
;;;269        SCB->SCR |= SCB_SCR_SLEEPONEXIT_Msk;
00004c  4b04              LDR      r3,|L5.96|
00004e  691b              LDR      r3,[r3,#0x10]
000050  2402              MOVS     r4,#2
000052  4323              ORRS     r3,r3,r4
000054  4c02              LDR      r4,|L5.96|
000056  6123              STR      r3,[r4,#0x10]
                  |L5.88|
;;;270      }
;;;271    }
000058  bd10              POP      {r4,pc}
;;;272    
                          ENDP

00005a  0000              DCW      0x0000
                  |L5.92|
                          DCD      0x40007000
                  |L5.96|
                          DCD      0xe000ed00

                          AREA ||i.PWR_EnterSleepMode||, CODE, READONLY, ALIGN=2

                  PWR_EnterSleepMode PROC
;;;185      */
;;;186    void PWR_EnterSleepMode(uint8_t PWR_SLEEPEntry)
000000  4906              LDR      r1,|L6.28|
;;;187    {
;;;188      /* Check the parameters */
;;;189      assert_param(IS_PWR_SLEEP_ENTRY(PWR_SLEEPEntry));
;;;190    
;;;191      /* Clear SLEEPDEEP bit of Cortex-M0 System Control Register */
;;;192      SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);
000002  6909              LDR      r1,[r1,#0x10]
000004  2204              MOVS     r2,#4
000006  4391              BICS     r1,r1,r2
000008  4a04              LDR      r2,|L6.28|
00000a  6111              STR      r1,[r2,#0x10]
;;;193      
;;;194      /* Select SLEEP mode entry -------------------------------------------------*/
;;;195      if(PWR_SLEEPEntry == PWR_SLEEPEntry_WFI)
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L6.20|
;;;196      {
;;;197        /* Request Wait For Interrupt */
;;;198        __WFI();
000010  bf30              WFI      
000012  e002              B        |L6.26|
                  |L6.20|
;;;199      }
;;;200      else
;;;201      {
;;;202        /* Request Wait For Event */
;;;203        __SEV();
000014  bf40              SEV      
;;;204        __WFE(); 
000016  bf20              WFE      
;;;205        __WFE();
000018  bf20              WFE      
                  |L6.26|
;;;206      }
;;;207    }
00001a  4770              BX       lr
;;;208    
                          ENDP

                  |L6.28|
                          DCD      0xe000ed00

                          AREA ||i.PWR_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  PWR_GetFlagStatus PROC
;;;315      */
;;;316    FlagStatus PWR_GetFlagStatus(uint32_t PWR_FLAG)
000000  4601              MOV      r1,r0
;;;317    {
;;;318      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;319      /* Check the parameters */
;;;320      assert_param(IS_PWR_GET_FLAG(PWR_FLAG));
;;;321    
;;;322      if ((PWR->CSR & PWR_FLAG) != (uint32_t)RESET)
000004  4a04              LDR      r2,|L7.24|
000006  6852              LDR      r2,[r2,#4]
000008  400a              ANDS     r2,r2,r1
00000a  2a00              CMP      r2,#0
00000c  d001              BEQ      |L7.18|
;;;323      {
;;;324        bitstatus = SET;
00000e  2001              MOVS     r0,#1
000010  e000              B        |L7.20|
                  |L7.18|
;;;325      }
;;;326      else
;;;327      {
;;;328        bitstatus = RESET;
000012  2000              MOVS     r0,#0
                  |L7.20|
;;;329      }
;;;330      /* Return the flag status */
;;;331      return bitstatus;
;;;332    }
000014  4770              BX       lr
;;;333    
                          ENDP

000016  0000              DCW      0x0000
                  |L7.24|
                          DCD      0x40007000

                          AREA ||i.PWR_PVDCmd||, CODE, READONLY, ALIGN=2

                  PWR_PVDCmd PROC
;;;118      */
;;;119    void PWR_PVDCmd(FunctionalState NewState)
000000  2800              CMP      r0,#0
;;;120    {
;;;121      /* Check the parameters */
;;;122      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;123      
;;;124      if (NewState != DISABLE)
000002  d006              BEQ      |L8.18|
;;;125      {
;;;126        /* Enable the PVD */
;;;127        PWR->CR |= PWR_CR_PVDE;
000004  4906              LDR      r1,|L8.32|
000006  6809              LDR      r1,[r1,#0]
000008  2210              MOVS     r2,#0x10
00000a  4311              ORRS     r1,r1,r2
00000c  4a04              LDR      r2,|L8.32|
00000e  6011              STR      r1,[r2,#0]
000010  e005              B        |L8.30|
                  |L8.18|
;;;128      }
;;;129      else
;;;130      {
;;;131        /* Disable the PVD */
;;;132        PWR->CR &= (uint32_t)~((uint32_t)PWR_CR_PVDE);
000012  4903              LDR      r1,|L8.32|
000014  6809              LDR      r1,[r1,#0]
000016  2210              MOVS     r2,#0x10
000018  4391              BICS     r1,r1,r2
00001a  4a01              LDR      r2,|L8.32|
00001c  6011              STR      r1,[r2,#0]
                  |L8.30|
;;;133      } 
;;;134    }
00001e  4770              BX       lr
;;;135    
                          ENDP

                  |L8.32|
                          DCD      0x40007000

                          AREA ||i.PWR_PVDLevelConfig||, CODE, READONLY, ALIGN=2

                  PWR_PVDLevelConfig PROC
;;;93       */
;;;94     void PWR_PVDLevelConfig(uint32_t PWR_PVDLevel)
000000  4601              MOV      r1,r0
;;;95     {
;;;96       uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;97       
;;;98       /* Check the parameters */
;;;99       assert_param(IS_PWR_PVD_LEVEL(PWR_PVDLevel));
;;;100      
;;;101      tmpreg = PWR->CR;
000004  4a06              LDR      r2,|L9.32|
000006  6810              LDR      r0,[r2,#0]
;;;102      
;;;103      /* Clear PLS[7:5] bits  PLS3*/
;;;104      tmpreg &= CR_PLS_MASK;
000008  2317              MOVS     r3,#0x17
00000a  015b              LSLS     r3,r3,#5
00000c  4602              MOV      r2,r0
00000e  439a              BICS     r2,r2,r3
000010  4610              MOV      r0,r2
;;;105      
;;;106      /* Set PLS[7:5] and PLS3 bits according to PWR_PVDLevel value */
;;;107      tmpreg |= PWR_PVDLevel;
000012  4602              MOV      r2,r0
000014  430a              ORRS     r2,r2,r1
000016  4610              MOV      r0,r2
;;;108      
;;;109      /* Store the new value */
;;;110      PWR->CR = tmpreg;
000018  4a01              LDR      r2,|L9.32|
00001a  6010              STR      r0,[r2,#0]
;;;111    }
00001c  4770              BX       lr
;;;112    
                          ENDP

00001e  0000              DCW      0x0000
                  |L9.32|
                          DCD      0x40007000

                          AREA ||i.PWR_WakeUpPinCmd||, CODE, READONLY, ALIGN=2

                  PWR_WakeUpPinCmd PROC
;;;154      */
;;;155    void PWR_WakeUpPinCmd(uint32_t PWR_WakeUpPin, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;156    {
;;;157      /* Check the parameters */
;;;158      assert_param(IS_PWR_WAKEUP_PIN(PWR_WakeUpPin));
;;;159      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;160    
;;;161      if (NewState != DISABLE)
000002  d005              BEQ      |L10.16|
;;;162      {
;;;163        /* Enable the EWUPx pin */
;;;164        PWR->CSR |= PWR_WakeUpPin;
000004  4a05              LDR      r2,|L10.28|
000006  6852              LDR      r2,[r2,#4]
000008  4302              ORRS     r2,r2,r0
00000a  4b04              LDR      r3,|L10.28|
00000c  605a              STR      r2,[r3,#4]
00000e  e004              B        |L10.26|
                  |L10.16|
;;;165      }
;;;166      else
;;;167      {
;;;168        /* Disable the EWUPx pin */
;;;169        PWR->CSR &= ~PWR_WakeUpPin;
000010  4a02              LDR      r2,|L10.28|
000012  6852              LDR      r2,[r2,#4]
000014  4382              BICS     r2,r2,r0
000016  4b01              LDR      r3,|L10.28|
000018  605a              STR      r2,[r3,#4]
                  |L10.26|
;;;170      }
;;;171    }
00001a  4770              BX       lr
;;;172    
                          ENDP

                  |L10.28|
                          DCD      0x40007000

;*** Start embedded assembler ***

#line 1 "..\\FTLib\\Src\\ft32f0xx_pwr.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_ft32f0xx_pwr_c_0c2a8b75____REV16|
#line 129 "..\\FTLib\\CMSIS\\inc\\core_cmInstr.h"
|__asm___14_ft32f0xx_pwr_c_0c2a8b75____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_ft32f0xx_pwr_c_0c2a8b75____REVSH|
#line 144
|__asm___14_ft32f0xx_pwr_c_0c2a8b75____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
