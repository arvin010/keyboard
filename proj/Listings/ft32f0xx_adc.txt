; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\ft32f0xx_adc.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\ft32f0xx_adc.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\FTLib\CMSIS\inc -I..\FTLib\Inc -I..\FTLib\Lib -I..\usb\inc -I..\user -I..\RTT -I..\iap2 -IC:\Users\dell1\AppData\Local\Arm\Packs\FMD\FT32F0xx_DFP\1.0.6\Drivers\CMSIS\FT32F0xx\Include -D__UVISION_VERSION=534 -DFT32F072x8 -DFT32F072x8 --omf_browse=.\objects\ft32f0xx_adc.crf ..\FTLib\Src\ft32f0xx_adc.c]
                          THUMB

                          AREA ||i.ADC_AnalogWatchdogCmd||, CODE, READONLY, ALIGN=1

                  ADC_AnalogWatchdogCmd PROC
;;;290      */
;;;291    void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;292    {
;;;293      /* Check the parameters */
;;;294      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;295      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;296      
;;;297      if (NewState != DISABLE)
000002  d005              BEQ      |L1.16|
;;;298      {
;;;299        /* Enable the ADC Analog Watchdog */
;;;300        ADCx->CFGR1 |= ADC_CFGR1_AWDEN;
000004  68c2              LDR      r2,[r0,#0xc]
000006  2301              MOVS     r3,#1
000008  05db              LSLS     r3,r3,#23
00000a  431a              ORRS     r2,r2,r3
00000c  60c2              STR      r2,[r0,#0xc]
00000e  e004              B        |L1.26|
                  |L1.16|
;;;301      }
;;;302      else
;;;303      {
;;;304        /* Disable the ADC Analog Watchdog */
;;;305        ADCx->CFGR1 &= (uint32_t)~ADC_CFGR1_AWDEN;
000010  68c2              LDR      r2,[r0,#0xc]
000012  2301              MOVS     r3,#1
000014  05db              LSLS     r3,r3,#23
000016  439a              BICS     r2,r2,r3
000018  60c2              STR      r2,[r0,#0xc]
                  |L1.26|
;;;306      }
;;;307    }
00001a  4770              BX       lr
;;;308    
                          ENDP


                          AREA ||i.ADC_AnalogWatchdogSingleChannelCmd||, CODE, READONLY, ALIGN=1

                  ADC_AnalogWatchdogSingleChannelCmd PROC
;;;386      */
;;;387    void ADC_AnalogWatchdogSingleChannelCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;388    {
;;;389      /* Check the parameters */
;;;390      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;391      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;392    
;;;393      if (NewState != DISABLE)
000002  d005              BEQ      |L2.16|
;;;394      {
;;;395        /* Enable the ADC Analog Watchdog Single Channel */
;;;396        ADCx->CFGR1 |= ADC_CFGR1_AWDSGL;
000004  68c2              LDR      r2,[r0,#0xc]
000006  2301              MOVS     r3,#1
000008  059b              LSLS     r3,r3,#22
00000a  431a              ORRS     r2,r2,r3
00000c  60c2              STR      r2,[r0,#0xc]
00000e  e004              B        |L2.26|
                  |L2.16|
;;;397      }
;;;398      else
;;;399      {
;;;400        /* Disable the ADC Analog Watchdog Single Channel */
;;;401        ADCx->CFGR1 &= (uint32_t)~ADC_CFGR1_AWDSGL;
000010  68c2              LDR      r2,[r0,#0xc]
000012  2301              MOVS     r3,#1
000014  059b              LSLS     r3,r3,#22
000016  439a              BICS     r2,r2,r3
000018  60c2              STR      r2,[r0,#0xc]
                  |L2.26|
;;;402      }
;;;403    }
00001a  4770              BX       lr
;;;404    
                          ENDP


                          AREA ||i.ADC_AnalogWatchdogSingleChannelConfig||, CODE, READONLY, ALIGN=1

                  ADC_AnalogWatchdogSingleChannelConfig PROC
;;;358      */
;;;359    void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog_Channel)
000000  b510              PUSH     {r4,lr}
;;;360    {
000002  460a              MOV      r2,r1
;;;361      uint32_t tmpreg = 0;
000004  2100              MOVS     r1,#0
;;;362    
;;;363      /* Check the parameters */
;;;364      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;365      assert_param(IS_ADC_ANALOG_WATCHDOG_CHANNEL(ADC_AnalogWatchdog_Channel));
;;;366    
;;;367      /* Get the old register value */
;;;368      tmpreg = ADCx->CFGR1;
000006  68c1              LDR      r1,[r0,#0xc]
;;;369    
;;;370      /* Clear the Analog watchdog channel select bits */
;;;371      tmpreg &= ~ADC_CFGR1_AWDCH;
000008  241f              MOVS     r4,#0x1f
00000a  06a4              LSLS     r4,r4,#26
00000c  460b              MOV      r3,r1
00000e  43a3              BICS     r3,r3,r4
000010  4619              MOV      r1,r3
;;;372    
;;;373      /* Set the Analog watchdog channel */
;;;374      tmpreg |= ADC_AnalogWatchdog_Channel;
000012  460b              MOV      r3,r1
000014  4313              ORRS     r3,r3,r2
000016  4619              MOV      r1,r3
;;;375    
;;;376      /* Store the new register value */
;;;377      ADCx->CFGR1 = tmpreg;
000018  60c1              STR      r1,[r0,#0xc]
;;;378    }
00001a  bd10              POP      {r4,pc}
;;;379    
                          ENDP


                          AREA ||i.ADC_AnalogWatchdogThresholdsConfig||, CODE, READONLY, ALIGN=1

                  ADC_AnalogWatchdogThresholdsConfig PROC
;;;317      */
;;;318    void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold,
000000  040b              LSLS     r3,r1,#16
;;;319                                            uint16_t LowThreshold)
;;;320    {
;;;321      /* Check the parameters */
;;;322      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;323      assert_param(IS_ADC_THRESHOLD(HighThreshold));
;;;324      assert_param(IS_ADC_THRESHOLD(LowThreshold));
;;;325    
;;;326      /* Set the ADCx high and low threshold */
;;;327      ADCx->TR = LowThreshold | ((uint32_t)HighThreshold << 16);
000002  4313              ORRS     r3,r3,r2
000004  6203              STR      r3,[r0,#0x20]
;;;328    
;;;329    }
000006  4770              BX       lr
;;;330    
                          ENDP


                          AREA ||i.ADC_AutoPowerOffCmd||, CODE, READONLY, ALIGN=1

                  ADC_AutoPowerOffCmd PROC
;;;228      */
;;;229    void ADC_AutoPowerOffCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;230    {
;;;231      /* Check the parameters */
;;;232      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;233      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;234      
;;;235      if (NewState != DISABLE)
000002  d005              BEQ      |L5.16|
;;;236      {
;;;237        /* Enable the ADC Automatic Power-Off */
;;;238        ADCx->CFGR1 |= ADC_CFGR1_AUTOFF;
000004  68c2              LDR      r2,[r0,#0xc]
000006  2301              MOVS     r3,#1
000008  03db              LSLS     r3,r3,#15
00000a  431a              ORRS     r2,r2,r3
00000c  60c2              STR      r2,[r0,#0xc]
00000e  e004              B        |L5.26|
                  |L5.16|
;;;239      }
;;;240      else
;;;241      {
;;;242        /* Disable the ADC Automatic Power-Off */
;;;243        ADCx->CFGR1 &= (uint32_t)~ADC_CFGR1_AUTOFF;
000010  68c2              LDR      r2,[r0,#0xc]
000012  2301              MOVS     r3,#1
000014  03db              LSLS     r3,r3,#15
000016  439a              BICS     r2,r2,r3
000018  60c2              STR      r2,[r0,#0xc]
                  |L5.26|
;;;244      }
;;;245    }
00001a  4770              BX       lr
;;;246    
                          ENDP


                          AREA ||i.ADC_ChannelConfig||, CODE, READONLY, ALIGN=1

                  ADC_ChannelConfig PROC
;;;516      */
;;;517    void ADC_ChannelConfig(ADC_TypeDef* ADCx, uint32_t ADC_Channel, uint32_t ADC_SampleTime)
000000  b510              PUSH     {r4,lr}
;;;518    {
000002  460b              MOV      r3,r1
;;;519      uint32_t tmpreg = 0;
000004  2100              MOVS     r1,#0
;;;520    
;;;521      /* Check the parameters */
;;;522      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;523      assert_param(IS_ADC_CHANNEL(ADC_Channel));
;;;524      assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
;;;525    
;;;526      /* Configure the ADC Channel */
;;;527      ADCx->CHSELR |= (uint32_t)ADC_Channel;
000006  6a84              LDR      r4,[r0,#0x28]
000008  431c              ORRS     r4,r4,r3
00000a  6284              STR      r4,[r0,#0x28]
;;;528    
;;;529      /* Clear the Sampling time Selection bits */
;;;530      tmpreg &= ~ADC_SMPR1_SMPR;
00000c  bf00              NOP      
;;;531    
;;;532      /* Set the ADC Sampling Time register */
;;;533      tmpreg |= (uint32_t)ADC_SampleTime;
00000e  460c              MOV      r4,r1
000010  4314              ORRS     r4,r4,r2
000012  4621              MOV      r1,r4
;;;534    
;;;535      /* Configure the ADC Sample time register */
;;;536      ADCx->SMPR = tmpreg ;
000014  6141              STR      r1,[r0,#0x14]
;;;537    }
000016  bd10              POP      {r4,pc}
;;;538    
                          ENDP


                          AREA ||i.ADC_ClearFlag||, CODE, READONLY, ALIGN=1

                  ADC_ClearFlag PROC
;;;847      */
;;;848    void ADC_ClearFlag(ADC_TypeDef* ADCx, uint32_t ADC_FLAG)
000000  6001              STR      r1,[r0,#0]
;;;849    {
;;;850      /* Check the parameters */
;;;851      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;852      assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
;;;853    
;;;854      /* Clear the selected ADC flags */
;;;855      ADCx->ISR = (uint32_t)ADC_FLAG;
;;;856    }
000002  4770              BX       lr
;;;857    
                          ENDP


                          AREA ||i.ADC_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  ADC_ClearITPendingBit PROC
;;;910      */
;;;911    void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint32_t ADC_IT)
000000  6001              STR      r1,[r0,#0]
;;;912    {
;;;913      /* Check the parameters */
;;;914      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;915      assert_param(IS_ADC_CLEAR_IT(ADC_IT));
;;;916    
;;;917      /* Clear the selected ADC interrupt pending bits */
;;;918      ADCx->ISR = (uint32_t)ADC_IT; 
;;;919    }
000002  4770              BX       lr
;;;920    
                          ENDP


                          AREA ||i.ADC_ClockModeConfig||, CODE, READONLY, ALIGN=1

                  ADC_ClockModeConfig PROC
;;;167      */
;;;168    void ADC_ClockModeConfig(ADC_TypeDef* ADCx, uint32_t ADC_ClockMode)
000000  6101              STR      r1,[r0,#0x10]
;;;169    {
;;;170      /* Check the parameters */
;;;171      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;172      assert_param(IS_ADC_CLOCKMODE(ADC_ClockMode));
;;;173    
;;;174        /* Configure the ADC Clock mode according to ADC_ClockMode */
;;;175        ADCx->CFGR2 = (uint32_t)ADC_ClockMode;
;;;176    
;;;177    }
000002  4770              BX       lr
;;;178    
                          ENDP


                          AREA ||i.ADC_Cmd||, CODE, READONLY, ALIGN=1

                  ADC_Cmd PROC
;;;137      */
;;;138    void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;139    {
;;;140      /* Check the parameters */
;;;141      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;142      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;143    
;;;144      if (NewState != DISABLE)
000002  d004              BEQ      |L10.14|
;;;145      {
;;;146        /* Set the ADEN bit to Enable the ADC peripheral */
;;;147        ADCx->CR |= (uint32_t)ADC_CR_ADEN;
000004  6882              LDR      r2,[r0,#8]
000006  2301              MOVS     r3,#1
000008  431a              ORRS     r2,r2,r3
00000a  6082              STR      r2,[r0,#8]
00000c  e003              B        |L10.22|
                  |L10.14|
;;;148      }
;;;149      else
;;;150      {
;;;151        /* Set the ADDIS to Disable the ADC peripheral */
;;;152        ADCx->CR |= (uint32_t)ADC_CR_ADDIS;
00000e  6882              LDR      r2,[r0,#8]
000010  2302              MOVS     r3,#2
000012  431a              ORRS     r2,r2,r3
000014  6082              STR      r2,[r0,#8]
                  |L10.22|
;;;153      }
;;;154    }
000016  4770              BX       lr
;;;155    
                          ENDP


                          AREA ||i.ADC_ContinuousModeCmd||, CODE, READONLY, ALIGN=1

                  ADC_ContinuousModeCmd PROC
;;;548      */
;;;549    void ADC_ContinuousModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;550    {
;;;551      /* Check the parameters */
;;;552      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;553      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;554    
;;;555      if (NewState != DISABLE)
000002  d005              BEQ      |L11.16|
;;;556      {
;;;557        /* Enable the Continuous mode*/
;;;558        ADCx->CFGR1 |= (uint32_t)ADC_CFGR1_CONT;
000004  68c2              LDR      r2,[r0,#0xc]
000006  2301              MOVS     r3,#1
000008  035b              LSLS     r3,r3,#13
00000a  431a              ORRS     r2,r2,r3
00000c  60c2              STR      r2,[r0,#0xc]
00000e  e004              B        |L11.26|
                  |L11.16|
;;;559      }
;;;560      else
;;;561      {
;;;562        /* Disable the Continuous mode */
;;;563        ADCx->CFGR1 &= (uint32_t)(~ADC_CFGR1_CONT);
000010  68c2              LDR      r2,[r0,#0xc]
000012  2301              MOVS     r3,#1
000014  035b              LSLS     r3,r3,#13
000016  439a              BICS     r2,r2,r3
000018  60c2              STR      r2,[r0,#0xc]
                  |L11.26|
;;;564      }
;;;565    }
00001a  4770              BX       lr
;;;566    
                          ENDP


                          AREA ||i.ADC_DMACmd||, CODE, READONLY, ALIGN=1

                  ADC_DMACmd PROC
;;;710      */
;;;711    void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;712    {
;;;713      /* Check the parameters */
;;;714      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;715      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;716    
;;;717      if (NewState != DISABLE)
000002  d004              BEQ      |L12.14|
;;;718      {
;;;719        /* Enable the selected ADC DMA request */
;;;720        ADCx->CFGR1 |= (uint32_t)ADC_CFGR1_DMAEN;
000004  68c2              LDR      r2,[r0,#0xc]
000006  2301              MOVS     r3,#1
000008  431a              ORRS     r2,r2,r3
00000a  60c2              STR      r2,[r0,#0xc]
00000c  e003              B        |L12.22|
                  |L12.14|
;;;721      }
;;;722      else
;;;723      {
;;;724        /* Disable the selected ADC DMA request */
;;;725        ADCx->CFGR1 &= (uint32_t)(~ADC_CFGR1_DMAEN);
00000e  68c2              LDR      r2,[r0,#0xc]
000010  0852              LSRS     r2,r2,#1
000012  0052              LSLS     r2,r2,#1
000014  60c2              STR      r2,[r0,#0xc]
                  |L12.22|
;;;726      }
;;;727    }
000016  4770              BX       lr
;;;728    
                          ENDP


                          AREA ||i.ADC_DMARequestModeConfig||, CODE, READONLY, ALIGN=1

                  ADC_DMARequestModeConfig PROC
;;;737      */
;;;738    void ADC_DMARequestModeConfig(ADC_TypeDef* ADCx, uint32_t ADC_DMARequestMode)
000000  68c2              LDR      r2,[r0,#0xc]
;;;739    {
;;;740      /* Check the parameters */
;;;741      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;742    
;;;743      ADCx->CFGR1 &= (uint32_t)~ADC_CFGR1_DMACFG;
000002  2302              MOVS     r3,#2
000004  439a              BICS     r2,r2,r3
000006  60c2              STR      r2,[r0,#0xc]
;;;744      ADCx->CFGR1 |= (uint32_t)ADC_DMARequestMode;
000008  68c2              LDR      r2,[r0,#0xc]
00000a  430a              ORRS     r2,r2,r1
00000c  60c2              STR      r2,[r0,#0xc]
;;;745    }
00000e  4770              BX       lr
;;;746    
                          ENDP


                          AREA ||i.ADC_DeInit||, CODE, READONLY, ALIGN=2

                  ADC_DeInit PROC
;;;37       */
;;;38     void ADC_DeInit(ADC_TypeDef* ADCx)
000000  b510              PUSH     {r4,lr}
;;;39     {
000002  4604              MOV      r4,r0
;;;40       /* Check the parameters */
;;;41       assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;42     
;;;43       if(ADCx == ADC1)
000004  4805              LDR      r0,|L14.28|
000006  4284              CMP      r4,r0
000008  d107              BNE      |L14.26|
;;;44       {
;;;45         /* Enable ADC1 reset state */
;;;46         RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  1540              ASRS     r0,r0,#21
00000e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;47     
;;;48         /* Release ADC1 from reset state */
;;;49         RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, DISABLE);
000012  2100              MOVS     r1,#0
000014  1560              ASRS     r0,r4,#21
000016  f7fffffe          BL       RCC_APB2PeriphResetCmd
                  |L14.26|
;;;50       }
;;;51     }
00001a  bd10              POP      {r4,pc}
;;;52     
                          ENDP

                  |L14.28|
                          DCD      0x40012400

                          AREA ||i.ADC_DiscModeCmd||, CODE, READONLY, ALIGN=1

                  ADC_DiscModeCmd PROC
;;;576      */
;;;577    void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;578    {
;;;579      /* Check the parameters */
;;;580      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;581      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;582    
;;;583        if (NewState != DISABLE)
000002  d005              BEQ      |L15.16|
;;;584      {
;;;585        /* Enable the Discontinuous mode */
;;;586        ADCx->CFGR1 |= (uint32_t)ADC_CFGR1_DISCEN;
000004  68c2              LDR      r2,[r0,#0xc]
000006  2301              MOVS     r3,#1
000008  041b              LSLS     r3,r3,#16
00000a  431a              ORRS     r2,r2,r3
00000c  60c2              STR      r2,[r0,#0xc]
00000e  e004              B        |L15.26|
                  |L15.16|
;;;587      }
;;;588      else
;;;589      {
;;;590        /* Disable the Discontinuous mode */
;;;591        ADCx->CFGR1 &= (uint32_t)(~ADC_CFGR1_DISCEN);
000010  68c2              LDR      r2,[r0,#0xc]
000012  2301              MOVS     r3,#1
000014  041b              LSLS     r3,r3,#16
000016  439a              BICS     r2,r2,r3
000018  60c2              STR      r2,[r0,#0xc]
                  |L15.26|
;;;592      }
;;;593    }
00001a  4770              BX       lr
;;;594    
                          ENDP


                          AREA ||i.ADC_GetCalibrationFactor||, CODE, READONLY, ALIGN=1

                  ADC_GetCalibrationFactor PROC
;;;626      */
;;;627    uint32_t ADC_GetCalibrationFactor(ADC_TypeDef* ADCx)
000000  b530              PUSH     {r4,r5,lr}
;;;628    {
000002  4601              MOV      r1,r0
;;;629      uint32_t tmpreg = 0, calibrationcounter = 0, calibrationstatus = 0;
000004  2000              MOVS     r0,#0
000006  2200              MOVS     r2,#0
000008  2300              MOVS     r3,#0
;;;630    
;;;631      /* Check the parameters */
;;;632      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;633      
;;;634      /* Set the ADC calibartion */
;;;635      ADCx->CR |= (uint32_t)ADC_CR_ADCAL;
00000a  688c              LDR      r4,[r1,#8]
00000c  2501              MOVS     r5,#1
00000e  07ed              LSLS     r5,r5,#31
000010  432c              ORRS     r4,r4,r5
000012  608c              STR      r4,[r1,#8]
;;;636      
;;;637      /* Wait until no ADC calibration is completed */
;;;638      do
000014  bf00              NOP      
                  |L16.22|
;;;639      {
;;;640        calibrationstatus = ADCx->CR & ADC_CR_ADCAL;
000016  688c              LDR      r4,[r1,#8]
000018  0fe3              LSRS     r3,r4,#31
00001a  07db              LSLS     r3,r3,#31
;;;641        calibrationcounter++;  
00001c  1c52              ADDS     r2,r2,#1
;;;642      } while((calibrationcounter != CALIBRATION_TIMEOUT) && (calibrationstatus != 0x00));
00001e  240f              MOVS     r4,#0xf
000020  0324              LSLS     r4,r4,#12
000022  42a2              CMP      r2,r4
000024  d001              BEQ      |L16.42|
000026  2b00              CMP      r3,#0
000028  d1f5              BNE      |L16.22|
                  |L16.42|
;;;643        
;;;644      if((uint32_t)(ADCx->CR & ADC_CR_ADCAL) == RESET)
00002a  688c              LDR      r4,[r1,#8]
00002c  0fe4              LSRS     r4,r4,#31
00002e  07e4              LSLS     r4,r4,#31
000030  2c00              CMP      r4,#0
000032  d101              BNE      |L16.56|
;;;645      {
;;;646        /*Get the calibration factor from the ADC data register */
;;;647        tmpreg = ADCx->DR;
000034  6c08              LDR      r0,[r1,#0x40]
000036  e000              B        |L16.58|
                  |L16.56|
;;;648      }
;;;649      else
;;;650      {
;;;651        /* Error factor */
;;;652        tmpreg = 0x00000000;
000038  2000              MOVS     r0,#0
                  |L16.58|
;;;653      }
;;;654      return tmpreg;
;;;655    }
00003a  bd30              POP      {r4,r5,pc}
;;;656    
                          ENDP


                          AREA ||i.ADC_GetConversionValue||, CODE, READONLY, ALIGN=1

                  ADC_GetConversionValue PROC
;;;691      */
;;;692    uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx)
000000  4601              MOV      r1,r0
;;;693    {
;;;694      /* Check the parameters */
;;;695      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;696    
;;;697      /* Return the selected ADC conversion value */
;;;698      return (uint16_t) ADCx->DR;
000002  6c08              LDR      r0,[r1,#0x40]
000004  b280              UXTH     r0,r0
;;;699    }
000006  4770              BX       lr
;;;700    
                          ENDP


                          AREA ||i.ADC_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetFlagStatus PROC
;;;801      */
;;;802    FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint32_t ADC_FLAG)
000000  b530              PUSH     {r4,r5,lr}
;;;803    {
000002  4602              MOV      r2,r0
;;;804      FlagStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;805      uint32_t tmpreg = 0;
000006  2300              MOVS     r3,#0
;;;806    
;;;807      /* Check the parameters */
;;;808      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;809      assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
;;;810    
;;;811      if((uint32_t)(ADC_FLAG & 0x01000000))
000008  2401              MOVS     r4,#1
00000a  0624              LSLS     r4,r4,#24
00000c  400c              ANDS     r4,r4,r1
00000e  2c00              CMP      r4,#0
000010  d005              BEQ      |L18.30|
;;;812      {
;;;813        tmpreg = ADCx->CR & 0xFEFFFFFF;
000012  6894              LDR      r4,[r2,#8]
000014  2501              MOVS     r5,#1
000016  062d              LSLS     r5,r5,#24
000018  43ac              BICS     r4,r4,r5
00001a  4623              MOV      r3,r4
00001c  e000              B        |L18.32|
                  |L18.30|
;;;814      }
;;;815      else
;;;816      {
;;;817        tmpreg = ADCx->ISR;
00001e  6813              LDR      r3,[r2,#0]
                  |L18.32|
;;;818      }
;;;819      
;;;820      /* Check the status of the specified ADC flag */
;;;821      if ((tmpreg & ADC_FLAG) != (uint32_t)RESET)
000020  461c              MOV      r4,r3
000022  400c              ANDS     r4,r4,r1
000024  2c00              CMP      r4,#0
000026  d001              BEQ      |L18.44|
;;;822      {
;;;823        /* ADC_FLAG is set */
;;;824        bitstatus = SET;
000028  2001              MOVS     r0,#1
00002a  e000              B        |L18.46|
                  |L18.44|
;;;825      }
;;;826      else
;;;827      {
;;;828        /* ADC_FLAG is reset */
;;;829        bitstatus = RESET;
00002c  2000              MOVS     r0,#0
                  |L18.46|
;;;830      }
;;;831      /* Return the ADC_FLAG status */
;;;832      return  bitstatus;
;;;833    }
00002e  bd30              POP      {r4,r5,pc}
;;;834    
                          ENDP


                          AREA ||i.ADC_GetITStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetITStatus PROC
;;;870      */
;;;871    ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint32_t ADC_IT)
000000  b510              PUSH     {r4,lr}
;;;872    {
000002  4602              MOV      r2,r0
;;;873      ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;874      uint32_t enablestatus = 0;
000006  2300              MOVS     r3,#0
;;;875    
;;;876      /* Check the parameters */
;;;877      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;878      assert_param(IS_ADC_GET_IT(ADC_IT));
;;;879    
;;;880      /* Get the ADC_IT enable bit status */
;;;881      enablestatus = (uint32_t)(ADCx->IER & ADC_IT); 
000008  6854              LDR      r4,[r2,#4]
00000a  400c              ANDS     r4,r4,r1
00000c  4623              MOV      r3,r4
;;;882    
;;;883      /* Check the status of the specified ADC interrupt */
;;;884      if (((uint32_t)(ADCx->ISR & ADC_IT) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
00000e  6814              LDR      r4,[r2,#0]
000010  400c              ANDS     r4,r4,r1
000012  2c00              CMP      r4,#0
000014  d003              BEQ      |L19.30|
000016  2b00              CMP      r3,#0
000018  d001              BEQ      |L19.30|
;;;885      {
;;;886        /* ADC_IT is set */
;;;887        bitstatus = SET;
00001a  2001              MOVS     r0,#1
00001c  e000              B        |L19.32|
                  |L19.30|
;;;888      }
;;;889      else
;;;890      {
;;;891        /* ADC_IT is reset */
;;;892        bitstatus = RESET;
00001e  2000              MOVS     r0,#0
                  |L19.32|
;;;893      }
;;;894      /* Return the ADC_IT status */
;;;895      return  bitstatus;
;;;896    }
000020  bd10              POP      {r4,pc}
;;;897    
                          ENDP


                          AREA ||i.ADC_ITConfig||, CODE, READONLY, ALIGN=1

                  ADC_ITConfig PROC
;;;764      */
;;;765    void ADC_ITConfig(ADC_TypeDef* ADCx, uint32_t ADC_IT, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;766    {
;;;767      /* Check the parameters */
;;;768      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;769      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;770      assert_param(IS_ADC_CONFIG_IT(ADC_IT)); 
;;;771    
;;;772      if (NewState != DISABLE)
000002  d003              BEQ      |L20.12|
;;;773      {
;;;774        /* Enable the selected ADC interrupts */
;;;775        ADCx->IER |= ADC_IT;
000004  6843              LDR      r3,[r0,#4]
000006  430b              ORRS     r3,r3,r1
000008  6043              STR      r3,[r0,#4]
00000a  e002              B        |L20.18|
                  |L20.12|
;;;776      }
;;;777      else
;;;778      {
;;;779        /* Disable the selected ADC interrupts */
;;;780        ADCx->IER &= (~(uint32_t)ADC_IT);
00000c  6843              LDR      r3,[r0,#4]
00000e  438b              BICS     r3,r3,r1
000010  6043              STR      r3,[r0,#4]
                  |L20.18|
;;;781      }
;;;782    }
000012  4770              BX       lr
;;;783    
                          ENDP


                          AREA ||i.ADC_Init||, CODE, READONLY, ALIGN=2

                  ADC_Init PROC
;;;63       */
;;;64     void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
000000  b510              PUSH     {r4,lr}
;;;65     {
;;;66       uint32_t tmpreg = 0;
000002  2200              MOVS     r2,#0
;;;67     
;;;68       /* Check the parameters */
;;;69       assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;70       assert_param(IS_ADC_RESOLUTION(ADC_InitStruct->ADC_Resolution));
;;;71       assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ContinuousConvMode));
;;;72       assert_param(IS_ADC_EXT_TRIG_EDGE(ADC_InitStruct->ADC_ExternalTrigConvEdge));
;;;73       assert_param(IS_ADC_EXTERNAL_TRIG_CONV(ADC_InitStruct->ADC_ExternalTrigConv));
;;;74       assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign));
;;;75       assert_param(IS_ADC_SCAN_DIRECTION(ADC_InitStruct->ADC_ScanDirection)); 
;;;76     
;;;77       /* Get the ADCx CFGR value */
;;;78       tmpreg = ADCx->CFGR1;
000004  68c2              LDR      r2,[r0,#0xc]
;;;79     
;;;80       /* Clear SCANDIR, RES[1:0], ALIGN, EXTSEL[2:0], EXTEN[1:0] and CONT bits */
;;;81       tmpreg &= CFGR1_CLEAR_MASK;
000006  4b08              LDR      r3,|L21.40|
000008  401a              ANDS     r2,r2,r3
;;;82     
;;;83       /*---------------------------- ADCx CFGR Configuration ---------------------*/
;;;84     
;;;85       /* Set RES[1:0] bits according to ADC_Resolution value */
;;;86       /* Set CONT bit according to ADC_ContinuousConvMode value */
;;;87       /* Set EXTEN[1:0] bits according to ADC_ExternalTrigConvEdge value */
;;;88       /* Set EXTSEL[2:0] bits according to ADC_ExternalTrigConv value */
;;;89       /* Set ALIGN bit according to ADC_DataAlign value */
;;;90       /* Set SCANDIR bit according to ADC_ScanDirection value */
;;;91      
;;;92       tmpreg  |= (uint32_t)(ADC_InitStruct->ADC_Resolution | ((uint32_t)(ADC_InitStruct->ADC_ContinuousConvMode) << 13) |
00000a  790c              LDRB     r4,[r1,#4]
00000c  0364              LSLS     r4,r4,#13
00000e  680b              LDR      r3,[r1,#0]
000010  4323              ORRS     r3,r3,r4
000012  688c              LDR      r4,[r1,#8]
000014  4323              ORRS     r3,r3,r4
000016  68cc              LDR      r4,[r1,#0xc]
000018  4323              ORRS     r3,r3,r4
00001a  690c              LDR      r4,[r1,#0x10]
00001c  4323              ORRS     r3,r3,r4
00001e  694c              LDR      r4,[r1,#0x14]
000020  4323              ORRS     r3,r3,r4
000022  431a              ORRS     r2,r2,r3
;;;93                  ADC_InitStruct->ADC_ExternalTrigConvEdge | ADC_InitStruct->ADC_ExternalTrigConv |
;;;94                  ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ScanDirection);
;;;95     
;;;96       /* Write to ADCx CFGR */
;;;97       ADCx->CFGR1 = tmpreg;
000024  60c2              STR      r2,[r0,#0xc]
;;;98     }
000026  bd10              POP      {r4,pc}
;;;99     
                          ENDP

                  |L21.40|
                          DCD      0xffffd203

                          AREA ||i.ADC_JitterCmd||, CODE, READONLY, ALIGN=1

                  ADC_JitterCmd PROC
;;;191      */
;;;192    void ADC_JitterCmd(ADC_TypeDef* ADCx, uint32_t ADC_JitterOff, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;193    {
;;;194      /* Check the parameters */
;;;195      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;196      assert_param(IS_ADC_JITTEROFF(ADC_JitterOff));
;;;197      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;198    
;;;199      if (NewState != DISABLE)
000002  d003              BEQ      |L22.12|
;;;200      {
;;;201        /* Disable Jitter */
;;;202        ADCx->CFGR2 |= (uint32_t)ADC_JitterOff;
000004  6903              LDR      r3,[r0,#0x10]
000006  430b              ORRS     r3,r3,r1
000008  6103              STR      r3,[r0,#0x10]
00000a  e002              B        |L22.18|
                  |L22.12|
;;;203      }
;;;204      else
;;;205      {
;;;206        /* Enable Jitter */
;;;207        ADCx->CFGR2 &= (uint32_t)(~ADC_JitterOff);
00000c  6903              LDR      r3,[r0,#0x10]
00000e  438b              BICS     r3,r3,r1
000010  6103              STR      r3,[r0,#0x10]
                  |L22.18|
;;;208      }
;;;209    }
000012  4770              BX       lr
;;;210    
                          ENDP


                          AREA ||i.ADC_OverrunModeCmd||, CODE, READONLY, ALIGN=1

                  ADC_OverrunModeCmd PROC
;;;601      */
;;;602    void ADC_OverrunModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;603    {
;;;604      /* Check the parameters */
;;;605      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;606      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;607    
;;;608        if (NewState != DISABLE)
000002  d005              BEQ      |L23.16|
;;;609      {
;;;610        /* Enable the Overrun mode */
;;;611        ADCx->CFGR1 |= (uint32_t)ADC_CFGR1_OVRMOD;
000004  68c2              LDR      r2,[r0,#0xc]
000006  2301              MOVS     r3,#1
000008  031b              LSLS     r3,r3,#12
00000a  431a              ORRS     r2,r2,r3
00000c  60c2              STR      r2,[r0,#0xc]
00000e  e004              B        |L23.26|
                  |L23.16|
;;;612      }
;;;613      else
;;;614      {
;;;615        /* Disable the Overrun mode */
;;;616        ADCx->CFGR1 &= (uint32_t)(~ADC_CFGR1_OVRMOD);
000010  68c2              LDR      r2,[r0,#0xc]
000012  2301              MOVS     r3,#1
000014  031b              LSLS     r3,r3,#12
000016  439a              BICS     r2,r2,r3
000018  60c2              STR      r2,[r0,#0xc]
                  |L23.26|
;;;617      }
;;;618    }
00001a  4770              BX       lr
;;;619    
                          ENDP


                          AREA ||i.ADC_StartOfConversion||, CODE, READONLY, ALIGN=1

                  ADC_StartOfConversion PROC
;;;678      */
;;;679    void ADC_StartOfConversion(ADC_TypeDef* ADCx)
000000  6881              LDR      r1,[r0,#8]
;;;680    {
;;;681      /* Check the parameters */
;;;682      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;683      
;;;684      ADCx->CR |= (uint32_t)ADC_CR_ADSTART;
000002  2204              MOVS     r2,#4
000004  4311              ORRS     r1,r1,r2
000006  6081              STR      r1,[r0,#8]
;;;685    }
000008  4770              BX       lr
;;;686    
                          ENDP


                          AREA ||i.ADC_StopOfConversion||, CODE, READONLY, ALIGN=1

                  ADC_StopOfConversion PROC
;;;663      */
;;;664    void ADC_StopOfConversion(ADC_TypeDef* ADCx)
000000  6881              LDR      r1,[r0,#8]
;;;665    {
;;;666      /* Check the parameters */
;;;667      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;668      
;;;669      ADCx->CR |= (uint32_t)ADC_CR_ADSTP;
000002  2210              MOVS     r2,#0x10
000004  4311              ORRS     r1,r1,r2
000006  6081              STR      r1,[r0,#8]
;;;670    }
000008  4770              BX       lr
;;;671    
                          ENDP


                          AREA ||i.ADC_StructInit||, CODE, READONLY, ALIGN=1

                  ADC_StructInit PROC
;;;108      */
;;;109    void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
000000  2100              MOVS     r1,#0
;;;110    {
;;;111      /* Reset ADC init structure parameters values */
;;;112      /* Initialize the ADC_Resolution member */
;;;113      ADC_InitStruct->ADC_Resolution = ADC_Resolution_12b;
000002  6001              STR      r1,[r0,#0]
;;;114    
;;;115       /* Initialize the ADC_ContinuousConvMode member */
;;;116      ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
000004  7101              STRB     r1,[r0,#4]
;;;117    
;;;118      /* Initialize the ADC_ExternalTrigConvEdge member */
;;;119      ADC_InitStruct->ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
000006  6081              STR      r1,[r0,#8]
;;;120    
;;;121      /* Initialize the ADC_ExternalTrigConv member */
;;;122      ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_TRGO;
000008  60c1              STR      r1,[r0,#0xc]
;;;123    
;;;124      /* Initialize the ADC_DataAlign member */
;;;125      ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
00000a  6101              STR      r1,[r0,#0x10]
;;;126    
;;;127      /* Initialize the ADC_ScanDirection member */
;;;128      ADC_InitStruct->ADC_ScanDirection = ADC_ScanDirection_Upward;
00000c  6141              STR      r1,[r0,#0x14]
;;;129    }
00000e  4770              BX       lr
;;;130    
                          ENDP


                          AREA ||i.ADC_TempSensorCmd||, CODE, READONLY, ALIGN=2

                  ADC_TempSensorCmd PROC
;;;413      */
;;;414    void ADC_TempSensorCmd(FunctionalState NewState)
000000  2800              CMP      r0,#0
;;;415    {
;;;416      /* Check the parameters */
;;;417      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;418    
;;;419      if (NewState != DISABLE)
000002  d007              BEQ      |L27.20|
;;;420      {
;;;421        /* Enable the temperature sensor channel*/
;;;422        ADC->CCR |= (uint32_t)ADC_CCR_TSEN;
000004  4907              LDR      r1,|L27.36|
000006  6889              LDR      r1,[r1,#8]
000008  2201              MOVS     r2,#1
00000a  05d2              LSLS     r2,r2,#23
00000c  4311              ORRS     r1,r1,r2
00000e  4a05              LDR      r2,|L27.36|
000010  6091              STR      r1,[r2,#8]
000012  e006              B        |L27.34|
                  |L27.20|
;;;423      }
;;;424      else
;;;425      {
;;;426        /* Disable the temperature sensor channel*/
;;;427        ADC->CCR &= (uint32_t)(~ADC_CCR_TSEN);
000014  4903              LDR      r1,|L27.36|
000016  6889              LDR      r1,[r1,#8]
000018  2201              MOVS     r2,#1
00001a  05d2              LSLS     r2,r2,#23
00001c  4391              BICS     r1,r1,r2
00001e  4a01              LDR      r2,|L27.36|
000020  6091              STR      r1,[r2,#8]
                  |L27.34|
;;;428      }
;;;429    }
000022  4770              BX       lr
;;;430    
                          ENDP

                  |L27.36|
                          DCD      0x40012700

                          AREA ||i.ADC_VbatCmd||, CODE, READONLY, ALIGN=2

                  ADC_VbatCmd PROC
;;;460      */
;;;461    void ADC_VbatCmd(FunctionalState NewState)
000000  2800              CMP      r0,#0
;;;462    {
;;;463      /* Check the parameters */
;;;464      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;465    
;;;466      if (NewState != DISABLE)
000002  d007              BEQ      |L28.20|
;;;467      {
;;;468        /* Enable the Vbat channel*/
;;;469        ADC->CCR |= (uint32_t)ADC_CCR_VBATEN;
000004  4907              LDR      r1,|L28.36|
000006  6889              LDR      r1,[r1,#8]
000008  2201              MOVS     r2,#1
00000a  0612              LSLS     r2,r2,#24
00000c  4311              ORRS     r1,r1,r2
00000e  4a05              LDR      r2,|L28.36|
000010  6091              STR      r1,[r2,#8]
000012  e006              B        |L28.34|
                  |L28.20|
;;;470      }
;;;471      else
;;;472      {
;;;473        /* Disable the Vbat channel*/
;;;474        ADC->CCR &= (uint32_t)(~ADC_CCR_VBATEN);
000014  4903              LDR      r1,|L28.36|
000016  6889              LDR      r1,[r1,#8]
000018  2201              MOVS     r2,#1
00001a  0612              LSLS     r2,r2,#24
00001c  4391              BICS     r1,r1,r2
00001e  4a01              LDR      r2,|L28.36|
000020  6091              STR      r1,[r2,#8]
                  |L28.34|
;;;475      }
;;;476    }
000022  4770              BX       lr
;;;477    
                          ENDP

                  |L28.36|
                          DCD      0x40012700

                          AREA ||i.ADC_VrefintCmd||, CODE, READONLY, ALIGN=2

                  ADC_VrefintCmd PROC
;;;436      */
;;;437    void ADC_VrefintCmd(FunctionalState NewState)
000000  2800              CMP      r0,#0
;;;438    {
;;;439      /* Check the parameters */
;;;440      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;441    
;;;442      if (NewState != DISABLE)
000002  d007              BEQ      |L29.20|
;;;443      {
;;;444        /* Enable the Vrefint channel*/
;;;445        ADC->CCR |= (uint32_t)ADC_CCR_VREFEN;
000004  4907              LDR      r1,|L29.36|
000006  6889              LDR      r1,[r1,#8]
000008  2201              MOVS     r2,#1
00000a  0592              LSLS     r2,r2,#22
00000c  4311              ORRS     r1,r1,r2
00000e  4a05              LDR      r2,|L29.36|
000010  6091              STR      r1,[r2,#8]
000012  e006              B        |L29.34|
                  |L29.20|
;;;446      }
;;;447      else
;;;448      {
;;;449        /* Disable the Vrefint channel*/
;;;450        ADC->CCR &= (uint32_t)(~ADC_CCR_VREFEN);
000014  4903              LDR      r1,|L29.36|
000016  6889              LDR      r1,[r1,#8]
000018  2201              MOVS     r2,#1
00001a  0592              LSLS     r2,r2,#22
00001c  4391              BICS     r1,r1,r2
00001e  4a01              LDR      r2,|L29.36|
000020  6091              STR      r1,[r2,#8]
                  |L29.34|
;;;451      }
;;;452    }
000022  4770              BX       lr
;;;453    
                          ENDP

                  |L29.36|
                          DCD      0x40012700

                          AREA ||i.ADC_VrefselConfig||, CODE, READONLY, ALIGN=2

                  ADC_VrefselConfig PROC
;;;931      */
;;;932    void ADC_VrefselConfig(uint32_t ADC_Vrefsel)
000000  4601              MOV      r1,r0
;;;933    {	
;;;934    	uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;935      /* Check the parameters */
;;;936      assert_param(IS_ADC_Vrefsel(ADC_Vrefsel));
;;;937      
;;;938      /* Clear the Vref Selection bits */
;;;939      tmpreg &= ~((uint32_t)0x0000000E) ;
000004  230e              MOVS     r3,#0xe
000006  4602              MOV      r2,r0
000008  439a              BICS     r2,r2,r3
00000a  4610              MOV      r0,r2
;;;940    
;;;941      /* Set the ADC Vref register */
;;;942      tmpreg |= (uint32_t)ADC_Vrefsel;
00000c  4602              MOV      r2,r0
00000e  430a              ORRS     r2,r2,r1
000010  4610              MOV      r0,r2
;;;943    
;;;944      /* Configure the ADC Vref register */
;;;945      ADC->CR2 = tmpreg ;
000012  4a01              LDR      r2,|L30.24|
000014  60d0              STR      r0,[r2,#0xc]
;;;946    }
000016  4770              BX       lr
;;;947    
                          ENDP

                  |L30.24|
                          DCD      0x40012700

                          AREA ||i.ADC_WaitModeCmd||, CODE, READONLY, ALIGN=1

                  ADC_WaitModeCmd PROC
;;;262      */
;;;263    void ADC_WaitModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;264    {
;;;265      /* Check the parameters */
;;;266      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;267      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;268      
;;;269      if (NewState != DISABLE)
000002  d005              BEQ      |L31.16|
;;;270      {
;;;271        /* Enable the ADC Automatic Delayed conversion */
;;;272        ADCx->CFGR1 |= ADC_CFGR1_WAIT;
000004  68c2              LDR      r2,[r0,#0xc]
000006  2301              MOVS     r3,#1
000008  039b              LSLS     r3,r3,#14
00000a  431a              ORRS     r2,r2,r3
00000c  60c2              STR      r2,[r0,#0xc]
00000e  e004              B        |L31.26|
                  |L31.16|
;;;273      }
;;;274      else
;;;275      {
;;;276        /* Disable the ADC Automatic Delayed conversion */
;;;277        ADCx->CFGR1 &= (uint32_t)~ADC_CFGR1_WAIT;
000010  68c2              LDR      r2,[r0,#0xc]
000012  2301              MOVS     r3,#1
000014  039b              LSLS     r3,r3,#14
000016  439a              BICS     r2,r2,r3
000018  60c2              STR      r2,[r0,#0xc]
                  |L31.26|
;;;278      }
;;;279    }
00001a  4770              BX       lr
;;;280    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\FTLib\\Src\\ft32f0xx_adc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_ft32f0xx_adc_c_e11a2ea2____REV16|
#line 129 "..\\FTLib\\CMSIS\\inc\\core_cmInstr.h"
|__asm___14_ft32f0xx_adc_c_e11a2ea2____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_ft32f0xx_adc_c_e11a2ea2____REVSH|
#line 144
|__asm___14_ft32f0xx_adc_c_e11a2ea2____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
