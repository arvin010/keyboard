; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\ft32f0xx_rtc.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\ft32f0xx_rtc.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\FTLib\CMSIS\inc -I..\FTLib\Inc -I..\FTLib\Lib -I..\usb\inc -I..\user -I..\RTT -I.\RTE\_Keyboard -IC:\Users\Reidgjiao\AppData\Local\Arm\Packs\FMD\FT32F0xx_DFP\1.0.6\Drivers\CMSIS\FT32F0xx\Include -IC:\Keil_v5-MDK\ARM\CMSIS\Include -D__UVISION_VERSION=529 -DFT32F072x8 -DFT32F072x8 --omf_browse=.\objects\ft32f0xx_rtc.crf ..\FTLib\Src\ft32f0xx_rtc.c]
                          THUMB

                          AREA ||i.RTC_AlarmCmd||, CODE, READONLY, ALIGN=2

                  RTC_AlarmCmd PROC
;;;938      */
;;;939    ErrorStatus RTC_AlarmCmd(uint32_t RTC_Alarm, FunctionalState NewState)
000000  b538              PUSH     {r3-r5,lr}
;;;940    {
000002  4602              MOV      r2,r0
;;;941      __IO uint32_t alarmcounter = 0x00;
000004  2400              MOVS     r4,#0
000006  9400              STR      r4,[sp,#0]
;;;942      uint32_t alarmstatus = 0x00;
000008  2300              MOVS     r3,#0
;;;943      ErrorStatus status = ERROR;
00000a  2000              MOVS     r0,#0
;;;944        
;;;945      /* Check the parameters */
;;;946      assert_param(IS_RTC_CMD_ALARM(RTC_Alarm));
;;;947      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;948    
;;;949      /* Disable the write protection for RTC registers */
;;;950      RTC->WPR = 0xCA;
00000c  24ca              MOVS     r4,#0xca
00000e  4d17              LDR      r5,|L1.108|
000010  626c              STR      r4,[r5,#0x24]
;;;951      RTC->WPR = 0x53;
000012  2453              MOVS     r4,#0x53
000014  626c              STR      r4,[r5,#0x24]
;;;952    
;;;953      /* Configure the Alarm state */
;;;954      if (NewState != DISABLE)
000016  2900              CMP      r1,#0
000018  d005              BEQ      |L1.38|
;;;955      {
;;;956        RTC->CR |= (uint32_t)RTC_Alarm;
00001a  462c              MOV      r4,r5
00001c  68a4              LDR      r4,[r4,#8]
00001e  4314              ORRS     r4,r4,r2
000020  60ac              STR      r4,[r5,#8]
;;;957    
;;;958        status = SUCCESS;    
000022  2001              MOVS     r0,#1
000024  e01d              B        |L1.98|
                  |L1.38|
;;;959      }
;;;960      else
;;;961      { 
;;;962        /* Disable the Alarm in RTC_CR register */
;;;963        RTC->CR &= (uint32_t)~RTC_Alarm;
000026  4c11              LDR      r4,|L1.108|
000028  68a4              LDR      r4,[r4,#8]
00002a  4394              BICS     r4,r4,r2
00002c  4d0f              LDR      r5,|L1.108|
00002e  60ac              STR      r4,[r5,#8]
;;;964       
;;;965        /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */
;;;966        do
000030  bf00              NOP      
                  |L1.50|
;;;967        {
;;;968          alarmstatus = RTC->ISR & (RTC_Alarm >> 8);
000032  4c0e              LDR      r4,|L1.108|
000034  68e4              LDR      r4,[r4,#0xc]
000036  0a15              LSRS     r5,r2,#8
000038  402c              ANDS     r4,r4,r5
00003a  4623              MOV      r3,r4
;;;969          alarmcounter++;  
00003c  9c00              LDR      r4,[sp,#0]
00003e  1c64              ADDS     r4,r4,#1
000040  9400              STR      r4,[sp,#0]
;;;970        } while((alarmcounter != INITMODE_TIMEOUT) && (alarmstatus == 0x00));
000042  2501              MOVS     r5,#1
000044  03ad              LSLS     r5,r5,#14
000046  9c00              LDR      r4,[sp,#0]
000048  42ac              CMP      r4,r5
00004a  d001              BEQ      |L1.80|
00004c  2b00              CMP      r3,#0
00004e  d0f0              BEQ      |L1.50|
                  |L1.80|
;;;971        
;;;972        if ((RTC->ISR & (RTC_Alarm >> 8)) == RESET)
000050  4c06              LDR      r4,|L1.108|
000052  68e4              LDR      r4,[r4,#0xc]
000054  0a15              LSRS     r5,r2,#8
000056  402c              ANDS     r4,r4,r5
000058  2c00              CMP      r4,#0
00005a  d101              BNE      |L1.96|
;;;973        {
;;;974          status = ERROR;
00005c  2000              MOVS     r0,#0
00005e  e000              B        |L1.98|
                  |L1.96|
;;;975        } 
;;;976        else
;;;977        {
;;;978          status = SUCCESS;
000060  2001              MOVS     r0,#1
                  |L1.98|
;;;979        }        
;;;980      } 
;;;981    
;;;982      /* Enable the write protection for RTC registers */
;;;983      RTC->WPR = 0xFF;
000062  24ff              MOVS     r4,#0xff
000064  4d01              LDR      r5,|L1.108|
000066  626c              STR      r4,[r5,#0x24]
;;;984      
;;;985      return status;
;;;986    }
000068  bd38              POP      {r3-r5,pc}
;;;987    
                          ENDP

00006a  0000              DCW      0x0000
                  |L1.108|
                          DCD      0x40002800

                          AREA ||i.RTC_AlarmStructInit||, CODE, READONLY, ALIGN=1

                  RTC_AlarmStructInit PROC
;;;863      */
;;;864    void RTC_AlarmStructInit(RTC_AlarmTypeDef* RTC_AlarmStruct)
000000  2100              MOVS     r1,#0
;;;865    {
;;;866      /* Alarm Time Settings : Time = 00h:00mn:00sec */
;;;867      RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = RTC_H12_AM;
000002  70c1              STRB     r1,[r0,#3]
;;;868      RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = 0;
000004  7001              STRB     r1,[r0,#0]
;;;869      RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = 0;
000006  7041              STRB     r1,[r0,#1]
;;;870      RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = 0;
000008  7081              STRB     r1,[r0,#2]
;;;871    
;;;872      /* Alarm Date Settings : Date = 1st day of the month */
;;;873      RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = RTC_AlarmDateWeekDaySel_Date;
00000a  6081              STR      r1,[r0,#8]
;;;874      RTC_AlarmStruct->RTC_AlarmDateWeekDay = 1;
00000c  2101              MOVS     r1,#1
00000e  7301              STRB     r1,[r0,#0xc]
;;;875    
;;;876      /* Alarm Masks Settings : Mask =  all fields are not masked */
;;;877      RTC_AlarmStruct->RTC_AlarmMask = RTC_AlarmMask_None;
000010  2100              MOVS     r1,#0
000012  6041              STR      r1,[r0,#4]
;;;878    }
000014  4770              BX       lr
;;;879    
                          ENDP


                          AREA ||i.RTC_AlarmSubSecondConfig||, CODE, READONLY, ALIGN=2

                  RTC_AlarmSubSecondConfig PROC
;;;1030     */
;;;1031   void RTC_AlarmSubSecondConfig(uint32_t RTC_Alarm, uint32_t RTC_AlarmSubSecondValue, uint8_t RTC_AlarmSubSecondMask)
000000  b530              PUSH     {r4,r5,lr}
;;;1032   {
000002  4603              MOV      r3,r0
;;;1033     uint32_t tmpreg = 0;
000004  2000              MOVS     r0,#0
;;;1034   
;;;1035     /* Check the parameters */
;;;1036     assert_param(IS_RTC_ALARM(RTC_Alarm));
;;;1037     assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(RTC_AlarmSubSecondValue));
;;;1038     assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(RTC_AlarmSubSecondMask));
;;;1039     
;;;1040     /* Disable the write protection for RTC registers */
;;;1041     RTC->WPR = 0xCA;
000006  24ca              MOVS     r4,#0xca
000008  4d06              LDR      r5,|L3.36|
00000a  626c              STR      r4,[r5,#0x24]
;;;1042     RTC->WPR = 0x53;
00000c  2453              MOVS     r4,#0x53
00000e  626c              STR      r4,[r5,#0x24]
;;;1043     
;;;1044     /* Configure the Alarm A or Alarm B SubSecond registers */
;;;1045     tmpreg = (uint32_t) (((uint32_t)(RTC_AlarmSubSecondValue)) | ((uint32_t)(RTC_AlarmSubSecondMask) << 24));
000010  0614              LSLS     r4,r2,#24
000012  430c              ORRS     r4,r4,r1
000014  4620              MOV      r0,r4
;;;1046     
;;;1047     /* Configure the AlarmA SubSecond register */
;;;1048     RTC->ALRMASSR = tmpreg;
000016  4c03              LDR      r4,|L3.36|
000018  3440              ADDS     r4,r4,#0x40
00001a  6060              STR      r0,[r4,#4]
;;;1049   
;;;1050     /* Enable the write protection for RTC registers */
;;;1051     RTC->WPR = 0xFF;
00001c  24ff              MOVS     r4,#0xff
00001e  626c              STR      r4,[r5,#0x24]
;;;1052   
;;;1053   }
000020  bd30              POP      {r4,r5,pc}
;;;1054   
                          ENDP

000022  0000              DCW      0x0000
                  |L3.36|
                          DCD      0x40002800

                          AREA ||i.RTC_Bcd2ToByte||, CODE, READONLY, ALIGN=1

                  RTC_Bcd2ToByte PROC
;;;1882     */
;;;1883   static uint8_t RTC_Bcd2ToByte(uint8_t Value)
000000  4601              MOV      r1,r0
;;;1884   {
;;;1885     uint8_t tmp = 0;
000002  bf00              NOP      
;;;1886     tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
000004  20f0              MOVS     r0,#0xf0
000006  4008              ANDS     r0,r0,r1
000008  1100              ASRS     r0,r0,#4
00000a  230a              MOVS     r3,#0xa
00000c  4358              MULS     r0,r3,r0
00000e  4602              MOV      r2,r0
;;;1887     return (tmp + (Value & (uint8_t)0x0F));
000010  0708              LSLS     r0,r1,#28
000012  0f00              LSRS     r0,r0,#28
000014  1880              ADDS     r0,r0,r2
000016  b2c0              UXTB     r0,r0
;;;1888   }
000018  4770              BX       lr
;;;1889   
                          ENDP


                          AREA ||i.RTC_BypassShadowCmd||, CODE, READONLY, ALIGN=2

                  RTC_BypassShadowCmd PROC
;;;383    */
;;;384    void RTC_BypassShadowCmd(FunctionalState NewState)
000000  21ca              MOVS     r1,#0xca
;;;385    {
;;;386      /* Check the parameters */
;;;387      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;388    
;;;389      /* Disable the write protection for RTC registers */
;;;390      RTC->WPR = 0xCA;
000002  4a0b              LDR      r2,|L5.48|
000004  6251              STR      r1,[r2,#0x24]
;;;391      RTC->WPR = 0x53;
000006  2153              MOVS     r1,#0x53
000008  6251              STR      r1,[r2,#0x24]
;;;392      
;;;393      if (NewState != DISABLE)
00000a  2800              CMP      r0,#0
00000c  d006              BEQ      |L5.28|
;;;394      {
;;;395        /* Set the BYPSHAD bit */
;;;396        RTC->CR |= (uint8_t)RTC_CR_BYPSHAD;
00000e  4611              MOV      r1,r2
000010  6889              LDR      r1,[r1,#8]
000012  2220              MOVS     r2,#0x20
000014  4311              ORRS     r1,r1,r2
000016  4a06              LDR      r2,|L5.48|
000018  6091              STR      r1,[r2,#8]
00001a  e005              B        |L5.40|
                  |L5.28|
;;;397      }
;;;398      else
;;;399      {
;;;400        /* Reset the BYPSHAD bit */
;;;401        RTC->CR &= (uint8_t)~RTC_CR_BYPSHAD;
00001c  4904              LDR      r1,|L5.48|
00001e  6889              LDR      r1,[r1,#8]
000020  22df              MOVS     r2,#0xdf
000022  4011              ANDS     r1,r1,r2
000024  4a02              LDR      r2,|L5.48|
000026  6091              STR      r1,[r2,#8]
                  |L5.40|
;;;402      }
;;;403    
;;;404      /* Enable the write protection for RTC registers */
;;;405      RTC->WPR = 0xFF;
000028  21ff              MOVS     r1,#0xff
00002a  4a01              LDR      r2,|L5.48|
00002c  6251              STR      r1,[r2,#0x24]
;;;406    }
00002e  4770              BX       lr
;;;407    
                          ENDP

                  |L5.48|
                          DCD      0x40002800

                          AREA ||i.RTC_ByteToBcd2||, CODE, READONLY, ALIGN=1

                  RTC_ByteToBcd2 PROC
;;;1864     */
;;;1865   static uint8_t RTC_ByteToBcd2(uint8_t Value)
000000  4601              MOV      r1,r0
;;;1866   {
;;;1867     uint8_t bcdhigh = 0;
000002  2200              MOVS     r2,#0
;;;1868     
;;;1869     while (Value >= 10)
000004  e004              B        |L6.16|
                  |L6.6|
;;;1870     {
;;;1871       bcdhigh++;
000006  1c50              ADDS     r0,r2,#1
000008  b2c2              UXTB     r2,r0
;;;1872       Value -= 10;
00000a  4608              MOV      r0,r1
00000c  380a              SUBS     r0,r0,#0xa
00000e  b2c1              UXTB     r1,r0
                  |L6.16|
000010  290a              CMP      r1,#0xa               ;1869
000012  daf8              BGE      |L6.6|
;;;1873     }
;;;1874     
;;;1875     return  ((uint8_t)(bcdhigh << 4) | Value);
000014  0710              LSLS     r0,r2,#28
000016  0e00              LSRS     r0,r0,#24
000018  4308              ORRS     r0,r0,r1
;;;1876   }
00001a  4770              BX       lr
;;;1877   
                          ENDP


                          AREA ||i.RTC_CalibOutputCmd||, CODE, READONLY, ALIGN=2

                  RTC_CalibOutputCmd PROC
;;;1170     */
;;;1171   void RTC_CalibOutputCmd(FunctionalState NewState)
000000  21ca              MOVS     r1,#0xca
;;;1172   {
;;;1173     /* Check the parameters */
;;;1174     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1175     
;;;1176     /* Disable the write protection for RTC registers */
;;;1177     RTC->WPR = 0xCA;
000002  4a0c              LDR      r2,|L7.52|
000004  6251              STR      r1,[r2,#0x24]
;;;1178     RTC->WPR = 0x53;
000006  2153              MOVS     r1,#0x53
000008  6251              STR      r1,[r2,#0x24]
;;;1179     
;;;1180     if (NewState != DISABLE)
00000a  2800              CMP      r0,#0
00000c  d007              BEQ      |L7.30|
;;;1181     {
;;;1182       /* Enable the RTC clock output */
;;;1183       RTC->CR |= (uint32_t)RTC_CR_COE;
00000e  4611              MOV      r1,r2
000010  6889              LDR      r1,[r1,#8]
000012  2201              MOVS     r2,#1
000014  05d2              LSLS     r2,r2,#23
000016  4311              ORRS     r1,r1,r2
000018  4a06              LDR      r2,|L7.52|
00001a  6091              STR      r1,[r2,#8]
00001c  e006              B        |L7.44|
                  |L7.30|
;;;1184     }
;;;1185     else
;;;1186     { 
;;;1187       /* Disable the RTC clock output */
;;;1188       RTC->CR &= (uint32_t)~RTC_CR_COE;
00001e  4905              LDR      r1,|L7.52|
000020  6889              LDR      r1,[r1,#8]
000022  2201              MOVS     r2,#1
000024  05d2              LSLS     r2,r2,#23
000026  4391              BICS     r1,r1,r2
000028  4a02              LDR      r2,|L7.52|
00002a  6091              STR      r1,[r2,#8]
                  |L7.44|
;;;1189     }
;;;1190     
;;;1191     /* Enable the write protection for RTC registers */
;;;1192     RTC->WPR = 0xFF; 
00002c  21ff              MOVS     r1,#0xff
00002e  4a01              LDR      r2,|L7.52|
000030  6251              STR      r1,[r2,#0x24]
;;;1193   }
000032  4770              BX       lr
;;;1194   
                          ENDP

                  |L7.52|
                          DCD      0x40002800

                          AREA ||i.RTC_CalibOutputConfig||, CODE, READONLY, ALIGN=2

                  RTC_CalibOutputConfig PROC
;;;1202   */
;;;1203   void RTC_CalibOutputConfig(uint32_t RTC_CalibOutput)
000000  21ca              MOVS     r1,#0xca
;;;1204   {
;;;1205     /* Check the parameters */
;;;1206     assert_param(IS_RTC_CALIB_OUTPUT(RTC_CalibOutput));
;;;1207   
;;;1208     /* Disable the write protection for RTC registers */
;;;1209     RTC->WPR = 0xCA;
000002  4a09              LDR      r2,|L8.40|
000004  6251              STR      r1,[r2,#0x24]
;;;1210     RTC->WPR = 0x53;
000006  2153              MOVS     r1,#0x53
000008  6251              STR      r1,[r2,#0x24]
;;;1211     
;;;1212     /*clear flags before config*/
;;;1213     RTC->CR &= (uint32_t)~(RTC_CR_CALSEL);
00000a  4611              MOV      r1,r2
00000c  6889              LDR      r1,[r1,#8]
00000e  2201              MOVS     r2,#1
000010  04d2              LSLS     r2,r2,#19
000012  4391              BICS     r1,r1,r2
000014  4a04              LDR      r2,|L8.40|
000016  6091              STR      r1,[r2,#8]
;;;1214   
;;;1215     /* Configure the RTC_CR register */
;;;1216     RTC->CR |= (uint32_t)RTC_CalibOutput;
000018  4611              MOV      r1,r2
00001a  6889              LDR      r1,[r1,#8]
00001c  4301              ORRS     r1,r1,r0
00001e  6091              STR      r1,[r2,#8]
;;;1217   
;;;1218     /* Enable the write protection for RTC registers */
;;;1219     RTC->WPR = 0xFF;
000020  21ff              MOVS     r1,#0xff
000022  6251              STR      r1,[r2,#0x24]
;;;1220   }
000024  4770              BX       lr
;;;1221   
                          ENDP

000026  0000              DCW      0x0000
                  |L8.40|
                          DCD      0x40002800

                          AREA ||i.RTC_ClearFlag||, CODE, READONLY, ALIGN=2

                  RTC_ClearFlag PROC
;;;1781     */
;;;1782   void RTC_ClearFlag(uint32_t RTC_FLAG)
000000  2180              MOVS     r1,#0x80
;;;1783   {
;;;1784     /* Check the parameters */
;;;1785     assert_param(IS_RTC_CLEAR_FLAG(RTC_FLAG));
;;;1786   
;;;1787     /* Clear the Flags in the RTC_ISR register */
;;;1788     RTC->ISR = (uint32_t)((uint32_t)(~((RTC_FLAG | RTC_ISR_INIT)& 0x0001FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT)));    
000002  4301              ORRS     r1,r1,r0
000004  03c9              LSLS     r1,r1,#15
000006  0bc9              LSRS     r1,r1,#15
000008  43c9              MVNS     r1,r1
00000a  4a04              LDR      r2,|L9.28|
00000c  68d2              LDR      r2,[r2,#0xc]
00000e  2380              MOVS     r3,#0x80
000010  401a              ANDS     r2,r2,r3
000012  4311              ORRS     r1,r1,r2
000014  4a01              LDR      r2,|L9.28|
000016  60d1              STR      r1,[r2,#0xc]
;;;1789   }
000018  4770              BX       lr
;;;1790   
                          ENDP

00001a  0000              DCW      0x0000
                  |L9.28|
                          DCD      0x40002800

                          AREA ||i.RTC_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  RTC_ClearITPendingBit PROC
;;;1841     */
;;;1842   void RTC_ClearITPendingBit(uint32_t RTC_IT)
000000  b510              PUSH     {r4,lr}
;;;1843   {
;;;1844     uint32_t tmpreg = 0;
000002  2100              MOVS     r1,#0
;;;1845   
;;;1846     /* Check the parameters */
;;;1847     assert_param(IS_RTC_CLEAR_IT(RTC_IT));
;;;1848   
;;;1849     /* Get the RTC_ISR Interrupt pending bits mask */
;;;1850     tmpreg = (uint32_t)(RTC_IT >> 4);
000004  0901              LSRS     r1,r0,#4
;;;1851   
;;;1852     /* Clear the interrupt pending bits in the RTC_ISR register */
;;;1853     RTC->ISR = (uint32_t)((uint32_t)(~((tmpreg | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT))); 
000006  2280              MOVS     r2,#0x80
000008  430a              ORRS     r2,r2,r1
00000a  b292              UXTH     r2,r2
00000c  43d2              MVNS     r2,r2
00000e  4b04              LDR      r3,|L10.32|
000010  68db              LDR      r3,[r3,#0xc]
000012  2480              MOVS     r4,#0x80
000014  4023              ANDS     r3,r3,r4
000016  431a              ORRS     r2,r2,r3
000018  4b01              LDR      r3,|L10.32|
00001a  60da              STR      r2,[r3,#0xc]
;;;1854   }
00001c  bd10              POP      {r4,pc}
;;;1855   
                          ENDP

00001e  0000              DCW      0x0000
                  |L10.32|
                          DCD      0x40002800

                          AREA ||i.RTC_DateStructInit||, CODE, READONLY, ALIGN=1

                  RTC_DateStructInit PROC
;;;695      */
;;;696    void RTC_DateStructInit(RTC_DateTypeDef* RTC_DateStruct)
000000  2101              MOVS     r1,#1
;;;697    {
;;;698      /* Monday, January 01 xx00 */
;;;699      RTC_DateStruct->RTC_WeekDay = RTC_Weekday_Monday;
000002  7001              STRB     r1,[r0,#0]
;;;700      RTC_DateStruct->RTC_Date = 1;
000004  7081              STRB     r1,[r0,#2]
;;;701      RTC_DateStruct->RTC_Month = RTC_Month_January;
000006  7041              STRB     r1,[r0,#1]
;;;702      RTC_DateStruct->RTC_Year = 0;
000008  2100              MOVS     r1,#0
00000a  70c1              STRB     r1,[r0,#3]
;;;703    }
00000c  4770              BX       lr
;;;704    
                          ENDP


                          AREA ||i.RTC_DayLightSavingConfig||, CODE, READONLY, ALIGN=2

                  RTC_DayLightSavingConfig PROC
;;;1089     */
;;;1090   void RTC_DayLightSavingConfig(uint32_t RTC_DayLightSaving, uint32_t RTC_StoreOperation)
000000  22ca              MOVS     r2,#0xca
;;;1091   {
;;;1092     /* Check the parameters */
;;;1093     assert_param(IS_RTC_DAYLIGHT_SAVING(RTC_DayLightSaving));
;;;1094     assert_param(IS_RTC_STORE_OPERATION(RTC_StoreOperation));
;;;1095   
;;;1096     /* Disable the write protection for RTC registers */
;;;1097     RTC->WPR = 0xCA;
000002  4b0a              LDR      r3,|L12.44|
000004  625a              STR      r2,[r3,#0x24]
;;;1098     RTC->WPR = 0x53;
000006  2253              MOVS     r2,#0x53
000008  625a              STR      r2,[r3,#0x24]
;;;1099   
;;;1100     /* Clear the bits to be configured */
;;;1101     RTC->CR &= (uint32_t)~(RTC_CR_BCK);
00000a  461a              MOV      r2,r3
00000c  6892              LDR      r2,[r2,#8]
00000e  2301              MOVS     r3,#1
000010  049b              LSLS     r3,r3,#18
000012  439a              BICS     r2,r2,r3
000014  4b05              LDR      r3,|L12.44|
000016  609a              STR      r2,[r3,#8]
;;;1102   
;;;1103     /* Configure the RTC_CR register */
;;;1104     RTC->CR |= (uint32_t)(RTC_DayLightSaving | RTC_StoreOperation);
000018  461a              MOV      r2,r3
00001a  6892              LDR      r2,[r2,#8]
00001c  4603              MOV      r3,r0
00001e  430b              ORRS     r3,r3,r1
000020  431a              ORRS     r2,r2,r3
000022  4b02              LDR      r3,|L12.44|
000024  609a              STR      r2,[r3,#8]
;;;1105   
;;;1106     /* Enable the write protection for RTC registers */
;;;1107     RTC->WPR = 0xFF;
000026  22ff              MOVS     r2,#0xff
000028  625a              STR      r2,[r3,#0x24]
;;;1108   }
00002a  4770              BX       lr
;;;1109   
                          ENDP

                  |L12.44|
                          DCD      0x40002800

                          AREA ||i.RTC_DeInit||, CODE, READONLY, ALIGN=2

                  RTC_DeInit PROC
;;;56       */
;;;57     ErrorStatus RTC_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;58     {
;;;59       ErrorStatus status = ERROR;
000002  2400              MOVS     r4,#0
;;;60       
;;;61       /* Disable the write protection for RTC registers */
;;;62       RTC->WPR = 0xCA;
000004  20ca              MOVS     r0,#0xca
000006  4916              LDR      r1,|L13.96|
000008  6248              STR      r0,[r1,#0x24]
;;;63       RTC->WPR = 0x53;
00000a  2053              MOVS     r0,#0x53
00000c  6248              STR      r0,[r1,#0x24]
;;;64     
;;;65       /* Set Initialization mode */
;;;66       if (RTC_EnterInitMode() == ERROR)
00000e  f7fffffe          BL       RTC_EnterInitMode
000012  2800              CMP      r0,#0
000014  d100              BNE      |L13.24|
;;;67       {
;;;68         status = ERROR;
000016  e01d              B        |L13.84|
                  |L13.24|
;;;69       }  
;;;70       else
;;;71       {
;;;72         /* Reset TR, DR and CR registers */
;;;73         RTC->TR        = (uint32_t)0x00000000;
000018  2000              MOVS     r0,#0
00001a  4911              LDR      r1,|L13.96|
00001c  6008              STR      r0,[r1,#0]
;;;74         RTC->DR        = (uint32_t)0x00002101;
00001e  4811              LDR      r0,|L13.100|
000020  6048              STR      r0,[r1,#4]
;;;75         RTC->CR        &= (uint32_t)0x00000000;
000022  4608              MOV      r0,r1
000024  6880              LDR      r0,[r0,#8]
000026  2000              MOVS     r0,#0
000028  6088              STR      r0,[r1,#8]
;;;76         RTC->PRER      = (uint32_t)0x007F00FF;
00002a  480f              LDR      r0,|L13.104|
00002c  6108              STR      r0,[r1,#0x10]
;;;77         RTC->ALRMAR    = (uint32_t)0x00000000;
00002e  2000              MOVS     r0,#0
000030  61c8              STR      r0,[r1,#0x1c]
;;;78         RTC->SHIFTR    = (uint32_t)0x00000000;
000032  62c8              STR      r0,[r1,#0x2c]
;;;79         RTC->CALR       = (uint32_t)0x00000000;
000034  63c8              STR      r0,[r1,#0x3c]
;;;80         RTC->ALRMASSR  = (uint32_t)0x00000000;
000036  490a              LDR      r1,|L13.96|
000038  3140              ADDS     r1,r1,#0x40
00003a  6048              STR      r0,[r1,#4]
;;;81     
;;;82         /* Reset ISR register and exit initialization mode */
;;;83         RTC->ISR = (uint32_t)0x00000000;
00003c  4908              LDR      r1,|L13.96|
00003e  60c8              STR      r0,[r1,#0xc]
;;;84         
;;;85         /* Reset Tamper and alternate functions configuration register */
;;;86         RTC->TAFCR = 0x00000000;
000040  4907              LDR      r1,|L13.96|
000042  3140              ADDS     r1,r1,#0x40
000044  6008              STR      r0,[r1,#0]
;;;87           
;;;88         /* Wait till the RTC RSF flag is set */
;;;89         if (RTC_WaitForSynchro() == ERROR)
000046  f7fffffe          BL       RTC_WaitForSynchro
00004a  2800              CMP      r0,#0
00004c  d101              BNE      |L13.82|
;;;90         {
;;;91           status = ERROR;
00004e  2400              MOVS     r4,#0
000050  e000              B        |L13.84|
                  |L13.82|
;;;92         }
;;;93         else
;;;94         {
;;;95           status = SUCCESS;
000052  2401              MOVS     r4,#1
                  |L13.84|
;;;96         }
;;;97     
;;;98       }
;;;99     
;;;100      /* Enable the write protection for RTC registers */
;;;101      RTC->WPR = 0xFF;  
000054  20ff              MOVS     r0,#0xff
000056  4902              LDR      r1,|L13.96|
000058  6248              STR      r0,[r1,#0x24]
;;;102    
;;;103      return status;
00005a  4620              MOV      r0,r4
;;;104    }
00005c  bd10              POP      {r4,pc}
;;;105    
                          ENDP

00005e  0000              DCW      0x0000
                  |L13.96|
                          DCD      0x40002800
                  |L13.100|
                          DCD      0x00002101
                  |L13.104|
                          DCD      0x007f00ff

                          AREA ||i.RTC_EnterInitMode||, CODE, READONLY, ALIGN=2

                  RTC_EnterInitMode PROC
;;;211      */
;;;212    ErrorStatus RTC_EnterInitMode(void)
000000  b508              PUSH     {r3,lr}
;;;213    {
;;;214      __IO uint32_t initcounter = 0x00;
000002  2200              MOVS     r2,#0
000004  9200              STR      r2,[sp,#0]
;;;215      ErrorStatus status = ERROR;
000006  2000              MOVS     r0,#0
;;;216      uint32_t initstatus = 0x00;
000008  2100              MOVS     r1,#0
;;;217    
;;;218      /* Check if the Initialization mode is set */
;;;219      if ((RTC->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
00000a  4a12              LDR      r2,|L14.84|
00000c  68d2              LDR      r2,[r2,#0xc]
00000e  2340              MOVS     r3,#0x40
000010  401a              ANDS     r2,r2,r3
000012  2a00              CMP      r2,#0
000014  d11b              BNE      |L14.78|
;;;220      {
;;;221        /* Set the Initialization mode */
;;;222        RTC->ISR = (uint32_t)RTC_INIT_MASK;
000016  1e42              SUBS     r2,r0,#1
000018  4b0e              LDR      r3,|L14.84|
00001a  60da              STR      r2,[r3,#0xc]
;;;223        
;;;224        /* Wait till RTC is in INIT state and if Time out is reached exit */
;;;225        do
00001c  bf00              NOP      
                  |L14.30|
;;;226        {
;;;227          initstatus = RTC->ISR & RTC_ISR_INITF;
00001e  4a0d              LDR      r2,|L14.84|
000020  68d2              LDR      r2,[r2,#0xc]
000022  2340              MOVS     r3,#0x40
000024  401a              ANDS     r2,r2,r3
000026  4611              MOV      r1,r2
;;;228          initcounter++;  
000028  9a00              LDR      r2,[sp,#0]
00002a  1c52              ADDS     r2,r2,#1
00002c  9200              STR      r2,[sp,#0]
;;;229        } while((initcounter != INITMODE_TIMEOUT) && (initstatus == 0x00));
00002e  021b              LSLS     r3,r3,#8
000030  9a00              LDR      r2,[sp,#0]
000032  429a              CMP      r2,r3
000034  d001              BEQ      |L14.58|
000036  2900              CMP      r1,#0
000038  d0f1              BEQ      |L14.30|
                  |L14.58|
;;;230        
;;;231        if ((RTC->ISR & RTC_ISR_INITF) != RESET)
00003a  4a06              LDR      r2,|L14.84|
00003c  68d2              LDR      r2,[r2,#0xc]
00003e  2340              MOVS     r3,#0x40
000040  401a              ANDS     r2,r2,r3
000042  2a00              CMP      r2,#0
000044  d001              BEQ      |L14.74|
;;;232        {
;;;233          status = SUCCESS;
000046  2001              MOVS     r0,#1
000048  e002              B        |L14.80|
                  |L14.74|
;;;234        }
;;;235        else
;;;236        {
;;;237          status = ERROR;
00004a  2000              MOVS     r0,#0
00004c  e000              B        |L14.80|
                  |L14.78|
;;;238        }
;;;239      }
;;;240      else
;;;241      {
;;;242        status = SUCCESS;
00004e  2001              MOVS     r0,#1
                  |L14.80|
;;;243      }
;;;244    
;;;245      return (status);
;;;246    }
000050  bd08              POP      {r3,pc}
;;;247    
                          ENDP

000052  0000              DCW      0x0000
                  |L14.84|
                          DCD      0x40002800

                          AREA ||i.RTC_ExitInitMode||, CODE, READONLY, ALIGN=2

                  RTC_ExitInitMode PROC
;;;256      */
;;;257    void RTC_ExitInitMode(void)
000000  4806              LDR      r0,|L15.28|
;;;258    {
;;;259      /* Exit Initialization mode */
;;;260      RTC->ISR &= (uint32_t)~RTC_ISR_INIT;
000002  68c0              LDR      r0,[r0,#0xc]
000004  2180              MOVS     r1,#0x80
000006  4388              BICS     r0,r0,r1
000008  4904              LDR      r1,|L15.28|
00000a  60c8              STR      r0,[r1,#0xc]
;;;261    	
;;;262    	/*when BypassShadow is enable,this bit should wait to clear zero.edit:2020.5.23*/
;;;263    	while((RTC->ISR & RTC_ISR_INITF) != RESET)
00000c  bf00              NOP      
                  |L15.14|
00000e  4803              LDR      r0,|L15.28|
000010  68c0              LDR      r0,[r0,#0xc]
000012  2140              MOVS     r1,#0x40
000014  4008              ANDS     r0,r0,r1
000016  2800              CMP      r0,#0
000018  d1f9              BNE      |L15.14|
;;;264    	{
;;;265    		;
;;;266    	}
;;;267    }
00001a  4770              BX       lr
;;;268    
                          ENDP

                  |L15.28|
                          DCD      0x40002800

                          AREA ||i.RTC_GetAlarm||, CODE, READONLY, ALIGN=2

                  RTC_GetAlarm PROC
;;;892      */
;;;893    void RTC_GetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
000000  b5f8              PUSH     {r3-r7,lr}
;;;894    {
000002  4606              MOV      r6,r0
000004  460f              MOV      r7,r1
000006  4614              MOV      r4,r2
;;;895      uint32_t tmpreg = 0;
000008  2500              MOVS     r5,#0
;;;896    
;;;897      /* Check the parameters */
;;;898      assert_param(IS_RTC_FORMAT(RTC_Format));
;;;899      assert_param(IS_RTC_ALARM(RTC_Alarm)); 
;;;900    
;;;901      /* Get the RTC_ALRMAR register */
;;;902      tmpreg = (uint32_t)(RTC->ALRMAR);
00000a  4819              LDR      r0,|L16.112|
00000c  69c5              LDR      r5,[r0,#0x1c]
;;;903    
;;;904      /* Fill the structure with the read parameters */
;;;905      RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = (uint32_t)((tmpreg & (RTC_ALRMAR_HT | \
00000e  203f              MOVS     r0,#0x3f
000010  0400              LSLS     r0,r0,#16
000012  4028              ANDS     r0,r0,r5
000014  0c00              LSRS     r0,r0,#16
000016  7020              STRB     r0,[r4,#0]
;;;906                                                         RTC_ALRMAR_HU)) >> 16);
;;;907      RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = (uint32_t)((tmpreg & (RTC_ALRMAR_MNT | \
000018  207f              MOVS     r0,#0x7f
00001a  0200              LSLS     r0,r0,#8
00001c  4028              ANDS     r0,r0,r5
00001e  0a00              LSRS     r0,r0,#8
000020  7060              STRB     r0,[r4,#1]
;;;908                                                         RTC_ALRMAR_MNU)) >> 8);
;;;909      RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | \
000022  0668              LSLS     r0,r5,#25
000024  0e40              LSRS     r0,r0,#25
000026  70a0              STRB     r0,[r4,#2]
;;;910                                                         RTC_ALRMAR_SU));
;;;911      RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16);
000028  2001              MOVS     r0,#1
00002a  0580              LSLS     r0,r0,#22
00002c  4028              ANDS     r0,r0,r5
00002e  0c00              LSRS     r0,r0,#16
000030  70e0              STRB     r0,[r4,#3]
;;;912      RTC_AlarmStruct->RTC_AlarmDateWeekDay = (uint32_t)((tmpreg & (RTC_ALRMAR_DT | RTC_ALRMAR_DU)) >> 24);
000032  203f              MOVS     r0,#0x3f
000034  0600              LSLS     r0,r0,#24
000036  4028              ANDS     r0,r0,r5
000038  0e00              LSRS     r0,r0,#24
00003a  7320              STRB     r0,[r4,#0xc]
;;;913      RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = (uint32_t)(tmpreg & RTC_ALRMAR_WDSEL);
00003c  2001              MOVS     r0,#1
00003e  0780              LSLS     r0,r0,#30
000040  4028              ANDS     r0,r0,r5
000042  60a0              STR      r0,[r4,#8]
;;;914      RTC_AlarmStruct->RTC_AlarmMask = (uint32_t)(tmpreg & RTC_AlarmMask_All);
000044  480b              LDR      r0,|L16.116|
000046  4028              ANDS     r0,r0,r5
000048  6060              STR      r0,[r4,#4]
;;;915    
;;;916      if (RTC_Format == RTC_Format_BIN)
00004a  2e00              CMP      r6,#0
00004c  d10f              BNE      |L16.110|
;;;917      {
;;;918        RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
00004e  7820              LDRB     r0,[r4,#0]
000050  f7fffffe          BL       RTC_Bcd2ToByte
000054  7020              STRB     r0,[r4,#0]
;;;919                                                            RTC_AlarmTime.RTC_Hours);
;;;920        RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
000056  7860              LDRB     r0,[r4,#1]
000058  f7fffffe          BL       RTC_Bcd2ToByte
00005c  7060              STRB     r0,[r4,#1]
;;;921                                                            RTC_AlarmTime.RTC_Minutes);
;;;922        RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
00005e  78a0              LDRB     r0,[r4,#2]
000060  f7fffffe          BL       RTC_Bcd2ToByte
000064  70a0              STRB     r0,[r4,#2]
;;;923                                                            RTC_AlarmTime.RTC_Seconds);
;;;924        RTC_AlarmStruct->RTC_AlarmDateWeekDay = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
000066  7b20              LDRB     r0,[r4,#0xc]
000068  f7fffffe          BL       RTC_Bcd2ToByte
00006c  7320              STRB     r0,[r4,#0xc]
                  |L16.110|
;;;925      }  
;;;926    }
00006e  bdf8              POP      {r3-r7,pc}
;;;927    
                          ENDP

                  |L16.112|
                          DCD      0x40002800
                  |L16.116|
                          DCD      0x80808080

                          AREA ||i.RTC_GetAlarmSubSecond||, CODE, READONLY, ALIGN=2

                  RTC_GetAlarmSubSecond PROC
;;;1062     */
;;;1063   uint32_t RTC_GetAlarmSubSecond(uint32_t RTC_Alarm)
000000  4601              MOV      r1,r0
;;;1064   {
;;;1065     uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;1066     
;;;1067     /* Get the RTC_ALRMAR register */
;;;1068     tmpreg = (uint32_t)((RTC->ALRMASSR) & RTC_ALRMASSR_SS);
000004  4a02              LDR      r2,|L17.16|
000006  6852              LDR      r2,[r2,#4]
000008  0450              LSLS     r0,r2,#17
00000a  0c40              LSRS     r0,r0,#17
;;;1069   
;;;1070     return (tmpreg);
;;;1071   }
00000c  4770              BX       lr
;;;1072   
                          ENDP

00000e  0000              DCW      0x0000
                  |L17.16|
                          DCD      0x40002840

                          AREA ||i.RTC_GetDate||, CODE, READONLY, ALIGN=2

                  RTC_GetDate PROC
;;;714      */
;;;715    void RTC_GetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;716    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;717      uint32_t tmpreg = 0;
000006  2500              MOVS     r5,#0
;;;718    
;;;719      /* Check the parameters */
;;;720      assert_param(IS_RTC_FORMAT(RTC_Format));
;;;721      
;;;722      /* Get the RTC_TR register */
;;;723      tmpreg = (uint32_t)(RTC->DR & RTC_DR_RESERVED_MASK); 
000008  4813              LDR      r0,|L18.88|
00000a  6840              LDR      r0,[r0,#4]
00000c  4913              LDR      r1,|L18.92|
00000e  4008              ANDS     r0,r0,r1
000010  4605              MOV      r5,r0
;;;724    
;;;725      /* Fill the structure fields with the read parameters */
;;;726      RTC_DateStruct->RTC_Year = (uint8_t)((tmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16);
000012  20ff              MOVS     r0,#0xff
000014  0400              LSLS     r0,r0,#16
000016  4028              ANDS     r0,r0,r5
000018  0c00              LSRS     r0,r0,#16
00001a  70e0              STRB     r0,[r4,#3]
;;;727      RTC_DateStruct->RTC_Month = (uint8_t)((tmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8);
00001c  201f              MOVS     r0,#0x1f
00001e  0200              LSLS     r0,r0,#8
000020  4028              ANDS     r0,r0,r5
000022  0a00              LSRS     r0,r0,#8
000024  7060              STRB     r0,[r4,#1]
;;;728      RTC_DateStruct->RTC_Date = (uint8_t)(tmpreg & (RTC_DR_DT | RTC_DR_DU));
000026  06a8              LSLS     r0,r5,#26
000028  0e80              LSRS     r0,r0,#26
00002a  70a0              STRB     r0,[r4,#2]
;;;729      RTC_DateStruct->RTC_WeekDay = (uint8_t)((tmpreg & (RTC_DR_WDU)) >> 13);  
00002c  2007              MOVS     r0,#7
00002e  0340              LSLS     r0,r0,#13
000030  4028              ANDS     r0,r0,r5
000032  0b40              LSRS     r0,r0,#13
000034  7020              STRB     r0,[r4,#0]
;;;730    
;;;731      /* Check the input parameters format */
;;;732      if (RTC_Format == RTC_Format_BIN)
000036  2e00              CMP      r6,#0
000038  d10d              BNE      |L18.86|
;;;733      {
;;;734        /* Convert the structure parameters to Binary format */
;;;735        RTC_DateStruct->RTC_Year = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year);
00003a  78e0              LDRB     r0,[r4,#3]
00003c  f7fffffe          BL       RTC_Bcd2ToByte
000040  70e0              STRB     r0,[r4,#3]
;;;736        RTC_DateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
000042  7860              LDRB     r0,[r4,#1]
000044  f7fffffe          BL       RTC_Bcd2ToByte
000048  7060              STRB     r0,[r4,#1]
;;;737        RTC_DateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
00004a  78a0              LDRB     r0,[r4,#2]
00004c  f7fffffe          BL       RTC_Bcd2ToByte
000050  70a0              STRB     r0,[r4,#2]
;;;738        RTC_DateStruct->RTC_WeekDay = (uint8_t)(RTC_DateStruct->RTC_WeekDay);   
000052  7820              LDRB     r0,[r4,#0]
000054  7020              STRB     r0,[r4,#0]
                  |L18.86|
;;;739      }
;;;740    }
000056  bd70              POP      {r4-r6,pc}
;;;741    
                          ENDP

                  |L18.88|
                          DCD      0x40002800
                  |L18.92|
                          DCD      0x00ffff3f

                          AREA ||i.RTC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  RTC_GetFlagStatus PROC
;;;1745     */
;;;1746   FlagStatus RTC_GetFlagStatus(uint32_t RTC_FLAG)
000000  b510              PUSH     {r4,lr}
;;;1747   {
000002  4601              MOV      r1,r0
;;;1748     FlagStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1749     uint32_t tmpreg = 0;
000006  2200              MOVS     r2,#0
;;;1750     
;;;1751     /* Check the parameters */
;;;1752     assert_param(IS_RTC_GET_FLAG(RTC_FLAG));
;;;1753     
;;;1754     /* Get all the flags */
;;;1755     tmpreg = (uint32_t)(RTC->ISR & RTC_FLAGS_MASK);
000008  4b06              LDR      r3,|L19.36|
00000a  68db              LDR      r3,[r3,#0xc]
00000c  4c06              LDR      r4,|L19.40|
00000e  4023              ANDS     r3,r3,r4
000010  461a              MOV      r2,r3
;;;1756     
;;;1757     /* Return the status of the flag */
;;;1758     if ((tmpreg & RTC_FLAG) != (uint32_t)RESET)
000012  4613              MOV      r3,r2
000014  400b              ANDS     r3,r3,r1
000016  2b00              CMP      r3,#0
000018  d001              BEQ      |L19.30|
;;;1759     {
;;;1760       bitstatus = SET;
00001a  2001              MOVS     r0,#1
00001c  e000              B        |L19.32|
                  |L19.30|
;;;1761     }
;;;1762     else
;;;1763     {
;;;1764       bitstatus = RESET;
00001e  2000              MOVS     r0,#0
                  |L19.32|
;;;1765     }
;;;1766     return bitstatus;
;;;1767   }
000020  bd10              POP      {r4,pc}
;;;1768   
                          ENDP

000022  0000              DCW      0x0000
                  |L19.36|
                          DCD      0x40002800
                  |L19.40|
                          DCD      0x00017978

                          AREA ||i.RTC_GetITStatus||, CODE, READONLY, ALIGN=2

                  RTC_GetITStatus PROC
;;;1801     */
;;;1802   ITStatus RTC_GetITStatus(uint32_t RTC_IT)
000000  b570              PUSH     {r4-r6,lr}
;;;1803   {
000002  4601              MOV      r1,r0
;;;1804     ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1805     uint32_t tmpreg = 0, enablestatus = 0;
000006  2200              MOVS     r2,#0
000008  2300              MOVS     r3,#0
;;;1806    
;;;1807     /* Check the parameters */
;;;1808     assert_param(IS_RTC_GET_IT(RTC_IT));
;;;1809     
;;;1810     /* Get the TAMPER Interrupt enable bit and pending bit */
;;;1811     tmpreg = (uint32_t)(RTC->TAFCR & (RTC_TAFCR_TAMPIE));
00000a  4c0f              LDR      r4,|L20.72|
00000c  6824              LDR      r4,[r4,#0]
00000e  2504              MOVS     r5,#4
000010  402c              ANDS     r4,r4,r5
000012  4622              MOV      r2,r4
;;;1812    
;;;1813     /* Get the Interrupt enable Status */
;;;1814     enablestatus = (uint32_t)((RTC->CR & RTC_IT) | (tmpreg & ((RTC_IT >> (RTC_IT >> 18)) >> 15)));
000014  4c0c              LDR      r4,|L20.72|
000016  3c40              SUBS     r4,r4,#0x40
000018  68a4              LDR      r4,[r4,#8]
00001a  400c              ANDS     r4,r4,r1
00001c  0c8e              LSRS     r6,r1,#18
00001e  460d              MOV      r5,r1
000020  40f5              LSRS     r5,r5,r6
000022  0bed              LSRS     r5,r5,#15
000024  4015              ANDS     r5,r5,r2
000026  432c              ORRS     r4,r4,r5
000028  4623              MOV      r3,r4
;;;1815     
;;;1816     /* Get the Interrupt pending bit */
;;;1817     tmpreg = (uint32_t)((RTC->ISR & (uint32_t)(RTC_IT >> 4)));
00002a  4c07              LDR      r4,|L20.72|
00002c  3c40              SUBS     r4,r4,#0x40
00002e  68e4              LDR      r4,[r4,#0xc]
000030  090d              LSRS     r5,r1,#4
000032  402c              ANDS     r4,r4,r5
000034  4622              MOV      r2,r4
;;;1818     
;;;1819     /* Get the status of the Interrupt */
;;;1820     if ((enablestatus != (uint32_t)RESET) && ((tmpreg & 0x0000FFFF) != (uint32_t)RESET))
000036  2b00              CMP      r3,#0
000038  d004              BEQ      |L20.68|
00003a  b294              UXTH     r4,r2
00003c  2c00              CMP      r4,#0
00003e  d001              BEQ      |L20.68|
;;;1821     {
;;;1822       bitstatus = SET;
000040  2001              MOVS     r0,#1
000042  e000              B        |L20.70|
                  |L20.68|
;;;1823     }
;;;1824     else
;;;1825     {
;;;1826       bitstatus = RESET;
000044  2000              MOVS     r0,#0
                  |L20.70|
;;;1827     }
;;;1828     return bitstatus;
;;;1829   }
000046  bd70              POP      {r4-r6,pc}
;;;1830   
                          ENDP

                  |L20.72|
                          DCD      0x40002840

                          AREA ||i.RTC_GetStoreOperation||, CODE, READONLY, ALIGN=2

                  RTC_GetStoreOperation PROC
;;;1116     */
;;;1117   uint32_t RTC_GetStoreOperation(void)
000000  4802              LDR      r0,|L21.12|
;;;1118   {
;;;1119     return (RTC->CR & RTC_CR_BCK);
000002  6880              LDR      r0,[r0,#8]
000004  2101              MOVS     r1,#1
000006  0489              LSLS     r1,r1,#18
000008  4008              ANDS     r0,r0,r1
;;;1120   }
00000a  4770              BX       lr
;;;1121   
                          ENDP

                  |L21.12|
                          DCD      0x40002800

                          AREA ||i.RTC_GetSubSecond||, CODE, READONLY, ALIGN=2

                  RTC_GetSubSecond PROC
;;;579      */
;;;580    uint32_t RTC_GetSubSecond(void)
000000  2000              MOVS     r0,#0
;;;581    {
;;;582      uint32_t tmpreg = 0;
;;;583      
;;;584      /* Get subseconds values from the correspondent registers*/
;;;585      tmpreg = (uint32_t)(RTC->SSR);
000002  4902              LDR      r1,|L22.12|
000004  6a88              LDR      r0,[r1,#0x28]
;;;586      
;;;587      /* Read DR register to unfroze calendar registers */
;;;588      (void) (RTC->DR);
000006  6849              LDR      r1,[r1,#4]
;;;589      
;;;590      return (tmpreg);
;;;591    }
000008  4770              BX       lr
;;;592    
                          ENDP

00000a  0000              DCW      0x0000
                  |L22.12|
                          DCD      0x40002800

                          AREA ||i.RTC_GetTime||, CODE, READONLY, ALIGN=2

                  RTC_GetTime PROC
;;;546      */
;;;547    void RTC_GetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;548    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;549      uint32_t tmpreg = 0;
000006  2500              MOVS     r5,#0
;;;550    
;;;551      /* Check the parameters */
;;;552      assert_param(IS_RTC_FORMAT(RTC_Format));
;;;553    
;;;554      /* Get the RTC_TR register */
;;;555      tmpreg = (uint32_t)(RTC->TR & RTC_TR_RESERVED_MASK); 
000008  4812              LDR      r0,|L23.84|
00000a  6800              LDR      r0,[r0,#0]
00000c  4912              LDR      r1,|L23.88|
00000e  4008              ANDS     r0,r0,r1
000010  4605              MOV      r5,r0
;;;556      
;;;557      /* Fill the structure fields with the read parameters */
;;;558      RTC_TimeStruct->RTC_Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
000012  203f              MOVS     r0,#0x3f
000014  0400              LSLS     r0,r0,#16
000016  4028              ANDS     r0,r0,r5
000018  0c00              LSRS     r0,r0,#16
00001a  7020              STRB     r0,[r4,#0]
;;;559      RTC_TimeStruct->RTC_Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
00001c  207f              MOVS     r0,#0x7f
00001e  0200              LSLS     r0,r0,#8
000020  4028              ANDS     r0,r0,r5
000022  0a00              LSRS     r0,r0,#8
000024  7060              STRB     r0,[r4,#1]
;;;560      RTC_TimeStruct->RTC_Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
000026  0668              LSLS     r0,r5,#25
000028  0e40              LSRS     r0,r0,#25
00002a  70a0              STRB     r0,[r4,#2]
;;;561      RTC_TimeStruct->RTC_H12 = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16);  
00002c  2001              MOVS     r0,#1
00002e  0580              LSLS     r0,r0,#22
000030  4028              ANDS     r0,r0,r5
000032  0c00              LSRS     r0,r0,#16
000034  70e0              STRB     r0,[r4,#3]
;;;562    
;;;563      /* Check the input parameters format */
;;;564      if (RTC_Format == RTC_Format_BIN)
000036  2e00              CMP      r6,#0
000038  d10b              BNE      |L23.82|
;;;565      {
;;;566        /* Convert the structure parameters to Binary format */
;;;567        RTC_TimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
00003a  7820              LDRB     r0,[r4,#0]
00003c  f7fffffe          BL       RTC_Bcd2ToByte
000040  7020              STRB     r0,[r4,#0]
;;;568        RTC_TimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes);
000042  7860              LDRB     r0,[r4,#1]
000044  f7fffffe          BL       RTC_Bcd2ToByte
000048  7060              STRB     r0,[r4,#1]
;;;569        RTC_TimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds);
00004a  78a0              LDRB     r0,[r4,#2]
00004c  f7fffffe          BL       RTC_Bcd2ToByte
000050  70a0              STRB     r0,[r4,#2]
                  |L23.82|
;;;570      }
;;;571    }
000052  bd70              POP      {r4-r6,pc}
;;;572    
                          ENDP

                  |L23.84|
                          DCD      0x40002800
                  |L23.88|
                          DCD      0x007f7f7f

                          AREA ||i.RTC_GetTimeStamp||, CODE, READONLY, ALIGN=2

                  RTC_GetTimeStamp PROC
;;;1346     */
;;;1347   void RTC_GetTimeStamp(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_StampTimeStruct, 
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;1348                                         RTC_DateTypeDef* RTC_StampDateStruct)
;;;1349   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;1350     uint32_t tmptime = 0, tmpdate = 0;
000006  2600              MOVS     r6,#0
000008  2700              MOVS     r7,#0
;;;1351   
;;;1352     /* Check the parameters */
;;;1353     assert_param(IS_RTC_FORMAT(RTC_Format));
;;;1354   
;;;1355     /* Get the TimeStamp time and date registers values */
;;;1356     tmptime = (uint32_t)(RTC->TSTR & RTC_TR_RESERVED_MASK);
00000a  4823              LDR      r0,|L24.152|
00000c  6b00              LDR      r0,[r0,#0x30]
00000e  4923              LDR      r1,|L24.156|
000010  4008              ANDS     r0,r0,r1
000012  4606              MOV      r6,r0
;;;1357     tmpdate = (uint32_t)(RTC->TSDR & RTC_DR_RESERVED_MASK);
000014  4820              LDR      r0,|L24.152|
000016  6b40              LDR      r0,[r0,#0x34]
000018  4921              LDR      r1,|L24.160|
00001a  4008              ANDS     r0,r0,r1
00001c  4607              MOV      r7,r0
;;;1358   
;;;1359     /* Fill the Time structure fields with the read parameters */
;;;1360     RTC_StampTimeStruct->RTC_Hours = (uint8_t)((tmptime & (RTC_TR_HT | RTC_TR_HU)) >> 16);
00001e  203f              MOVS     r0,#0x3f
000020  0400              LSLS     r0,r0,#16
000022  4030              ANDS     r0,r0,r6
000024  0c00              LSRS     r0,r0,#16
000026  7020              STRB     r0,[r4,#0]
;;;1361     RTC_StampTimeStruct->RTC_Minutes = (uint8_t)((tmptime & (RTC_TR_MNT | RTC_TR_MNU)) >> 8);
000028  207f              MOVS     r0,#0x7f
00002a  0200              LSLS     r0,r0,#8
00002c  4030              ANDS     r0,r0,r6
00002e  0a00              LSRS     r0,r0,#8
000030  7060              STRB     r0,[r4,#1]
;;;1362     RTC_StampTimeStruct->RTC_Seconds = (uint8_t)(tmptime & (RTC_TR_ST | RTC_TR_SU));
000032  0670              LSLS     r0,r6,#25
000034  0e40              LSRS     r0,r0,#25
000036  70a0              STRB     r0,[r4,#2]
;;;1363     RTC_StampTimeStruct->RTC_H12 = (uint8_t)((tmptime & (RTC_TR_PM)) >> 16);  
000038  2001              MOVS     r0,#1
00003a  0580              LSLS     r0,r0,#22
00003c  4030              ANDS     r0,r0,r6
00003e  0c00              LSRS     r0,r0,#16
000040  70e0              STRB     r0,[r4,#3]
;;;1364   
;;;1365     /* Fill the Date structure fields with the read parameters */
;;;1366     RTC_StampDateStruct->RTC_Year = 0;
000042  2000              MOVS     r0,#0
000044  70e8              STRB     r0,[r5,#3]
;;;1367     RTC_StampDateStruct->RTC_Month = (uint8_t)((tmpdate & (RTC_DR_MT | RTC_DR_MU)) >> 8);
000046  201f              MOVS     r0,#0x1f
000048  0200              LSLS     r0,r0,#8
00004a  4038              ANDS     r0,r0,r7
00004c  0a00              LSRS     r0,r0,#8
00004e  7068              STRB     r0,[r5,#1]
;;;1368     RTC_StampDateStruct->RTC_Date = (uint8_t)(tmpdate & (RTC_DR_DT | RTC_DR_DU));
000050  06b8              LSLS     r0,r7,#26
000052  0e80              LSRS     r0,r0,#26
000054  70a8              STRB     r0,[r5,#2]
;;;1369     RTC_StampDateStruct->RTC_WeekDay = (uint8_t)((tmpdate & (RTC_DR_WDU)) >> 13);
000056  2007              MOVS     r0,#7
000058  0340              LSLS     r0,r0,#13
00005a  4038              ANDS     r0,r0,r7
00005c  0b40              LSRS     r0,r0,#13
00005e  7028              STRB     r0,[r5,#0]
;;;1370   
;;;1371     /* Check the input parameters format */
;;;1372     if (RTC_Format == RTC_Format_BIN)
000060  9800              LDR      r0,[sp,#0]
000062  2800              CMP      r0,#0
000064  d117              BNE      |L24.150|
;;;1373     {
;;;1374       /* Convert the Time structure parameters to Binary format */
;;;1375       RTC_StampTimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Hours);
000066  7820              LDRB     r0,[r4,#0]
000068  f7fffffe          BL       RTC_Bcd2ToByte
00006c  7020              STRB     r0,[r4,#0]
;;;1376       RTC_StampTimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Minutes);
00006e  7860              LDRB     r0,[r4,#1]
000070  f7fffffe          BL       RTC_Bcd2ToByte
000074  7060              STRB     r0,[r4,#1]
;;;1377       RTC_StampTimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Seconds);
000076  78a0              LDRB     r0,[r4,#2]
000078  f7fffffe          BL       RTC_Bcd2ToByte
00007c  70a0              STRB     r0,[r4,#2]
;;;1378   
;;;1379       /* Convert the Date structure parameters to Binary format */
;;;1380       RTC_StampDateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Month);
00007e  7868              LDRB     r0,[r5,#1]
000080  f7fffffe          BL       RTC_Bcd2ToByte
000084  7068              STRB     r0,[r5,#1]
;;;1381       RTC_StampDateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Date);
000086  78a8              LDRB     r0,[r5,#2]
000088  f7fffffe          BL       RTC_Bcd2ToByte
00008c  70a8              STRB     r0,[r5,#2]
;;;1382       RTC_StampDateStruct->RTC_WeekDay = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_WeekDay);
00008e  7828              LDRB     r0,[r5,#0]
000090  f7fffffe          BL       RTC_Bcd2ToByte
000094  7028              STRB     r0,[r5,#0]
                  |L24.150|
;;;1383     }
;;;1384   }
000096  bdfe              POP      {r1-r7,pc}
;;;1385   
                          ENDP

                  |L24.152|
                          DCD      0x40002800
                  |L24.156|
                          DCD      0x007f7f7f
                  |L24.160|
                          DCD      0x00ffff3f

                          AREA ||i.RTC_GetTimeStampSubSecond||, CODE, READONLY, ALIGN=2

                  RTC_GetTimeStampSubSecond PROC
;;;1390     */
;;;1391   uint32_t RTC_GetTimeStampSubSecond(void)
000000  4801              LDR      r0,|L25.8|
;;;1392   {
;;;1393     /* Get timestamp subseconds values from the correspondent registers */
;;;1394     return (uint32_t)(RTC->TSSSR);
000002  6b80              LDR      r0,[r0,#0x38]
;;;1395   }
000004  4770              BX       lr
;;;1396   
                          ENDP

000006  0000              DCW      0x0000
                  |L25.8|
                          DCD      0x40002800

                          AREA ||i.RTC_ITConfig||, CODE, READONLY, ALIGN=2

                  RTC_ITConfig PROC
;;;1701     */
;;;1702   void RTC_ITConfig(uint32_t RTC_IT, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;1703   {
;;;1704     /* Check the parameters */
;;;1705     assert_param(IS_RTC_CONFIG_IT(RTC_IT));
;;;1706     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1707   
;;;1708     /* Disable the write protection for RTC registers */
;;;1709     RTC->WPR = 0xCA;
000002  22ca              MOVS     r2,#0xca
000004  4b16              LDR      r3,|L26.96|
000006  625a              STR      r2,[r3,#0x24]
;;;1710     RTC->WPR = 0x53;
000008  2253              MOVS     r2,#0x53
00000a  625a              STR      r2,[r3,#0x24]
;;;1711   
;;;1712     if (NewState != DISABLE)
00000c  2900              CMP      r1,#0
00000e  d011              BEQ      |L26.52|
;;;1713     {
;;;1714       /* Configure the Interrupts in the RTC_CR register */
;;;1715       RTC->CR |= (uint32_t)(RTC_IT & ~RTC_TAFCR_TAMPIE);
000010  461a              MOV      r2,r3
000012  6892              LDR      r2,[r2,#8]
000014  2404              MOVS     r4,#4
000016  4603              MOV      r3,r0
000018  43a3              BICS     r3,r3,r4
00001a  431a              ORRS     r2,r2,r3
00001c  4b10              LDR      r3,|L26.96|
00001e  609a              STR      r2,[r3,#8]
;;;1716       /* Configure the Tamper Interrupt in the RTC_TAFCR */
;;;1717       RTC->TAFCR |= (uint32_t)(RTC_IT & RTC_TAFCR_TAMPIE);
000020  4a0f              LDR      r2,|L26.96|
000022  3240              ADDS     r2,r2,#0x40
000024  6812              LDR      r2,[r2,#0]
000026  2304              MOVS     r3,#4
000028  4003              ANDS     r3,r3,r0
00002a  431a              ORRS     r2,r2,r3
00002c  4b0c              LDR      r3,|L26.96|
00002e  3340              ADDS     r3,r3,#0x40
000030  601a              STR      r2,[r3,#0]
000032  e010              B        |L26.86|
                  |L26.52|
;;;1718     }
;;;1719     else
;;;1720     {
;;;1721       /* Configure the Interrupts in the RTC_CR register */
;;;1722       RTC->CR &= (uint32_t)~(RTC_IT & (uint32_t)~RTC_TAFCR_TAMPIE);
000034  4a0a              LDR      r2,|L26.96|
000036  6892              LDR      r2,[r2,#8]
000038  2404              MOVS     r4,#4
00003a  4603              MOV      r3,r0
00003c  43a3              BICS     r3,r3,r4
00003e  439a              BICS     r2,r2,r3
000040  4b07              LDR      r3,|L26.96|
000042  609a              STR      r2,[r3,#8]
;;;1723       /* Configure the Tamper Interrupt in the RTC_TAFCR */
;;;1724       RTC->TAFCR &= (uint32_t)~(RTC_IT & RTC_TAFCR_TAMPIE);
000044  4a06              LDR      r2,|L26.96|
000046  3240              ADDS     r2,r2,#0x40
000048  6812              LDR      r2,[r2,#0]
00004a  2304              MOVS     r3,#4
00004c  4003              ANDS     r3,r3,r0
00004e  439a              BICS     r2,r2,r3
000050  4b03              LDR      r3,|L26.96|
000052  3340              ADDS     r3,r3,#0x40
000054  601a              STR      r2,[r3,#0]
                  |L26.86|
;;;1725     }
;;;1726     /* Enable the write protection for RTC registers */
;;;1727     RTC->WPR = 0xFF; 
000056  22ff              MOVS     r2,#0xff
000058  4b01              LDR      r3,|L26.96|
00005a  625a              STR      r2,[r3,#0x24]
;;;1728   }
00005c  bd10              POP      {r4,pc}
;;;1729   
                          ENDP

00005e  0000              DCW      0x0000
                  |L26.96|
                          DCD      0x40002800

                          AREA ||i.RTC_Init||, CODE, READONLY, ALIGN=2

                  RTC_Init PROC
;;;116      */
;;;117    ErrorStatus RTC_Init(RTC_InitTypeDef* RTC_InitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;118    {
000002  4604              MOV      r4,r0
;;;119      ErrorStatus status = ERROR;
000004  2500              MOVS     r5,#0
;;;120    
;;;121      /* Check the parameters */
;;;122      assert_param(IS_RTC_HOUR_FORMAT(RTC_InitStruct->RTC_HourFormat));
;;;123      assert_param(IS_RTC_ASYNCH_PREDIV(RTC_InitStruct->RTC_AsynchPrediv));
;;;124      assert_param(IS_RTC_SYNCH_PREDIV(RTC_InitStruct->RTC_SynchPrediv));
;;;125    
;;;126      /* Disable the write protection for RTC registers */
;;;127      RTC->WPR = 0xCA;
000006  20ca              MOVS     r0,#0xca
000008  4912              LDR      r1,|L27.84|
00000a  6248              STR      r0,[r1,#0x24]
;;;128      RTC->WPR = 0x53;
00000c  2053              MOVS     r0,#0x53
00000e  6248              STR      r0,[r1,#0x24]
;;;129    
;;;130      /* Set Initialization mode */
;;;131      if (RTC_EnterInitMode() == ERROR)
000010  f7fffffe          BL       RTC_EnterInitMode
000014  2800              CMP      r0,#0
000016  d100              BNE      |L27.26|
;;;132      {
;;;133        status = ERROR;
000018  e017              B        |L27.74|
                  |L27.26|
;;;134      }
;;;135      else
;;;136      {
;;;137        /* Clear RTC CR FMT Bit */
;;;138        RTC->CR &= ((uint32_t)~(RTC_CR_FMT));
00001a  480e              LDR      r0,|L27.84|
00001c  6880              LDR      r0,[r0,#8]
00001e  2140              MOVS     r1,#0x40
000020  4388              BICS     r0,r0,r1
000022  490c              LDR      r1,|L27.84|
000024  6088              STR      r0,[r1,#8]
;;;139        /* Set RTC_CR register */
;;;140        RTC->CR |=  ((uint32_t)(RTC_InitStruct->RTC_HourFormat));
000026  4608              MOV      r0,r1
000028  6880              LDR      r0,[r0,#8]
00002a  6821              LDR      r1,[r4,#0]
00002c  4308              ORRS     r0,r0,r1
00002e  4909              LDR      r1,|L27.84|
000030  6088              STR      r0,[r1,#8]
;;;141      
;;;142        /* Configure the RTC PRER */
;;;143        RTC->PRER = (uint32_t)(RTC_InitStruct->RTC_SynchPrediv);
000032  68a0              LDR      r0,[r4,#8]
000034  6108              STR      r0,[r1,#0x10]
;;;144        RTC->PRER |= (uint32_t)(RTC_InitStruct->RTC_AsynchPrediv << 16);
000036  4608              MOV      r0,r1
000038  6900              LDR      r0,[r0,#0x10]
00003a  88a1              LDRH     r1,[r4,#4]
00003c  0409              LSLS     r1,r1,#16
00003e  4308              ORRS     r0,r0,r1
000040  4904              LDR      r1,|L27.84|
000042  6108              STR      r0,[r1,#0x10]
;;;145    
;;;146        /* Exit Initialization mode */
;;;147        RTC_ExitInitMode();
000044  f7fffffe          BL       RTC_ExitInitMode
;;;148    
;;;149        status = SUCCESS;
000048  2501              MOVS     r5,#1
                  |L27.74|
;;;150      }
;;;151      /* Enable the write protection for RTC registers */
;;;152      RTC->WPR = 0xFF;
00004a  20ff              MOVS     r0,#0xff
00004c  4901              LDR      r1,|L27.84|
00004e  6248              STR      r0,[r1,#0x24]
;;;153    
;;;154      return status;
000050  4628              MOV      r0,r5
;;;155    }
000052  bd30              POP      {r4,r5,pc}
;;;156    
                          ENDP

                  |L27.84|
                          DCD      0x40002800

                          AREA ||i.RTC_OutputConfig||, CODE, READONLY, ALIGN=2

                  RTC_OutputConfig PROC
;;;1140     */
;;;1141   void RTC_OutputConfig(uint32_t RTC_Output, uint32_t RTC_OutputPolarity)
000000  22ca              MOVS     r2,#0xca
;;;1142   {
;;;1143     /* Check the parameters */
;;;1144     assert_param(IS_RTC_OUTPUT(RTC_Output));
;;;1145     assert_param(IS_RTC_OUTPUT_POL(RTC_OutputPolarity));
;;;1146   
;;;1147     /* Disable the write protection for RTC registers */
;;;1148     RTC->WPR = 0xCA;
000002  4b0a              LDR      r3,|L28.44|
000004  625a              STR      r2,[r3,#0x24]
;;;1149     RTC->WPR = 0x53;
000006  2253              MOVS     r2,#0x53
000008  625a              STR      r2,[r3,#0x24]
;;;1150   
;;;1151     /* Clear the bits to be configured */
;;;1152     RTC->CR &= (uint32_t)~(RTC_CR_OSEL | RTC_CR_POL);
00000a  461a              MOV      r2,r3
00000c  6892              LDR      r2,[r2,#8]
00000e  2303              MOVS     r3,#3
000010  051b              LSLS     r3,r3,#20
000012  439a              BICS     r2,r2,r3
000014  4b05              LDR      r3,|L28.44|
000016  609a              STR      r2,[r3,#8]
;;;1153   
;;;1154     /* Configure the output selection and polarity */
;;;1155     RTC->CR |= (uint32_t)(RTC_Output | RTC_OutputPolarity);
000018  461a              MOV      r2,r3
00001a  6892              LDR      r2,[r2,#8]
00001c  4603              MOV      r3,r0
00001e  430b              ORRS     r3,r3,r1
000020  431a              ORRS     r2,r2,r3
000022  4b02              LDR      r3,|L28.44|
000024  609a              STR      r2,[r3,#8]
;;;1156   
;;;1157     /* Enable the write protection for RTC registers */
;;;1158     RTC->WPR = 0xFF;
000026  22ff              MOVS     r2,#0xff
000028  625a              STR      r2,[r3,#0x24]
;;;1159   }
00002a  4770              BX       lr
;;;1160   
                          ENDP

                  |L28.44|
                          DCD      0x40002800

                          AREA ||i.RTC_OutputTypeConfig||, CODE, READONLY, ALIGN=2

                  RTC_OutputTypeConfig PROC
;;;1603     */
;;;1604   void RTC_OutputTypeConfig(uint32_t RTC_OutputType)
000000  4905              LDR      r1,|L29.24|
;;;1605   {
;;;1606     /* Check the parameters */
;;;1607     assert_param(IS_RTC_OUTPUT_TYPE(RTC_OutputType));
;;;1608     
;;;1609     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_ALARMOUTTYPE);
000002  6809              LDR      r1,[r1,#0]
000004  2201              MOVS     r2,#1
000006  0492              LSLS     r2,r2,#18
000008  4391              BICS     r1,r1,r2
00000a  4a03              LDR      r2,|L29.24|
00000c  6011              STR      r1,[r2,#0]
;;;1610     RTC->TAFCR |= (uint32_t)(RTC_OutputType);  
00000e  4611              MOV      r1,r2
000010  6809              LDR      r1,[r1,#0]
000012  4301              ORRS     r1,r1,r0
000014  6011              STR      r1,[r2,#0]
;;;1611   }
000016  4770              BX       lr
;;;1612   
                          ENDP

                  |L29.24|
                          DCD      0x40002840

                          AREA ||i.RTC_RefClockCmd||, CODE, READONLY, ALIGN=2

                  RTC_RefClockCmd PROC
;;;335      */
;;;336    ErrorStatus RTC_RefClockCmd(FunctionalState NewState)
000000  b530              PUSH     {r4,r5,lr}
;;;337    {
000002  4604              MOV      r4,r0
;;;338      ErrorStatus status = ERROR;
000004  2500              MOVS     r5,#0
;;;339    
;;;340      /* Check the parameters */
;;;341      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;342    
;;;343      /* Disable the write protection for RTC registers */
;;;344      RTC->WPR = 0xCA;
000006  20ca              MOVS     r0,#0xca
000008  490f              LDR      r1,|L30.72|
00000a  6248              STR      r0,[r1,#0x24]
;;;345      RTC->WPR = 0x53;
00000c  2053              MOVS     r0,#0x53
00000e  6248              STR      r0,[r1,#0x24]
;;;346    
;;;347      /* Set Initialization mode */
;;;348      if (RTC_EnterInitMode() == ERROR)
000010  f7fffffe          BL       RTC_EnterInitMode
000014  2800              CMP      r0,#0
000016  d100              BNE      |L30.26|
;;;349      {
;;;350        status = ERROR;
000018  e011              B        |L30.62|
                  |L30.26|
;;;351      }
;;;352      else
;;;353      {
;;;354        if (NewState != DISABLE)
00001a  2c00              CMP      r4,#0
00001c  d006              BEQ      |L30.44|
;;;355        {
;;;356          /* Enable the RTC reference clock detection */
;;;357          RTC->CR |= RTC_CR_REFCKON;
00001e  480a              LDR      r0,|L30.72|
000020  6880              LDR      r0,[r0,#8]
000022  2110              MOVS     r1,#0x10
000024  4308              ORRS     r0,r0,r1
000026  4908              LDR      r1,|L30.72|
000028  6088              STR      r0,[r1,#8]
00002a  e005              B        |L30.56|
                  |L30.44|
;;;358        }
;;;359        else
;;;360        {
;;;361          /* Disable the RTC reference clock detection */
;;;362          RTC->CR &= ~RTC_CR_REFCKON;
00002c  4806              LDR      r0,|L30.72|
00002e  6880              LDR      r0,[r0,#8]
000030  2110              MOVS     r1,#0x10
000032  4388              BICS     r0,r0,r1
000034  4904              LDR      r1,|L30.72|
000036  6088              STR      r0,[r1,#8]
                  |L30.56|
;;;363        }
;;;364        /* Exit Initialization mode */
;;;365        RTC_ExitInitMode();
000038  f7fffffe          BL       RTC_ExitInitMode
;;;366    
;;;367        status = SUCCESS;
00003c  2501              MOVS     r5,#1
                  |L30.62|
;;;368      }
;;;369    
;;;370      /* Enable the write protection for RTC registers */
;;;371      RTC->WPR = 0xFF;
00003e  20ff              MOVS     r0,#0xff
000040  4901              LDR      r1,|L30.72|
000042  6248              STR      r0,[r1,#0x24]
;;;372    
;;;373      return status;
000044  4628              MOV      r0,r5
;;;374    }
000046  bd30              POP      {r4,r5,pc}
;;;375    
                          ENDP

                  |L30.72|
                          DCD      0x40002800

                          AREA ||i.RTC_SetAlarm||, CODE, READONLY, ALIGN=2

                  RTC_SetAlarm PROC
;;;759      */
;;;760    void RTC_SetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
000000  b5f8              PUSH     {r3-r7,lr}
;;;761    {
000002  4605              MOV      r5,r0
000004  4614              MOV      r4,r2
;;;762      uint32_t tmpreg = 0;
000006  2600              MOVS     r6,#0
;;;763      
;;;764      /* Check the parameters */
;;;765      assert_param(IS_RTC_FORMAT(RTC_Format));
;;;766      assert_param(IS_RTC_ALARM(RTC_Alarm));
;;;767      assert_param(IS_RTC_ALARM_MASK(RTC_AlarmStruct->RTC_AlarmMask));
;;;768      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel));
;;;769    
;;;770      if (RTC_Format == RTC_Format_BIN)
000008  2d00              CMP      r5,#0
00000a  d10e              BNE      |L31.42|
;;;771      {
;;;772        if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
00000c  4831              LDR      r0,|L31.212|
00000e  6880              LDR      r0,[r0,#8]
000010  2140              MOVS     r1,#0x40
000012  4008              ANDS     r0,r0,r1
000014  2800              CMP      r0,#0
000016  d000              BEQ      |L31.26|
;;;773        {
;;;774          assert_param(IS_RTC_HOUR12(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
;;;775          assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
000018  e002              B        |L31.32|
                  |L31.26|
;;;776        } 
;;;777        else
;;;778        {
;;;779          RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
00001a  2000              MOVS     r0,#0
00001c  70e0              STRB     r0,[r4,#3]
;;;780          assert_param(IS_RTC_HOUR24(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
00001e  bf00              NOP      
                  |L31.32|
;;;781        }
;;;782        assert_param(IS_RTC_MINUTES(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes));
;;;783        assert_param(IS_RTC_SECONDS(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds));
;;;784        
;;;785        if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
000020  68a0              LDR      r0,[r4,#8]
000022  2800              CMP      r0,#0
000024  d100              BNE      |L31.40|
;;;786        {
;;;787          assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
000026  e01b              B        |L31.96|
                  |L31.40|
;;;788        }
;;;789        else
;;;790        {
;;;791          assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
000028  e01a              B        |L31.96|
                  |L31.42|
;;;792        }
;;;793      }
;;;794      else
;;;795      {
;;;796        if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
00002a  482a              LDR      r0,|L31.212|
00002c  6880              LDR      r0,[r0,#8]
00002e  2140              MOVS     r1,#0x40
000030  4008              ANDS     r0,r0,r1
000032  2800              CMP      r0,#0
000034  d004              BEQ      |L31.64|
;;;797        {
;;;798          tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours);
000036  7820              LDRB     r0,[r4,#0]
000038  f7fffffe          BL       RTC_Bcd2ToByte
00003c  4606              MOV      r6,r0
;;;799          assert_param(IS_RTC_HOUR12(tmpreg));
;;;800          assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
00003e  e002              B        |L31.70|
                  |L31.64|
;;;801        } 
;;;802        else
;;;803        {
;;;804          RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
000040  2000              MOVS     r0,#0
000042  70e0              STRB     r0,[r4,#3]
;;;805          assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours)));
000044  bf00              NOP      
                  |L31.70|
;;;806        }
;;;807        
;;;808        assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes)));
;;;809        assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)));
;;;810        
;;;811        if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
000046  68a0              LDR      r0,[r4,#8]
000048  2800              CMP      r0,#0
00004a  d104              BNE      |L31.86|
;;;812        {
;;;813          tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
00004c  7b20              LDRB     r0,[r4,#0xc]
00004e  f7fffffe          BL       RTC_Bcd2ToByte
000052  4606              MOV      r6,r0
;;;814          assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(tmpreg));    
000054  e004              B        |L31.96|
                  |L31.86|
;;;815        }
;;;816        else
;;;817        {
;;;818          tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
000056  7b20              LDRB     r0,[r4,#0xc]
000058  f7fffffe          BL       RTC_Bcd2ToByte
00005c  4606              MOV      r6,r0
;;;819          assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(tmpreg));      
00005e  bf00              NOP      
                  |L31.96|
;;;820        }    
;;;821      }
;;;822    
;;;823      /* Check the input parameters format */
;;;824      if (RTC_Format != RTC_Format_BIN)
000060  2d00              CMP      r5,#0
000062  d012              BEQ      |L31.138|
;;;825      {
;;;826        tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
000064  7820              LDRB     r0,[r4,#0]
000066  0400              LSLS     r0,r0,#16
000068  7861              LDRB     r1,[r4,#1]
00006a  0209              LSLS     r1,r1,#8
00006c  4308              ORRS     r0,r0,r1
00006e  78a1              LDRB     r1,[r4,#2]
000070  4308              ORRS     r0,r0,r1
000072  78e1              LDRB     r1,[r4,#3]
000074  0409              LSLS     r1,r1,#16
000076  4308              ORRS     r0,r0,r1
000078  7b21              LDRB     r1,[r4,#0xc]
00007a  0609              LSLS     r1,r1,#24
00007c  4308              ORRS     r0,r0,r1
00007e  68a1              LDR      r1,[r4,#8]
000080  4308              ORRS     r0,r0,r1
000082  6861              LDR      r1,[r4,#4]
000084  4308              ORRS     r0,r0,r1
000086  4606              MOV      r6,r0
000088  e019              B        |L31.190|
                  |L31.138|
;;;827                  ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
;;;828                  ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
;;;829                  ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
;;;830                  ((uint32_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
;;;831                  ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
;;;832                  ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
;;;833      }  
;;;834      else
;;;835      {
;;;836        tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
00008a  7820              LDRB     r0,[r4,#0]
00008c  f7fffffe          BL       RTC_ByteToBcd2
000090  0407              LSLS     r7,r0,#16
000092  7860              LDRB     r0,[r4,#1]
000094  f7fffffe          BL       RTC_ByteToBcd2
000098  0200              LSLS     r0,r0,#8
00009a  4307              ORRS     r7,r7,r0
00009c  78a0              LDRB     r0,[r4,#2]
00009e  f7fffffe          BL       RTC_ByteToBcd2
0000a2  4307              ORRS     r7,r7,r0
0000a4  78e0              LDRB     r0,[r4,#3]
0000a6  0400              LSLS     r0,r0,#16
0000a8  4307              ORRS     r7,r7,r0
0000aa  7b20              LDRB     r0,[r4,#0xc]
0000ac  f7fffffe          BL       RTC_ByteToBcd2
0000b0  0600              LSLS     r0,r0,#24
0000b2  4307              ORRS     r7,r7,r0
0000b4  68a0              LDR      r0,[r4,#8]
0000b6  4307              ORRS     r7,r7,r0
0000b8  6860              LDR      r0,[r4,#4]
0000ba  4307              ORRS     r7,r7,r0
0000bc  463e              MOV      r6,r7
                  |L31.190|
;;;837                  ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
;;;838                  ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
;;;839                  ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
;;;840                  ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
;;;841                  ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
;;;842                  ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
;;;843      }
;;;844    
;;;845      /* Disable the write protection for RTC registers */
;;;846      RTC->WPR = 0xCA;
0000be  20ca              MOVS     r0,#0xca
0000c0  4904              LDR      r1,|L31.212|
0000c2  6248              STR      r0,[r1,#0x24]
;;;847      RTC->WPR = 0x53;
0000c4  2053              MOVS     r0,#0x53
0000c6  6248              STR      r0,[r1,#0x24]
;;;848    
;;;849      /* Configure the Alarm register */
;;;850      RTC->ALRMAR = (uint32_t)tmpreg;
0000c8  4608              MOV      r0,r1
0000ca  61c6              STR      r6,[r0,#0x1c]
;;;851    
;;;852      /* Enable the write protection for RTC registers */
;;;853      RTC->WPR = 0xFF;
0000cc  20ff              MOVS     r0,#0xff
0000ce  6248              STR      r0,[r1,#0x24]
;;;854    }
0000d0  bdf8              POP      {r3-r7,pc}
;;;855    
                          ENDP

0000d2  0000              DCW      0x0000
                  |L31.212|
                          DCD      0x40002800

                          AREA ||i.RTC_SetDate||, CODE, READONLY, ALIGN=2

                  RTC_SetDate PROC
;;;604      */
;;;605    ErrorStatus RTC_SetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
000000  b5f8              PUSH     {r3-r7,lr}
;;;606    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;607      uint32_t tmpreg = 0;
000006  2600              MOVS     r6,#0
;;;608      ErrorStatus status = ERROR;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;609      
;;;610      /* Check the parameters */
;;;611      assert_param(IS_RTC_FORMAT(RTC_Format));
;;;612    
;;;613      if ((RTC_Format == RTC_Format_BIN) && ((RTC_DateStruct->RTC_Month & 0x10) == 0x10))
00000c  2d00              CMP      r5,#0
00000e  d108              BNE      |L32.34|
000010  7860              LDRB     r0,[r4,#1]
000012  2110              MOVS     r1,#0x10
000014  4008              ANDS     r0,r0,r1
000016  2810              CMP      r0,#0x10
000018  d103              BNE      |L32.34|
;;;614      {
;;;615        RTC_DateStruct->RTC_Month = (RTC_DateStruct->RTC_Month & (uint32_t)~(0x10)) + 0x0A;
00001a  7860              LDRB     r0,[r4,#1]
00001c  4388              BICS     r0,r0,r1
00001e  300a              ADDS     r0,r0,#0xa
000020  7060              STRB     r0,[r4,#1]
                  |L32.34|
;;;616      }  
;;;617      if (RTC_Format == RTC_Format_BIN)
000022  2d00              CMP      r5,#0
000024  d100              BNE      |L32.40|
;;;618      {
;;;619        assert_param(IS_RTC_YEAR(RTC_DateStruct->RTC_Year));
;;;620        assert_param(IS_RTC_MONTH(RTC_DateStruct->RTC_Month));
;;;621        assert_param(IS_RTC_DATE(RTC_DateStruct->RTC_Date));
000026  e008              B        |L32.58|
                  |L32.40|
;;;622      }
;;;623      else
;;;624      {
;;;625        assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year)));
;;;626        tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
000028  7860              LDRB     r0,[r4,#1]
00002a  f7fffffe          BL       RTC_Bcd2ToByte
00002e  4606              MOV      r6,r0
;;;627        assert_param(IS_RTC_MONTH(tmpreg));
;;;628        tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
000030  78a0              LDRB     r0,[r4,#2]
000032  f7fffffe          BL       RTC_Bcd2ToByte
000036  4606              MOV      r6,r0
;;;629        assert_param(IS_RTC_DATE(tmpreg));
000038  bf00              NOP      
                  |L32.58|
;;;630      }
;;;631      assert_param(IS_RTC_WEEKDAY(RTC_DateStruct->RTC_WeekDay));
;;;632    
;;;633      /* Check the input parameters format */
;;;634      if (RTC_Format != RTC_Format_BIN)
00003a  2d00              CMP      r5,#0
00003c  d00b              BEQ      |L32.86|
;;;635      {
;;;636        tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
00003e  78e0              LDRB     r0,[r4,#3]
000040  0400              LSLS     r0,r0,#16
000042  7861              LDRB     r1,[r4,#1]
000044  0209              LSLS     r1,r1,#8
000046  4308              ORRS     r0,r0,r1
000048  78a1              LDRB     r1,[r4,#2]
00004a  4308              ORRS     r0,r0,r1
00004c  7821              LDRB     r1,[r4,#0]
00004e  0349              LSLS     r1,r1,#13
000050  4308              ORRS     r0,r0,r1
000052  4606              MOV      r6,r0
000054  e010              B        |L32.120|
                  |L32.86|
;;;637                  (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
;;;638                  ((uint32_t)RTC_DateStruct->RTC_Date) | \
;;;639                  (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
;;;640      }  
;;;641      else
;;;642      {
;;;643        tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
000056  78e0              LDRB     r0,[r4,#3]
000058  f7fffffe          BL       RTC_ByteToBcd2
00005c  0407              LSLS     r7,r0,#16
00005e  7860              LDRB     r0,[r4,#1]
000060  f7fffffe          BL       RTC_ByteToBcd2
000064  0200              LSLS     r0,r0,#8
000066  4307              ORRS     r7,r7,r0
000068  78a0              LDRB     r0,[r4,#2]
00006a  f7fffffe          BL       RTC_ByteToBcd2
00006e  4307              ORRS     r7,r7,r0
000070  7820              LDRB     r0,[r4,#0]
000072  0340              LSLS     r0,r0,#13
000074  4307              ORRS     r7,r7,r0
000076  463e              MOV      r6,r7
                  |L32.120|
;;;644                  ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
;;;645                  ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Date)) | \
;;;646                  ((uint32_t)RTC_DateStruct->RTC_WeekDay << 13));
;;;647      }
;;;648    
;;;649      /* Disable the write protection for RTC registers */
;;;650      RTC->WPR = 0xCA;
000078  20ca              MOVS     r0,#0xca
00007a  4913              LDR      r1,|L32.200|
00007c  6248              STR      r0,[r1,#0x24]
;;;651      RTC->WPR = 0x53;
00007e  2053              MOVS     r0,#0x53
000080  6248              STR      r0,[r1,#0x24]
;;;652    
;;;653      /* Set Initialization mode */
;;;654      if (RTC_EnterInitMode() == ERROR)
000082  f7fffffe          BL       RTC_EnterInitMode
000086  2800              CMP      r0,#0
000088  d101              BNE      |L32.142|
;;;655      {
;;;656        status = ERROR;
00008a  9000              STR      r0,[sp,#0]
00008c  e016              B        |L32.188|
                  |L32.142|
;;;657      } 
;;;658      else
;;;659      {
;;;660        /* Set the RTC_DR register */
;;;661        RTC->DR = (uint32_t)(tmpreg & RTC_DR_RESERVED_MASK);
00008e  480f              LDR      r0,|L32.204|
000090  4030              ANDS     r0,r0,r6
000092  490d              LDR      r1,|L32.200|
000094  6048              STR      r0,[r1,#4]
;;;662    
;;;663        /* Exit Initialization mode */
;;;664        RTC_ExitInitMode(); 
000096  f7fffffe          BL       RTC_ExitInitMode
;;;665    
;;;666        /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
;;;667        if ((RTC->CR & RTC_CR_BYPSHAD) == RESET)
00009a  480b              LDR      r0,|L32.200|
00009c  6880              LDR      r0,[r0,#8]
00009e  2120              MOVS     r1,#0x20
0000a0  4008              ANDS     r0,r0,r1
0000a2  2800              CMP      r0,#0
0000a4  d108              BNE      |L32.184|
;;;668        {
;;;669          if (RTC_WaitForSynchro() == ERROR)
0000a6  f7fffffe          BL       RTC_WaitForSynchro
0000aa  2800              CMP      r0,#0
0000ac  d101              BNE      |L32.178|
;;;670          {
;;;671            status = ERROR;
0000ae  9000              STR      r0,[sp,#0]
0000b0  e004              B        |L32.188|
                  |L32.178|
;;;672          }
;;;673          else
;;;674          {
;;;675            status = SUCCESS;
0000b2  2001              MOVS     r0,#1
0000b4  9000              STR      r0,[sp,#0]
0000b6  e001              B        |L32.188|
                  |L32.184|
;;;676          }
;;;677        }
;;;678        else
;;;679        {
;;;680          status = SUCCESS;
0000b8  2001              MOVS     r0,#1
0000ba  9000              STR      r0,[sp,#0]
                  |L32.188|
;;;681        }
;;;682      }
;;;683      /* Enable the write protection for RTC registers */
;;;684      RTC->WPR = 0xFF;
0000bc  20ff              MOVS     r0,#0xff
0000be  4902              LDR      r1,|L32.200|
0000c0  6248              STR      r0,[r1,#0x24]
;;;685      
;;;686      return status;
0000c2  9800              LDR      r0,[sp,#0]
;;;687    }
0000c4  bdf8              POP      {r3-r7,pc}
;;;688    
                          ENDP

0000c6  0000              DCW      0x0000
                  |L32.200|
                          DCD      0x40002800
                  |L32.204|
                          DCD      0x00ffff3f

                          AREA ||i.RTC_SetTime||, CODE, READONLY, ALIGN=2

                  RTC_SetTime PROC
;;;423      */
;;;424    ErrorStatus RTC_SetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
000000  b5f8              PUSH     {r3-r7,lr}
;;;425    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;426      uint32_t tmpreg = 0;
000006  2600              MOVS     r6,#0
;;;427      ErrorStatus status = ERROR;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;428    
;;;429      /* Check the parameters */
;;;430      assert_param(IS_RTC_FORMAT(RTC_Format));
;;;431      
;;;432      if (RTC_Format == RTC_Format_BIN)
00000c  2d00              CMP      r5,#0
00000e  d10a              BNE      |L33.38|
;;;433      {
;;;434        if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
000010  482f              LDR      r0,|L33.208|
000012  6880              LDR      r0,[r0,#8]
000014  2140              MOVS     r1,#0x40
000016  4008              ANDS     r0,r0,r1
000018  2800              CMP      r0,#0
00001a  d000              BEQ      |L33.30|
;;;435        {
;;;436          assert_param(IS_RTC_HOUR12(RTC_TimeStruct->RTC_Hours));
;;;437          assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12));
00001c  e002              B        |L33.36|
                  |L33.30|
;;;438        }
;;;439        else
;;;440        {
;;;441          RTC_TimeStruct->RTC_H12 = 0x00;
00001e  2000              MOVS     r0,#0
000020  70e0              STRB     r0,[r4,#3]
;;;442          assert_param(IS_RTC_HOUR24(RTC_TimeStruct->RTC_Hours));
000022  bf00              NOP      
                  |L33.36|
;;;443        }
;;;444        assert_param(IS_RTC_MINUTES(RTC_TimeStruct->RTC_Minutes));
;;;445        assert_param(IS_RTC_SECONDS(RTC_TimeStruct->RTC_Seconds));
000024  e00e              B        |L33.68|
                  |L33.38|
;;;446      }
;;;447      else
;;;448      {
;;;449        if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
000026  482a              LDR      r0,|L33.208|
000028  6880              LDR      r0,[r0,#8]
00002a  2140              MOVS     r1,#0x40
00002c  4008              ANDS     r0,r0,r1
00002e  2800              CMP      r0,#0
000030  d004              BEQ      |L33.60|
;;;450        {
;;;451          tmpreg = RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
000032  7820              LDRB     r0,[r4,#0]
000034  f7fffffe          BL       RTC_Bcd2ToByte
000038  4606              MOV      r6,r0
;;;452          assert_param(IS_RTC_HOUR12(tmpreg));
;;;453          assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12)); 
00003a  e002              B        |L33.66|
                  |L33.60|
;;;454        } 
;;;455        else
;;;456        {
;;;457          RTC_TimeStruct->RTC_H12 = 0x00;
00003c  2000              MOVS     r0,#0
00003e  70e0              STRB     r0,[r4,#3]
;;;458          assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours)));
000040  bf00              NOP      
                  |L33.66|
;;;459        }
;;;460        assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes)));
;;;461        assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds)));
000042  bf00              NOP      
                  |L33.68|
;;;462      }
;;;463      
;;;464      /* Check the input parameters format */
;;;465      if (RTC_Format != RTC_Format_BIN)
000044  2d00              CMP      r5,#0
000046  d00b              BEQ      |L33.96|
;;;466      {
;;;467        tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
000048  7820              LDRB     r0,[r4,#0]
00004a  0400              LSLS     r0,r0,#16
00004c  7861              LDRB     r1,[r4,#1]
00004e  0209              LSLS     r1,r1,#8
000050  4308              ORRS     r0,r0,r1
000052  78a1              LDRB     r1,[r4,#2]
000054  4308              ORRS     r0,r0,r1
000056  78e1              LDRB     r1,[r4,#3]
000058  0409              LSLS     r1,r1,#16
00005a  4308              ORRS     r0,r0,r1
00005c  4606              MOV      r6,r0
00005e  e010              B        |L33.130|
                  |L33.96|
;;;468                 ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
;;;469                 ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
;;;470                 ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
;;;471      }
;;;472      else
;;;473      {
;;;474        tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
000060  7820              LDRB     r0,[r4,#0]
000062  f7fffffe          BL       RTC_ByteToBcd2
000066  0407              LSLS     r7,r0,#16
000068  7860              LDRB     r0,[r4,#1]
00006a  f7fffffe          BL       RTC_ByteToBcd2
00006e  0200              LSLS     r0,r0,#8
000070  4307              ORRS     r7,r7,r0
000072  78a0              LDRB     r0,[r4,#2]
000074  f7fffffe          BL       RTC_ByteToBcd2
000078  4307              ORRS     r7,r7,r0
00007a  78e0              LDRB     r0,[r4,#3]
00007c  0400              LSLS     r0,r0,#16
00007e  4307              ORRS     r7,r7,r0
000080  463e              MOV      r6,r7
                  |L33.130|
;;;475                       ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
;;;476                       ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Seconds)) | \
;;;477                       (((uint32_t)RTC_TimeStruct->RTC_H12) << 16));
;;;478      } 
;;;479    
;;;480      /* Disable the write protection for RTC registers */
;;;481      RTC->WPR = 0xCA;
000082  20ca              MOVS     r0,#0xca
000084  4912              LDR      r1,|L33.208|
000086  6248              STR      r0,[r1,#0x24]
;;;482      RTC->WPR = 0x53;
000088  2053              MOVS     r0,#0x53
00008a  6248              STR      r0,[r1,#0x24]
;;;483    
;;;484      /* Set Initialization mode */
;;;485      if (RTC_EnterInitMode() == ERROR)
00008c  f7fffffe          BL       RTC_EnterInitMode
000090  2800              CMP      r0,#0
000092  d101              BNE      |L33.152|
;;;486      {
;;;487        status = ERROR;
000094  9000              STR      r0,[sp,#0]
000096  e016              B        |L33.198|
                  |L33.152|
;;;488      } 
;;;489      else
;;;490      {
;;;491        /* Set the RTC_TR register */
;;;492        RTC->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
000098  480e              LDR      r0,|L33.212|
00009a  4030              ANDS     r0,r0,r6
00009c  490c              LDR      r1,|L33.208|
00009e  6008              STR      r0,[r1,#0]
;;;493    
;;;494        /* Exit Initialization mode */
;;;495        RTC_ExitInitMode(); 
0000a0  f7fffffe          BL       RTC_ExitInitMode
;;;496    	
;;;497        /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
;;;498        if ((RTC->CR & RTC_CR_BYPSHAD) == RESET)
0000a4  480a              LDR      r0,|L33.208|
0000a6  6880              LDR      r0,[r0,#8]
0000a8  2120              MOVS     r1,#0x20
0000aa  4008              ANDS     r0,r0,r1
0000ac  2800              CMP      r0,#0
0000ae  d108              BNE      |L33.194|
;;;499        {
;;;500          if (RTC_WaitForSynchro() == ERROR)
0000b0  f7fffffe          BL       RTC_WaitForSynchro
0000b4  2800              CMP      r0,#0
0000b6  d101              BNE      |L33.188|
;;;501          {
;;;502            status = ERROR;
0000b8  9000              STR      r0,[sp,#0]
0000ba  e004              B        |L33.198|
                  |L33.188|
;;;503          }
;;;504          else
;;;505          {
;;;506            status = SUCCESS;
0000bc  2001              MOVS     r0,#1
0000be  9000              STR      r0,[sp,#0]
0000c0  e001              B        |L33.198|
                  |L33.194|
;;;507          }
;;;508        }
;;;509        else
;;;510        {
;;;511          status = SUCCESS;
0000c2  2001              MOVS     r0,#1
0000c4  9000              STR      r0,[sp,#0]
                  |L33.198|
;;;512        }
;;;513      
;;;514      }
;;;515      /* Enable the write protection for RTC registers */
;;;516      RTC->WPR = 0xFF;
0000c6  20ff              MOVS     r0,#0xff
0000c8  4901              LDR      r1,|L33.208|
0000ca  6248              STR      r0,[r1,#0x24]
;;;517        
;;;518      return status;
0000cc  9800              LDR      r0,[sp,#0]
;;;519    }
0000ce  bdf8              POP      {r3-r7,pc}
;;;520    
                          ENDP

                  |L33.208|
                          DCD      0x40002800
                  |L33.212|
                          DCD      0x007f7f7f

                          AREA ||i.RTC_SmoothCalibConfig||, CODE, READONLY, ALIGN=2

                  RTC_SmoothCalibConfig PROC
;;;1238   */
;;;1239   ErrorStatus RTC_SmoothCalibConfig(uint32_t RTC_SmoothCalibPeriod,
000000  b570              PUSH     {r4-r6,lr}
;;;1240                                     uint32_t RTC_SmoothCalibPlusPulses,
;;;1241                                     uint32_t RTC_SmouthCalibMinusPulsesValue)
;;;1242   {
000002  4603              MOV      r3,r0
;;;1243     ErrorStatus status = ERROR;
000004  2000              MOVS     r0,#0
;;;1244     uint32_t recalpfcount = 0;
000006  2400              MOVS     r4,#0
;;;1245   
;;;1246     /* Check the parameters */
;;;1247     assert_param(IS_RTC_SMOOTH_CALIB_PERIOD(RTC_SmoothCalibPeriod));
;;;1248     assert_param(IS_RTC_SMOOTH_CALIB_PLUS(RTC_SmoothCalibPlusPulses));
;;;1249     assert_param(IS_RTC_SMOOTH_CALIB_MINUS(RTC_SmouthCalibMinusPulsesValue));
;;;1250   
;;;1251     /* Disable the write protection for RTC registers */
;;;1252     RTC->WPR = 0xCA;
000008  25ca              MOVS     r5,#0xca
00000a  4e14              LDR      r6,|L34.92|
00000c  6275              STR      r5,[r6,#0x24]
;;;1253     RTC->WPR = 0x53;
00000e  2553              MOVS     r5,#0x53
000010  6275              STR      r5,[r6,#0x24]
;;;1254     
;;;1255     /* check if a calibration is pending*/
;;;1256     if ((RTC->ISR & RTC_ISR_RECALPF) != RESET)
000012  4635              MOV      r5,r6
000014  68ed              LDR      r5,[r5,#0xc]
000016  13b6              ASRS     r6,r6,#14
000018  4035              ANDS     r5,r5,r6
00001a  2d00              CMP      r5,#0
00001c  d00b              BEQ      |L34.54|
;;;1257     {
;;;1258       /* wait until the Calibration is completed*/
;;;1259       while (((RTC->ISR & RTC_ISR_RECALPF) != RESET) && (recalpfcount != RECALPF_TIMEOUT))
00001e  e000              B        |L34.34|
                  |L34.32|
;;;1260       {
;;;1261         recalpfcount++;
000020  1c64              ADDS     r4,r4,#1
                  |L34.34|
000022  4d0e              LDR      r5,|L34.92|
000024  68ed              LDR      r5,[r5,#0xc]          ;1259
000026  2601              MOVS     r6,#1                 ;1259
000028  0436              LSLS     r6,r6,#16             ;1259
00002a  4035              ANDS     r5,r5,r6              ;1259
00002c  2d00              CMP      r5,#0                 ;1259
00002e  d002              BEQ      |L34.54|
000030  1135              ASRS     r5,r6,#4              ;1259
000032  42ac              CMP      r4,r5                 ;1259
000034  d1f4              BNE      |L34.32|
                  |L34.54|
;;;1262       }
;;;1263     }
;;;1264   
;;;1265     /* check if the calibration pending is completed or if there is no calibration operation at all*/
;;;1266     if ((RTC->ISR & RTC_ISR_RECALPF) == RESET)
000036  4d09              LDR      r5,|L34.92|
000038  68ed              LDR      r5,[r5,#0xc]
00003a  2601              MOVS     r6,#1
00003c  0436              LSLS     r6,r6,#16
00003e  4035              ANDS     r5,r5,r6
000040  2d00              CMP      r5,#0
000042  d106              BNE      |L34.82|
;;;1267     {
;;;1268       /* Configure the Smooth calibration settings */
;;;1269       RTC->CALR = (uint32_t)((uint32_t)RTC_SmoothCalibPeriod | (uint32_t)RTC_SmoothCalibPlusPulses | (uint32_t)RTC_SmouthCalibMinusPulsesValue);
000044  461d              MOV      r5,r3
000046  430d              ORRS     r5,r5,r1
000048  4315              ORRS     r5,r5,r2
00004a  4e04              LDR      r6,|L34.92|
00004c  63f5              STR      r5,[r6,#0x3c]
;;;1270   
;;;1271       status = SUCCESS;
00004e  2001              MOVS     r0,#1
000050  e000              B        |L34.84|
                  |L34.82|
;;;1272     }
;;;1273     else
;;;1274     {
;;;1275       status = ERROR;
000052  2000              MOVS     r0,#0
                  |L34.84|
;;;1276     }
;;;1277   
;;;1278     /* Enable the write protection for RTC registers */
;;;1279     RTC->WPR = 0xFF;
000054  25ff              MOVS     r5,#0xff
000056  4e01              LDR      r6,|L34.92|
000058  6275              STR      r5,[r6,#0x24]
;;;1280     
;;;1281     return (ErrorStatus)(status);
;;;1282   }
00005a  bd70              POP      {r4-r6,pc}
;;;1283   
                          ENDP

                  |L34.92|
                          DCD      0x40002800

                          AREA ||i.RTC_StructInit||, CODE, READONLY, ALIGN=1

                  RTC_StructInit PROC
;;;162      */
;;;163    void RTC_StructInit(RTC_InitTypeDef* RTC_InitStruct)
000000  2100              MOVS     r1,#0
;;;164    {
;;;165      /* Initialize the RTC_HourFormat member */
;;;166      RTC_InitStruct->RTC_HourFormat = RTC_HourFormat_24;
000002  6001              STR      r1,[r0,#0]
;;;167    
;;;168      /* Initialize the RTC_AsynchPrediv member */
;;;169      RTC_InitStruct->RTC_AsynchPrediv = (uint32_t)0x7F;
000004  217f              MOVS     r1,#0x7f
000006  6041              STR      r1,[r0,#4]
;;;170    
;;;171      /* Initialize the RTC_SynchPrediv member */
;;;172      RTC_InitStruct->RTC_SynchPrediv = (uint32_t)0xFF; 
000008  21ff              MOVS     r1,#0xff
00000a  6081              STR      r1,[r0,#8]
;;;173    }
00000c  4770              BX       lr
;;;174    
                          ENDP


                          AREA ||i.RTC_SynchroShiftConfig||, CODE, READONLY, ALIGN=2

                  RTC_SynchroShiftConfig PROC
;;;1628   */
;;;1629   ErrorStatus RTC_SynchroShiftConfig(uint32_t RTC_ShiftAdd1S, uint32_t RTC_ShiftSubFS)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1630   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1631     ErrorStatus status = ERROR;
000006  2700              MOVS     r7,#0
;;;1632     uint32_t shpfcount = 0;
000008  2600              MOVS     r6,#0
;;;1633   
;;;1634     /* Check the parameters */
;;;1635     assert_param(IS_RTC_SHIFT_ADD1S(RTC_ShiftAdd1S));
;;;1636     assert_param(IS_RTC_SHIFT_SUBFS(RTC_ShiftSubFS));
;;;1637   
;;;1638     /* Disable the write protection for RTC registers */
;;;1639     RTC->WPR = 0xCA;
00000a  20ca              MOVS     r0,#0xca
00000c  491a              LDR      r1,|L36.120|
00000e  6248              STR      r0,[r1,#0x24]
;;;1640     RTC->WPR = 0x53;
000010  2053              MOVS     r0,#0x53
000012  6248              STR      r0,[r1,#0x24]
;;;1641     
;;;1642     /* Check if a Shift is pending*/
;;;1643     if ((RTC->ISR & RTC_ISR_SHPF) != RESET)
000014  4608              MOV      r0,r1
000016  68c0              LDR      r0,[r0,#0xc]
000018  2108              MOVS     r1,#8
00001a  4008              ANDS     r0,r0,r1
00001c  2800              CMP      r0,#0
00001e  d00a              BEQ      |L36.54|
;;;1644     {
;;;1645       /* Wait until the shift is completed*/
;;;1646       while (((RTC->ISR & RTC_ISR_SHPF) != RESET) && (shpfcount != SHPF_TIMEOUT))
000020  e000              B        |L36.36|
                  |L36.34|
;;;1647       {
;;;1648         shpfcount++;
000022  1c76              ADDS     r6,r6,#1
                  |L36.36|
000024  4814              LDR      r0,|L36.120|
000026  68c0              LDR      r0,[r0,#0xc]          ;1646
000028  2108              MOVS     r1,#8                 ;1646
00002a  4008              ANDS     r0,r0,r1              ;1646
00002c  2800              CMP      r0,#0                 ;1646
00002e  d002              BEQ      |L36.54|
000030  0248              LSLS     r0,r1,#9              ;1646
000032  4286              CMP      r6,r0                 ;1646
000034  d1f5              BNE      |L36.34|
                  |L36.54|
;;;1649       }
;;;1650     }
;;;1651   
;;;1652     /* Check if the Shift pending is completed or if there is no Shift operation at all*/
;;;1653     if ((RTC->ISR & RTC_ISR_SHPF) == RESET)
000036  4810              LDR      r0,|L36.120|
000038  68c0              LDR      r0,[r0,#0xc]
00003a  2108              MOVS     r1,#8
00003c  4008              ANDS     r0,r0,r1
00003e  2800              CMP      r0,#0
000040  d113              BNE      |L36.106|
;;;1654     {
;;;1655       /* check if the reference clock detection is disabled */
;;;1656       if((RTC->CR & RTC_CR_REFCKON) == RESET)
000042  480d              LDR      r0,|L36.120|
000044  6880              LDR      r0,[r0,#8]
000046  2110              MOVS     r1,#0x10
000048  4008              ANDS     r0,r0,r1
00004a  2800              CMP      r0,#0
00004c  d10b              BNE      |L36.102|
;;;1657       {
;;;1658         /* Configure the Shift settings */
;;;1659         RTC->SHIFTR = (uint32_t)(uint32_t)(RTC_ShiftSubFS) | (uint32_t)(RTC_ShiftAdd1S);
00004e  4628              MOV      r0,r5
000050  4320              ORRS     r0,r0,r4
000052  4909              LDR      r1,|L36.120|
000054  62c8              STR      r0,[r1,#0x2c]
;;;1660       
;;;1661         if(RTC_WaitForSynchro() == ERROR)
000056  f7fffffe          BL       RTC_WaitForSynchro
00005a  2800              CMP      r0,#0
00005c  d101              BNE      |L36.98|
;;;1662         {
;;;1663           status = ERROR;
00005e  2700              MOVS     r7,#0
000060  e004              B        |L36.108|
                  |L36.98|
;;;1664         }
;;;1665         else
;;;1666         {
;;;1667           status = SUCCESS;
000062  2701              MOVS     r7,#1
000064  e002              B        |L36.108|
                  |L36.102|
;;;1668         }
;;;1669       }
;;;1670       else
;;;1671       {
;;;1672         status = ERROR;
000066  2700              MOVS     r7,#0
000068  e000              B        |L36.108|
                  |L36.106|
;;;1673       }
;;;1674     }
;;;1675     else
;;;1676     {
;;;1677       status = ERROR;
00006a  2700              MOVS     r7,#0
                  |L36.108|
;;;1678     }
;;;1679   
;;;1680     /* Enable the write protection for RTC registers */
;;;1681     RTC->WPR = 0xFF;
00006c  20ff              MOVS     r0,#0xff
00006e  4902              LDR      r1,|L36.120|
000070  6248              STR      r0,[r1,#0x24]
;;;1682     
;;;1683     return (ErrorStatus)(status);
000072  4638              MOV      r0,r7
;;;1684   }
000074  bdf0              POP      {r4-r7,pc}
;;;1685   
                          ENDP

000076  0000              DCW      0x0000
                  |L36.120|
                          DCD      0x40002800

                          AREA ||i.RTC_TamperCmd||, CODE, READONLY, ALIGN=2

                  RTC_TamperCmd PROC
;;;1442     */
;;;1443   void RTC_TamperCmd(uint32_t RTC_Tamper, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1444   {
;;;1445     /* Check the parameters */
;;;1446     assert_param(IS_RTC_TAMPER(RTC_Tamper));  
;;;1447     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1448     
;;;1449     if (NewState != DISABLE)
000002  d005              BEQ      |L37.16|
;;;1450     {
;;;1451       /* Enable the selected Tamper pin */
;;;1452       RTC->TAFCR |= (uint32_t)RTC_Tamper;
000004  4a05              LDR      r2,|L37.28|
000006  6812              LDR      r2,[r2,#0]
000008  4302              ORRS     r2,r2,r0
00000a  4b04              LDR      r3,|L37.28|
00000c  601a              STR      r2,[r3,#0]
00000e  e004              B        |L37.26|
                  |L37.16|
;;;1453     }
;;;1454     else
;;;1455     {
;;;1456       /* Disable the selected Tamper pin */
;;;1457       RTC->TAFCR &= (uint32_t)~RTC_Tamper;    
000010  4a02              LDR      r2,|L37.28|
000012  6812              LDR      r2,[r2,#0]
000014  4382              BICS     r2,r2,r0
000016  4b01              LDR      r3,|L37.28|
000018  601a              STR      r2,[r3,#0]
                  |L37.26|
;;;1458     }  
;;;1459   }
00001a  4770              BX       lr
;;;1460   
                          ENDP

                  |L37.28|
                          DCD      0x40002840

                          AREA ||i.RTC_TamperFilterConfig||, CODE, READONLY, ALIGN=2

                  RTC_TamperFilterConfig PROC
;;;1473     */
;;;1474   void RTC_TamperFilterConfig(uint32_t RTC_TamperFilter)
000000  4905              LDR      r1,|L38.24|
;;;1475   {
;;;1476     /* Check the parameters */
;;;1477     assert_param(IS_RTC_TAMPER_FILTER(RTC_TamperFilter));
;;;1478      
;;;1479     /* Clear TAMPFLT[1:0] bits in the RTC_TAFCR register */
;;;1480     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFLT);
000002  6809              LDR      r1,[r1,#0]
000004  2203              MOVS     r2,#3
000006  02d2              LSLS     r2,r2,#11
000008  4391              BICS     r1,r1,r2
00000a  4a03              LDR      r2,|L38.24|
00000c  6011              STR      r1,[r2,#0]
;;;1481   
;;;1482     /* Configure the RTC_TAFCR register */
;;;1483     RTC->TAFCR |= (uint32_t)RTC_TamperFilter;
00000e  4611              MOV      r1,r2
000010  6809              LDR      r1,[r1,#0]
000012  4301              ORRS     r1,r1,r0
000014  6011              STR      r1,[r2,#0]
;;;1484   }
000016  4770              BX       lr
;;;1485   
                          ENDP

                  |L38.24|
                          DCD      0x40002840

                          AREA ||i.RTC_TamperPinsPrechargeDuration||, CODE, READONLY, ALIGN=2

                  RTC_TamperPinsPrechargeDuration PROC
;;;1530     */
;;;1531   void RTC_TamperPinsPrechargeDuration(uint32_t RTC_TamperPrechargeDuration)
000000  4905              LDR      r1,|L39.24|
;;;1532   {
;;;1533     /* Check the parameters */
;;;1534     assert_param(IS_RTC_TAMPER_PRECHARGE_DURATION(RTC_TamperPrechargeDuration));
;;;1535      
;;;1536     /* Clear TAMPPRCH[1:0] bits in the RTC_TAFCR register */
;;;1537     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPPRCH);
000002  6809              LDR      r1,[r1,#0]
000004  2203              MOVS     r2,#3
000006  0352              LSLS     r2,r2,#13
000008  4391              BICS     r1,r1,r2
00000a  4a03              LDR      r2,|L39.24|
00000c  6011              STR      r1,[r2,#0]
;;;1538   
;;;1539     /* Configure the RTC_TAFCR register */
;;;1540     RTC->TAFCR |= (uint32_t)RTC_TamperPrechargeDuration;
00000e  4611              MOV      r1,r2
000010  6809              LDR      r1,[r1,#0]
000012  4301              ORRS     r1,r1,r0
000014  6011              STR      r1,[r2,#0]
;;;1541   }
000016  4770              BX       lr
;;;1542   
                          ENDP

                  |L39.24|
                          DCD      0x40002840

                          AREA ||i.RTC_TamperPullUpCmd||, CODE, READONLY, ALIGN=2

                  RTC_TamperPullUpCmd PROC
;;;1573     */
;;;1574   void RTC_TamperPullUpCmd(FunctionalState NewState)
000000  2800              CMP      r0,#0
;;;1575   {
;;;1576     /* Check the parameters */
;;;1577     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1578     
;;;1579    if (NewState != DISABLE)
000002  d007              BEQ      |L40.20|
;;;1580     {
;;;1581       /* Enable precharge of the selected Tamper pin */
;;;1582       RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPPUDIS; 
000004  4907              LDR      r1,|L40.36|
000006  6809              LDR      r1,[r1,#0]
000008  2201              MOVS     r2,#1
00000a  03d2              LSLS     r2,r2,#15
00000c  4391              BICS     r1,r1,r2
00000e  4a05              LDR      r2,|L40.36|
000010  6011              STR      r1,[r2,#0]
000012  e006              B        |L40.34|
                  |L40.20|
;;;1583     }
;;;1584     else
;;;1585     {
;;;1586       /* Disable precharge of the selected Tamper pin */
;;;1587       RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPPUDIS;    
000014  4903              LDR      r1,|L40.36|
000016  6809              LDR      r1,[r1,#0]
000018  2201              MOVS     r2,#1
00001a  03d2              LSLS     r2,r2,#15
00001c  4311              ORRS     r1,r1,r2
00001e  4a01              LDR      r2,|L40.36|
000020  6011              STR      r1,[r2,#0]
                  |L40.34|
;;;1588     } 
;;;1589   }
000022  4770              BX       lr
;;;1590   
                          ENDP

                  |L40.36|
                          DCD      0x40002840

                          AREA ||i.RTC_TamperSamplingFreqConfig||, CODE, READONLY, ALIGN=2

                  RTC_TamperSamplingFreqConfig PROC
;;;1507     */
;;;1508   void RTC_TamperSamplingFreqConfig(uint32_t RTC_TamperSamplingFreq)
000000  4905              LDR      r1,|L41.24|
;;;1509   {
;;;1510     /* Check the parameters */
;;;1511     assert_param(IS_RTC_TAMPER_SAMPLING_FREQ(RTC_TamperSamplingFreq));
;;;1512    
;;;1513     /* Clear TAMPFREQ[2:0] bits in the RTC_TAFCR register */
;;;1514     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFREQ);
000002  6809              LDR      r1,[r1,#0]
000004  2207              MOVS     r2,#7
000006  0212              LSLS     r2,r2,#8
000008  4391              BICS     r1,r1,r2
00000a  4a03              LDR      r2,|L41.24|
00000c  6011              STR      r1,[r2,#0]
;;;1515   
;;;1516     /* Configure the RTC_TAFCR register */
;;;1517     RTC->TAFCR |= (uint32_t)RTC_TamperSamplingFreq;
00000e  4611              MOV      r1,r2
000010  6809              LDR      r1,[r1,#0]
000012  4301              ORRS     r1,r1,r0
000014  6011              STR      r1,[r2,#0]
;;;1518   }
000016  4770              BX       lr
;;;1519   
                          ENDP

                  |L41.24|
                          DCD      0x40002840

                          AREA ||i.RTC_TamperTriggerConfig||, CODE, READONLY, ALIGN=2

                  RTC_TamperTriggerConfig PROC
;;;1414     */
;;;1415   void RTC_TamperTriggerConfig(uint32_t RTC_Tamper, uint32_t RTC_TamperTrigger)
000000  2900              CMP      r1,#0
;;;1416   {
;;;1417     /* Check the parameters */
;;;1418     assert_param(IS_RTC_TAMPER(RTC_Tamper)); 
;;;1419     assert_param(IS_RTC_TAMPER_TRIGGER(RTC_TamperTrigger));
;;;1420    
;;;1421     if (RTC_TamperTrigger == RTC_TamperTrigger_RisingEdge)
000002  d106              BNE      |L42.18|
;;;1422     {  
;;;1423       /* Configure the RTC_TAFCR register */
;;;1424       RTC->TAFCR &= (uint32_t)((uint32_t)~(RTC_Tamper << 1));	
000004  4a06              LDR      r2,|L42.32|
000006  6812              LDR      r2,[r2,#0]
000008  0043              LSLS     r3,r0,#1
00000a  439a              BICS     r2,r2,r3
00000c  4b04              LDR      r3,|L42.32|
00000e  601a              STR      r2,[r3,#0]
000010  e005              B        |L42.30|
                  |L42.18|
;;;1425     }
;;;1426     else
;;;1427     { 
;;;1428       /* Configure the RTC_TAFCR register */
;;;1429       RTC->TAFCR |= (uint32_t)(RTC_Tamper << 1);  
000012  4a03              LDR      r2,|L42.32|
000014  6812              LDR      r2,[r2,#0]
000016  0043              LSLS     r3,r0,#1
000018  431a              ORRS     r2,r2,r3
00001a  4b01              LDR      r3,|L42.32|
00001c  601a              STR      r2,[r3,#0]
                  |L42.30|
;;;1430     }  
;;;1431   }
00001e  4770              BX       lr
;;;1432   
                          ENDP

                  |L42.32|
                          DCD      0x40002840

                          AREA ||i.RTC_TimeStampCmd||, CODE, READONLY, ALIGN=2

                  RTC_TimeStampCmd PROC
;;;1301     */
;;;1302   void RTC_TimeStampCmd(uint32_t RTC_TimeStampEdge, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;1303   {
000002  460a              MOV      r2,r1
;;;1304     uint32_t tmpreg = 0;
000004  2100              MOVS     r1,#0
;;;1305   
;;;1306   	/*��Edge�ĸ��û�д�λ�Ķ���*/
;;;1307     /* Check the parameters */
;;;1308     assert_param(IS_RTC_TIMESTAMP_EDGE(RTC_TimeStampEdge));
;;;1309     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1310   
;;;1311     /* Get the RTC_CR register and clear the bits to be configured */
;;;1312     tmpreg = (uint32_t)(RTC->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
000006  4b0c              LDR      r3,|L43.56|
000008  689b              LDR      r3,[r3,#8]
00000a  4c0c              LDR      r4,|L43.60|
00000c  4023              ANDS     r3,r3,r4
00000e  4619              MOV      r1,r3
;;;1313   
;;;1314     /* Get the new configuration */
;;;1315     if (NewState != DISABLE)
000010  2a00              CMP      r2,#0
000012  d004              BEQ      |L43.30|
;;;1316     {
;;;1317       tmpreg |= (uint32_t)(RTC_TimeStampEdge | RTC_CR_TSE);
000014  2301              MOVS     r3,#1
000016  02db              LSLS     r3,r3,#11
000018  4303              ORRS     r3,r3,r0
00001a  4319              ORRS     r1,r1,r3
00001c  e002              B        |L43.36|
                  |L43.30|
;;;1318     }
;;;1319     else
;;;1320     {
;;;1321       tmpreg |= (uint32_t)(RTC_TimeStampEdge);
00001e  460b              MOV      r3,r1
000020  4303              ORRS     r3,r3,r0
000022  4619              MOV      r1,r3
                  |L43.36|
;;;1322     }
;;;1323   
;;;1324     /* Disable the write protection for RTC registers */
;;;1325     RTC->WPR = 0xCA;
000024  23ca              MOVS     r3,#0xca
000026  4c04              LDR      r4,|L43.56|
000028  6263              STR      r3,[r4,#0x24]
;;;1326     RTC->WPR = 0x53;
00002a  2353              MOVS     r3,#0x53
00002c  6263              STR      r3,[r4,#0x24]
;;;1327   
;;;1328     /* Configure the Time Stamp TSEDGE and Enable bits */
;;;1329     RTC->CR = (uint32_t)tmpreg;
00002e  4623              MOV      r3,r4
000030  6099              STR      r1,[r3,#8]
;;;1330   
;;;1331     /* Enable the write protection for RTC registers */
;;;1332     RTC->WPR = 0xFF;
000032  23ff              MOVS     r3,#0xff
000034  6263              STR      r3,[r4,#0x24]
;;;1333   }
000036  bd10              POP      {r4,pc}
;;;1334   
                          ENDP

                  |L43.56|
                          DCD      0x40002800
                  |L43.60|
                          DCD      0xfffff7f7

                          AREA ||i.RTC_TimeStampOnTamperDetectionCmd||, CODE, READONLY, ALIGN=2

                  RTC_TimeStampOnTamperDetectionCmd PROC
;;;1550     */
;;;1551   void RTC_TimeStampOnTamperDetectionCmd(FunctionalState NewState)
000000  2800              CMP      r0,#0
;;;1552   {
;;;1553     /* Check the parameters */
;;;1554     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1555      
;;;1556     if (NewState != DISABLE)
000002  d006              BEQ      |L44.18|
;;;1557     {
;;;1558       /* Save timestamp on tamper detection event */
;;;1559       RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPTS;
000004  4906              LDR      r1,|L44.32|
000006  6809              LDR      r1,[r1,#0]
000008  2280              MOVS     r2,#0x80
00000a  4311              ORRS     r1,r1,r2
00000c  4a04              LDR      r2,|L44.32|
00000e  6011              STR      r1,[r2,#0]
000010  e005              B        |L44.30|
                  |L44.18|
;;;1560     }
;;;1561     else
;;;1562     {
;;;1563       /* Tamper detection does not cause a timestamp to be saved */
;;;1564       RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPTS;    
000012  4903              LDR      r1,|L44.32|
000014  6809              LDR      r1,[r1,#0]
000016  2280              MOVS     r2,#0x80
000018  4391              BICS     r1,r1,r2
00001a  4a01              LDR      r2,|L44.32|
00001c  6011              STR      r1,[r2,#0]
                  |L44.30|
;;;1565     }
;;;1566   }
00001e  4770              BX       lr
;;;1567   
                          ENDP

                  |L44.32|
                          DCD      0x40002840

                          AREA ||i.RTC_TimeStructInit||, CODE, READONLY, ALIGN=1

                  RTC_TimeStructInit PROC
;;;527      */
;;;528    void RTC_TimeStructInit(RTC_TimeTypeDef* RTC_TimeStruct)
000000  2100              MOVS     r1,#0
;;;529    {
;;;530      /* Time = 00h:00min:00sec */
;;;531      RTC_TimeStruct->RTC_H12 = RTC_H12_AM;
000002  70c1              STRB     r1,[r0,#3]
;;;532      RTC_TimeStruct->RTC_Hours = 0;
000004  7001              STRB     r1,[r0,#0]
;;;533      RTC_TimeStruct->RTC_Minutes = 0;
000006  7041              STRB     r1,[r0,#1]
;;;534      RTC_TimeStruct->RTC_Seconds = 0; 
000008  7081              STRB     r1,[r0,#2]
;;;535    }
00000a  4770              BX       lr
;;;536    
                          ENDP


                          AREA ||i.RTC_WaitForSynchro||, CODE, READONLY, ALIGN=2

                  RTC_WaitForSynchro PROC
;;;284      */
;;;285    ErrorStatus RTC_WaitForSynchro(void)
000000  b508              PUSH     {r3,lr}
;;;286    {
;;;287      __IO uint32_t synchrocounter = 0;
000002  2200              MOVS     r2,#0
000004  9200              STR      r2,[sp,#0]
;;;288      ErrorStatus status = ERROR;
000006  2000              MOVS     r0,#0
;;;289      uint32_t synchrostatus = 0x00;
000008  2100              MOVS     r1,#0
;;;290    
;;;291      if ((RTC->CR & RTC_CR_BYPSHAD) != RESET)
00000a  4a17              LDR      r2,|L46.104|
00000c  6892              LDR      r2,[r2,#8]
00000e  2320              MOVS     r3,#0x20
000010  401a              ANDS     r2,r2,r3
000012  2a00              CMP      r2,#0
000014  d001              BEQ      |L46.26|
;;;292      {
;;;293        /* Bypass shadow mode */
;;;294        status = SUCCESS;
000016  2001              MOVS     r0,#1
000018  e025              B        |L46.102|
                  |L46.26|
;;;295      }
;;;296      else
;;;297      {
;;;298        /* Disable the write protection for RTC registers */
;;;299        RTC->WPR = 0xCA;
00001a  22ca              MOVS     r2,#0xca
00001c  4b12              LDR      r3,|L46.104|
00001e  625a              STR      r2,[r3,#0x24]
;;;300        RTC->WPR = 0x53;
000020  2253              MOVS     r2,#0x53
000022  625a              STR      r2,[r3,#0x24]
;;;301    
;;;302        /* Clear RSF flag */
;;;303        RTC->ISR &= (uint32_t)RTC_RSF_MASK;
000024  461a              MOV      r2,r3
000026  68d2              LDR      r2,[r2,#0xc]
000028  23a0              MOVS     r3,#0xa0
00002a  439a              BICS     r2,r2,r3
00002c  4b0e              LDR      r3,|L46.104|
00002e  60da              STR      r2,[r3,#0xc]
;;;304    
;;;305        /* Wait the registers to be synchronised */
;;;306        do
000030  bf00              NOP      
                  |L46.50|
;;;307        {
;;;308          synchrostatus = RTC->ISR & RTC_ISR_RSF;
000032  4a0d              LDR      r2,|L46.104|
000034  68d2              LDR      r2,[r2,#0xc]
000036  2320              MOVS     r3,#0x20
000038  401a              ANDS     r2,r2,r3
00003a  4611              MOV      r1,r2
;;;309          synchrocounter++;  
00003c  9a00              LDR      r2,[sp,#0]
00003e  1c52              ADDS     r2,r2,#1
000040  9200              STR      r2,[sp,#0]
;;;310        } while((synchrocounter != SYNCHRO_TIMEOUT) && (synchrostatus == 0x00));
000042  029b              LSLS     r3,r3,#10
000044  9a00              LDR      r2,[sp,#0]
000046  429a              CMP      r2,r3
000048  d001              BEQ      |L46.78|
00004a  2900              CMP      r1,#0
00004c  d0f1              BEQ      |L46.50|
                  |L46.78|
;;;311    
;;;312        if ((RTC->ISR & RTC_ISR_RSF) != RESET)
00004e  4a06              LDR      r2,|L46.104|
000050  68d2              LDR      r2,[r2,#0xc]
000052  2320              MOVS     r3,#0x20
000054  401a              ANDS     r2,r2,r3
000056  2a00              CMP      r2,#0
000058  d001              BEQ      |L46.94|
;;;313        {
;;;314          status = SUCCESS;
00005a  2001              MOVS     r0,#1
00005c  e000              B        |L46.96|
                  |L46.94|
;;;315        }
;;;316        else
;;;317        {
;;;318          status = ERROR;
00005e  2000              MOVS     r0,#0
                  |L46.96|
;;;319        }
;;;320    
;;;321        /* Disable the write protection for RTC registers */
;;;322        RTC->WPR = 0xFF;
000060  22ff              MOVS     r2,#0xff
000062  4b01              LDR      r3,|L46.104|
000064  625a              STR      r2,[r3,#0x24]
                  |L46.102|
;;;323      }
;;;324    
;;;325      return (status);
;;;326    }
000066  bd08              POP      {r3,pc}
;;;327    
                          ENDP

                  |L46.104|
                          DCD      0x40002800

                          AREA ||i.RTC_WriteProtectionCmd||, CODE, READONLY, ALIGN=2

                  RTC_WriteProtectionCmd PROC
;;;184      */
;;;185    void RTC_WriteProtectionCmd(FunctionalState NewState)
000000  2800              CMP      r0,#0
;;;186    {
;;;187      /* Check the parameters */
;;;188      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;189    
;;;190      if (NewState != DISABLE)
000002  d003              BEQ      |L47.12|
;;;191      {
;;;192        /* Enable the write protection for RTC registers */
;;;193        RTC->WPR = 0xFF;
000004  21ff              MOVS     r1,#0xff
000006  4a04              LDR      r2,|L47.24|
000008  6251              STR      r1,[r2,#0x24]
00000a  e004              B        |L47.22|
                  |L47.12|
;;;194      }
;;;195      else
;;;196      {
;;;197        /* Disable the write protection for RTC registers */
;;;198        RTC->WPR = 0xCA;
00000c  21ca              MOVS     r1,#0xca
00000e  4a02              LDR      r2,|L47.24|
000010  6251              STR      r1,[r2,#0x24]
;;;199        RTC->WPR = 0x53;
000012  2153              MOVS     r1,#0x53
000014  6251              STR      r1,[r2,#0x24]
                  |L47.22|
;;;200      }
;;;201    }
000016  4770              BX       lr
;;;202    
                          ENDP

                  |L47.24|
                          DCD      0x40002800

;*** Start embedded assembler ***

#line 1 "..\\FTLib\\Src\\ft32f0xx_rtc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_ft32f0xx_rtc_c_81435638____REV16|
#line 129 "..\\FTLib\\CMSIS\\inc\\core_cmInstr.h"
|__asm___14_ft32f0xx_rtc_c_81435638____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_ft32f0xx_rtc_c_81435638____REVSH|
#line 144
|__asm___14_ft32f0xx_rtc_c_81435638____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
