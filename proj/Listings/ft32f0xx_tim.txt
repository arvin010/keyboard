; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\ft32f0xx_tim.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\ft32f0xx_tim.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\FTLib\CMSIS\inc -I..\FTLib\Inc -I..\FTLib\Lib -I..\usb\inc -I..\user -I..\RTT -I..\iap2 -IC:\Users\dell1\AppData\Local\Arm\Packs\FMD\FT32F0xx_DFP\1.0.6\Drivers\CMSIS\FT32F0xx\Include -D__UVISION_VERSION=534 -DFT32F072x8 -DFT32F072x8 --omf_browse=.\objects\ft32f0xx_tim.crf ..\FTLib\Src\ft32f0xx_tim.c]
                          THUMB

                          AREA ||i.TI1_Config||, CODE, READONLY, ALIGN=2

                  TI1_Config PROC
;;;2741     */
;;;2742   static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000000  b5f0              PUSH     {r4-r7,lr}
;;;2743                          uint16_t TIM_ICFilter)
;;;2744   {
000002  460c              MOV      r4,r1
;;;2745     uint16_t tmpccmr1 = 0, tmpccer = 0;
000004  2100              MOVS     r1,#0
000006  2500              MOVS     r5,#0
;;;2746     /* Disable the Channel 1: Reset the CC1E Bit */
;;;2747     TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC1E);
000008  8c06              LDRH     r6,[r0,#0x20]
00000a  4f0a              LDR      r7,|L1.52|
00000c  403e              ANDS     r6,r6,r7
00000e  8406              STRH     r6,[r0,#0x20]
;;;2748     tmpccmr1 = TIMx->CCMR1;
000010  8b01              LDRH     r1,[r0,#0x18]
;;;2749     tmpccer = TIMx->CCER;
000012  8c05              LDRH     r5,[r0,#0x20]
;;;2750     /* Select the Input and set the filter */
;;;2751     tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC1F)));
000014  4e07              LDR      r6,|L1.52|
000016  3ef2              SUBS     r6,r6,#0xf2
000018  4031              ANDS     r1,r1,r6
;;;2752     tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
00001a  051e              LSLS     r6,r3,#20
00001c  0c36              LSRS     r6,r6,#16
00001e  4316              ORRS     r6,r6,r2
000020  4331              ORRS     r1,r1,r6
;;;2753    
;;;2754     /* Select the Polarity and set the CC1E Bit */
;;;2755     tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC1P | TIM_CCER_CC1NP));
000022  4e04              LDR      r6,|L1.52|
000024  3e09              SUBS     r6,r6,#9
000026  4035              ANDS     r5,r5,r6
;;;2756     tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
000028  2601              MOVS     r6,#1
00002a  4326              ORRS     r6,r6,r4
00002c  4335              ORRS     r5,r5,r6
;;;2757     /* Write to TIMx CCMR1 and CCER registers */
;;;2758     TIMx->CCMR1 = tmpccmr1;
00002e  8301              STRH     r1,[r0,#0x18]
;;;2759     TIMx->CCER = tmpccer;
000030  8405              STRH     r5,[r0,#0x20]
;;;2760   }
000032  bdf0              POP      {r4-r7,pc}
;;;2761   
                          ENDP

                  |L1.52|
                          DCD      0x0000fffe

                          AREA ||i.TI2_Config||, CODE, READONLY, ALIGN=2

                  TI2_Config PROC
;;;2777     */
;;;2778   static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000000  b5f8              PUSH     {r3-r7,lr}
;;;2779                          uint16_t TIM_ICFilter)
;;;2780   {
000002  460c              MOV      r4,r1
;;;2781     uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
000004  2100              MOVS     r1,#0
000006  2500              MOVS     r5,#0
000008  2600              MOVS     r6,#0
00000a  9600              STR      r6,[sp,#0]
;;;2782     /* Disable the Channel 2: Reset the CC2E Bit */
;;;2783     TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC2E);
00000c  8c06              LDRH     r6,[r0,#0x20]
00000e  4f0d              LDR      r7,|L2.68|
000010  403e              ANDS     r6,r6,r7
000012  8406              STRH     r6,[r0,#0x20]
;;;2784     tmpccmr1 = TIMx->CCMR1;
000014  8b01              LDRH     r1,[r0,#0x18]
;;;2785     tmpccer = TIMx->CCER;
000016  8c05              LDRH     r5,[r0,#0x20]
;;;2786     tmp = (uint16_t)(TIM_ICPolarity << 4);
000018  0526              LSLS     r6,r4,#20
00001a  0c36              LSRS     r6,r6,#16
00001c  9600              STR      r6,[sp,#0]
;;;2787     /* Select the Input and set the filter */
;;;2788     tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC2S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC2F)));
00001e  4e0a              LDR      r6,|L2.72|
000020  4031              ANDS     r1,r1,r6
;;;2789     tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
000022  071e              LSLS     r6,r3,#28
000024  0c36              LSRS     r6,r6,#16
000026  4331              ORRS     r1,r1,r6
;;;2790     tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8); 
000028  0616              LSLS     r6,r2,#24
00002a  0c36              LSRS     r6,r6,#16
00002c  4331              ORRS     r1,r1,r6
;;;2791     /* Select the Polarity and set the CC2E Bit */
;;;2792     tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC2P | TIM_CCER_CC2NP));
00002e  4e05              LDR      r6,|L2.68|
000030  3e90              SUBS     r6,r6,#0x90
000032  4035              ANDS     r5,r5,r6
;;;2793     tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);  
000034  2710              MOVS     r7,#0x10
000036  9e00              LDR      r6,[sp,#0]
000038  433e              ORRS     r6,r6,r7
00003a  4335              ORRS     r5,r5,r6
;;;2794     /* Write to TIMx CCMR1 and CCER registers */
;;;2795     TIMx->CCMR1 = tmpccmr1 ;
00003c  8301              STRH     r1,[r0,#0x18]
;;;2796     TIMx->CCER = tmpccer;
00003e  8405              STRH     r5,[r0,#0x20]
;;;2797   }
000040  bdf8              POP      {r3-r7,pc}
;;;2798   
                          ENDP

000042  0000              DCW      0x0000
                  |L2.68|
                          DCD      0x0000ffef
                  |L2.72|
                          DCD      0x00000cff

                          AREA ||i.TI3_Config||, CODE, READONLY, ALIGN=2

                  TI3_Config PROC
;;;2814     */
;;;2815   static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000000  b5f8              PUSH     {r3-r7,lr}
;;;2816                          uint16_t TIM_ICFilter)
;;;2817   {
000002  460c              MOV      r4,r1
;;;2818     uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
000004  2100              MOVS     r1,#0
000006  2500              MOVS     r5,#0
000008  2600              MOVS     r6,#0
00000a  9600              STR      r6,[sp,#0]
;;;2819     /* Disable the Channel 3: Reset the CC3E Bit */
;;;2820     TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC3E);
00000c  8c06              LDRH     r6,[r0,#0x20]
00000e  4f0c              LDR      r7,|L3.64|
000010  403e              ANDS     r6,r6,r7
000012  8406              STRH     r6,[r0,#0x20]
;;;2821     tmpccmr2 = TIMx->CCMR2;
000014  8b81              LDRH     r1,[r0,#0x1c]
;;;2822     tmpccer = TIMx->CCER;
000016  8c05              LDRH     r5,[r0,#0x20]
;;;2823     tmp = (uint16_t)(TIM_ICPolarity << 8);
000018  0626              LSLS     r6,r4,#24
00001a  0c36              LSRS     r6,r6,#16
00001c  9600              STR      r6,[sp,#0]
;;;2824     /* Select the Input and set the filter */
;;;2825     tmpccmr2 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR2_CC3S)) & ((uint16_t)~((uint16_t)TIM_CCMR2_IC3F)));
00001e  4e08              LDR      r6,|L3.64|
000020  360d              ADDS     r6,r6,#0xd
000022  4031              ANDS     r1,r1,r6
;;;2826     tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
000024  051e              LSLS     r6,r3,#20
000026  0c36              LSRS     r6,r6,#16
000028  4316              ORRS     r6,r6,r2
00002a  4331              ORRS     r1,r1,r6
;;;2827     /* Select the Polarity and set the CC3E Bit */
;;;2828     tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC3P | TIM_CCER_CC3NP));
00002c  4e05              LDR      r6,|L3.68|
00002e  4035              ANDS     r5,r5,r6
;;;2829     tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);  
000030  27ff              MOVS     r7,#0xff
000032  3701              ADDS     r7,#1
000034  9e00              LDR      r6,[sp,#0]
000036  433e              ORRS     r6,r6,r7
000038  4335              ORRS     r5,r5,r6
;;;2830     /* Write to TIMx CCMR2 and CCER registers */
;;;2831     TIMx->CCMR2 = tmpccmr2;
00003a  8381              STRH     r1,[r0,#0x1c]
;;;2832     TIMx->CCER = tmpccer;
00003c  8405              STRH     r5,[r0,#0x20]
;;;2833   }
00003e  bdf8              POP      {r3-r7,pc}
;;;2834   
                          ENDP

                  |L3.64|
                          DCD      0x0000feff
                  |L3.68|
                          DCD      0x0000f5ff

                          AREA ||i.TI4_Config||, CODE, READONLY, ALIGN=2

                  TI4_Config PROC
;;;2850     */
;;;2851   static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000000  b5f8              PUSH     {r3-r7,lr}
;;;2852                          uint16_t TIM_ICFilter)
;;;2853   {
000002  460c              MOV      r4,r1
;;;2854     uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
000004  2100              MOVS     r1,#0
000006  2500              MOVS     r5,#0
000008  2600              MOVS     r6,#0
00000a  9600              STR      r6,[sp,#0]
;;;2855   
;;;2856      /* Disable the Channel 4: Reset the CC4E Bit */
;;;2857     TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC4E);
00000c  8c06              LDRH     r6,[r0,#0x20]
00000e  4f0d              LDR      r7,|L4.68|
000010  403e              ANDS     r6,r6,r7
000012  8406              STRH     r6,[r0,#0x20]
;;;2858     tmpccmr2 = TIMx->CCMR2;
000014  8b81              LDRH     r1,[r0,#0x1c]
;;;2859     tmpccer = TIMx->CCER;
000016  8c05              LDRH     r5,[r0,#0x20]
;;;2860     tmp = (uint16_t)(TIM_ICPolarity << 12);
000018  0726              LSLS     r6,r4,#28
00001a  0c36              LSRS     r6,r6,#16
00001c  9600              STR      r6,[sp,#0]
;;;2861     /* Select the Input and set the filter */
;;;2862     tmpccmr2 &= (uint16_t)((uint16_t)(~(uint16_t)TIM_CCMR2_CC4S) & ((uint16_t)~((uint16_t)TIM_CCMR2_IC4F)));
00001e  4e0a              LDR      r6,|L4.72|
000020  4031              ANDS     r1,r1,r6
;;;2863     tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
000022  0616              LSLS     r6,r2,#24
000024  0c36              LSRS     r6,r6,#16
000026  4331              ORRS     r1,r1,r6
;;;2864     tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);  
000028  071e              LSLS     r6,r3,#28
00002a  0c36              LSRS     r6,r6,#16
00002c  4331              ORRS     r1,r1,r6
;;;2865     /* Select the Polarity and set the CC4E Bit */
;;;2866     tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC4P));
00002e  4e07              LDR      r6,|L4.76|
000030  4035              ANDS     r5,r5,r6
;;;2867     tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);
000032  2701              MOVS     r7,#1
000034  033f              LSLS     r7,r7,#12
000036  9e00              LDR      r6,[sp,#0]
000038  433e              ORRS     r6,r6,r7
00003a  4335              ORRS     r5,r5,r6
;;;2868     /* Write to TIMx CCMR2 and CCER registers */
;;;2869     TIMx->CCMR2 = tmpccmr2;
00003c  8381              STRH     r1,[r0,#0x1c]
;;;2870     TIMx->CCER = tmpccer;
00003e  8405              STRH     r5,[r0,#0x20]
;;;2871   }
000040  bdf8              POP      {r3-r7,pc}
;;;2872   
                          ENDP

000042  0000              DCW      0x0000
                  |L4.68|
                          DCD      0x0000efff
                  |L4.72|
                          DCD      0x00000cff
                  |L4.76|
                          DCD      0x0000dfff

                          AREA ||i.TIM_ARRPreloadConfig||, CODE, READONLY, ALIGN=2

                  TIM_ARRPreloadConfig PROC
;;;348      */
;;;349    void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;350    {
;;;351      /* Check the parameters */
;;;352      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;353      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;354      
;;;355      if (NewState != DISABLE)
000002  d004              BEQ      |L5.14|
;;;356      {
;;;357        /* Set the ARR Preload Bit */
;;;358        TIMx->CR1 |= TIM_CR1_ARPE;
000004  8802              LDRH     r2,[r0,#0]
000006  2380              MOVS     r3,#0x80
000008  431a              ORRS     r2,r2,r3
00000a  8002              STRH     r2,[r0,#0]
00000c  e003              B        |L5.22|
                  |L5.14|
;;;359      }
;;;360      else
;;;361      {
;;;362        /* Reset the ARR Preload Bit */
;;;363        TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_ARPE);
00000e  8802              LDRH     r2,[r0,#0]
000010  4b01              LDR      r3,|L5.24|
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L5.22|
;;;364      }
;;;365    }
000016  4770              BX       lr
;;;366    
                          ENDP

                  |L5.24|
                          DCD      0x0000ff7f

                          AREA ||i.TIM_BDTRConfig||, CODE, READONLY, ALIGN=1

                  TIM_BDTRConfig PROC
;;;447      */
;;;448    void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
000000  880a              LDRH     r2,[r1,#0]
;;;449    {
;;;450      /* Check the parameters */
;;;451      assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;452      assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct->TIM_OSSRState));
;;;453      assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct->TIM_OSSIState));
;;;454      assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->TIM_LOCKLevel));
;;;455      assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
;;;456      assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
;;;457      assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
;;;458      /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSR State,
;;;459         the OSSI State, the dead time value and the Automatic Output Enable Bit */
;;;460      TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
000002  884b              LDRH     r3,[r1,#2]
000004  431a              ORRS     r2,r2,r3
000006  888b              LDRH     r3,[r1,#4]
000008  431a              ORRS     r2,r2,r3
00000a  88cb              LDRH     r3,[r1,#6]
00000c  431a              ORRS     r2,r2,r3
00000e  890b              LDRH     r3,[r1,#8]
000010  431a              ORRS     r2,r2,r3
000012  894b              LDRH     r3,[r1,#0xa]
000014  431a              ORRS     r2,r2,r3
000016  898b              LDRH     r3,[r1,#0xc]
000018  431a              ORRS     r2,r2,r3
00001a  2344              MOVS     r3,#0x44
00001c  521a              STRH     r2,[r3,r0]
;;;461                 TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
;;;462                 TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
;;;463                 TIM_BDTRInitStruct->TIM_AutomaticOutput;
;;;464    }
00001e  4770              BX       lr
;;;465    
                          ENDP


                          AREA ||i.TIM_BDTRStructInit||, CODE, READONLY, ALIGN=1

                  TIM_BDTRStructInit PROC
;;;471      */
;;;472    void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
000000  2100              MOVS     r1,#0
;;;473    {
;;;474      /* Set the default configuration */
;;;475      TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
000002  8001              STRH     r1,[r0,#0]
;;;476      TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
000004  8041              STRH     r1,[r0,#2]
;;;477      TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
000006  8081              STRH     r1,[r0,#4]
;;;478      TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
000008  80c1              STRH     r1,[r0,#6]
;;;479      TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
00000a  8101              STRH     r1,[r0,#8]
;;;480      TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
00000c  8141              STRH     r1,[r0,#0xa]
;;;481      TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
00000e  8181              STRH     r1,[r0,#0xc]
;;;482    }
000010  4770              BX       lr
;;;483    
                          ENDP


                          AREA ||i.TIM_CCPreloadControl||, CODE, READONLY, ALIGN=2

                  TIM_CCPreloadControl PROC
;;;1079     */
;;;1080   void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1081   { 
;;;1082     /* Check the parameters */
;;;1083     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1084     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1085     if (NewState != DISABLE)
000002  d004              BEQ      |L8.14|
;;;1086     {
;;;1087       /* Set the CCPC Bit */
;;;1088       TIMx->CR2 |= TIM_CR2_CCPC;
000004  8882              LDRH     r2,[r0,#4]
000006  2301              MOVS     r3,#1
000008  431a              ORRS     r2,r2,r3
00000a  8082              STRH     r2,[r0,#4]
00000c  e003              B        |L8.22|
                  |L8.14|
;;;1089     }
;;;1090     else
;;;1091     {
;;;1092       /* Reset the CCPC Bit */
;;;1093       TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCPC);
00000e  8882              LDRH     r2,[r0,#4]
000010  4b01              LDR      r3,|L8.24|
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L8.22|
;;;1094     }
;;;1095   }
000016  4770              BX       lr
;;;1096   
                          ENDP

                  |L8.24|
                          DCD      0x0000fffe

                          AREA ||i.TIM_CCxCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxCmd PROC
;;;1617     */
;;;1618   void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
000000  b530              PUSH     {r4,r5,lr}
;;;1619   {
;;;1620     uint16_t tmp = 0;
000002  2300              MOVS     r3,#0
;;;1621   
;;;1622     /* Check the parameters */
;;;1623     assert_param(IS_TIM_LIST4_PERIPH(TIMx)); 
;;;1624     assert_param(IS_TIM_CCX(TIM_CCx));
;;;1625   
;;;1626     tmp = CCER_CCE_SET << TIM_Channel;
000004  2401              MOVS     r4,#1
000006  408c              LSLS     r4,r4,r1
000008  b2a3              UXTH     r3,r4
;;;1627   
;;;1628     /* Reset the CCxE Bit */
;;;1629     TIMx->CCER &= (uint16_t)~ tmp;
00000a  8c04              LDRH     r4,[r0,#0x20]
00000c  439c              BICS     r4,r4,r3
00000e  8404              STRH     r4,[r0,#0x20]
;;;1630   
;;;1631     /* Set or reset the CCxE Bit */ 
;;;1632     TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
000010  8c04              LDRH     r4,[r0,#0x20]
000012  4615              MOV      r5,r2
000014  408d              LSLS     r5,r5,r1
000016  b2ad              UXTH     r5,r5
000018  432c              ORRS     r4,r4,r5
00001a  8404              STRH     r4,[r0,#0x20]
;;;1633   }
00001c  bd30              POP      {r4,r5,pc}
;;;1634   
                          ENDP


                          AREA ||i.TIM_CCxNCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxNCmd PROC
;;;1646     */
;;;1647   void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN)
000000  b530              PUSH     {r4,r5,lr}
;;;1648   {
;;;1649     uint16_t tmp = 0;
000002  2300              MOVS     r3,#0
;;;1650   
;;;1651     /* Check the parameters */
;;;1652     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1653     assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
;;;1654     assert_param(IS_TIM_CCXN(TIM_CCxN));
;;;1655   
;;;1656     tmp = CCER_CCNE_SET << TIM_Channel;
000004  2404              MOVS     r4,#4
000006  408c              LSLS     r4,r4,r1
000008  b2a3              UXTH     r3,r4
;;;1657   
;;;1658     /* Reset the CCxNE Bit */
;;;1659     TIMx->CCER &= (uint16_t) ~tmp;
00000a  8c04              LDRH     r4,[r0,#0x20]
00000c  439c              BICS     r4,r4,r3
00000e  8404              STRH     r4,[r0,#0x20]
;;;1660   
;;;1661     /* Set or reset the CCxNE Bit */ 
;;;1662     TIMx->CCER |=  (uint16_t)(TIM_CCxN << TIM_Channel);
000010  8c04              LDRH     r4,[r0,#0x20]
000012  4615              MOV      r5,r2
000014  408d              LSLS     r5,r5,r1
000016  b2ad              UXTH     r5,r5
000018  432c              ORRS     r4,r4,r5
00001a  8404              STRH     r4,[r0,#0x20]
;;;1663   }
00001c  bd30              POP      {r4,r5,pc}
;;;1664   
                          ENDP


                          AREA ||i.TIM_ClearFlag||, CODE, READONLY, ALIGN=1

                  TIM_ClearFlag PROC
;;;2122     */
;;;2123   void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
000000  43ca              MVNS     r2,r1
;;;2124   {  
;;;2125     /* Check the parameters */
;;;2126     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2127     assert_param(IS_TIM_CLEAR_FLAG(TIM_FLAG));
;;;2128      
;;;2129     /* Clear the flags */
;;;2130     TIMx->SR = (uint16_t)~TIM_FLAG;
000002  8202              STRH     r2,[r0,#0x10]
;;;2131   }
000004  4770              BX       lr
;;;2132   
                          ENDP


                          AREA ||i.TIM_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  TIM_ClearITPendingBit PROC
;;;2199     */
;;;2200   void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
000000  43ca              MVNS     r2,r1
;;;2201   {
;;;2202     /* Check the parameters */
;;;2203     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2204     assert_param(IS_TIM_IT(TIM_IT));
;;;2205      
;;;2206     /* Clear the IT pending Bit */
;;;2207     TIMx->SR = (uint16_t)~TIM_IT;
000002  8202              STRH     r2,[r0,#0x10]
;;;2208   }
000004  4770              BX       lr
;;;2209   
                          ENDP


                          AREA ||i.TIM_ClearOC1Ref||, CODE, READONLY, ALIGN=2

                  TIM_ClearOC1Ref PROC
;;;1316     */
;;;1317   void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  460a              MOV      r2,r1
;;;1318   {
;;;1319     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1320     
;;;1321     /* Check the parameters */
;;;1322     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1323     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1324     
;;;1325     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1326     /* Reset the OC1CE Bit */
;;;1327     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1CE);
000006  4b03              LDR      r3,|L13.20|
000008  4019              ANDS     r1,r1,r3
;;;1328     /* Enable or Disable the Output Compare Clear Bit */
;;;1329     tmpccmr1 |= TIM_OCClear;
00000a  460b              MOV      r3,r1
00000c  4313              ORRS     r3,r3,r2
00000e  4619              MOV      r1,r3
;;;1330     /* Write to TIMx CCMR1 register */
;;;1331     TIMx->CCMR1 = tmpccmr1;
000010  8301              STRH     r1,[r0,#0x18]
;;;1332   }
000012  4770              BX       lr
;;;1333   
                          ENDP

                  |L13.20|
                          DCD      0x0000ff7f

                          AREA ||i.TIM_ClearOC2Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC2Ref PROC
;;;1342     */
;;;1343   void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  460a              MOV      r2,r1
;;;1344   {
;;;1345     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1346     
;;;1347     /* Check the parameters */
;;;1348     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1349     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1350     
;;;1351     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1352     /* Reset the OC2CE Bit */
;;;1353     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2CE);
000006  0449              LSLS     r1,r1,#17
000008  0c49              LSRS     r1,r1,#17
;;;1354     /* Enable or Disable the Output Compare Clear Bit */
;;;1355     tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
00000a  0613              LSLS     r3,r2,#24
00000c  0c1b              LSRS     r3,r3,#16
00000e  4319              ORRS     r1,r1,r3
;;;1356     /* Write to TIMx CCMR1 register */
;;;1357     TIMx->CCMR1 = tmpccmr1;
000010  8301              STRH     r1,[r0,#0x18]
;;;1358   }
000012  4770              BX       lr
;;;1359   
                          ENDP


                          AREA ||i.TIM_ClearOC3Ref||, CODE, READONLY, ALIGN=2

                  TIM_ClearOC3Ref PROC
;;;1368     */
;;;1369   void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  460a              MOV      r2,r1
;;;1370   {
;;;1371     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1372     
;;;1373     /* Check the parameters */
;;;1374     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1375     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1376     
;;;1377     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1378     /* Reset the OC3CE Bit */
;;;1379     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3CE);
000006  4b03              LDR      r3,|L15.20|
000008  4019              ANDS     r1,r1,r3
;;;1380     /* Enable or Disable the Output Compare Clear Bit */
;;;1381     tmpccmr2 |= TIM_OCClear;
00000a  460b              MOV      r3,r1
00000c  4313              ORRS     r3,r3,r2
00000e  4619              MOV      r1,r3
;;;1382     /* Write to TIMx CCMR2 register */
;;;1383     TIMx->CCMR2 = tmpccmr2;
000010  8381              STRH     r1,[r0,#0x1c]
;;;1384   }
000012  4770              BX       lr
;;;1385   
                          ENDP

                  |L15.20|
                          DCD      0x0000ff7f

                          AREA ||i.TIM_ClearOC4Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC4Ref PROC
;;;1394     */
;;;1395   void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  460a              MOV      r2,r1
;;;1396   {
;;;1397     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1398     
;;;1399     /* Check the parameters */
;;;1400     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1401     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1402     
;;;1403     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1404     /* Reset the OC4CE Bit */
;;;1405     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4CE);
000006  0449              LSLS     r1,r1,#17
000008  0c49              LSRS     r1,r1,#17
;;;1406     /* Enable or Disable the Output Compare Clear Bit */
;;;1407     tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
00000a  0613              LSLS     r3,r2,#24
00000c  0c1b              LSRS     r3,r3,#16
00000e  4319              ORRS     r1,r1,r3
;;;1408     /* Write to TIMx CCMR2 register */
;;;1409     TIMx->CCMR2 = tmpccmr2;
000010  8381              STRH     r1,[r0,#0x1c]
;;;1410   }
000012  4770              BX       lr
;;;1411   
                          ENDP


                          AREA ||i.TIM_Cmd||, CODE, READONLY, ALIGN=2

                  TIM_Cmd PROC
;;;418      */
;;;419    void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;420    {
;;;421      /* Check the parameters */
;;;422      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;423      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;424      
;;;425      if (NewState != DISABLE)
000002  d004              BEQ      |L17.14|
;;;426      {
;;;427        /* Enable the TIM Counter */
;;;428        TIMx->CR1 |= TIM_CR1_CEN;
000004  8802              LDRH     r2,[r0,#0]
000006  2301              MOVS     r3,#1
000008  431a              ORRS     r2,r2,r3
00000a  8002              STRH     r2,[r0,#0]
00000c  e003              B        |L17.22|
                  |L17.14|
;;;429      }
;;;430      else
;;;431      {
;;;432        /* Disable the TIM Counter */
;;;433        TIMx->CR1 &= (uint16_t)(~((uint16_t)TIM_CR1_CEN));
00000e  8802              LDRH     r2,[r0,#0]
000010  4b01              LDR      r3,|L17.24|
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L17.22|
;;;434      }
;;;435    }
000016  4770              BX       lr
;;;436    
                          ENDP

                  |L17.24|
                          DCD      0x0000fffe

                          AREA ||i.TIM_CounterModeConfig||, CODE, READONLY, ALIGN=2

                  TIM_CounterModeConfig PROC
;;;206      */
;;;207    void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode)
000000  460a              MOV      r2,r1
;;;208    {
;;;209      uint16_t tmpcr1 = 0;
000002  2100              MOVS     r1,#0
;;;210      
;;;211      /* Check the parameters */
;;;212      assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;213      assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
;;;214      
;;;215      tmpcr1 = TIMx->CR1;
000004  8801              LDRH     r1,[r0,#0]
;;;216      /* Reset the CMS and DIR Bits */
;;;217      tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
000006  4b03              LDR      r3,|L18.20|
000008  4019              ANDS     r1,r1,r3
;;;218      /* Set the Counter Mode */
;;;219      tmpcr1 |= TIM_CounterMode;
00000a  460b              MOV      r3,r1
00000c  4313              ORRS     r3,r3,r2
00000e  4619              MOV      r1,r3
;;;220      /* Write to TIMx CR1 register */
;;;221      TIMx->CR1 = tmpcr1;
000010  8001              STRH     r1,[r0,#0]
;;;222    }
000012  4770              BX       lr
;;;223    
                          ENDP

                  |L18.20|
                          DCD      0x0000ff8f

                          AREA ||i.TIM_CtrlPWMOutputs||, CODE, READONLY, ALIGN=1

                  TIM_CtrlPWMOutputs PROC
;;;490      */
;;;491    void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;492    {
;;;493      /* Check the parameters */
;;;494      assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;495      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;496      if (NewState != DISABLE)
000002  d007              BEQ      |L19.20|
;;;497      {
;;;498        /* Enable the TIM Main Output */
;;;499        TIMx->BDTR |= TIM_BDTR_MOE;
000004  2244              MOVS     r2,#0x44
000006  5a12              LDRH     r2,[r2,r0]
000008  2301              MOVS     r3,#1
00000a  03db              LSLS     r3,r3,#15
00000c  431a              ORRS     r2,r2,r3
00000e  2344              MOVS     r3,#0x44
000010  521a              STRH     r2,[r3,r0]
000012  e005              B        |L19.32|
                  |L19.20|
;;;500      }
;;;501      else
;;;502      {
;;;503        /* Disable the TIM Main Output */
;;;504        TIMx->BDTR &= (uint16_t)(~((uint16_t)TIM_BDTR_MOE));
000014  2244              MOVS     r2,#0x44
000016  5a12              LDRH     r2,[r2,r0]
000018  0453              LSLS     r3,r2,#17
00001a  0c5b              LSRS     r3,r3,#17
00001c  2244              MOVS     r2,#0x44
00001e  5213              STRH     r3,[r2,r0]
                  |L19.32|
;;;505      }  
;;;506    }
000020  4770              BX       lr
;;;507    
                          ENDP


                          AREA ||i.TIM_DMACmd||, CODE, READONLY, ALIGN=1

                  TIM_DMACmd PROC
;;;2262     */
;;;2263   void TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;2264   { 
;;;2265     /* Check the parameters */
;;;2266     assert_param(IS_TIM_LIST10_PERIPH(TIMx));
;;;2267     assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
;;;2268     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2269     
;;;2270     if (NewState != DISABLE)
000002  d003              BEQ      |L20.12|
;;;2271     {
;;;2272       /* Enable the DMA sources */
;;;2273       TIMx->DIER |= TIM_DMASource; 
000004  8983              LDRH     r3,[r0,#0xc]
000006  430b              ORRS     r3,r3,r1
000008  8183              STRH     r3,[r0,#0xc]
00000a  e002              B        |L20.18|
                  |L20.12|
;;;2274     }
;;;2275     else
;;;2276     {
;;;2277       /* Disable the DMA sources */
;;;2278       TIMx->DIER &= (uint16_t)~TIM_DMASource;
00000c  8983              LDRH     r3,[r0,#0xc]
00000e  438b              BICS     r3,r3,r1
000010  8183              STRH     r3,[r0,#0xc]
                  |L20.18|
;;;2279     }
;;;2280   }
000012  4770              BX       lr
;;;2281   
                          ENDP


                          AREA ||i.TIM_DMAConfig||, CODE, READONLY, ALIGN=1

                  TIM_DMAConfig PROC
;;;2236     */
;;;2237   void TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength)
000000  b510              PUSH     {r4,lr}
;;;2238   {
;;;2239     /* Check the parameters */
;;;2240     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;2241     assert_param(IS_TIM_DMA_BASE(TIM_DMABase)); 
;;;2242     assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
;;;2243     /* Set the DMA Base and the DMA Burst Length */
;;;2244     TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
000002  460b              MOV      r3,r1
000004  4313              ORRS     r3,r3,r2
000006  2448              MOVS     r4,#0x48
000008  5223              STRH     r3,[r4,r0]
;;;2245   }
00000a  bd10              POP      {r4,pc}
;;;2246   
                          ENDP


                          AREA ||i.TIM_DeInit||, CODE, READONLY, ALIGN=2

                  TIM_DeInit PROC
;;;46       */
;;;47     void TIM_DeInit(TIM_TypeDef* TIMx)
000000  b510              PUSH     {r4,lr}
;;;48     {
000002  4604              MOV      r4,r0
;;;49       /* Check the parameters */
;;;50       assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;51     
;;;52       if (TIMx == TIM1)
000004  482b              LDR      r0,|L22.180|
000006  4284              CMP      r4,r0
000008  d108              BNE      |L22.28|
;;;53       {
;;;54         RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  14c0              ASRS     r0,r0,#19
00000e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;55         RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
000012  2100              MOVS     r1,#0
000014  14e0              ASRS     r0,r4,#19
000016  f7fffffe          BL       RCC_APB2PeriphResetCmd
00001a  e049              B        |L22.176|
                  |L22.28|
;;;56       }     
;;;57     //  else if (TIMx == TIM2)
;;;58     //  {
;;;59     //    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
;;;60     //    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
;;;61     //  }
;;;62       else if (TIMx == TIM3)
00001c  4826              LDR      r0,|L22.184|
00001e  4284              CMP      r4,r0
000020  d108              BNE      |L22.52|
;;;63       {
;;;64         RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
000022  2101              MOVS     r1,#1
000024  2002              MOVS     r0,#2
000026  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;65         RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
00002a  2100              MOVS     r1,#0
00002c  2002              MOVS     r0,#2
00002e  f7fffffe          BL       RCC_APB1PeriphResetCmd
000032  e03d              B        |L22.176|
                  |L22.52|
;;;66       }
;;;67       else if (TIMx == TIM6)
000034  4821              LDR      r0,|L22.188|
000036  4284              CMP      r4,r0
000038  d108              BNE      |L22.76|
;;;68       {
;;;69         RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
00003a  2101              MOVS     r1,#1
00003c  2010              MOVS     r0,#0x10
00003e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;70         RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
000042  2100              MOVS     r1,#0
000044  2010              MOVS     r0,#0x10
000046  f7fffffe          BL       RCC_APB1PeriphResetCmd
00004a  e031              B        |L22.176|
                  |L22.76|
;;;71       } 
;;;72     //  else if (TIMx == TIM7)
;;;73     //  {
;;;74     //    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
;;;75     //    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
;;;76     //  }
;;;77       else if (TIMx == TIM14) 
00004c  481c              LDR      r0,|L22.192|
00004e  4284              CMP      r4,r0
000050  d108              BNE      |L22.100|
;;;78       {       
;;;79         RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
000052  2101              MOVS     r1,#1
000054  1580              ASRS     r0,r0,#22
000056  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;80         RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE);  
00005a  2100              MOVS     r1,#0
00005c  15a0              ASRS     r0,r4,#22
00005e  f7fffffe          BL       RCC_APB1PeriphResetCmd
000062  e025              B        |L22.176|
                  |L22.100|
;;;81       }        
;;;82       else if (TIMx == TIM15)
000064  4817              LDR      r0,|L22.196|
000066  4284              CMP      r4,r0
000068  d109              BNE      |L22.126|
;;;83       {
;;;84         RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM15, ENABLE);
00006a  2101              MOVS     r1,#1
00006c  0408              LSLS     r0,r1,#16
00006e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;85         RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM15, DISABLE);
000072  2100              MOVS     r1,#0
000074  2001              MOVS     r0,#1
000076  0400              LSLS     r0,r0,#16
000078  f7fffffe          BL       RCC_APB2PeriphResetCmd
00007c  e018              B        |L22.176|
                  |L22.126|
;;;86       } 
;;;87       else if (TIMx == TIM16)
00007e  4812              LDR      r0,|L22.200|
000080  4284              CMP      r4,r0
000082  d109              BNE      |L22.152|
;;;88       {
;;;89         RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM16, ENABLE);
000084  2101              MOVS     r1,#1
000086  0448              LSLS     r0,r1,#17
000088  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;90         RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM16, DISABLE);
00008c  2100              MOVS     r1,#0
00008e  2001              MOVS     r0,#1
000090  0440              LSLS     r0,r0,#17
000092  f7fffffe          BL       RCC_APB2PeriphResetCmd
000096  e00b              B        |L22.176|
                  |L22.152|
;;;91       } 
;;;92       else
;;;93       {
;;;94         if (TIMx == TIM17)
000098  480c              LDR      r0,|L22.204|
00009a  4284              CMP      r4,r0
00009c  d108              BNE      |L22.176|
;;;95         {
;;;96           RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, ENABLE);
00009e  2101              MOVS     r1,#1
0000a0  0488              LSLS     r0,r1,#18
0000a2  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;97           RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, DISABLE);
0000a6  2100              MOVS     r1,#0
0000a8  2001              MOVS     r0,#1
0000aa  0480              LSLS     r0,r0,#18
0000ac  f7fffffe          BL       RCC_APB2PeriphResetCmd
                  |L22.176|
;;;98         }  
;;;99       }
;;;100         
;;;101    }
0000b0  bd10              POP      {r4,pc}
;;;102    
                          ENDP

0000b2  0000              DCW      0x0000
                  |L22.180|
                          DCD      0x40012c00
                  |L22.184|
                          DCD      0x40000400
                  |L22.188|
                          DCD      0x40001000
                  |L22.192|
                          DCD      0x40002000
                  |L22.196|
                          DCD      0x40014000
                  |L22.200|
                          DCD      0x40014400
                  |L22.204|
                          DCD      0x40014800

                          AREA ||i.TIM_ETRClockMode1Config||, CODE, READONLY, ALIGN=2

                  TIM_ETRClockMode1Config PROC
;;;2400     */
;;;2401   void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
000000  b5ff              PUSH     {r0-r7,lr}
;;;2402                                uint16_t ExtTRGFilter)
;;;2403   {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
;;;2404     uint16_t tmpsmcr = 0;
000008  2400              MOVS     r4,#0
;;;2405     
;;;2406     /* Check the parameters */
;;;2407     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2408     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;2409     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;2410     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;2411     
;;;2412     /* Configure the ETR Clock source */
;;;2413     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
00000a  463a              MOV      r2,r7
00000c  4631              MOV      r1,r6
00000e  4628              MOV      r0,r5
000010  9b03              LDR      r3,[sp,#0xc]
000012  f7fffffe          BL       TIM_ETRConfig
;;;2414     
;;;2415     /* Get the TIMx SMCR register value */
;;;2416     tmpsmcr = TIMx->SMCR;
000016  892c              LDRH     r4,[r5,#8]
;;;2417     /* Reset the SMS Bits */
;;;2418     tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
000018  4805              LDR      r0,|L23.48|
00001a  4004              ANDS     r4,r4,r0
;;;2419     /* Select the External clock mode1 */
;;;2420     tmpsmcr |= TIM_SlaveMode_External1;
00001c  2007              MOVS     r0,#7
00001e  4304              ORRS     r4,r4,r0
;;;2421     /* Select the Trigger selection : ETRF */
;;;2422     tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
000020  4803              LDR      r0,|L23.48|
000022  3869              SUBS     r0,r0,#0x69
000024  4004              ANDS     r4,r4,r0
;;;2423     tmpsmcr |= TIM_TS_ETRF;
000026  2070              MOVS     r0,#0x70
000028  4304              ORRS     r4,r4,r0
;;;2424     /* Write to TIMx SMCR */
;;;2425     TIMx->SMCR = tmpsmcr;
00002a  812c              STRH     r4,[r5,#8]
;;;2426   }
00002c  bdff              POP      {r0-r7,pc}
;;;2427   
                          ENDP

00002e  0000              DCW      0x0000
                  |L23.48|
                          DCD      0x0000fff8

                          AREA ||i.TIM_ETRClockMode2Config||, CODE, READONLY, ALIGN=1

                  TIM_ETRClockMode2Config PROC
;;;2444     */
;;;2445   void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
000000  b5f0              PUSH     {r4-r7,lr}
;;;2446                                uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
;;;2447   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
;;;2448     /* Check the parameters */
;;;2449     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2450     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;2451     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;2452     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;2453     
;;;2454     /* Configure the ETR Clock source */
;;;2455     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
00000a  463b              MOV      r3,r7
00000c  4632              MOV      r2,r6
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       TIM_ETRConfig
;;;2456     /* Enable the External clock mode2 */
;;;2457     TIMx->SMCR |= TIM_SMCR_ECE;
000016  8920              LDRH     r0,[r4,#8]
000018  2101              MOVS     r1,#1
00001a  0389              LSLS     r1,r1,#14
00001c  4308              ORRS     r0,r0,r1
00001e  8120              STRH     r0,[r4,#8]
;;;2458   }
000020  bdf0              POP      {r4-r7,pc}
;;;2459   
                          ENDP


                          AREA ||i.TIM_ETRConfig||, CODE, READONLY, ALIGN=1

                  TIM_ETRConfig PROC
;;;2592     */
;;;2593   void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
000000  b530              PUSH     {r4,r5,lr}
;;;2594                      uint16_t ExtTRGFilter)
;;;2595   {
000002  460c              MOV      r4,r1
;;;2596     uint16_t tmpsmcr = 0;
000004  2100              MOVS     r1,#0
;;;2597     
;;;2598     /* Check the parameters */
;;;2599     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2600     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;2601     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;2602     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;2603     
;;;2604     tmpsmcr = TIMx->SMCR;
000006  8901              LDRH     r1,[r0,#8]
;;;2605     /* Reset the ETR Bits */
;;;2606     tmpsmcr &= SMCR_ETR_MASK;
000008  b2c9              UXTB     r1,r1
;;;2607     /* Set the Prescaler, the Filter value and the Polarity */
;;;2608     tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
00000a  061d              LSLS     r5,r3,#24
00000c  0c2d              LSRS     r5,r5,#16
00000e  4315              ORRS     r5,r5,r2
000010  4325              ORRS     r5,r5,r4
000012  4329              ORRS     r1,r1,r5
;;;2609     /* Write to TIMx SMCR */
;;;2610     TIMx->SMCR = tmpsmcr;
000014  8101              STRH     r1,[r0,#8]
;;;2611   }
000016  bd30              POP      {r4,r5,pc}
;;;2612   
                          ENDP


                          AREA ||i.TIM_EncoderInterfaceConfig||, CODE, READONLY, ALIGN=2

                  TIM_EncoderInterfaceConfig PROC
;;;2634     */
;;;2635   void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
000000  b5f0              PUSH     {r4-r7,lr}
;;;2636                                   uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
;;;2637   {
000002  460c              MOV      r4,r1
;;;2638     uint16_t tmpsmcr = 0;
000004  2100              MOVS     r1,#0
;;;2639     uint16_t tmpccmr1 = 0;
000006  2500              MOVS     r5,#0
;;;2640     uint16_t tmpccer = 0;
000008  2600              MOVS     r6,#0
;;;2641       
;;;2642     /* Check the parameters */
;;;2643     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2644     assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
;;;2645     assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
;;;2646     assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
;;;2647     
;;;2648     /* Get the TIMx SMCR register value */
;;;2649     tmpsmcr = TIMx->SMCR;
00000a  8901              LDRH     r1,[r0,#8]
;;;2650     /* Get the TIMx CCMR1 register value */
;;;2651     tmpccmr1 = TIMx->CCMR1;
00000c  8b05              LDRH     r5,[r0,#0x18]
;;;2652     /* Get the TIMx CCER register value */
;;;2653     tmpccer = TIMx->CCER;
00000e  8c06              LDRH     r6,[r0,#0x20]
;;;2654     /* Set the encoder Mode */
;;;2655     tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
000010  4f0a              LDR      r7,|L26.60|
000012  4039              ANDS     r1,r1,r7
;;;2656     tmpsmcr |= TIM_EncoderMode;
000014  460f              MOV      r7,r1
000016  4327              ORRS     r7,r7,r4
000018  4639              MOV      r1,r7
;;;2657     /* Select the Capture Compare 1 and the Capture Compare 2 as input */
;;;2658     tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S)));
00001a  4f09              LDR      r7,|L26.64|
00001c  403d              ANDS     r5,r5,r7
;;;2659     tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
00001e  27ff              MOVS     r7,#0xff
000020  3702              ADDS     r7,#2
000022  433d              ORRS     r5,r5,r7
;;;2660     /* Set the TI1 and the TI2 Polarities */
;;;2661     tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC1P | TIM_CCER_CC1NP)) & (uint16_t)~((uint16_t)(TIM_CCER_CC2P | TIM_CCER_CC2NP));
000024  4f05              LDR      r7,|L26.60|
000026  3fa3              SUBS     r7,r7,#0xa3
000028  403e              ANDS     r6,r6,r7
;;;2662     tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
00002a  051f              LSLS     r7,r3,#20
00002c  0c3f              LSRS     r7,r7,#16
00002e  4317              ORRS     r7,r7,r2
000030  433e              ORRS     r6,r6,r7
;;;2663     /* Write to TIMx SMCR */
;;;2664     TIMx->SMCR = tmpsmcr;
000032  8101              STRH     r1,[r0,#8]
;;;2665     /* Write to TIMx CCMR1 */
;;;2666     TIMx->CCMR1 = tmpccmr1;
000034  8305              STRH     r5,[r0,#0x18]
;;;2667     /* Write to TIMx CCER */
;;;2668     TIMx->CCER = tmpccer;
000036  8406              STRH     r6,[r0,#0x20]
;;;2669   }
000038  bdf0              POP      {r4-r7,pc}
;;;2670   
                          ENDP

00003a  0000              DCW      0x0000
                  |L26.60|
                          DCD      0x0000fff8
                  |L26.64|
                          DCD      0x0000fcfc

                          AREA ||i.TIM_ForcedOC1Config||, CODE, READONLY, ALIGN=2

                  TIM_ForcedOC1Config PROC
;;;980      */
;;;981    void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  460a              MOV      r2,r1
;;;982    {
;;;983      uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;984      /* Check the parameters */
;;;985      assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;986      assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;987      tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;988      /* Reset the OC1M Bits */
;;;989      tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1M);
000006  4b03              LDR      r3,|L27.20|
000008  4019              ANDS     r1,r1,r3
;;;990      /* Configure The Forced output Mode */
;;;991      tmpccmr1 |= TIM_ForcedAction;
00000a  460b              MOV      r3,r1
00000c  4313              ORRS     r3,r3,r2
00000e  4619              MOV      r1,r3
;;;992      /* Write to TIMx CCMR1 register */
;;;993      TIMx->CCMR1 = tmpccmr1;
000010  8301              STRH     r1,[r0,#0x18]
;;;994    }
000012  4770              BX       lr
;;;995     
                          ENDP

                  |L27.20|
                          DCD      0x0000ff8f

                          AREA ||i.TIM_ForcedOC2Config||, CODE, READONLY, ALIGN=2

                  TIM_ForcedOC2Config PROC
;;;1004     */
;;;1005   void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  460a              MOV      r2,r1
;;;1006   {
;;;1007     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1008     
;;;1009     /* Check the parameters */
;;;1010     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1011     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1012     
;;;1013     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1014     /* Reset the OC2M Bits */
;;;1015     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2M);
000006  4b03              LDR      r3,|L28.20|
000008  4019              ANDS     r1,r1,r3
;;;1016     /* Configure The Forced output Mode */
;;;1017     tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);
00000a  0613              LSLS     r3,r2,#24
00000c  0c1b              LSRS     r3,r3,#16
00000e  4319              ORRS     r1,r1,r3
;;;1018     /* Write to TIMx CCMR1 register */
;;;1019     TIMx->CCMR1 = tmpccmr1;
000010  8301              STRH     r1,[r0,#0x18]
;;;1020   }
000012  4770              BX       lr
;;;1021   
                          ENDP

                  |L28.20|
                          DCD      0x00008fff

                          AREA ||i.TIM_ForcedOC3Config||, CODE, READONLY, ALIGN=2

                  TIM_ForcedOC3Config PROC
;;;1030     */
;;;1031   void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  460a              MOV      r2,r1
;;;1032   {
;;;1033     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1034     
;;;1035     /* Check the parameters */
;;;1036     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1037     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1038     
;;;1039     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1040     /* Reset the OC1M Bits */
;;;1041     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3M);
000006  4b03              LDR      r3,|L29.20|
000008  4019              ANDS     r1,r1,r3
;;;1042     /* Configure The Forced output Mode */
;;;1043     tmpccmr2 |= TIM_ForcedAction;
00000a  460b              MOV      r3,r1
00000c  4313              ORRS     r3,r3,r2
00000e  4619              MOV      r1,r3
;;;1044     /* Write to TIMx CCMR2 register */
;;;1045     TIMx->CCMR2 = tmpccmr2;
000010  8381              STRH     r1,[r0,#0x1c]
;;;1046   }
000012  4770              BX       lr
;;;1047   
                          ENDP

                  |L29.20|
                          DCD      0x0000ff8f

                          AREA ||i.TIM_ForcedOC4Config||, CODE, READONLY, ALIGN=2

                  TIM_ForcedOC4Config PROC
;;;1056     */
;;;1057   void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  460a              MOV      r2,r1
;;;1058   {
;;;1059     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1060     /* Check the parameters */
;;;1061     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1062     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1063     
;;;1064     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1065     /* Reset the OC2M Bits */
;;;1066     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4M);
000006  4b03              LDR      r3,|L30.20|
000008  4019              ANDS     r1,r1,r3
;;;1067     /* Configure The Forced output Mode */
;;;1068     tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);
00000a  0613              LSLS     r3,r2,#24
00000c  0c1b              LSRS     r3,r3,#16
00000e  4319              ORRS     r1,r1,r3
;;;1069     /* Write to TIMx CCMR2 register */
;;;1070     TIMx->CCMR2 = tmpccmr2;
000010  8381              STRH     r1,[r0,#0x1c]
;;;1071   }
000012  4770              BX       lr
;;;1072   
                          ENDP

                  |L30.20|
                          DCD      0x00008fff

                          AREA ||i.TIM_GenerateEvent||, CODE, READONLY, ALIGN=1

                  TIM_GenerateEvent PROC
;;;2041     */
;;;2042   void TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource)
000000  8281              STRH     r1,[r0,#0x14]
;;;2043   { 
;;;2044     /* Check the parameters */
;;;2045     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2046     assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource)); 
;;;2047     /* Set the event sources */
;;;2048     TIMx->EGR = TIM_EventSource;
;;;2049   }
000002  4770              BX       lr
;;;2050   
                          ENDP


                          AREA ||i.TIM_GetCapture1||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture1 PROC
;;;1832     */
;;;1833   uint32_t TIM_GetCapture1(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;1834   {
;;;1835     /* Check the parameters */
;;;1836     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1837     
;;;1838     /* Get the Capture 1 Register value */
;;;1839     return TIMx->CCR1;
000002  6b48              LDR      r0,[r1,#0x34]
;;;1840   }
000004  4770              BX       lr
;;;1841   
                          ENDP


                          AREA ||i.TIM_GetCapture2||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture2 PROC
;;;1846     */
;;;1847   uint32_t TIM_GetCapture2(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;1848   {
;;;1849     /* Check the parameters */
;;;1850     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1851     
;;;1852     /* Get the Capture 2 Register value */
;;;1853     return TIMx->CCR2;
000002  6b88              LDR      r0,[r1,#0x38]
;;;1854   }
000004  4770              BX       lr
;;;1855   
                          ENDP


                          AREA ||i.TIM_GetCapture3||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture3 PROC
;;;1860     */
;;;1861   uint32_t TIM_GetCapture3(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;1862   {
;;;1863     /* Check the parameters */
;;;1864     assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;1865     
;;;1866     /* Get the Capture 3 Register value */
;;;1867     return TIMx->CCR3;
000002  6bc8              LDR      r0,[r1,#0x3c]
;;;1868   }
000004  4770              BX       lr
;;;1869   
                          ENDP


                          AREA ||i.TIM_GetCapture4||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture4 PROC
;;;1874     */
;;;1875   uint32_t TIM_GetCapture4(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;1876   {
;;;1877     /* Check the parameters */
;;;1878     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1879     
;;;1880     /* Get the Capture 4 Register value */
;;;1881     return TIMx->CCR4;
000002  6c08              LDR      r0,[r1,#0x40]
;;;1882   }
000004  4770              BX       lr
;;;1883   
                          ENDP


                          AREA ||i.TIM_GetCounter||, CODE, READONLY, ALIGN=1

                  TIM_GetCounter PROC
;;;260      */
;;;261    uint32_t TIM_GetCounter(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;262    {
;;;263      /* Check the parameters */
;;;264      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;265      
;;;266      /* Get the Counter Register value */
;;;267      return TIMx->CNT;
000002  6a48              LDR      r0,[r1,#0x24]
;;;268    }
000004  4770              BX       lr
;;;269    
                          ENDP


                          AREA ||i.TIM_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  TIM_GetFlagStatus PROC
;;;2076     */
;;;2077   FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
000000  4602              MOV      r2,r0
;;;2078   { 
;;;2079     ITStatus bitstatus = RESET; 
000002  2000              MOVS     r0,#0
;;;2080      
;;;2081     /* Check the parameters */
;;;2082     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2083     assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
;;;2084     
;;;2085     if ((TIMx->SR & TIM_FLAG) != (uint16_t)RESET)
000004  8a13              LDRH     r3,[r2,#0x10]
000006  400b              ANDS     r3,r3,r1
000008  2b00              CMP      r3,#0
00000a  d001              BEQ      |L37.16|
;;;2086     {
;;;2087       bitstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L37.18|
                  |L37.16|
;;;2088     }
;;;2089     else
;;;2090     {
;;;2091       bitstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L37.18|
;;;2092     }
;;;2093     return bitstatus;
;;;2094   }
000012  4770              BX       lr
;;;2095   
                          ENDP


                          AREA ||i.TIM_GetITStatus||, CODE, READONLY, ALIGN=1

                  TIM_GetITStatus PROC
;;;2154     */
;;;2155   ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)
000000  b530              PUSH     {r4,r5,lr}
;;;2156   {
000002  4602              MOV      r2,r0
;;;2157     ITStatus bitstatus = RESET;  
000004  2000              MOVS     r0,#0
;;;2158     uint16_t itstatus = 0x0, itenable = 0x0;
000006  2300              MOVS     r3,#0
000008  2400              MOVS     r4,#0
;;;2159     
;;;2160     /* Check the parameters */
;;;2161     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2162     assert_param(IS_TIM_GET_IT(TIM_IT));
;;;2163      
;;;2164     itstatus = TIMx->SR & TIM_IT;
00000a  8a15              LDRH     r5,[r2,#0x10]
00000c  400d              ANDS     r5,r5,r1
00000e  462b              MOV      r3,r5
;;;2165     
;;;2166     itenable = TIMx->DIER & TIM_IT;
000010  8995              LDRH     r5,[r2,#0xc]
000012  400d              ANDS     r5,r5,r1
000014  462c              MOV      r4,r5
;;;2167     if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
000016  2b00              CMP      r3,#0
000018  d003              BEQ      |L38.34|
00001a  2c00              CMP      r4,#0
00001c  d001              BEQ      |L38.34|
;;;2168     {
;;;2169       bitstatus = SET;
00001e  2001              MOVS     r0,#1
000020  e000              B        |L38.36|
                  |L38.34|
;;;2170     }
;;;2171     else
;;;2172     {
;;;2173       bitstatus = RESET;
000022  2000              MOVS     r0,#0
                  |L38.36|
;;;2174     }
;;;2175     return bitstatus;
;;;2176   }
000024  bd30              POP      {r4,r5,pc}
;;;2177   
                          ENDP


                          AREA ||i.TIM_GetPrescaler||, CODE, READONLY, ALIGN=1

                  TIM_GetPrescaler PROC
;;;275      */
;;;276    uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx)
000000  4601              MOV      r1,r0
;;;277    {
;;;278      /* Check the parameters */
;;;279      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;280      
;;;281      /* Get the Prescaler Register value */
;;;282      return TIMx->PSC;
000002  8d08              LDRH     r0,[r1,#0x28]
;;;283    }
000004  4770              BX       lr
;;;284    
                          ENDP


                          AREA ||i.TIM_ICInit||, CODE, READONLY, ALIGN=1

                  TIM_ICInit PROC
;;;1700     */
;;;1701   void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;1702   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1703     /* Check the parameters */
;;;1704     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1705     assert_param(IS_TIM_CHANNEL(TIM_ICInitStruct->TIM_Channel));  
;;;1706     assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
;;;1707     assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
;;;1708     assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
;;;1709     assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
;;;1710   
;;;1711     if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
000006  8820              LDRH     r0,[r4,#0]
000008  2800              CMP      r0,#0
00000a  d10a              BNE      |L40.34|
;;;1712     {
;;;1713       assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1714       /* TI1 Configuration */
;;;1715       TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
00000c  8923              LDRH     r3,[r4,#8]
00000e  88a2              LDRH     r2,[r4,#4]
000010  8861              LDRH     r1,[r4,#2]
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       TI1_Config
;;;1716                  TIM_ICInitStruct->TIM_ICSelection,
;;;1717                  TIM_ICInitStruct->TIM_ICFilter);
;;;1718       /* Set the Input Capture Prescaler value */
;;;1719       TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000018  88e1              LDRH     r1,[r4,#6]
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       TIM_SetIC1Prescaler
000020  e025              B        |L40.110|
                  |L40.34|
;;;1720     }
;;;1721     else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
000022  8820              LDRH     r0,[r4,#0]
000024  2804              CMP      r0,#4
000026  d10a              BNE      |L40.62|
;;;1722     {
;;;1723       assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1724       /* TI2 Configuration */
;;;1725       TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
000028  8923              LDRH     r3,[r4,#8]
00002a  88a2              LDRH     r2,[r4,#4]
00002c  8861              LDRH     r1,[r4,#2]
00002e  4628              MOV      r0,r5
000030  f7fffffe          BL       TI2_Config
;;;1726                  TIM_ICInitStruct->TIM_ICSelection,
;;;1727                  TIM_ICInitStruct->TIM_ICFilter);
;;;1728       /* Set the Input Capture Prescaler value */
;;;1729       TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000034  88e1              LDRH     r1,[r4,#6]
000036  4628              MOV      r0,r5
000038  f7fffffe          BL       TIM_SetIC2Prescaler
00003c  e017              B        |L40.110|
                  |L40.62|
;;;1730     }
;;;1731     else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
00003e  8820              LDRH     r0,[r4,#0]
000040  2808              CMP      r0,#8
000042  d10a              BNE      |L40.90|
;;;1732     {
;;;1733       assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1734       /* TI3 Configuration */
;;;1735       TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
000044  8923              LDRH     r3,[r4,#8]
000046  88a2              LDRH     r2,[r4,#4]
000048  8861              LDRH     r1,[r4,#2]
00004a  4628              MOV      r0,r5
00004c  f7fffffe          BL       TI3_Config
;;;1736                  TIM_ICInitStruct->TIM_ICSelection,
;;;1737                  TIM_ICInitStruct->TIM_ICFilter);
;;;1738       /* Set the Input Capture Prescaler value */
;;;1739       TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000050  88e1              LDRH     r1,[r4,#6]
000052  4628              MOV      r0,r5
000054  f7fffffe          BL       TIM_SetIC3Prescaler
000058  e009              B        |L40.110|
                  |L40.90|
;;;1740     }
;;;1741     else
;;;1742     {
;;;1743       assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1744       /* TI4 Configuration */
;;;1745       TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
00005a  8923              LDRH     r3,[r4,#8]
00005c  88a2              LDRH     r2,[r4,#4]
00005e  8861              LDRH     r1,[r4,#2]
000060  4628              MOV      r0,r5
000062  f7fffffe          BL       TI4_Config
;;;1746                  TIM_ICInitStruct->TIM_ICSelection,
;;;1747                  TIM_ICInitStruct->TIM_ICFilter);
;;;1748       /* Set the Input Capture Prescaler value */
;;;1749       TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000066  88e1              LDRH     r1,[r4,#6]
000068  4628              MOV      r0,r5
00006a  f7fffffe          BL       TIM_SetIC4Prescaler
                  |L40.110|
;;;1750     }
;;;1751   }
00006e  bd70              POP      {r4-r6,pc}
;;;1752   
                          ENDP


                          AREA ||i.TIM_ICStructInit||, CODE, READONLY, ALIGN=1

                  TIM_ICStructInit PROC
;;;1758     */
;;;1759   void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  2100              MOVS     r1,#0
;;;1760   {
;;;1761     /* Set the default configuration */
;;;1762     TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
000002  8001              STRH     r1,[r0,#0]
;;;1763     TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
000004  8041              STRH     r1,[r0,#2]
;;;1764     TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
000006  2101              MOVS     r1,#1
000008  8081              STRH     r1,[r0,#4]
;;;1765     TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
00000a  2100              MOVS     r1,#0
00000c  80c1              STRH     r1,[r0,#6]
;;;1766     TIM_ICInitStruct->TIM_ICFilter = 0x00;
00000e  8101              STRH     r1,[r0,#8]
;;;1767   }
000010  4770              BX       lr
;;;1768   
                          ENDP


                          AREA ||i.TIM_ITConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITConfig PROC
;;;2002     */
;;;2003   void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;2004   {  
;;;2005     /* Check the parameters */
;;;2006     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2007     assert_param(IS_TIM_IT(TIM_IT));
;;;2008     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2009     
;;;2010     if (NewState != DISABLE)
000002  d003              BEQ      |L42.12|
;;;2011     {
;;;2012       /* Enable the Interrupt sources */
;;;2013       TIMx->DIER |= TIM_IT;
000004  8983              LDRH     r3,[r0,#0xc]
000006  430b              ORRS     r3,r3,r1
000008  8183              STRH     r3,[r0,#0xc]
00000a  e002              B        |L42.18|
                  |L42.12|
;;;2014     }
;;;2015     else
;;;2016     {
;;;2017       /* Disable the Interrupt sources */
;;;2018       TIMx->DIER &= (uint16_t)~TIM_IT;
00000c  8983              LDRH     r3,[r0,#0xc]
00000e  438b              BICS     r3,r3,r1
000010  8183              STRH     r3,[r0,#0xc]
                  |L42.18|
;;;2019     }
;;;2020   }
000012  4770              BX       lr
;;;2021   
                          ENDP


                          AREA ||i.TIM_ITRxExternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITRxExternalClockConfig PROC
;;;2333     */
;;;2334   void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
000000  b530              PUSH     {r4,r5,lr}
;;;2335   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2336     /* Check the parameters */
;;;2337     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2338     assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;2339     /* Select the Internal Trigger */
;;;2340     TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       TIM_SelectInputTrigger
;;;2341     /* Select the External clock mode1 */
;;;2342     TIMx->SMCR |= TIM_SlaveMode_External1;
00000e  8920              LDRH     r0,[r4,#8]
000010  2107              MOVS     r1,#7
000012  4308              ORRS     r0,r0,r1
000014  8120              STRH     r0,[r4,#8]
;;;2343   }
000016  bd30              POP      {r4,r5,pc}
;;;2344   
                          ENDP


                          AREA ||i.TIM_InternalClockConfig||, CODE, READONLY, ALIGN=2

                  TIM_InternalClockConfig PROC
;;;2314     */
;;;2315   void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
000000  8901              LDRH     r1,[r0,#8]
;;;2316   {
;;;2317     /* Check the parameters */
;;;2318     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2319     /* Disable slave mode to clock the prescaler directly with the internal clock */
;;;2320     TIMx->SMCR &=  (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
000002  4a02              LDR      r2,|L44.12|
000004  4011              ANDS     r1,r1,r2
000006  8101              STRH     r1,[r0,#8]
;;;2321   }
000008  4770              BX       lr
;;;2322   
                          ENDP

00000a  0000              DCW      0x0000
                  |L44.12|
                          DCD      0x0000fff8

                          AREA ||i.TIM_OC1FastConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC1FastConfig PROC
;;;1208     */
;;;1209   void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  460a              MOV      r2,r1
;;;1210   {
;;;1211     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1212     
;;;1213     /* Check the parameters */
;;;1214     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1215     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1216     
;;;1217     /* Get the TIMx CCMR1 register value */
;;;1218     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1219     /* Reset the OC1FE Bit */
;;;1220     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1FE);
000006  4b03              LDR      r3,|L45.20|
000008  4019              ANDS     r1,r1,r3
;;;1221     /* Enable or Disable the Output Compare Fast Bit */
;;;1222     tmpccmr1 |= TIM_OCFast;
00000a  460b              MOV      r3,r1
00000c  4313              ORRS     r3,r3,r2
00000e  4619              MOV      r1,r3
;;;1223     /* Write to TIMx CCMR1 */
;;;1224     TIMx->CCMR1 = tmpccmr1;
000010  8301              STRH     r1,[r0,#0x18]
;;;1225   }
000012  4770              BX       lr
;;;1226   
                          ENDP

                  |L45.20|
                          DCD      0x0000fffb

                          AREA ||i.TIM_OC1Init||, CODE, READONLY, ALIGN=2

                  TIM_OC1Init PROC
;;;520      */
;;;521    void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;522    {
;;;523      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000002  2400              MOVS     r4,#0
000004  2200              MOVS     r2,#0
000006  2300              MOVS     r3,#0
;;;524       
;;;525      /* Check the parameters */
;;;526      assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;527      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;528      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;529      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;530     /* Disable the Channel 1: Reset the CC1E Bit */
;;;531      TIMx->CCER &= (uint16_t)(~(uint16_t)TIM_CCER_CC1E);
000008  8c05              LDRH     r5,[r0,#0x20]
00000a  4e1c              LDR      r6,|L46.124|
00000c  4035              ANDS     r5,r5,r6
00000e  8405              STRH     r5,[r0,#0x20]
;;;532      /* Get the TIMx CCER register value */
;;;533      tmpccer = TIMx->CCER;
000010  8c02              LDRH     r2,[r0,#0x20]
;;;534      /* Get the TIMx CR2 register value */
;;;535      tmpcr2 =  TIMx->CR2;
000012  8883              LDRH     r3,[r0,#4]
;;;536      
;;;537      /* Get the TIMx CCMR1 register value */
;;;538      tmpccmrx = TIMx->CCMR1;
000014  8b04              LDRH     r4,[r0,#0x18]
;;;539        
;;;540      /* Reset the Output Compare Mode Bits */
;;;541      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC1M));
000016  4d19              LDR      r5,|L46.124|
000018  3d6f              SUBS     r5,r5,#0x6f
00001a  402c              ANDS     r4,r4,r5
;;;542      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC1S));
00001c  1eb5              SUBS     r5,r6,#2
00001e  402c              ANDS     r4,r4,r5
;;;543    
;;;544      /* Select the Output Compare Mode */
;;;545      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
000020  880d              LDRH     r5,[r1,#0]
000022  432c              ORRS     r4,r4,r5
;;;546      
;;;547      /* Reset the Output Polarity level */
;;;548      tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1P));
000024  1e75              SUBS     r5,r6,#1
000026  402a              ANDS     r2,r2,r5
;;;549      /* Set the Output Compare Polarity */
;;;550      tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
000028  898d              LDRH     r5,[r1,#0xc]
00002a  432a              ORRS     r2,r2,r5
;;;551      
;;;552      /* Set the Output State */
;;;553      tmpccer |= TIM_OCInitStruct->TIM_OutputState;
00002c  884d              LDRH     r5,[r1,#2]
00002e  432a              ORRS     r2,r2,r5
;;;554        
;;;555      if((TIMx == TIM1) || (TIMx == TIM15) || (TIMx == TIM16) || (TIMx == TIM17))
000030  4d13              LDR      r5,|L46.128|
000032  42a8              CMP      r0,r5
000034  d008              BEQ      |L46.72|
000036  4d13              LDR      r5,|L46.132|
000038  42a8              CMP      r0,r5
00003a  d005              BEQ      |L46.72|
00003c  4d12              LDR      r5,|L46.136|
00003e  42a8              CMP      r0,r5
000040  d002              BEQ      |L46.72|
000042  4d12              LDR      r5,|L46.140|
000044  42a8              CMP      r0,r5
000046  d112              BNE      |L46.110|
                  |L46.72|
;;;556      {
;;;557        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;558        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;559        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;560        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;561        
;;;562        /* Reset the Output N Polarity level */
;;;563        tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1NP));
000048  4d0c              LDR      r5,|L46.124|
00004a  1fed              SUBS     r5,r5,#7
00004c  402a              ANDS     r2,r2,r5
;;;564        /* Set the Output N Polarity */
;;;565        tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
00004e  89cd              LDRH     r5,[r1,#0xe]
000050  432a              ORRS     r2,r2,r5
;;;566        
;;;567        /* Reset the Output N State */
;;;568        tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1NE));    
000052  4d0a              LDR      r5,|L46.124|
000054  1eed              SUBS     r5,r5,#3
000056  402a              ANDS     r2,r2,r5
;;;569        /* Set the Output N State */
;;;570        tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
000058  888d              LDRH     r5,[r1,#4]
00005a  432a              ORRS     r2,r2,r5
;;;571        
;;;572        /* Reset the Ouput Compare and Output Compare N IDLE State */
;;;573        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS1));
00005c  4d07              LDR      r5,|L46.124|
00005e  3dff              SUBS     r5,r5,#0xff
000060  402b              ANDS     r3,r3,r5
;;;574        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS1N));
000062  4d0b              LDR      r5,|L46.144|
000064  402b              ANDS     r3,r3,r5
;;;575        
;;;576        /* Set the Output Idle state */
;;;577        tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
000066  8a0d              LDRH     r5,[r1,#0x10]
000068  432b              ORRS     r3,r3,r5
;;;578        /* Set the Output N Idle state */
;;;579        tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
00006a  8a4d              LDRH     r5,[r1,#0x12]
00006c  432b              ORRS     r3,r3,r5
                  |L46.110|
;;;580      }
;;;581      /* Write to TIMx CR2 */
;;;582      TIMx->CR2 = tmpcr2;
00006e  8083              STRH     r3,[r0,#4]
;;;583      
;;;584      /* Write to TIMx CCMR1 */
;;;585      TIMx->CCMR1 = tmpccmrx;
000070  8304              STRH     r4,[r0,#0x18]
;;;586    
;;;587      /* Set the Capture Compare Register value */
;;;588      TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse; 
000072  688d              LDR      r5,[r1,#8]
000074  6345              STR      r5,[r0,#0x34]
;;;589     
;;;590      /* Write to TIMx CCER */
;;;591      TIMx->CCER = tmpccer;
000076  8402              STRH     r2,[r0,#0x20]
;;;592    }
000078  bd70              POP      {r4-r6,pc}
;;;593    
                          ENDP

00007a  0000              DCW      0x0000
                  |L46.124|
                          DCD      0x0000fffe
                  |L46.128|
                          DCD      0x40012c00
                  |L46.132|
                          DCD      0x40014000
                  |L46.136|
                          DCD      0x40014400
                  |L46.140|
                          DCD      0x40014800
                  |L46.144|
                          DCD      0x0000fdff

                          AREA ||i.TIM_OC1NPolarityConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC1NPolarityConfig PROC
;;;1445     */
;;;1446   void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000000  460a              MOV      r2,r1
;;;1447   {
;;;1448     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1449     /* Check the parameters */
;;;1450     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1451     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1452      
;;;1453     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;1454     /* Set or Reset the CC1NP Bit */
;;;1455     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC1NP);
000006  4b03              LDR      r3,|L47.20|
000008  4019              ANDS     r1,r1,r3
;;;1456     tmpccer |= TIM_OCNPolarity;
00000a  460b              MOV      r3,r1
00000c  4313              ORRS     r3,r3,r2
00000e  4619              MOV      r1,r3
;;;1457     /* Write to TIMx CCER register */
;;;1458     TIMx->CCER = tmpccer;
000010  8401              STRH     r1,[r0,#0x20]
;;;1459   }
000012  4770              BX       lr
;;;1460   
                          ENDP

                  |L47.20|
                          DCD      0x0000fff7

                          AREA ||i.TIM_OC1PolarityConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC1PolarityConfig PROC
;;;1420     */
;;;1421   void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  460a              MOV      r2,r1
;;;1422   {
;;;1423     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1424     
;;;1425     /* Check the parameters */
;;;1426     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1427     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1428     
;;;1429     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;1430     /* Set or Reset the CC1P Bit */
;;;1431     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC1P);
000006  4b03              LDR      r3,|L48.20|
000008  4019              ANDS     r1,r1,r3
;;;1432     tmpccer |= TIM_OCPolarity;
00000a  460b              MOV      r3,r1
00000c  4313              ORRS     r3,r3,r2
00000e  4619              MOV      r1,r3
;;;1433     /* Write to TIMx CCER register */
;;;1434     TIMx->CCER = tmpccer;
000010  8401              STRH     r1,[r0,#0x20]
;;;1435   }
000012  4770              BX       lr
;;;1436   
                          ENDP

                  |L48.20|
                          DCD      0x0000fffd

                          AREA ||i.TIM_OC1PreloadConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC1PreloadConfig PROC
;;;1106     */
;;;1107   void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  460a              MOV      r2,r1
;;;1108   {
;;;1109     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1110     /* Check the parameters */
;;;1111     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1112     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1113     
;;;1114     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1115     /* Reset the OC1PE Bit */
;;;1116     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1PE);
000006  4b03              LDR      r3,|L49.20|
000008  4019              ANDS     r1,r1,r3
;;;1117     /* Enable or Disable the Output Compare Preload feature */
;;;1118     tmpccmr1 |= TIM_OCPreload;
00000a  460b              MOV      r3,r1
00000c  4313              ORRS     r3,r3,r2
00000e  4619              MOV      r1,r3
;;;1119     /* Write to TIMx CCMR1 register */
;;;1120     TIMx->CCMR1 = tmpccmr1;
000010  8301              STRH     r1,[r0,#0x18]
;;;1121   }
000012  4770              BX       lr
;;;1122   
                          ENDP

                  |L49.20|
                          DCD      0x0000fff7

                          AREA ||i.TIM_OC2FastConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC2FastConfig PROC
;;;1235     */
;;;1236   void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  460a              MOV      r2,r1
;;;1237   {
;;;1238     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1239     
;;;1240     /* Check the parameters */
;;;1241     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1242     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1243     
;;;1244     /* Get the TIMx CCMR1 register value */
;;;1245     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1246     /* Reset the OC2FE Bit */
;;;1247     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2FE);
000006  4b03              LDR      r3,|L50.20|
000008  4019              ANDS     r1,r1,r3
;;;1248     /* Enable or Disable the Output Compare Fast Bit */
;;;1249     tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);
00000a  0613              LSLS     r3,r2,#24
00000c  0c1b              LSRS     r3,r3,#16
00000e  4319              ORRS     r1,r1,r3
;;;1250     /* Write to TIMx CCMR1 */
;;;1251     TIMx->CCMR1 = tmpccmr1;
000010  8301              STRH     r1,[r0,#0x18]
;;;1252   }
000012  4770              BX       lr
;;;1253   
                          ENDP

                  |L50.20|
                          DCD      0x0000fbff

                          AREA ||i.TIM_OC2Init||, CODE, READONLY, ALIGN=2

                  TIM_OC2Init PROC
;;;602      */
;;;603    void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;604    {
;;;605      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000002  2400              MOVS     r4,#0
000004  2200              MOVS     r2,#0
000006  2300              MOVS     r3,#0
;;;606       
;;;607      /* Check the parameters */
;;;608      assert_param(IS_TIM_LIST6_PERIPH(TIMx)); 
;;;609      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;610      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;611      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;612       /* Disable the Channel 2: Reset the CC2E Bit */
;;;613      TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC2E));
000008  8c05              LDRH     r5,[r0,#0x20]
00000a  4e21              LDR      r6,|L51.144|
00000c  4035              ANDS     r5,r5,r6
00000e  8405              STRH     r5,[r0,#0x20]
;;;614      
;;;615      /* Get the TIMx CCER register value */  
;;;616      tmpccer = TIMx->CCER;
000010  8c02              LDRH     r2,[r0,#0x20]
;;;617      /* Get the TIMx CR2 register value */
;;;618      tmpcr2 =  TIMx->CR2;
000012  8883              LDRH     r3,[r0,#4]
;;;619      
;;;620      /* Get the TIMx CCMR1 register value */
;;;621      tmpccmrx = TIMx->CCMR1;
000014  8b04              LDRH     r4,[r0,#0x18]
;;;622        
;;;623      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;624      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC2M));
000016  4d1f              LDR      r5,|L51.148|
000018  402c              ANDS     r4,r4,r5
;;;625      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S));
00001a  4d1f              LDR      r5,|L51.152|
00001c  402c              ANDS     r4,r4,r5
;;;626      
;;;627      /* Select the Output Compare Mode */
;;;628      tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
00001e  780d              LDRB     r5,[r1,#0]
000020  062d              LSLS     r5,r5,#24
000022  0c2d              LSRS     r5,r5,#16
000024  432c              ORRS     r4,r4,r5
;;;629      
;;;630      /* Reset the Output Polarity level */
;;;631      tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2P));
000026  4d1a              LDR      r5,|L51.144|
000028  3d10              SUBS     r5,r5,#0x10
00002a  402a              ANDS     r2,r2,r5
;;;632      /* Set the Output Compare Polarity */
;;;633      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
00002c  898d              LDRH     r5,[r1,#0xc]
00002e  052d              LSLS     r5,r5,#20
000030  0c2d              LSRS     r5,r5,#16
000032  432a              ORRS     r2,r2,r5
;;;634      
;;;635      /* Set the Output State */
;;;636      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
000034  884d              LDRH     r5,[r1,#2]
000036  052d              LSLS     r5,r5,#20
000038  0c2d              LSRS     r5,r5,#16
00003a  432a              ORRS     r2,r2,r5
;;;637        
;;;638      if((TIMx == TIM1) || (TIMx == TIM15))
00003c  4d17              LDR      r5,|L51.156|
00003e  42a8              CMP      r0,r5
000040  d002              BEQ      |L51.72|
000042  4d17              LDR      r5,|L51.160|
000044  42a8              CMP      r0,r5
000046  d11c              BNE      |L51.130|
                  |L51.72|
;;;639      {
;;;640        /* Check the parameters */
;;;641        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;642        
;;;643        /* Reset the Ouput Compare State */
;;;644        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS2));
000048  4d16              LDR      r5,|L51.164|
00004a  402b              ANDS     r3,r3,r5
;;;645        
;;;646        /* Set the Output Idle state */
;;;647        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
00004c  8a0d              LDRH     r5,[r1,#0x10]
00004e  04ad              LSLS     r5,r5,#18
000050  0c2d              LSRS     r5,r5,#16
000052  432b              ORRS     r3,r3,r5
;;;648        
;;;649        if (TIMx == TIM1)
000054  4d11              LDR      r5,|L51.156|
000056  42a8              CMP      r0,r5
000058  d113              BNE      |L51.130|
;;;650        {    
;;;651          /* Check the parameters */
;;;652          assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;653          assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;654          assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;655          
;;;656          /* Reset the Output N Polarity level */
;;;657          tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2NP));
00005a  4d0d              LDR      r5,|L51.144|
00005c  3d70              SUBS     r5,r5,#0x70
00005e  402a              ANDS     r2,r2,r5
;;;658          /* Set the Output N Polarity */
;;;659          tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
000060  89cd              LDRH     r5,[r1,#0xe]
000062  052d              LSLS     r5,r5,#20
000064  0c2d              LSRS     r5,r5,#16
000066  432a              ORRS     r2,r2,r5
;;;660          
;;;661          /* Reset the Output N State */
;;;662          tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2NE));    
000068  4d09              LDR      r5,|L51.144|
00006a  3d30              SUBS     r5,r5,#0x30
00006c  402a              ANDS     r2,r2,r5
;;;663          /* Set the Output N State */
;;;664          tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
00006e  888d              LDRH     r5,[r1,#4]
000070  052d              LSLS     r5,r5,#20
000072  0c2d              LSRS     r5,r5,#16
000074  432a              ORRS     r2,r2,r5
;;;665          
;;;666          /* Reset the Output Compare N IDLE State */
;;;667          tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS2N));
000076  4d0c              LDR      r5,|L51.168|
000078  402b              ANDS     r3,r3,r5
;;;668          
;;;669          /* Set the Output N Idle state */
;;;670          tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
00007a  8a4d              LDRH     r5,[r1,#0x12]
00007c  04ad              LSLS     r5,r5,#18
00007e  0c2d              LSRS     r5,r5,#16
000080  432b              ORRS     r3,r3,r5
                  |L51.130|
;;;671        }
;;;672      }
;;;673      /* Write to TIMx CR2 */
;;;674      TIMx->CR2 = tmpcr2;
000082  8083              STRH     r3,[r0,#4]
;;;675      
;;;676      /* Write to TIMx CCMR1 */
;;;677      TIMx->CCMR1 = tmpccmrx;
000084  8304              STRH     r4,[r0,#0x18]
;;;678    
;;;679      /* Set the Capture Compare Register value */
;;;680      TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
000086  688d              LDR      r5,[r1,#8]
000088  6385              STR      r5,[r0,#0x38]
;;;681      
;;;682      /* Write to TIMx CCER */
;;;683      TIMx->CCER = tmpccer;
00008a  8402              STRH     r2,[r0,#0x20]
;;;684    }
00008c  bd70              POP      {r4-r6,pc}
;;;685    
                          ENDP

00008e  0000              DCW      0x0000
                  |L51.144|
                          DCD      0x0000ffef
                  |L51.148|
                          DCD      0x00008fff
                  |L51.152|
                          DCD      0x0000fcff
                  |L51.156|
                          DCD      0x40012c00
                  |L51.160|
                          DCD      0x40014000
                  |L51.164|
                          DCD      0x0000fbff
                  |L51.168|
                          DCD      0x0000f7ff

                          AREA ||i.TIM_OC2NPolarityConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC2NPolarityConfig PROC
;;;1494     */
;;;1495   void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000000  460a              MOV      r2,r1
;;;1496   {
;;;1497     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1498     /* Check the parameters */
;;;1499     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1500     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1501     
;;;1502     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;1503     /* Set or Reset the CC2NP Bit */
;;;1504     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC2NP);
000006  4b03              LDR      r3,|L52.20|
000008  4019              ANDS     r1,r1,r3
;;;1505     tmpccer |= (uint16_t)(TIM_OCNPolarity << 4);
00000a  0513              LSLS     r3,r2,#20
00000c  0c1b              LSRS     r3,r3,#16
00000e  4319              ORRS     r1,r1,r3
;;;1506     /* Write to TIMx CCER register */
;;;1507     TIMx->CCER = tmpccer;
000010  8401              STRH     r1,[r0,#0x20]
;;;1508   }
000012  4770              BX       lr
;;;1509   
                          ENDP

                  |L52.20|
                          DCD      0x0000ff7f

                          AREA ||i.TIM_OC2PolarityConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC2PolarityConfig PROC
;;;1469     */
;;;1470   void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  460a              MOV      r2,r1
;;;1471   {
;;;1472     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1473     
;;;1474     /* Check the parameters */
;;;1475     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1476     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1477     
;;;1478     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;1479     /* Set or Reset the CC2P Bit */
;;;1480     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC2P);
000006  4b03              LDR      r3,|L53.20|
000008  4019              ANDS     r1,r1,r3
;;;1481     tmpccer |= (uint16_t)(TIM_OCPolarity << 4);
00000a  0513              LSLS     r3,r2,#20
00000c  0c1b              LSRS     r3,r3,#16
00000e  4319              ORRS     r1,r1,r3
;;;1482     /* Write to TIMx CCER register */
;;;1483     TIMx->CCER = tmpccer;
000010  8401              STRH     r1,[r0,#0x20]
;;;1484   }
000012  4770              BX       lr
;;;1485   
                          ENDP

                  |L53.20|
                          DCD      0x0000ffdf

                          AREA ||i.TIM_OC2PreloadConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC2PreloadConfig PROC
;;;1131     */
;;;1132   void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  460a              MOV      r2,r1
;;;1133   {
;;;1134     uint16_t tmpccmr1 = 0;
000002  2100              MOVS     r1,#0
;;;1135     /* Check the parameters */
;;;1136     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1137     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1138     
;;;1139     tmpccmr1 = TIMx->CCMR1;
000004  8b01              LDRH     r1,[r0,#0x18]
;;;1140     /* Reset the OC2PE Bit */
;;;1141     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2PE);
000006  4b03              LDR      r3,|L54.20|
000008  4019              ANDS     r1,r1,r3
;;;1142     /* Enable or Disable the Output Compare Preload feature */
;;;1143     tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
00000a  0613              LSLS     r3,r2,#24
00000c  0c1b              LSRS     r3,r3,#16
00000e  4319              ORRS     r1,r1,r3
;;;1144     /* Write to TIMx CCMR1 register */
;;;1145     TIMx->CCMR1 = tmpccmr1;
000010  8301              STRH     r1,[r0,#0x18]
;;;1146   }
000012  4770              BX       lr
;;;1147   
                          ENDP

                  |L54.20|
                          DCD      0x0000f7ff

                          AREA ||i.TIM_OC3FastConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC3FastConfig PROC
;;;1262     */
;;;1263   void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  460a              MOV      r2,r1
;;;1264   {
;;;1265     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1266     
;;;1267     /* Check the parameters */
;;;1268     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1269     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1270     
;;;1271     /* Get the TIMx CCMR2 register value */
;;;1272     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1273     /* Reset the OC3FE Bit */
;;;1274     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3FE);
000006  4b03              LDR      r3,|L55.20|
000008  4019              ANDS     r1,r1,r3
;;;1275     /* Enable or Disable the Output Compare Fast Bit */
;;;1276     tmpccmr2 |= TIM_OCFast;
00000a  460b              MOV      r3,r1
00000c  4313              ORRS     r3,r3,r2
00000e  4619              MOV      r1,r3
;;;1277     /* Write to TIMx CCMR2 */
;;;1278     TIMx->CCMR2 = tmpccmr2;
000010  8381              STRH     r1,[r0,#0x1c]
;;;1279   }
000012  4770              BX       lr
;;;1280   
                          ENDP

                  |L55.20|
                          DCD      0x0000fffb

                          AREA ||i.TIM_OC3Init||, CODE, READONLY, ALIGN=2

                  TIM_OC3Init PROC
;;;694      */
;;;695    void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;696    {
;;;697      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000002  2400              MOVS     r4,#0
000004  2200              MOVS     r2,#0
000006  2300              MOVS     r3,#0
;;;698       
;;;699      /* Check the parameters */
;;;700      assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;701      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;702      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;703      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;704      /* Disable the Channel 2: Reset the CC2E Bit */
;;;705      TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC3E));
000008  8c05              LDRH     r5,[r0,#0x20]
00000a  4e1c              LDR      r6,|L56.124|
00000c  4035              ANDS     r5,r5,r6
00000e  8405              STRH     r5,[r0,#0x20]
;;;706      
;;;707      /* Get the TIMx CCER register value */
;;;708      tmpccer = TIMx->CCER;
000010  8c02              LDRH     r2,[r0,#0x20]
;;;709      /* Get the TIMx CR2 register value */
;;;710      tmpcr2 =  TIMx->CR2;
000012  8883              LDRH     r3,[r0,#4]
;;;711      
;;;712      /* Get the TIMx CCMR2 register value */
;;;713      tmpccmrx = TIMx->CCMR2;
000014  8b84              LDRH     r4,[r0,#0x1c]
;;;714        
;;;715      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;716      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC3M));
000016  4d19              LDR      r5,|L56.124|
000018  3590              ADDS     r5,r5,#0x90
00001a  402c              ANDS     r4,r4,r5
;;;717      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC3S));  
00001c  4d17              LDR      r5,|L56.124|
00001e  35fd              ADDS     r5,r5,#0xfd
000020  402c              ANDS     r4,r4,r5
;;;718      /* Select the Output Compare Mode */
;;;719      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
000022  880d              LDRH     r5,[r1,#0]
000024  432c              ORRS     r4,r4,r5
;;;720      
;;;721      /* Reset the Output Polarity level */
;;;722      tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3P));
000026  4d16              LDR      r5,|L56.128|
000028  402a              ANDS     r2,r2,r5
;;;723      /* Set the Output Compare Polarity */
;;;724      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
00002a  7b0d              LDRB     r5,[r1,#0xc]
00002c  062d              LSLS     r5,r5,#24
00002e  0c2d              LSRS     r5,r5,#16
000030  432a              ORRS     r2,r2,r5
;;;725      
;;;726      /* Set the Output State */
;;;727      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
000032  788d              LDRB     r5,[r1,#2]
000034  062d              LSLS     r5,r5,#24
000036  0c2d              LSRS     r5,r5,#16
000038  432a              ORRS     r2,r2,r5
;;;728        
;;;729      if(TIMx == TIM1)
00003a  4d12              LDR      r5,|L56.132|
00003c  42a8              CMP      r0,r5
00003e  d117              BNE      |L56.112|
;;;730      {
;;;731        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;732        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;733        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;734        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;735        
;;;736        /* Reset the Output N Polarity level */
;;;737        tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3NP));
000040  4d11              LDR      r5,|L56.136|
000042  402a              ANDS     r2,r2,r5
;;;738        /* Set the Output N Polarity */
;;;739        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
000044  7b8d              LDRB     r5,[r1,#0xe]
000046  062d              LSLS     r5,r5,#24
000048  0c2d              LSRS     r5,r5,#16
00004a  432a              ORRS     r2,r2,r5
;;;740        /* Reset the Output N State */
;;;741        tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3NE));
00004c  4d0f              LDR      r5,|L56.140|
00004e  402a              ANDS     r2,r2,r5
;;;742        
;;;743        /* Set the Output N State */
;;;744        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
000050  790d              LDRB     r5,[r1,#4]
000052  062d              LSLS     r5,r5,#24
000054  0c2d              LSRS     r5,r5,#16
000056  432a              ORRS     r2,r2,r5
;;;745        /* Reset the Ouput Compare and Output Compare N IDLE State */
;;;746        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS3));
000058  4d0d              LDR      r5,|L56.144|
00005a  402b              ANDS     r3,r3,r5
;;;747        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS3N));
00005c  4d0d              LDR      r5,|L56.148|
00005e  402b              ANDS     r3,r3,r5
;;;748        /* Set the Output Idle state */
;;;749        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
000060  8a0d              LDRH     r5,[r1,#0x10]
000062  052d              LSLS     r5,r5,#20
000064  0c2d              LSRS     r5,r5,#16
000066  432b              ORRS     r3,r3,r5
;;;750        /* Set the Output N Idle state */
;;;751        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
000068  8a4d              LDRH     r5,[r1,#0x12]
00006a  052d              LSLS     r5,r5,#20
00006c  0c2d              LSRS     r5,r5,#16
00006e  432b              ORRS     r3,r3,r5
                  |L56.112|
;;;752      }
;;;753      /* Write to TIMx CR2 */
;;;754      TIMx->CR2 = tmpcr2;
000070  8083              STRH     r3,[r0,#4]
;;;755      
;;;756      /* Write to TIMx CCMR2 */
;;;757      TIMx->CCMR2 = tmpccmrx;
000072  8384              STRH     r4,[r0,#0x1c]
;;;758    
;;;759      /* Set the Capture Compare Register value */
;;;760      TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
000074  688d              LDR      r5,[r1,#8]
000076  63c5              STR      r5,[r0,#0x3c]
;;;761      
;;;762      /* Write to TIMx CCER */
;;;763      TIMx->CCER = tmpccer;
000078  8402              STRH     r2,[r0,#0x20]
;;;764    }
00007a  bd70              POP      {r4-r6,pc}
;;;765    
                          ENDP

                  |L56.124|
                          DCD      0x0000feff
                  |L56.128|
                          DCD      0x0000fdff
                  |L56.132|
                          DCD      0x40012c00
                  |L56.136|
                          DCD      0x0000f7ff
                  |L56.140|
                          DCD      0x0000fbff
                  |L56.144|
                          DCD      0x0000efff
                  |L56.148|
                          DCD      0x0000dfff

                          AREA ||i.TIM_OC3NPolarityConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC3NPolarityConfig PROC
;;;1543     */
;;;1544   void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000000  460a              MOV      r2,r1
;;;1545   {
;;;1546     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1547    
;;;1548     /* Check the parameters */
;;;1549     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1550     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1551       
;;;1552     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;1553     /* Set or Reset the CC3NP Bit */
;;;1554     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC3NP);
000006  4b03              LDR      r3,|L57.20|
000008  4019              ANDS     r1,r1,r3
;;;1555     tmpccer |= (uint16_t)(TIM_OCNPolarity << 8);
00000a  0613              LSLS     r3,r2,#24
00000c  0c1b              LSRS     r3,r3,#16
00000e  4319              ORRS     r1,r1,r3
;;;1556     /* Write to TIMx CCER register */
;;;1557     TIMx->CCER = tmpccer;
000010  8401              STRH     r1,[r0,#0x20]
;;;1558   }
000012  4770              BX       lr
;;;1559   
                          ENDP

                  |L57.20|
                          DCD      0x0000f7ff

                          AREA ||i.TIM_OC3PolarityConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC3PolarityConfig PROC
;;;1518     */
;;;1519   void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  460a              MOV      r2,r1
;;;1520   {
;;;1521     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1522     
;;;1523     /* Check the parameters */
;;;1524     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1525     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1526     
;;;1527     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;1528     /* Set or Reset the CC3P Bit */
;;;1529     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC3P);
000006  4b03              LDR      r3,|L58.20|
000008  4019              ANDS     r1,r1,r3
;;;1530     tmpccer |= (uint16_t)(TIM_OCPolarity << 8);
00000a  0613              LSLS     r3,r2,#24
00000c  0c1b              LSRS     r3,r3,#16
00000e  4319              ORRS     r1,r1,r3
;;;1531     /* Write to TIMx CCER register */
;;;1532     TIMx->CCER = tmpccer;
000010  8401              STRH     r1,[r0,#0x20]
;;;1533   }
000012  4770              BX       lr
;;;1534   
                          ENDP

                  |L58.20|
                          DCD      0x0000fdff

                          AREA ||i.TIM_OC3PreloadConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC3PreloadConfig PROC
;;;1156     */
;;;1157   void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  460a              MOV      r2,r1
;;;1158   {
;;;1159     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1160     
;;;1161     /* Check the parameters */
;;;1162     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1163     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1164     
;;;1165     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1166     /* Reset the OC3PE Bit */
;;;1167     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3PE);
000006  4b03              LDR      r3,|L59.20|
000008  4019              ANDS     r1,r1,r3
;;;1168     /* Enable or Disable the Output Compare Preload feature */
;;;1169     tmpccmr2 |= TIM_OCPreload;
00000a  460b              MOV      r3,r1
00000c  4313              ORRS     r3,r3,r2
00000e  4619              MOV      r1,r3
;;;1170     /* Write to TIMx CCMR2 register */
;;;1171     TIMx->CCMR2 = tmpccmr2;
000010  8381              STRH     r1,[r0,#0x1c]
;;;1172   }
000012  4770              BX       lr
;;;1173   
                          ENDP

                  |L59.20|
                          DCD      0x0000fff7

                          AREA ||i.TIM_OC4FastConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC4FastConfig PROC
;;;1289     */
;;;1290   void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  460a              MOV      r2,r1
;;;1291   {
;;;1292     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1293     
;;;1294     /* Check the parameters */
;;;1295     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1296     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1297     
;;;1298     /* Get the TIMx CCMR2 register value */
;;;1299     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1300     /* Reset the OC4FE Bit */
;;;1301     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4FE);
000006  4b03              LDR      r3,|L60.20|
000008  4019              ANDS     r1,r1,r3
;;;1302     /* Enable or Disable the Output Compare Fast Bit */
;;;1303     tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);
00000a  0613              LSLS     r3,r2,#24
00000c  0c1b              LSRS     r3,r3,#16
00000e  4319              ORRS     r1,r1,r3
;;;1304     /* Write to TIMx CCMR2 */
;;;1305     TIMx->CCMR2 = tmpccmr2;
000010  8381              STRH     r1,[r0,#0x1c]
;;;1306   }
000012  4770              BX       lr
;;;1307   
                          ENDP

                  |L60.20|
                          DCD      0x0000fbff

                          AREA ||i.TIM_OC4Init||, CODE, READONLY, ALIGN=2

                  TIM_OC4Init PROC
;;;774      */
;;;775    void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;776    {
;;;777      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
000002  2200              MOVS     r2,#0
000004  2300              MOVS     r3,#0
000006  2400              MOVS     r4,#0
;;;778       
;;;779      /* Check the parameters */
;;;780      assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;781      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;782      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;783      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;784      /* Disable the Channel 2: Reset the CC4E Bit */
;;;785      TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC4E));
000008  8c05              LDRH     r5,[r0,#0x20]
00000a  4e13              LDR      r6,|L61.88|
00000c  4035              ANDS     r5,r5,r6
00000e  8405              STRH     r5,[r0,#0x20]
;;;786      
;;;787      /* Get the TIMx CCER register value */
;;;788      tmpccer = TIMx->CCER;
000010  8c03              LDRH     r3,[r0,#0x20]
;;;789      /* Get the TIMx CR2 register value */
;;;790      tmpcr2 =  TIMx->CR2;
000012  8884              LDRH     r4,[r0,#4]
;;;791      
;;;792      /* Get the TIMx CCMR2 register value */
;;;793      tmpccmrx = TIMx->CCMR2;
000014  8b82              LDRH     r2,[r0,#0x1c]
;;;794        
;;;795      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;796      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC4M));
000016  4d11              LDR      r5,|L61.92|
000018  402a              ANDS     r2,r2,r5
;;;797      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC4S));
00001a  4d11              LDR      r5,|L61.96|
00001c  402a              ANDS     r2,r2,r5
;;;798      
;;;799      /* Select the Output Compare Mode */
;;;800      tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
00001e  780d              LDRB     r5,[r1,#0]
000020  062d              LSLS     r5,r5,#24
000022  0c2d              LSRS     r5,r5,#16
000024  432a              ORRS     r2,r2,r5
;;;801      
;;;802      /* Reset the Output Polarity level */
;;;803      tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC4P));
000026  4d0f              LDR      r5,|L61.100|
000028  402b              ANDS     r3,r3,r5
;;;804      /* Set the Output Compare Polarity */
;;;805      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
00002a  7b0d              LDRB     r5,[r1,#0xc]
00002c  072d              LSLS     r5,r5,#28
00002e  0c2d              LSRS     r5,r5,#16
000030  432b              ORRS     r3,r3,r5
;;;806      
;;;807      /* Set the Output State */
;;;808      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
000032  788d              LDRB     r5,[r1,#2]
000034  072d              LSLS     r5,r5,#28
000036  0c2d              LSRS     r5,r5,#16
000038  432b              ORRS     r3,r3,r5
;;;809        
;;;810      if(TIMx == TIM1)
00003a  4d0b              LDR      r5,|L61.104|
00003c  42a8              CMP      r0,r5
00003e  d105              BNE      |L61.76|
;;;811      {
;;;812        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;813        /* Reset the Ouput Compare IDLE State */
;;;814        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS4));
000040  4d0a              LDR      r5,|L61.108|
000042  402c              ANDS     r4,r4,r5
;;;815        /* Set the Output Idle state */
;;;816        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
000044  8a0d              LDRH     r5,[r1,#0x10]
000046  05ad              LSLS     r5,r5,#22
000048  0c2d              LSRS     r5,r5,#16
00004a  432c              ORRS     r4,r4,r5
                  |L61.76|
;;;817      }
;;;818      /* Write to TIMx CR2 */
;;;819      TIMx->CR2 = tmpcr2;
00004c  8084              STRH     r4,[r0,#4]
;;;820      
;;;821      /* Write to TIMx CCMR2 */  
;;;822      TIMx->CCMR2 = tmpccmrx;
00004e  8382              STRH     r2,[r0,#0x1c]
;;;823    
;;;824      /* Set the Capture Compare Register value */
;;;825      TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
000050  688d              LDR      r5,[r1,#8]
000052  6405              STR      r5,[r0,#0x40]
;;;826      
;;;827      /* Write to TIMx CCER */
;;;828      TIMx->CCER = tmpccer;
000054  8403              STRH     r3,[r0,#0x20]
;;;829    }
000056  bd70              POP      {r4-r6,pc}
;;;830    
                          ENDP

                  |L61.88|
                          DCD      0x0000efff
                  |L61.92|
                          DCD      0x00008fff
                  |L61.96|
                          DCD      0x0000fcff
                  |L61.100|
                          DCD      0x0000dfff
                  |L61.104|
                          DCD      0x40012c00
                  |L61.108|
                          DCD      0x0000bfff

                          AREA ||i.TIM_OC4PolarityConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC4PolarityConfig PROC
;;;1568     */
;;;1569   void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  460a              MOV      r2,r1
;;;1570   {
;;;1571     uint16_t tmpccer = 0;
000002  2100              MOVS     r1,#0
;;;1572     
;;;1573     /* Check the parameters */
;;;1574     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1575     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1576     
;;;1577     tmpccer = TIMx->CCER;
000004  8c01              LDRH     r1,[r0,#0x20]
;;;1578     /* Set or Reset the CC4P Bit */
;;;1579     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC4P);
000006  4b03              LDR      r3,|L62.20|
000008  4019              ANDS     r1,r1,r3
;;;1580     tmpccer |= (uint16_t)(TIM_OCPolarity << 12);
00000a  0713              LSLS     r3,r2,#28
00000c  0c1b              LSRS     r3,r3,#16
00000e  4319              ORRS     r1,r1,r3
;;;1581     /* Write to TIMx CCER register */
;;;1582     TIMx->CCER = tmpccer;
000010  8401              STRH     r1,[r0,#0x20]
;;;1583   }
000012  4770              BX       lr
;;;1584   
                          ENDP

                  |L62.20|
                          DCD      0x0000dfff

                          AREA ||i.TIM_OC4PreloadConfig||, CODE, READONLY, ALIGN=2

                  TIM_OC4PreloadConfig PROC
;;;1182     */
;;;1183   void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  460a              MOV      r2,r1
;;;1184   {
;;;1185     uint16_t tmpccmr2 = 0;
000002  2100              MOVS     r1,#0
;;;1186     
;;;1187     /* Check the parameters */
;;;1188     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1189     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1190     
;;;1191     tmpccmr2 = TIMx->CCMR2;
000004  8b81              LDRH     r1,[r0,#0x1c]
;;;1192     /* Reset the OC4PE Bit */
;;;1193     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4PE);
000006  4b03              LDR      r3,|L63.20|
000008  4019              ANDS     r1,r1,r3
;;;1194     /* Enable or Disable the Output Compare Preload feature */
;;;1195     tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);
00000a  0613              LSLS     r3,r2,#24
00000c  0c1b              LSRS     r3,r3,#16
00000e  4319              ORRS     r1,r1,r3
;;;1196     /* Write to TIMx CCMR2 register */
;;;1197     TIMx->CCMR2 = tmpccmr2;
000010  8381              STRH     r1,[r0,#0x1c]
;;;1198   }
000012  4770              BX       lr
;;;1199   
                          ENDP

                  |L63.20|
                          DCD      0x0000f7ff

                          AREA ||i.TIM_OCStructInit||, CODE, READONLY, ALIGN=1

                  TIM_OCStructInit PROC
;;;836      */
;;;837    void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  2100              MOVS     r1,#0
;;;838    {
;;;839      /* Set the default configuration */
;;;840      TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
000002  8001              STRH     r1,[r0,#0]
;;;841      TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
000004  8041              STRH     r1,[r0,#2]
;;;842      TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
000006  8081              STRH     r1,[r0,#4]
;;;843      TIM_OCInitStruct->TIM_Pulse = 0x0000000;
000008  6081              STR      r1,[r0,#8]
;;;844      TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
00000a  8181              STRH     r1,[r0,#0xc]
;;;845      TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
00000c  81c1              STRH     r1,[r0,#0xe]
;;;846      TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
00000e  8201              STRH     r1,[r0,#0x10]
;;;847      TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
000010  8241              STRH     r1,[r0,#0x12]
;;;848    }
000012  4770              BX       lr
;;;849    
                          ENDP


                          AREA ||i.TIM_PWMIConfig||, CODE, READONLY, ALIGN=1

                  TIM_PWMIConfig PROC
;;;1777     */
;;;1778   void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1779   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1780     uint16_t icoppositepolarity = TIM_ICPolarity_Rising;
000006  2600              MOVS     r6,#0
;;;1781     uint16_t icoppositeselection = TIM_ICSelection_DirectTI;
000008  2701              MOVS     r7,#1
;;;1782     /* Check the parameters */
;;;1783     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1784     /* Select the Opposite Input Polarity */
;;;1785     if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
00000a  8860              LDRH     r0,[r4,#2]
00000c  2800              CMP      r0,#0
00000e  d101              BNE      |L65.20|
;;;1786     {
;;;1787       icoppositepolarity = TIM_ICPolarity_Falling;
000010  2602              MOVS     r6,#2
000012  e000              B        |L65.22|
                  |L65.20|
;;;1788     }
;;;1789     else
;;;1790     {
;;;1791       icoppositepolarity = TIM_ICPolarity_Rising;
000014  2600              MOVS     r6,#0
                  |L65.22|
;;;1792     }
;;;1793     /* Select the Opposite Input */
;;;1794     if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
000016  88a0              LDRH     r0,[r4,#4]
000018  2801              CMP      r0,#1
00001a  d101              BNE      |L65.32|
;;;1795     {
;;;1796       icoppositeselection = TIM_ICSelection_IndirectTI;
00001c  2702              MOVS     r7,#2
00001e  e000              B        |L65.34|
                  |L65.32|
;;;1797     }
;;;1798     else
;;;1799     {
;;;1800       icoppositeselection = TIM_ICSelection_DirectTI;
000020  2701              MOVS     r7,#1
                  |L65.34|
;;;1801     }
;;;1802     if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
000022  8820              LDRH     r0,[r4,#0]
000024  2800              CMP      r0,#0
000026  d114              BNE      |L65.82|
;;;1803     {
;;;1804       /* TI1 Configuration */
;;;1805       TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
000028  8923              LDRH     r3,[r4,#8]
00002a  88a2              LDRH     r2,[r4,#4]
00002c  8861              LDRH     r1,[r4,#2]
00002e  4628              MOV      r0,r5
000030  f7fffffe          BL       TI1_Config
;;;1806                  TIM_ICInitStruct->TIM_ICFilter);
;;;1807       /* Set the Input Capture Prescaler value */
;;;1808       TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000034  88e1              LDRH     r1,[r4,#6]
000036  4628              MOV      r0,r5
000038  f7fffffe          BL       TIM_SetIC1Prescaler
;;;1809       /* TI2 Configuration */
;;;1810       TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
00003c  8923              LDRH     r3,[r4,#8]
00003e  463a              MOV      r2,r7
000040  4631              MOV      r1,r6
000042  4628              MOV      r0,r5
000044  f7fffffe          BL       TI2_Config
;;;1811       /* Set the Input Capture Prescaler value */
;;;1812       TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000048  88e1              LDRH     r1,[r4,#6]
00004a  4628              MOV      r0,r5
00004c  f7fffffe          BL       TIM_SetIC2Prescaler
000050  e013              B        |L65.122|
                  |L65.82|
;;;1813     }
;;;1814     else
;;;1815     { 
;;;1816       /* TI2 Configuration */
;;;1817       TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
000052  8923              LDRH     r3,[r4,#8]
000054  88a2              LDRH     r2,[r4,#4]
000056  8861              LDRH     r1,[r4,#2]
000058  4628              MOV      r0,r5
00005a  f7fffffe          BL       TI2_Config
;;;1818                  TIM_ICInitStruct->TIM_ICFilter);
;;;1819       /* Set the Input Capture Prescaler value */
;;;1820       TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
00005e  88e1              LDRH     r1,[r4,#6]
000060  4628              MOV      r0,r5
000062  f7fffffe          BL       TIM_SetIC2Prescaler
;;;1821       /* TI1 Configuration */
;;;1822       TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
000066  8923              LDRH     r3,[r4,#8]
000068  463a              MOV      r2,r7
00006a  4631              MOV      r1,r6
00006c  4628              MOV      r0,r5
00006e  f7fffffe          BL       TI1_Config
;;;1823       /* Set the Input Capture Prescaler value */
;;;1824       TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000072  88e1              LDRH     r1,[r4,#6]
000074  4628              MOV      r0,r5
000076  f7fffffe          BL       TIM_SetIC1Prescaler
                  |L65.122|
;;;1825     }
;;;1826   }
00007a  bdf8              POP      {r3-r7,pc}
;;;1827   
                          ENDP


                          AREA ||i.TIM_PrescalerConfig||, CODE, READONLY, ALIGN=1

                  TIM_PrescalerConfig PROC
;;;182      */
;;;183    void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)
000000  8501              STRH     r1,[r0,#0x28]
;;;184    {
;;;185      /* Check the parameters */
;;;186      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;187      assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
;;;188      
;;;189      /* Set the Prescaler value */
;;;190      TIMx->PSC = Prescaler;
;;;191      /* Set or reset the UG Bit */
;;;192      TIMx->EGR = TIM_PSCReloadMode;
000002  8282              STRH     r2,[r0,#0x14]
;;;193    }
000004  4770              BX       lr
;;;194    
                          ENDP


                          AREA ||i.TIM_RemapConfig||, CODE, READONLY, ALIGN=1

                  TIM_RemapConfig PROC
;;;2711     */
;;;2712   void TIM_RemapConfig(TIM_TypeDef* TIMx, uint16_t TIM_Remap)
000000  2250              MOVS     r2,#0x50
;;;2713   {
;;;2714    /* Check the parameters */
;;;2715     assert_param(IS_TIM_LIST11_PERIPH(TIMx));
;;;2716     assert_param(IS_TIM_REMAP(TIM_Remap));
;;;2717   
;;;2718     /* Set the Timer remapping configuration */
;;;2719     TIMx->OR =  TIM_Remap;
000002  5211              STRH     r1,[r2,r0]
;;;2720   }
000004  4770              BX       lr
;;;2721   
                          ENDP


                          AREA ||i.TIM_SelectCCDMA||, CODE, READONLY, ALIGN=2

                  TIM_SelectCCDMA PROC
;;;2288     */
;;;2289   void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;2290   {
;;;2291     /* Check the parameters */
;;;2292     assert_param(IS_TIM_LIST5_PERIPH(TIMx));
;;;2293     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2294     
;;;2295     if (NewState != DISABLE)
000002  d004              BEQ      |L68.14|
;;;2296     {
;;;2297       /* Set the CCDS Bit */
;;;2298       TIMx->CR2 |= TIM_CR2_CCDS;
000004  8882              LDRH     r2,[r0,#4]
000006  2308              MOVS     r3,#8
000008  431a              ORRS     r2,r2,r3
00000a  8082              STRH     r2,[r0,#4]
00000c  e003              B        |L68.22|
                  |L68.14|
;;;2299     }
;;;2300     else
;;;2301     {
;;;2302       /* Reset the CCDS Bit */
;;;2303       TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCDS);
00000e  8882              LDRH     r2,[r0,#4]
000010  4b01              LDR      r3,|L68.24|
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L68.22|
;;;2304     }
;;;2305   }
000016  4770              BX       lr
;;;2306   
                          ENDP

                  |L68.24|
                          DCD      0x0000fff7

                          AREA ||i.TIM_SelectCOM||, CODE, READONLY, ALIGN=2

                  TIM_SelectCOM PROC
;;;1671     */
;;;1672   void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1673   {
;;;1674     /* Check the parameters */
;;;1675     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1676     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1677     if (NewState != DISABLE)
000002  d004              BEQ      |L69.14|
;;;1678     {
;;;1679       /* Set the COM Bit */
;;;1680       TIMx->CR2 |= TIM_CR2_CCUS;
000004  8882              LDRH     r2,[r0,#4]
000006  2304              MOVS     r3,#4
000008  431a              ORRS     r2,r2,r3
00000a  8082              STRH     r2,[r0,#4]
00000c  e003              B        |L69.22|
                  |L69.14|
;;;1681     }
;;;1682     else
;;;1683     {
;;;1684       /* Reset the COM Bit */
;;;1685       TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCUS);
00000e  8882              LDRH     r2,[r0,#4]
000010  4b01              LDR      r3,|L69.24|
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L69.22|
;;;1686     }
;;;1687   }
000016  4770              BX       lr
;;;1688   
                          ENDP

                  |L69.24|
                          DCD      0x0000fffb

                          AREA ||i.TIM_SelectHallSensor||, CODE, READONLY, ALIGN=2

                  TIM_SelectHallSensor PROC
;;;2677     */
;;;2678   void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;2679   {
;;;2680     /* Check the parameters */
;;;2681     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2682     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2683     
;;;2684     if (NewState != DISABLE)
000002  d004              BEQ      |L70.14|
;;;2685     {
;;;2686       /* Set the TI1S Bit */
;;;2687       TIMx->CR2 |= TIM_CR2_TI1S;
000004  8882              LDRH     r2,[r0,#4]
000006  2380              MOVS     r3,#0x80
000008  431a              ORRS     r2,r2,r3
00000a  8082              STRH     r2,[r0,#4]
00000c  e003              B        |L70.22|
                  |L70.14|
;;;2688     }
;;;2689     else
;;;2690     {
;;;2691       /* Reset the TI1S Bit */
;;;2692       TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_TI1S);
00000e  8882              LDRH     r2,[r0,#4]
000010  4b01              LDR      r3,|L70.24|
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L70.22|
;;;2693     }
;;;2694   }
000016  4770              BX       lr
;;;2695   
                          ENDP

                  |L70.24|
                          DCD      0x0000ff7f

                          AREA ||i.TIM_SelectInputTrigger||, CODE, READONLY, ALIGN=2

                  TIM_SelectInputTrigger PROC
;;;2477     */
;;;2478   void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
000000  460a              MOV      r2,r1
;;;2479   {
;;;2480     uint16_t tmpsmcr = 0;
000002  2100              MOVS     r1,#0
;;;2481   
;;;2482     /* Check the parameters */
;;;2483     assert_param(IS_TIM_LIST6_PERIPH(TIMx)); 
;;;2484     assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;2485   
;;;2486     /* Get the TIMx SMCR register value */
;;;2487     tmpsmcr = TIMx->SMCR;
000004  8901              LDRH     r1,[r0,#8]
;;;2488     /* Reset the TS Bits */
;;;2489     tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
000006  4b03              LDR      r3,|L71.20|
000008  4019              ANDS     r1,r1,r3
;;;2490     /* Set the Input Trigger source */
;;;2491     tmpsmcr |= TIM_InputTriggerSource;
00000a  460b              MOV      r3,r1
00000c  4313              ORRS     r3,r3,r2
00000e  4619              MOV      r1,r3
;;;2492     /* Write to TIMx SMCR */
;;;2493     TIMx->SMCR = tmpsmcr;
000010  8101              STRH     r1,[r0,#8]
;;;2494   }
000012  4770              BX       lr
;;;2495   
                          ENDP

                  |L71.20|
                          DCD      0x0000ff8f

                          AREA ||i.TIM_SelectMasterSlaveMode||, CODE, READONLY, ALIGN=2

                  TIM_SelectMasterSlaveMode PROC
;;;2562     */
;;;2563   void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode)
000000  8902              LDRH     r2,[r0,#8]
;;;2564   {
;;;2565     /* Check the parameters */
;;;2566     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2567     assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
;;;2568     
;;;2569     /* Reset the MSM Bit */
;;;2570     TIMx->SMCR &= (uint16_t)~((uint16_t)TIM_SMCR_MSM);
000002  4b03              LDR      r3,|L72.16|
000004  401a              ANDS     r2,r2,r3
000006  8102              STRH     r2,[r0,#8]
;;;2571     
;;;2572     /* Set or Reset the MSM Bit */
;;;2573     TIMx->SMCR |= TIM_MasterSlaveMode;
000008  8902              LDRH     r2,[r0,#8]
00000a  430a              ORRS     r2,r2,r1
00000c  8102              STRH     r2,[r0,#8]
;;;2574   }
00000e  4770              BX       lr
;;;2575   
                          ENDP

                  |L72.16|
                          DCD      0x0000ff7f

                          AREA ||i.TIM_SelectOCREFClear||, CODE, READONLY, ALIGN=2

                  TIM_SelectOCREFClear PROC
;;;1593     */
;;;1594   void TIM_SelectOCREFClear(TIM_TypeDef* TIMx, uint16_t TIM_OCReferenceClear)
000000  8902              LDRH     r2,[r0,#8]
;;;1595   {
;;;1596     /* Check the parameters */
;;;1597     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1598     assert_param(TIM_OCREFERENCECECLEAR_SOURCE(TIM_OCReferenceClear));
;;;1599   
;;;1600     /* Set the TIM_OCReferenceClear source */
;;;1601     TIMx->SMCR &=  (uint16_t)~((uint16_t)TIM_SMCR_OCCS);
000002  4b03              LDR      r3,|L73.16|
000004  401a              ANDS     r2,r2,r3
000006  8102              STRH     r2,[r0,#8]
;;;1602     TIMx->SMCR |=  TIM_OCReferenceClear;
000008  8902              LDRH     r2,[r0,#8]
00000a  430a              ORRS     r2,r2,r1
00000c  8102              STRH     r2,[r0,#8]
;;;1603   }
00000e  4770              BX       lr
;;;1604   
                          ENDP

                  |L73.16|
                          DCD      0x0000fff7

                          AREA ||i.TIM_SelectOCxM||, CODE, READONLY, ALIGN=1

                  TIM_SelectOCxM PROC
;;;872      */
;;;873    void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode)
000000  b570              PUSH     {r4-r6,lr}
;;;874    {
000002  4603              MOV      r3,r0
;;;875      uint32_t tmp = 0;
000004  2000              MOVS     r0,#0
;;;876      uint16_t tmp1 = 0;
000006  2400              MOVS     r4,#0
;;;877    
;;;878      /* Check the parameters */
;;;879      assert_param(IS_TIM_LIST4_PERIPH(TIMx));  
;;;880      assert_param(IS_TIM_OCM(TIM_OCMode));
;;;881      
;;;882      tmp = (uint32_t) TIMx;
000008  4618              MOV      r0,r3
;;;883      tmp += CCMR_OFFSET;
00000a  3018              ADDS     r0,r0,#0x18
;;;884    
;;;885      tmp1 = CCER_CCE_SET << (uint16_t)TIM_Channel;
00000c  2501              MOVS     r5,#1
00000e  408d              LSLS     r5,r5,r1
000010  b2ac              UXTH     r4,r5
;;;886    
;;;887      /* Disable the Channel: Reset the CCxE Bit */
;;;888      TIMx->CCER &= (uint16_t) ~tmp1;
000012  8c1d              LDRH     r5,[r3,#0x20]
000014  43a5              BICS     r5,r5,r4
000016  841d              STRH     r5,[r3,#0x20]
;;;889    
;;;890      if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
000018  2900              CMP      r1,#0
00001a  d001              BEQ      |L74.32|
00001c  2908              CMP      r1,#8
00001e  d109              BNE      |L74.52|
                  |L74.32|
;;;891      {
;;;892        tmp += (TIM_Channel>>1);
000020  104d              ASRS     r5,r1,#1
000022  1828              ADDS     r0,r5,r0
;;;893    
;;;894        /* Reset the OCxM bits in the CCMRx register */
;;;895        *(__IO uint32_t *) tmp &= (uint32_t)~((uint32_t)TIM_CCMR1_OC1M);
000024  6805              LDR      r5,[r0,#0]
000026  2670              MOVS     r6,#0x70
000028  43b5              BICS     r5,r5,r6
00002a  6005              STR      r5,[r0,#0]
;;;896       
;;;897        /* Configure the OCxM bits in the CCMRx register */
;;;898        *(__IO uint32_t *) tmp |= TIM_OCMode;
00002c  6805              LDR      r5,[r0,#0]
00002e  4315              ORRS     r5,r5,r2
000030  6005              STR      r5,[r0,#0]
000032  e00d              B        |L74.80|
                  |L74.52|
;;;899      }
;;;900      else
;;;901      {
;;;902        tmp += (uint16_t)(TIM_Channel - (uint16_t)4)>> (uint16_t)1;
000034  1f0d              SUBS     r5,r1,#4
000036  042d              LSLS     r5,r5,#16
000038  0c6d              LSRS     r5,r5,#17
00003a  1828              ADDS     r0,r5,r0
;;;903    
;;;904        /* Reset the OCxM bits in the CCMRx register */
;;;905        *(__IO uint32_t *) tmp &= (uint32_t)~((uint32_t)TIM_CCMR1_OC2M);
00003c  6805              LDR      r5,[r0,#0]
00003e  2607              MOVS     r6,#7
000040  0336              LSLS     r6,r6,#12
000042  43b5              BICS     r5,r5,r6
000044  6005              STR      r5,[r0,#0]
;;;906        
;;;907        /* Configure the OCxM bits in the CCMRx register */
;;;908        *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
000046  6805              LDR      r5,[r0,#0]
000048  0616              LSLS     r6,r2,#24
00004a  0c36              LSRS     r6,r6,#16
00004c  4335              ORRS     r5,r5,r6
00004e  6005              STR      r5,[r0,#0]
                  |L74.80|
;;;909      }
;;;910    }
000050  bd70              POP      {r4-r6,pc}
;;;911    
                          ENDP


                          AREA ||i.TIM_SelectOnePulseMode||, CODE, READONLY, ALIGN=2

                  TIM_SelectOnePulseMode PROC
;;;376      */
;;;377    void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode)
000000  8802              LDRH     r2,[r0,#0]
;;;378    {
;;;379      /* Check the parameters */
;;;380      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;381      assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
;;;382      
;;;383      /* Reset the OPM Bit */
;;;384      TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_OPM);
000002  4b03              LDR      r3,|L75.16|
000004  401a              ANDS     r2,r2,r3
000006  8002              STRH     r2,[r0,#0]
;;;385      /* Configure the OPM Mode */
;;;386      TIMx->CR1 |= TIM_OPMode;
000008  8802              LDRH     r2,[r0,#0]
00000a  430a              ORRS     r2,r2,r1
00000c  8002              STRH     r2,[r0,#0]
;;;387    }
00000e  4770              BX       lr
;;;388    
                          ENDP

                  |L75.16|
                          DCD      0x0000fff7

                          AREA ||i.TIM_SelectOutputTrigger||, CODE, READONLY, ALIGN=2

                  TIM_SelectOutputTrigger PROC
;;;2516     */
;;;2517   void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource)
000000  8882              LDRH     r2,[r0,#4]
;;;2518   {
;;;2519     /* Check the parameters */
;;;2520     assert_param(IS_TIM_LIST9_PERIPH(TIMx));
;;;2521     assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
;;;2522   
;;;2523     /* Reset the MMS Bits */
;;;2524     TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_MMS);
000002  4b03              LDR      r3,|L76.16|
000004  401a              ANDS     r2,r2,r3
000006  8082              STRH     r2,[r0,#4]
;;;2525     /* Select the TRGO source */
;;;2526     TIMx->CR2 |=  TIM_TRGOSource;
000008  8882              LDRH     r2,[r0,#4]
00000a  430a              ORRS     r2,r2,r1
00000c  8082              STRH     r2,[r0,#4]
;;;2527   }
00000e  4770              BX       lr
;;;2528   
                          ENDP

                  |L76.16|
                          DCD      0x0000ff8f

                          AREA ||i.TIM_SelectSlaveMode||, CODE, READONLY, ALIGN=2

                  TIM_SelectSlaveMode PROC
;;;2540     */
;;;2541   void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode)
000000  8902              LDRH     r2,[r0,#8]
;;;2542   {
;;;2543     /* Check the parameters */
;;;2544     assert_param(IS_TIM_LIST6_PERIPH(TIMx)); 
;;;2545     assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
;;;2546     
;;;2547     /* Reset the SMS Bits */
;;;2548     TIMx->SMCR &= (uint16_t)~((uint16_t)TIM_SMCR_SMS);
000002  4b03              LDR      r3,|L77.16|
000004  401a              ANDS     r2,r2,r3
000006  8102              STRH     r2,[r0,#8]
;;;2549     /* Select the Slave Mode */
;;;2550     TIMx->SMCR |= TIM_SlaveMode;
000008  8902              LDRH     r2,[r0,#8]
00000a  430a              ORRS     r2,r2,r1
00000c  8102              STRH     r2,[r0,#8]
;;;2551   }
00000e  4770              BX       lr
;;;2552   
                          ENDP

                  |L77.16|
                          DCD      0x0000fff8

                          AREA ||i.TIM_SetAutoreload||, CODE, READONLY, ALIGN=1

                  TIM_SetAutoreload PROC
;;;245      */
;;;246    void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint32_t Autoreload)
000000  62c1              STR      r1,[r0,#0x2c]
;;;247    {
;;;248      /* Check the parameters */
;;;249      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;250      
;;;251      /* Set the Autoreload Register value */
;;;252      TIMx->ARR = Autoreload;
;;;253    }
000002  4770              BX       lr
;;;254    
                          ENDP


                          AREA ||i.TIM_SetClockDivision||, CODE, READONLY, ALIGN=2

                  TIM_SetClockDivision PROC
;;;398      */
;;;399    void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD)
000000  8802              LDRH     r2,[r0,#0]
;;;400    {
;;;401      /* Check the parameters */
;;;402      assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;403      assert_param(IS_TIM_CKD_DIV(TIM_CKD));
;;;404      
;;;405      /* Reset the CKD Bits */
;;;406      TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_CKD);
000002  4b03              LDR      r3,|L79.16|
000004  401a              ANDS     r2,r2,r3
000006  8002              STRH     r2,[r0,#0]
;;;407      /* Set the CKD value */
;;;408      TIMx->CR1 |= TIM_CKD;
000008  8802              LDRH     r2,[r0,#0]
00000a  430a              ORRS     r2,r2,r1
00000c  8002              STRH     r2,[r0,#0]
;;;409    }
00000e  4770              BX       lr
;;;410    
                          ENDP

                  |L79.16|
                          DCD      0x0000fcff

                          AREA ||i.TIM_SetCompare1||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare1 PROC
;;;917      */
;;;918    void TIM_SetCompare1(TIM_TypeDef* TIMx, uint32_t Compare1)
000000  6341              STR      r1,[r0,#0x34]
;;;919    {
;;;920      /* Check the parameters */
;;;921      assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;922      
;;;923      /* Set the Capture Compare1 Register value */
;;;924      TIMx->CCR1 = Compare1;
;;;925    }
000002  4770              BX       lr
;;;926    
                          ENDP


                          AREA ||i.TIM_SetCompare2||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare2 PROC
;;;932      */
;;;933    void TIM_SetCompare2(TIM_TypeDef* TIMx, uint32_t Compare2)
000000  6381              STR      r1,[r0,#0x38]
;;;934    {
;;;935      /* Check the parameters */
;;;936      assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;937      
;;;938      /* Set the Capture Compare2 Register value */
;;;939      TIMx->CCR2 = Compare2;
;;;940    }
000002  4770              BX       lr
;;;941    
                          ENDP


                          AREA ||i.TIM_SetCompare3||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare3 PROC
;;;947      */
;;;948    void TIM_SetCompare3(TIM_TypeDef* TIMx, uint32_t Compare3)
000000  63c1              STR      r1,[r0,#0x3c]
;;;949    {
;;;950      /* Check the parameters */
;;;951      assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;952      
;;;953      /* Set the Capture Compare3 Register value */
;;;954      TIMx->CCR3 = Compare3;
;;;955    }
000002  4770              BX       lr
;;;956    
                          ENDP


                          AREA ||i.TIM_SetCompare4||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare4 PROC
;;;962      */
;;;963    void TIM_SetCompare4(TIM_TypeDef* TIMx, uint32_t Compare4)
000000  6401              STR      r1,[r0,#0x40]
;;;964    {
;;;965      /* Check the parameters */
;;;966      assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;967      
;;;968      /* Set the Capture Compare4 Register value */
;;;969      TIMx->CCR4 = Compare4;
;;;970    }
000002  4770              BX       lr
;;;971    
                          ENDP


                          AREA ||i.TIM_SetCounter||, CODE, READONLY, ALIGN=1

                  TIM_SetCounter PROC
;;;230      */
;;;231    void TIM_SetCounter(TIM_TypeDef* TIMx, uint32_t Counter)
000000  6241              STR      r1,[r0,#0x24]
;;;232    {
;;;233      /* Check the parameters */
;;;234       assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;235       
;;;236      /* Set the Counter Register value */
;;;237      TIMx->CNT = Counter;
;;;238    }
000002  4770              BX       lr
;;;239    
                          ENDP


                          AREA ||i.TIM_SetIC1Prescaler||, CODE, READONLY, ALIGN=2

                  TIM_SetIC1Prescaler PROC
;;;1894     */
;;;1895   void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1896   {
;;;1897     /* Check the parameters */
;;;1898     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1899     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;1900     
;;;1901     /* Reset the IC1PSC Bits */
;;;1902     TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC1PSC);
000002  4b03              LDR      r3,|L85.16|
000004  401a              ANDS     r2,r2,r3
000006  8302              STRH     r2,[r0,#0x18]
;;;1903     /* Set the IC1PSC value */
;;;1904     TIMx->CCMR1 |= TIM_ICPSC;
000008  8b02              LDRH     r2,[r0,#0x18]
00000a  430a              ORRS     r2,r2,r1
00000c  8302              STRH     r2,[r0,#0x18]
;;;1905   }
00000e  4770              BX       lr
;;;1906   
                          ENDP

                  |L85.16|
                          DCD      0x0000fff3

                          AREA ||i.TIM_SetIC2Prescaler||, CODE, READONLY, ALIGN=2

                  TIM_SetIC2Prescaler PROC
;;;1917     */
;;;1918   void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1919   {
;;;1920     /* Check the parameters */
;;;1921     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1922     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;1923     
;;;1924     /* Reset the IC2PSC Bits */
;;;1925     TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC2PSC);
000002  4b04              LDR      r3,|L86.20|
000004  401a              ANDS     r2,r2,r3
000006  8302              STRH     r2,[r0,#0x18]
;;;1926     /* Set the IC2PSC value */
;;;1927     TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
000008  8b02              LDRH     r2,[r0,#0x18]
00000a  060b              LSLS     r3,r1,#24
00000c  0c1b              LSRS     r3,r3,#16
00000e  431a              ORRS     r2,r2,r3
000010  8302              STRH     r2,[r0,#0x18]
;;;1928   }
000012  4770              BX       lr
;;;1929   
                          ENDP

                  |L86.20|
                          DCD      0x0000f3ff

                          AREA ||i.TIM_SetIC3Prescaler||, CODE, READONLY, ALIGN=2

                  TIM_SetIC3Prescaler PROC
;;;1940     */
;;;1941   void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1942   {
;;;1943     /* Check the parameters */
;;;1944     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1945     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;1946     
;;;1947     /* Reset the IC3PSC Bits */
;;;1948     TIMx->CCMR2 &= (uint16_t)~((uint16_t)TIM_CCMR2_IC3PSC);
000002  4b03              LDR      r3,|L87.16|
000004  401a              ANDS     r2,r2,r3
000006  8382              STRH     r2,[r0,#0x1c]
;;;1949     /* Set the IC3PSC value */
;;;1950     TIMx->CCMR2 |= TIM_ICPSC;
000008  8b82              LDRH     r2,[r0,#0x1c]
00000a  430a              ORRS     r2,r2,r1
00000c  8382              STRH     r2,[r0,#0x1c]
;;;1951   }
00000e  4770              BX       lr
;;;1952   
                          ENDP

                  |L87.16|
                          DCD      0x0000fff3

                          AREA ||i.TIM_SetIC4Prescaler||, CODE, READONLY, ALIGN=2

                  TIM_SetIC4Prescaler PROC
;;;1963     */
;;;1964   void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1965   {  
;;;1966     /* Check the parameters */
;;;1967     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1968     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;1969     
;;;1970     /* Reset the IC4PSC Bits */
;;;1971     TIMx->CCMR2 &= (uint16_t)~((uint16_t)TIM_CCMR2_IC4PSC);
000002  4b04              LDR      r3,|L88.20|
000004  401a              ANDS     r2,r2,r3
000006  8382              STRH     r2,[r0,#0x1c]
;;;1972     /* Set the IC4PSC value */
;;;1973     TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
000008  8b82              LDRH     r2,[r0,#0x1c]
00000a  060b              LSLS     r3,r1,#24
00000c  0c1b              LSRS     r3,r3,#16
00000e  431a              ORRS     r2,r2,r3
000010  8382              STRH     r2,[r0,#0x1c]
;;;1974   }
000012  4770              BX       lr
;;;1975   
                          ENDP

                  |L88.20|
                          DCD      0x0000f3ff

                          AREA ||i.TIM_TIxExternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_TIxExternalClockConfig PROC
;;;2360     */
;;;2361   void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
000000  b5f8              PUSH     {r3-r7,lr}
;;;2362                                   uint16_t TIM_ICPolarity, uint16_t ICFilter)
;;;2363   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
;;;2364     /* Check the parameters */
;;;2365     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2366     assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
;;;2367     assert_param(IS_TIM_IC_FILTER(ICFilter));
;;;2368     
;;;2369     /* Configure the Timer Input Clock Source */
;;;2370     if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
00000a  2d60              CMP      r5,#0x60
00000c  d106              BNE      |L89.28|
;;;2371     {
;;;2372       TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
00000e  463b              MOV      r3,r7
000010  2201              MOVS     r2,#1
000012  4631              MOV      r1,r6
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       TI2_Config
00001a  e005              B        |L89.40|
                  |L89.28|
;;;2373     }
;;;2374     else
;;;2375     {
;;;2376       TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
00001c  463b              MOV      r3,r7
00001e  2201              MOVS     r2,#1
000020  4631              MOV      r1,r6
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       TI1_Config
                  |L89.40|
;;;2377     }
;;;2378     /* Select the Trigger source */
;;;2379     TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
000028  4629              MOV      r1,r5
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       TIM_SelectInputTrigger
;;;2380     /* Select the External clock mode1 */
;;;2381     TIMx->SMCR |= TIM_SlaveMode_External1;
000030  8920              LDRH     r0,[r4,#8]
000032  2107              MOVS     r1,#7
000034  4308              ORRS     r0,r0,r1
000036  8120              STRH     r0,[r4,#8]
;;;2382   }
000038  bdf8              POP      {r3-r7,pc}
;;;2383   
                          ENDP


                          AREA ||i.TIM_TimeBaseInit||, CODE, READONLY, ALIGN=2

                  TIM_TimeBaseInit PROC
;;;112      */
;;;113    void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
000000  2200              MOVS     r2,#0
;;;114    {
;;;115      uint16_t tmpcr1 = 0;
;;;116    
;;;117      /* Check the parameters */
;;;118      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;119      assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
;;;120      assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
;;;121    
;;;122      tmpcr1 = TIMx->CR1;  
000002  8802              LDRH     r2,[r0,#0]
;;;123    
;;;124      if((TIMx == TIM1) || (TIMx == TIM2) || (TIMx == TIM3))
000004  4b15              LDR      r3,|L90.92|
000006  4298              CMP      r0,r3
000008  d006              BEQ      |L90.24|
00000a  2301              MOVS     r3,#1
00000c  079b              LSLS     r3,r3,#30
00000e  4298              CMP      r0,r3
000010  d002              BEQ      |L90.24|
000012  4b13              LDR      r3,|L90.96|
000014  4298              CMP      r0,r3
000016  d103              BNE      |L90.32|
                  |L90.24|
;;;125      {
;;;126        /* Select the Counter Mode */
;;;127        tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
000018  4b12              LDR      r3,|L90.100|
00001a  401a              ANDS     r2,r2,r3
;;;128        tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
00001c  884b              LDRH     r3,[r1,#2]
00001e  431a              ORRS     r2,r2,r3
                  |L90.32|
;;;129      }
;;;130     
;;;131      if(TIMx != TIM6)
000020  4b11              LDR      r3,|L90.104|
000022  4298              CMP      r0,r3
000024  d003              BEQ      |L90.46|
;;;132      {
;;;133        /* Set the clock division */
;;;134        tmpcr1 &= (uint16_t)(~((uint16_t)TIM_CR1_CKD));
000026  4b11              LDR      r3,|L90.108|
000028  401a              ANDS     r2,r2,r3
;;;135        tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
00002a  890b              LDRH     r3,[r1,#8]
00002c  431a              ORRS     r2,r2,r3
                  |L90.46|
;;;136      }
;;;137    
;;;138      TIMx->CR1 = tmpcr1;
00002e  8002              STRH     r2,[r0,#0]
;;;139    
;;;140      /* Set the Autoreload value */
;;;141      TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
000030  684b              LDR      r3,[r1,#4]
000032  62c3              STR      r3,[r0,#0x2c]
;;;142     
;;;143      /* Set the Prescaler value */
;;;144      TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
000034  880b              LDRH     r3,[r1,#0]
000036  8503              STRH     r3,[r0,#0x28]
;;;145        
;;;146      if ((TIMx == TIM1) || (TIMx == TIM15)|| (TIMx == TIM16) || (TIMx == TIM17))  
000038  4b08              LDR      r3,|L90.92|
00003a  4298              CMP      r0,r3
00003c  d008              BEQ      |L90.80|
00003e  4b0c              LDR      r3,|L90.112|
000040  4298              CMP      r0,r3
000042  d005              BEQ      |L90.80|
000044  4b0b              LDR      r3,|L90.116|
000046  4298              CMP      r0,r3
000048  d002              BEQ      |L90.80|
00004a  4b0b              LDR      r3,|L90.120|
00004c  4298              CMP      r0,r3
00004e  d101              BNE      |L90.84|
                  |L90.80|
;;;147      {
;;;148        /* Set the Repetition Counter value */
;;;149        TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
000050  7a8b              LDRB     r3,[r1,#0xa]
000052  8603              STRH     r3,[r0,#0x30]
                  |L90.84|
;;;150      }
;;;151    
;;;152      /* Generate an update event to reload the Prescaler and the Repetition counter
;;;153         values immediately */
;;;154      TIMx->EGR = TIM_PSCReloadMode_Immediate;           
000054  2301              MOVS     r3,#1
000056  8283              STRH     r3,[r0,#0x14]
;;;155    }
000058  4770              BX       lr
;;;156    
                          ENDP

00005a  0000              DCW      0x0000
                  |L90.92|
                          DCD      0x40012c00
                  |L90.96|
                          DCD      0x40000400
                  |L90.100|
                          DCD      0x0000ff8f
                  |L90.104|
                          DCD      0x40001000
                  |L90.108|
                          DCD      0x0000fcff
                  |L90.112|
                          DCD      0x40014000
                  |L90.116|
                          DCD      0x40014400
                  |L90.120|
                          DCD      0x40014800

                          AREA ||i.TIM_TimeBaseStructInit||, CODE, READONLY, ALIGN=1

                  TIM_TimeBaseStructInit PROC
;;;162      */
;;;163    void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
000000  2100              MOVS     r1,#0
;;;164    {
;;;165      /* Set the default configuration */
;;;166      TIM_TimeBaseInitStruct->TIM_Period = 0xFFFFFFFF;
000002  43c9              MVNS     r1,r1
000004  6041              STR      r1,[r0,#4]
;;;167      TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
000006  2100              MOVS     r1,#0
000008  8001              STRH     r1,[r0,#0]
;;;168      TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
00000a  8101              STRH     r1,[r0,#8]
;;;169      TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
00000c  8041              STRH     r1,[r0,#2]
;;;170      TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
00000e  7281              STRB     r1,[r0,#0xa]
;;;171    }
000010  4770              BX       lr
;;;172    
                          ENDP


                          AREA ||i.TIM_UpdateDisableConfig||, CODE, READONLY, ALIGN=2

                  TIM_UpdateDisableConfig PROC
;;;292      */
;;;293    void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;294    {
;;;295      /* Check the parameters */
;;;296      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;297      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;298      
;;;299      if (NewState != DISABLE)
000002  d004              BEQ      |L92.14|
;;;300      {
;;;301        /* Set the Update Disable Bit */
;;;302        TIMx->CR1 |= TIM_CR1_UDIS;
000004  8802              LDRH     r2,[r0,#0]
000006  2302              MOVS     r3,#2
000008  431a              ORRS     r2,r2,r3
00000a  8002              STRH     r2,[r0,#0]
00000c  e003              B        |L92.22|
                  |L92.14|
;;;303      }
;;;304      else
;;;305      {
;;;306        /* Reset the Update Disable Bit */
;;;307        TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_UDIS);
00000e  8802              LDRH     r2,[r0,#0]
000010  4b01              LDR      r3,|L92.24|
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L92.22|
;;;308      }
;;;309    }
000016  4770              BX       lr
;;;310    
                          ENDP

                  |L92.24|
                          DCD      0x0000fffd

                          AREA ||i.TIM_UpdateRequestConfig||, CODE, READONLY, ALIGN=2

                  TIM_UpdateRequestConfig PROC
;;;322      */
;;;323    void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource)
000000  2900              CMP      r1,#0
;;;324    {
;;;325      /* Check the parameters */
;;;326      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;327      assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
;;;328      
;;;329      if (TIM_UpdateSource != TIM_UpdateSource_Global)
000002  d004              BEQ      |L93.14|
;;;330      {
;;;331        /* Set the URS Bit */
;;;332        TIMx->CR1 |= TIM_CR1_URS;
000004  8802              LDRH     r2,[r0,#0]
000006  2304              MOVS     r3,#4
000008  431a              ORRS     r2,r2,r3
00000a  8002              STRH     r2,[r0,#0]
00000c  e003              B        |L93.22|
                  |L93.14|
;;;333      }
;;;334      else
;;;335      {
;;;336        /* Reset the URS Bit */
;;;337        TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_URS);
00000e  8802              LDRH     r2,[r0,#0]
000010  4b01              LDR      r3,|L93.24|
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L93.22|
;;;338      }
;;;339    }
000016  4770              BX       lr
;;;340    
                          ENDP

                  |L93.24|
                          DCD      0x0000fffb

;*** Start embedded assembler ***

#line 1 "..\\FTLib\\Src\\ft32f0xx_tim.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_ft32f0xx_tim_c_c458916b____REV16|
#line 129 "..\\FTLib\\CMSIS\\inc\\core_cmInstr.h"
|__asm___14_ft32f0xx_tim_c_c458916b____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_ft32f0xx_tim_c_c458916b____REVSH|
#line 144
|__asm___14_ft32f0xx_tim_c_c458916b____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
