; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\ft32f0xx_crs.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\ft32f0xx_crs.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\FTLib\CMSIS\inc -I..\FTLib\Inc -I..\FTLib\Lib -I..\usb\inc -I..\user -I..\RTT -I..\iap2 -IC:\Users\dell1\AppData\Local\Arm\Packs\FMD\FT32F0xx_DFP\1.0.6\Drivers\CMSIS\FT32F0xx\Include -D__UVISION_VERSION=534 -DFT32F072x8 -DFT32F072x8 --omf_browse=.\objects\ft32f0xx_crs.crf ..\FTLib\Src\ft32f0xx_crs.c]
                          THUMB

                          AREA ||i.CRS_AdjustHSI48CalibrationValue||, CODE, READONLY, ALIGN=2

                  CRS_AdjustHSI48CalibrationValue PROC
;;;47       */
;;;48     void CRS_AdjustHSI48CalibrationValue(uint8_t CRS_HSI48CalibrationValue)
000000  4906              LDR      r1,|L1.28|
;;;49     {
;;;50       /* Clear TRIM[5:0] bits */
;;;51       CRS->CR &= ~CRS_CR_TRIM;
000002  6809              LDR      r1,[r1,#0]
000004  223f              MOVS     r2,#0x3f
000006  0212              LSLS     r2,r2,#8
000008  4391              BICS     r1,r1,r2
00000a  4a04              LDR      r2,|L1.28|
00000c  6011              STR      r1,[r2,#0]
;;;52       
;;;53       /* Set the TRIM[5:0] bits according to CRS_HSI48CalibrationValue value */
;;;54       CRS->CR |= (uint32_t)((uint32_t)CRS_HSI48CalibrationValue << 8);
00000e  4611              MOV      r1,r2
000010  6809              LDR      r1,[r1,#0]
000012  0202              LSLS     r2,r0,#8
000014  4311              ORRS     r1,r1,r2
000016  4a01              LDR      r2,|L1.28|
000018  6011              STR      r1,[r2,#0]
;;;55     
;;;56     }
00001a  4770              BX       lr
;;;57     
                          ENDP

                  |L1.28|
                          DCD      0x40006c00

                          AREA ||i.CRS_AutomaticCalibrationCmd||, CODE, READONLY, ALIGN=2

                  CRS_AutomaticCalibrationCmd PROC
;;;85       */
;;;86     void CRS_AutomaticCalibrationCmd(FunctionalState NewState)
000000  2800              CMP      r0,#0
;;;87     {
;;;88       assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;89     
;;;90       if (NewState != DISABLE)
000002  d006              BEQ      |L2.18|
;;;91       {
;;;92         CRS->CR |= CRS_CR_AUTOTRIMEN;
000004  4906              LDR      r1,|L2.32|
000006  6809              LDR      r1,[r1,#0]
000008  2240              MOVS     r2,#0x40
00000a  4311              ORRS     r1,r1,r2
00000c  4a04              LDR      r2,|L2.32|
00000e  6011              STR      r1,[r2,#0]
000010  e005              B        |L2.30|
                  |L2.18|
;;;93       }
;;;94     else
;;;95       {
;;;96         CRS->CR &= ~CRS_CR_AUTOTRIMEN;
000012  4903              LDR      r1,|L2.32|
000014  6809              LDR      r1,[r1,#0]
000016  2240              MOVS     r2,#0x40
000018  4391              BICS     r1,r1,r2
00001a  4a01              LDR      r2,|L2.32|
00001c  6011              STR      r1,[r2,#0]
                  |L2.30|
;;;97       }
;;;98     }
00001e  4770              BX       lr
;;;99     
                          ENDP

                  |L2.32|
                          DCD      0x40006c00

                          AREA ||i.CRS_ClearFlag||, CODE, READONLY, ALIGN=2

                  CRS_ClearFlag PROC
;;;321      */
;;;322    void CRS_ClearFlag(uint32_t CRS_FLAG)
000000  2107              MOVS     r1,#7
;;;323    {
;;;324      /* Check the parameters */
;;;325      assert_param(IS_CRS_FLAG(CRS_FLAG));
;;;326      
;;;327      if ((CRS_FLAG & FLAG_MASK)!= 0)
000002  0209              LSLS     r1,r1,#8
000004  4001              ANDS     r1,r1,r0
000006  2900              CMP      r1,#0
000008  d006              BEQ      |L3.24|
;;;328      {
;;;329        CRS->ICR |= CRS_ICR_ERRC;  
00000a  4906              LDR      r1,|L3.36|
00000c  68c9              LDR      r1,[r1,#0xc]
00000e  2204              MOVS     r2,#4
000010  4311              ORRS     r1,r1,r2
000012  4a04              LDR      r2,|L3.36|
000014  60d1              STR      r1,[r2,#0xc]
000016  e004              B        |L3.34|
                  |L3.24|
;;;330      }
;;;331      else
;;;332      {
;;;333        CRS->ICR |= CRS_FLAG;
000018  4902              LDR      r1,|L3.36|
00001a  68c9              LDR      r1,[r1,#0xc]
00001c  4301              ORRS     r1,r1,r0
00001e  4a01              LDR      r2,|L3.36|
000020  60d1              STR      r1,[r2,#0xc]
                  |L3.34|
;;;334      }
;;;335    }
000022  4770              BX       lr
;;;336    
                          ENDP

                  |L3.36|
                          DCD      0x40006c00

                          AREA ||i.CRS_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  CRS_ClearITPendingBit PROC
;;;370      */
;;;371    void CRS_ClearITPendingBit(uint32_t CRS_IT)
000000  2107              MOVS     r1,#7
;;;372    {
;;;373      /* Check the parameters */
;;;374      assert_param(IS_CRS_CLEAR_IT(CRS_IT));
;;;375      
;;;376      if ((CRS_IT & FLAG_MASK)!= 0)
000002  0209              LSLS     r1,r1,#8
000004  4001              ANDS     r1,r1,r0
000006  2900              CMP      r1,#0
000008  d006              BEQ      |L4.24|
;;;377      {
;;;378        CRS->ICR |= CRS_ICR_ERRC;  
00000a  4906              LDR      r1,|L4.36|
00000c  68c9              LDR      r1,[r1,#0xc]
00000e  2204              MOVS     r2,#4
000010  4311              ORRS     r1,r1,r2
000012  4a04              LDR      r2,|L4.36|
000014  60d1              STR      r1,[r2,#0xc]
000016  e004              B        |L4.34|
                  |L4.24|
;;;379      }
;;;380      else
;;;381      {
;;;382        CRS->ICR |= CRS_IT;
000018  4902              LDR      r1,|L4.36|
00001a  68c9              LDR      r1,[r1,#0xc]
00001c  4301              ORRS     r1,r1,r0
00001e  4a01              LDR      r2,|L4.36|
000020  60d1              STR      r1,[r2,#0xc]
                  |L4.34|
;;;383      }
;;;384    }
000022  4770              BX       lr
;;;385    /**
                          ENDP

                  |L4.36|
                          DCD      0x40006c00

                          AREA ||i.CRS_DeInit||, CODE, READONLY, ALIGN=1

                  CRS_DeInit PROC
;;;33       */
;;;34     void CRS_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;35     {
;;;36       RCC_APB1PeriphResetCmd(RCC_APB1Periph_CRS, ENABLE);
000002  2101              MOVS     r1,#1
000004  06c8              LSLS     r0,r1,#27
000006  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;37       RCC_APB1PeriphResetCmd(RCC_APB1Periph_CRS, DISABLE);
00000a  2100              MOVS     r1,#0
00000c  2001              MOVS     r0,#1
00000e  06c0              LSLS     r0,r0,#27
000010  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;38     }
000014  bd10              POP      {r4,pc}
;;;39     
                          ENDP


                          AREA ||i.CRS_FrequencyErrorCounterCmd||, CODE, READONLY, ALIGN=2

                  CRS_FrequencyErrorCounterCmd PROC
;;;64       */
;;;65     void CRS_FrequencyErrorCounterCmd(FunctionalState NewState)
000000  2800              CMP      r0,#0
;;;66     {
;;;67       assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;68     
;;;69       if (NewState != DISABLE)
000002  d006              BEQ      |L6.18|
;;;70       {
;;;71     		CRS->CR |= CRS_CR_CEN;
000004  4906              LDR      r1,|L6.32|
000006  6809              LDR      r1,[r1,#0]
000008  2220              MOVS     r2,#0x20
00000a  4311              ORRS     r1,r1,r2
00000c  4a04              LDR      r2,|L6.32|
00000e  6011              STR      r1,[r2,#0]
000010  e005              B        |L6.30|
                  |L6.18|
;;;72       }
;;;73       else
;;;74       {
;;;75     		CRS->CR &= ~CRS_CR_CEN;
000012  4903              LDR      r1,|L6.32|
000014  6809              LDR      r1,[r1,#0]
000016  2220              MOVS     r2,#0x20
000018  4391              BICS     r1,r1,r2
00001a  4a01              LDR      r2,|L6.32|
00001c  6011              STR      r1,[r2,#0]
                  |L6.30|
;;;76       }
;;;77     }
00001e  4770              BX       lr
;;;78     
                          ENDP

                  |L6.32|
                          DCD      0x40006c00

                          AREA ||i.CRS_FrequencyErrorCounterReload||, CODE, READONLY, ALIGN=2

                  CRS_FrequencyErrorCounterReload PROC
;;;118      */
;;;119    void CRS_FrequencyErrorCounterReload(uint32_t CRS_ReloadValue)
000000  4905              LDR      r1,|L7.24|
;;;120    {
;;;121     
;;;122      /* Clear RELOAD[15:0] bits */
;;;123      CRS->CFGR &= ~CRS_CFGR_RELOAD;
000002  6849              LDR      r1,[r1,#4]
000004  0c09              LSRS     r1,r1,#16
000006  0409              LSLS     r1,r1,#16
000008  4a03              LDR      r2,|L7.24|
00000a  6051              STR      r1,[r2,#4]
;;;124      
;;;125      /* Set the RELOAD[15:0] bits according to CRS_ReloadValue value */
;;;126      CRS->CFGR |= (uint32_t)CRS_ReloadValue;
00000c  4611              MOV      r1,r2
00000e  6849              LDR      r1,[r1,#4]
000010  4301              ORRS     r1,r1,r0
000012  6051              STR      r1,[r2,#4]
;;;127    
;;;128    }
000014  4770              BX       lr
;;;129    
                          ENDP

000016  0000              DCW      0x0000
                  |L7.24|
                          DCD      0x40006c00

                          AREA ||i.CRS_FrequencyErrorLimitConfig||, CODE, READONLY, ALIGN=2

                  CRS_FrequencyErrorLimitConfig PROC
;;;136      */
;;;137    void CRS_FrequencyErrorLimitConfig(uint8_t CRS_ErrorLimitValue)
000000  4906              LDR      r1,|L8.28|
;;;138    {
;;;139      /* Clear FELIM[7:0] bits */
;;;140      CRS->CFGR &= ~CRS_CFGR_FELIM;
000002  6849              LDR      r1,[r1,#4]
000004  22ff              MOVS     r2,#0xff
000006  0412              LSLS     r2,r2,#16
000008  4391              BICS     r1,r1,r2
00000a  4a04              LDR      r2,|L8.28|
00000c  6051              STR      r1,[r2,#4]
;;;141      
;;;142      /* Set the FELIM[7:0] bits according to CRS_ErrorLimitValue value */
;;;143      CRS->CFGR |= (uint32_t)(CRS_ErrorLimitValue <<16);
00000e  4611              MOV      r1,r2
000010  6849              LDR      r1,[r1,#4]
000012  0402              LSLS     r2,r0,#16
000014  4311              ORRS     r1,r1,r2
000016  4a01              LDR      r2,|L8.28|
000018  6051              STR      r1,[r2,#4]
;;;144    }
00001a  4770              BX       lr
;;;145    
                          ENDP

                  |L8.28|
                          DCD      0x40006c00

                          AREA ||i.CRS_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  CRS_GetFlagStatus PROC
;;;300      */
;;;301    FlagStatus CRS_GetFlagStatus(uint32_t CRS_FLAG)
000000  4601              MOV      r1,r0
;;;302    {
;;;303      /* Check the parameters */
;;;304      assert_param(IS_CRS_FLAG(CRS_FLAG));
;;;305    
;;;306      return ((FlagStatus)(CRS->ISR & CRS_FLAG));
000002  4802              LDR      r0,|L9.12|
000004  6880              LDR      r0,[r0,#8]
000006  4008              ANDS     r0,r0,r1
000008  b2c0              UXTB     r0,r0
;;;307    }
00000a  4770              BX       lr
;;;308    
                          ENDP

                  |L9.12|
                          DCD      0x40006c00

                          AREA ||i.CRS_GetFrequencyErrorDirection||, CODE, READONLY, ALIGN=2

                  CRS_GetFrequencyErrorDirection PROC
;;;253      */
;;;254    uint32_t CRS_GetFrequencyErrorDirection(void)
000000  4802              LDR      r0,|L10.12|
;;;255    {
;;;256      return ((uint32_t)(CRS->ISR & CRS_ISR_FEDIR));
000002  6880              LDR      r0,[r0,#8]
000004  2101              MOVS     r1,#1
000006  03c9              LSLS     r1,r1,#15
000008  4008              ANDS     r0,r0,r1
;;;257    }
00000a  4770              BX       lr
;;;258    
                          ENDP

                  |L10.12|
                          DCD      0x40006c00

                          AREA ||i.CRS_GetFrequencyErrorValue||, CODE, READONLY, ALIGN=2

                  CRS_GetFrequencyErrorValue PROC
;;;240      */
;;;241    uint32_t CRS_GetFrequencyErrorValue(void)
000000  4802              LDR      r0,|L11.12|
;;;242    {
;;;243      return ((uint32_t)(CRS->ISR & CRS_ISR_FECAP));
000002  6880              LDR      r0,[r0,#8]
000004  0c00              LSRS     r0,r0,#16
000006  0400              LSLS     r0,r0,#16
;;;244    }
000008  4770              BX       lr
;;;245    
                          ENDP

00000a  0000              DCW      0x0000
                  |L11.12|
                          DCD      0x40006c00

                          AREA ||i.CRS_GetHSI48CalibrationValue||, CODE, READONLY, ALIGN=2

                  CRS_GetHSI48CalibrationValue PROC
;;;230      */
;;;231    uint32_t CRS_GetHSI48CalibrationValue(void)
000000  4803              LDR      r0,|L12.16|
;;;232    {
;;;233      return (((uint32_t)(CRS->CR & CRS_CR_TRIM)) >> 8);
000002  6800              LDR      r0,[r0,#0]
000004  213f              MOVS     r1,#0x3f
000006  0209              LSLS     r1,r1,#8
000008  4008              ANDS     r0,r0,r1
00000a  0a00              LSRS     r0,r0,#8
;;;234    }
00000c  4770              BX       lr
;;;235    
                          ENDP

00000e  0000              DCW      0x0000
                  |L12.16|
                          DCD      0x40006c00

                          AREA ||i.CRS_GetITStatus||, CODE, READONLY, ALIGN=2

                  CRS_GetITStatus PROC
;;;349      */
;;;350    ITStatus CRS_GetITStatus(uint32_t CRS_IT)
000000  4601              MOV      r1,r0
;;;351    {
;;;352      /* Check the parameters */
;;;353      assert_param(IS_CRS_GET_IT(CRS_IT));
;;;354    
;;;355      return ((ITStatus)(CRS->ISR & CRS_IT));
000002  4802              LDR      r0,|L13.12|
000004  6880              LDR      r0,[r0,#8]
000006  4008              ANDS     r0,r0,r1
000008  b2c0              UXTB     r0,r0
;;;356    }
00000a  4770              BX       lr
;;;357    
                          ENDP

                  |L13.12|
                          DCD      0x40006c00

                          AREA ||i.CRS_GetReloadValue||, CODE, READONLY, ALIGN=2

                  CRS_GetReloadValue PROC
;;;220      */
;;;221    uint32_t CRS_GetReloadValue(void)
000000  4801              LDR      r0,|L14.8|
;;;222    {
;;;223      return ((uint32_t)(CRS->CFGR & CRS_CFGR_RELOAD));
000002  6840              LDR      r0,[r0,#4]
000004  b280              UXTH     r0,r0
;;;224    }
000006  4770              BX       lr
;;;225    
                          ENDP

                  |L14.8|
                          DCD      0x40006c00

                          AREA ||i.CRS_ITConfig||, CODE, READONLY, ALIGN=2

                  CRS_ITConfig PROC
;;;271      */
;;;272    void CRS_ITConfig(uint32_t CRS_IT, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;273    {
;;;274      /* Check the parameters */
;;;275      assert_param(IS_CRS_IT(CRS_IT));
;;;276      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;277      
;;;278      if (NewState != DISABLE)
000002  d005              BEQ      |L15.16|
;;;279      {
;;;280        CRS->CR |= CRS_IT;
000004  4a05              LDR      r2,|L15.28|
000006  6812              LDR      r2,[r2,#0]
000008  4302              ORRS     r2,r2,r0
00000a  4b04              LDR      r3,|L15.28|
00000c  601a              STR      r2,[r3,#0]
00000e  e004              B        |L15.26|
                  |L15.16|
;;;281      }
;;;282      else
;;;283      {
;;;284        CRS->CR &= ~CRS_IT;
000010  4a02              LDR      r2,|L15.28|
000012  6812              LDR      r2,[r2,#0]
000014  4382              BICS     r2,r2,r0
000016  4b01              LDR      r3,|L15.28|
000018  601a              STR      r2,[r3,#0]
                  |L15.26|
;;;285      }
;;;286    }
00001a  4770              BX       lr
;;;287    
                          ENDP

                  |L15.28|
                          DCD      0x40006c00

                          AREA ||i.CRS_SoftwareSynchronizationGenerate||, CODE, READONLY, ALIGN=2

                  CRS_SoftwareSynchronizationGenerate PROC
;;;104      */
;;;105    void CRS_SoftwareSynchronizationGenerate(void)
000000  4803              LDR      r0,|L16.16|
;;;106    {
;;;107      CRS->CR |= CRS_CR_SWSYNC;
000002  6800              LDR      r0,[r0,#0]
000004  2180              MOVS     r1,#0x80
000006  4308              ORRS     r0,r0,r1
000008  4901              LDR      r1,|L16.16|
00000a  6008              STR      r0,[r1,#0]
;;;108    }
00000c  4770              BX       lr
;;;109    
                          ENDP

00000e  0000              DCW      0x0000
                  |L16.16|
                          DCD      0x40006c00

                          AREA ||i.CRS_SynchronizationPolarityConfig||, CODE, READONLY, ALIGN=2

                  CRS_SynchronizationPolarityConfig PROC
;;;203      */
;;;204    void CRS_SynchronizationPolarityConfig(uint32_t CRS_Polarity)
000000  4905              LDR      r1,|L17.24|
;;;205    {
;;;206      /* Check the parameters */
;;;207      assert_param(IS_CRS_SYNC_POLARITY(CRS_Polarity));
;;;208      
;;;209      /* Clear SYNCSPOL bit */
;;;210      CRS->CFGR &= ~CRS_CFGR_SYNCPOL;
000002  6849              LDR      r1,[r1,#4]
000004  0049              LSLS     r1,r1,#1
000006  0849              LSRS     r1,r1,#1
000008  4a03              LDR      r2,|L17.24|
00000a  6051              STR      r1,[r2,#4]
;;;211      
;;;212      /* Set the SYNCSPOL bits according to CRS_Polarity value */
;;;213      CRS->CFGR |= CRS_Polarity;
00000c  4611              MOV      r1,r2
00000e  6849              LDR      r1,[r1,#4]
000010  4301              ORRS     r1,r1,r0
000012  6051              STR      r1,[r2,#4]
;;;214    }
000014  4770              BX       lr
;;;215    
                          ENDP

000016  0000              DCW      0x0000
                  |L17.24|
                          DCD      0x40006c00

                          AREA ||i.CRS_SynchronizationPrescalerConfig||, CODE, READONLY, ALIGN=2

                  CRS_SynchronizationPrescalerConfig PROC
;;;160      */
;;;161    void CRS_SynchronizationPrescalerConfig(uint32_t CRS_Prescaler)
000000  4905              LDR      r1,|L18.24|
;;;162    {
;;;163      /* Check the parameters */
;;;164      assert_param(IS_CRS_SYNC_DIV(CRS_Prescaler));
;;;165      
;;;166      /* Clear SYNCDIV[2:0] bits */
;;;167      CRS->CFGR &= ~CRS_CFGR_SYNCDIV;
000002  6849              LDR      r1,[r1,#4]
000004  2207              MOVS     r2,#7
000006  0612              LSLS     r2,r2,#24
000008  4391              BICS     r1,r1,r2
00000a  4a03              LDR      r2,|L18.24|
00000c  6051              STR      r1,[r2,#4]
;;;168      
;;;169      /* Set the CRS_CFGR_SYNCDIV[2:0] bits according to CRS_Prescaler value */
;;;170      CRS->CFGR |= CRS_Prescaler;
00000e  4611              MOV      r1,r2
000010  6849              LDR      r1,[r1,#4]
000012  4301              ORRS     r1,r1,r0
000014  6051              STR      r1,[r2,#4]
;;;171    }
000016  4770              BX       lr
;;;172    
                          ENDP

                  |L18.24|
                          DCD      0x40006c00

                          AREA ||i.CRS_SynchronizationSourceConfig||, CODE, READONLY, ALIGN=2

                  CRS_SynchronizationSourceConfig PROC
;;;182      */
;;;183    void CRS_SynchronizationSourceConfig(uint32_t CRS_Source)
000000  4905              LDR      r1,|L19.24|
;;;184    {
;;;185      /* Check the parameters */
;;;186      assert_param(IS_CRS_SYNC_SOURCE(CRS_Source));
;;;187      
;;;188      /* Clear SYNCSRC[1:0] bits */
;;;189      CRS->CFGR &= ~CRS_CFGR_SYNCSRC;
000002  6849              LDR      r1,[r1,#4]
000004  2203              MOVS     r2,#3
000006  0712              LSLS     r2,r2,#28
000008  4391              BICS     r1,r1,r2
00000a  4a03              LDR      r2,|L19.24|
00000c  6051              STR      r1,[r2,#4]
;;;190      
;;;191      /* Set the SYNCSRC[1:0] bits according to CRS_Source value */
;;;192      CRS->CFGR |= CRS_Source;
00000e  4611              MOV      r1,r2
000010  6849              LDR      r1,[r1,#4]
000012  4301              ORRS     r1,r1,r0
000014  6051              STR      r1,[r2,#4]
;;;193    }
000016  4770              BX       lr
;;;194    
                          ENDP

                  |L19.24|
                          DCD      0x40006c00

;*** Start embedded assembler ***

#line 1 "..\\FTLib\\Src\\ft32f0xx_crs.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_ft32f0xx_crs_c_468ef44f____REV16|
#line 129 "..\\FTLib\\CMSIS\\inc\\core_cmInstr.h"
|__asm___14_ft32f0xx_crs_c_468ef44f____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_ft32f0xx_crs_c_468ef44f____REVSH|
#line 144
|__asm___14_ft32f0xx_crs_c_468ef44f____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
