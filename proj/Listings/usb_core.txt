; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\usb_core.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\usb_core.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\FTLib\CMSIS\inc -I..\FTLib\Inc -I..\FTLib\Lib -I..\usb\inc -I..\user -I..\RTT -I..\iap2 -IC:\Users\dell1\AppData\Local\Arm\Packs\FMD\FT32F0xx_DFP\1.0.6\Drivers\CMSIS\FT32F0xx\Include -D__UVISION_VERSION=534 -DFT32F072x8 -DFT32F072x8 --omf_browse=.\objects\usb_core.crf ..\usb\src\usb_core.c]
                          THUMB

                          AREA ||i.ConfigureIfs||, CODE, READONLY, ALIGN=2

                  ConfigureIfs PROC
;;;1738   */
;;;1739   static uint32_t ConfigureIfs(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1740   {
000002  b087              SUB      sp,sp,#0x1c
;;;1741   	PSTD_CFG_DSCR	pcfg;
;;;1742   	BYTE		byIf, byAltIf, byEP, byNumEPs, by;
;;;1743   	BYTE		*pby;
;;;1744   	BYTE		*pbyIfVal;
;;;1745   	PSTD_IF_DSCR	pif;
;;;1746   	PSTD_EP_DSCR	pep;
;;;1747   
;;;1748   	/* Set pointer to first interface descriptor in current configuration */
;;;1749   	pby = (BYTE *)(gpCurCfg) + sizeof(STD_CFG_DSCR);
000004  487d              LDR      r0,|L1.508|
000006  6800              LDR      r0,[r0,#0]  ; gpCurCfg
000008  4605              MOV      r5,r0
00000a  3509              ADDS     r5,r5,#9
;;;1750   	pif = (PSTD_IF_DSCR)pby;
00000c  462f              MOV      r7,r5
;;;1751   
;;;1752   	/* Loop through all interfaces in the current configuration */
;;;1753   	pcfg = (PSTD_CFG_DSCR)gpCurCfg;
00000e  487b              LDR      r0,|L1.508|
000010  6800              LDR      r0,[r0,#0]  ; gpCurCfg
000012  9006              STR      r0,[sp,#0x18]
;;;1754   	pbyIfVal = (BYTE*)&gbyCurIfVal;	//接口
000014  487a              LDR      r0,|L1.512|
000016  9001              STR      r0,[sp,#4]
;;;1755   
;;;1756   	SEGGER_RTT_printf(0,"ConfigureIfs;  pcfg->bNumInterfaces=%d\n",pcfg->bNumInterfaces);
000018  9806              LDR      r0,[sp,#0x18]
00001a  7902              LDRB     r2,[r0,#4]
00001c  a179              ADR      r1,|L1.516|
00001e  2000              MOVS     r0,#0
000020  f7fffffe          BL       SEGGER_RTT_printf
;;;1757   	for (byIf=0; byIf < pcfg->bNumInterfaces; byIf++, pbyIfVal++) 
000024  2000              MOVS     r0,#0
000026  9005              STR      r0,[sp,#0x14]
000028  e0e0              B        |L1.492|
                  |L1.42|
;;;1758   	{
;;;1759   		SEGGER_RTT_printf(0,"ConfigureIfs; byIf=%d	byAltIf=%d pbyIfVal=%d\n",byIf,byAltIf ,*pbyIfVal);
00002a  9801              LDR      r0,[sp,#4]
00002c  7800              LDRB     r0,[r0,#0]
00002e  9000              STR      r0,[sp,#0]
000030  a17e              ADR      r1,|L1.556|
000032  2000              MOVS     r0,#0
000034  9b04              LDR      r3,[sp,#0x10]
000036  9a05              LDR      r2,[sp,#0x14]
000038  f7fffffe          BL       SEGGER_RTT_printf
;;;1760   		/* Advance pointer to selected alternate interface descriptor */
;;;1761   		if (*pbyIfVal) 
00003c  9801              LDR      r0,[sp,#4]
00003e  7800              LDRB     r0,[r0,#0]
000040  2800              CMP      r0,#0
000042  d024              BEQ      |L1.142|
;;;1762   		{
;;;1763   		
;;;1764   	
;;;1765   			for (byAltIf=0; byAltIf<*pbyIfVal; byAltIf++) 
000044  2000              MOVS     r0,#0
000046  9004              STR      r0,[sp,#0x10]
000048  e01c              B        |L1.132|
                  |L1.74|
;;;1766   			{
;;;1767   				byNumEPs = pif->bNumEndpoints;
00004a  7938              LDRB     r0,[r7,#4]
00004c  9002              STR      r0,[sp,#8]
;;;1768   				
;;;1769   				SEGGER_RTT_printf(0,"ConfigureIfs; byAltIf=%d	byNumEPs=%d\n",byNumEPs,byAltIf);
00004e  a183              ADR      r1,|L1.604|
000050  2000              MOVS     r0,#0
000052  9b04              LDR      r3,[sp,#0x10]
000054  9a02              LDR      r2,[sp,#8]
000056  f7fffffe          BL       SEGGER_RTT_printf
;;;1770   				pby += sizeof(STD_IF_DSCR) + byNumEPs * sizeof(STD_EP_DSCR) /*+ sizeof(STD_HID_DSCR)*/;
00005a  9802              LDR      r0,[sp,#8]
00005c  00c1              LSLS     r1,r0,#3
00005e  1a08              SUBS     r0,r1,r0
000060  3009              ADDS     r0,r0,#9
000062  182d              ADDS     r5,r5,r0
;;;1771   				pif  = (PSTD_IF_DSCR)pby;
000064  462f              MOV      r7,r5
;;;1772   				/* Check an alternate setting > number of alternates not specified */
;;;1773   				if (!pif->bAlternateSetting)
000066  78f8              LDRB     r0,[r7,#3]
000068  2800              CMP      r0,#0
00006a  d107              BNE      |L1.124|
;;;1774   				{
;;;1775   				
;;;1776   				SEGGER_RTT_printf(0,"ConfigureIfs; byAltIf=%d	byNumEPs=%d !pif->bAlternateSetting\n",byNumEPs,byAltIf);
00006c  a185              ADR      r1,|L1.644|
00006e  9b04              LDR      r3,[sp,#0x10]
000070  9a02              LDR      r2,[sp,#8]
000072  f7fffffe          BL       SEGGER_RTT_printf
;;;1777   					return FALSE;
000076  2000              MOVS     r0,#0
                  |L1.120|
;;;1778   				}
;;;1779   			} 
;;;1780   		}
;;;1781   
;;;1782   		/* Store pointer to interface in global array */
;;;1783   		gpCurIf[byIf] = pif;
;;;1784   		SEGGER_RTT_printf(0,"aa ConfigureIfs;	pif->bNumEndpoints=%d\n",pif->bNumEndpoints);
;;;1785   
;;;1786   		/* Loop through all endpoints in interface */
;;;1787   		byNumEPs = pif->bNumEndpoints;
;;;1788   		
;;;1789   		SEGGER_RTT_printf(0,"bbb ConfigureIfs;	pif->bNumEndpoints=%d\n",pif->bNumEndpoints);
;;;1790   		pby += sizeof(STD_IF_DSCR) /*+ sizeof(STD_HID_DSCR)*/;	//endpoint
;;;1791   		
;;;1792   		SEGGER_RTT_printf(0,"ccc ConfigureIfs;	pif->bNumEndpoints=%d\n",pif->bNumEndpoints);
;;;1793   		for ( byEP = 0; byEP < byNumEPs; byEP++ )
;;;1794   		{
;;;1795   		
;;;1796   		SEGGER_RTT_printf(0,"ddd ConfigureIfs;	pep->bEndpointAddress=0x%02x\n",pep->bEndpointAddress);
;;;1797   			pep = (PSTD_EP_DSCR)pby;
;;;1798   			SEGGER_RTT_printf(0,"ee ConfigureIfs;	pep->bEndpointAddress=0x%02x\n",pep->bEndpointAddress);
;;;1799   
;;;1800   			/* Configure the endpoint */
;;;1801   			MWRITE_BYTE(M_REG_INDEX, (pep->bEndpointAddress & 0x0F));
;;;1802   			
;;;1803   			SEGGER_RTT_printf(0,"ff ConfigureIfs;	pep->bEndpointAddress=0x%02x\n",pep->bEndpointAddress);
;;;1804   			/* Round up max packet size to a multiple of 8 for writing to MaxP registers */
;;;1805   			by = (BYTE)((pep->wMaxPacketSize + 7) >> 3);
;;;1806   			
;;;1807   			SEGGER_RTT_printf(0,"33 ConfigureIfs;	pep->bEndpointAddress=0x%02x\n",pep->bEndpointAddress);
;;;1808   			if(pep->bEndpointAddress & 0x80)
;;;1809   			{
;;;1810   			
;;;1811   			SEGGER_RTT_printf(0,"444 ConfigureIfs;	pep->bEndpointAddress=0x%02x\n",pep->bEndpointAddress);
;;;1812   				MWRITE_BYTE(M_REG_INMAXP, by);
;;;1813   				by = MREAD_BYTE(M_REG_INCSR2);
;;;1814   				
;;;1815   				SEGGER_RTT_printf(0,"66 ConfigureIfs;	pep->bmAttributes=0x%02x\n",pep->bmAttributes);
;;;1816   				
;;;1817   				SEGGER_RTT_printf(0,"66 ConfigureIfs;	pep->bmAttributes=0x%02x\n",(pep->bmAttributes & M_EP_TFMASK));
;;;1818   				switch (pep->bmAttributes & M_EP_TFMASK)
;;;1819   				{
;;;1820   					case M_EP_ISO:
;;;1821   						
;;;1822   						SEGGER_RTT_printf(0,"555 ConfigureIfs;	pep->bEndpointAddress=0x%02x\n",pep->bEndpointAddress);
;;;1823   						by |= M_INCSR2_ISO;
;;;1824   					break;
;;;1825   					case M_EP_BULK:
;;;1826   					case M_EP_INTR:		
;;;1827   						
;;;1828   						SEGGER_RTT_printf(0,"777 ConfigureIfs;	pep->bmAttributes=0x%02x\n",pep->bmAttributes);
;;;1829   						by &= ~M_INCSR2_ISO;
;;;1830   					break;
;;;1831   				}
;;;1832   				
;;;1833   				/* Set mode bit high (only strictly necessary if sharing a FIFO) */
;;;1834   				by |= M_INCSR2_MODE;
;;;1835   				
;;;1836   				MWRITE_BYTE(M_REG_INCSR2, by);
;;;1837   				
;;;1838   				/* Other configuration for an IN endpoint */
;;;1839   				/* e.g. AutoClr, DMA */
;;;1840   				/* should be added here */
;;;1841   			}
;;;1842   			else
;;;1843   			{
;;;1844   				MWRITE_BYTE(M_REG_OUTMAXP, by);
;;;1845   				by = MREAD_BYTE(M_REG_OUTCSR2);
;;;1846   				
;;;1847   				SEGGER_RTT_printf(0,"999 ConfigureIfs;	pep->bmAttributes=0x%02x\n",pep->bmAttributes);
;;;1848   				switch (pep->bmAttributes & M_EP_TFMASK)
;;;1849   				{
;;;1850   					case M_EP_ISO:
;;;1851   						
;;;1852   						SEGGER_RTT_printf(0,"hhh ConfigureIfs;	pep->bmAttributes=0x%02x\n",pep->bmAttributes);
;;;1853   						by |= M_OUTCSR2_ISO;
;;;1854   					break;
;;;1855   					case M_EP_BULK:
;;;1856   					case M_EP_INTR:
;;;1857   						
;;;1858   						SEGGER_RTT_printf(0,"ffff ConfigureIfs;	pep->bmAttributes=0x%02x\n",pep->bmAttributes);
;;;1859   						by &= ~M_OUTCSR2_ISO;
;;;1860   					break;
;;;1861   				}
;;;1862   				MWRITE_BYTE(M_REG_OUTCSR2, by);
;;;1863   				/* Other configuration for an OUT endpoint */
;;;1864   				/* e.g. AutoSet, DMA */
;;;1865   				/* should be added here */
;;;1866   			}
;;;1867   			
;;;1868   			pby += sizeof(STD_EP_DSCR);	
;;;1869   		}
;;;1870   	}
;;;1871   
;;;1872   	return TRUE;
;;;1873   }
000078  b007              ADD      sp,sp,#0x1c
00007a  bdf0              POP      {r4-r7,pc}
                  |L1.124|
00007c  9804              LDR      r0,[sp,#0x10]         ;1765
00007e  1c40              ADDS     r0,r0,#1              ;1765
000080  b2c0              UXTB     r0,r0                 ;1765
000082  9004              STR      r0,[sp,#0x10]         ;1765
                  |L1.132|
000084  9801              LDR      r0,[sp,#4]            ;1765
000086  7801              LDRB     r1,[r0,#0]            ;1765
000088  9804              LDR      r0,[sp,#0x10]         ;1765
00008a  4281              CMP      r1,r0                 ;1765
00008c  dcdd              BGT      |L1.74|
                  |L1.142|
00008e  9805              LDR      r0,[sp,#0x14]         ;1783
000090  0080              LSLS     r0,r0,#2              ;1783
000092  498c              LDR      r1,|L1.708|
000094  500f              STR      r7,[r1,r0]            ;1783
000096  793a              LDRB     r2,[r7,#4]            ;1784
000098  a18b              ADR      r1,|L1.712|
00009a  2000              MOVS     r0,#0                 ;1784
00009c  f7fffffe          BL       SEGGER_RTT_printf
0000a0  7938              LDRB     r0,[r7,#4]            ;1787
0000a2  9002              STR      r0,[sp,#8]            ;1787
0000a4  793a              LDRB     r2,[r7,#4]            ;1789
0000a6  a192              ADR      r1,|L1.752|
0000a8  2000              MOVS     r0,#0                 ;1789
0000aa  f7fffffe          BL       SEGGER_RTT_printf
0000ae  3509              ADDS     r5,r5,#9              ;1790
0000b0  793a              LDRB     r2,[r7,#4]            ;1792
0000b2  a19a              ADR      r1,|L1.796|
0000b4  2000              MOVS     r0,#0                 ;1792
0000b6  f7fffffe          BL       SEGGER_RTT_printf
0000ba  2000              MOVS     r0,#0                 ;1793
0000bc  9003              STR      r0,[sp,#0xc]          ;1793
0000be  e089              B        |L1.468|
                  |L1.192|
0000c0  78a2              LDRB     r2,[r4,#2]            ;1796
0000c2  a1a1              ADR      r1,|L1.840|
0000c4  2000              MOVS     r0,#0                 ;1796
0000c6  f7fffffe          BL       SEGGER_RTT_printf
0000ca  462c              MOV      r4,r5                 ;1797
0000cc  78a2              LDRB     r2,[r4,#2]            ;1798
0000ce  a1aa              ADR      r1,|L1.888|
0000d0  2000              MOVS     r0,#0                 ;1798
0000d2  f7fffffe          BL       SEGGER_RTT_printf
0000d6  78a0              LDRB     r0,[r4,#2]            ;1801
0000d8  0700              LSLS     r0,r0,#28             ;1801
0000da  0f00              LSRS     r0,r0,#28             ;1801
0000dc  49b2              LDR      r1,|L1.936|
0000de  7388              STRB     r0,[r1,#0xe]          ;1801
0000e0  78a2              LDRB     r2,[r4,#2]            ;1803
0000e2  a1b2              ADR      r1,|L1.940|
0000e4  2000              MOVS     r0,#0                 ;1803
0000e6  f7fffffe          BL       SEGGER_RTT_printf
0000ea  7960              LDRB     r0,[r4,#5]            ;1805
0000ec  7921              LDRB     r1,[r4,#4]            ;1805
0000ee  0200              LSLS     r0,r0,#8              ;1805
0000f0  4308              ORRS     r0,r0,r1              ;1805
0000f2  1dc0              ADDS     r0,r0,#7              ;1805
0000f4  0540              LSLS     r0,r0,#21             ;1805
0000f6  0e06              LSRS     r6,r0,#24             ;1805
0000f8  78a2              LDRB     r2,[r4,#2]            ;1807
0000fa  a1b8              ADR      r1,|L1.988|
0000fc  2000              MOVS     r0,#0                 ;1807
0000fe  f7fffffe          BL       SEGGER_RTT_printf
000102  78a0              LDRB     r0,[r4,#2]            ;1808
000104  2180              MOVS     r1,#0x80              ;1808
000106  4008              ANDS     r0,r0,r1              ;1808
000108  2800              CMP      r0,#0                 ;1808
00010a  d036              BEQ      |L1.378|
00010c  78a2              LDRB     r2,[r4,#2]            ;1811
00010e  a1bf              ADR      r1,|L1.1036|
000110  2000              MOVS     r0,#0                 ;1811
000112  f7fffffe          BL       SEGGER_RTT_printf
000116  48a4              LDR      r0,|L1.936|
000118  7406              STRB     r6,[r0,#0x10]         ;1812
00011a  7c86              LDRB     r6,[r0,#0x12]         ;1813
00011c  78e2              LDRB     r2,[r4,#3]            ;1815
00011e  a1c7              ADR      r1,|L1.1084|
000120  2000              MOVS     r0,#0                 ;1815
000122  f7fffffe          BL       SEGGER_RTT_printf
000126  78e0              LDRB     r0,[r4,#3]            ;1817
000128  0782              LSLS     r2,r0,#30             ;1817
00012a  0f92              LSRS     r2,r2,#30             ;1817
00012c  a1c3              ADR      r1,|L1.1084|
00012e  2000              MOVS     r0,#0                 ;1817
000130  f7fffffe          BL       SEGGER_RTT_printf
000134  78e0              LDRB     r0,[r4,#3]            ;1818
000136  0780              LSLS     r0,r0,#30             ;1818
000138  0f80              LSRS     r0,r0,#30             ;1818
00013a  2801              CMP      r0,#1                 ;1818
00013c  d004              BEQ      |L1.328|
00013e  2802              CMP      r0,#2                 ;1818
000140  d00a              BEQ      |L1.344|
000142  2803              CMP      r0,#3                 ;1818
000144  d113              BNE      |L1.366|
000146  e008              B        |L1.346|
                  |L1.328|
000148  78a2              LDRB     r2,[r4,#2]            ;1822
00014a  a1c7              ADR      r1,|L1.1128|
00014c  2000              MOVS     r0,#0                 ;1822
00014e  f7fffffe          BL       SEGGER_RTT_printf
000152  2040              MOVS     r0,#0x40              ;1823
000154  4306              ORRS     r6,r6,r0              ;1823
000156  e00a              B        |L1.366|
                  |L1.344|
000158  bf00              NOP                            ;1826
                  |L1.346|
00015a  78e2              LDRB     r2,[r4,#3]            ;1828
00015c  a1ce              ADR      r1,|L1.1176|
00015e  2000              MOVS     r0,#0                 ;1828
000160  f7fffffe          BL       SEGGER_RTT_printf
000164  2140              MOVS     r1,#0x40              ;1829
000166  4630              MOV      r0,r6                 ;1829
000168  4388              BICS     r0,r0,r1              ;1829
00016a  4606              MOV      r6,r0                 ;1829
00016c  bf00              NOP                            ;1830
                  |L1.366|
00016e  bf00              NOP                            ;1824
000170  2020              MOVS     r0,#0x20              ;1834
000172  4306              ORRS     r6,r6,r0              ;1834
000174  488c              LDR      r0,|L1.936|
000176  7486              STRB     r6,[r0,#0x12]         ;1836
000178  e027              B        |L1.458|
                  |L1.378|
00017a  488b              LDR      r0,|L1.936|
00017c  74c6              STRB     r6,[r0,#0x13]         ;1844
00017e  7d46              LDRB     r6,[r0,#0x15]         ;1845
000180  78e2              LDRB     r2,[r4,#3]            ;1847
000182  a1d0              ADR      r1,|L1.1220|
000184  2000              MOVS     r0,#0                 ;1847
000186  f7fffffe          BL       SEGGER_RTT_printf
00018a  78e0              LDRB     r0,[r4,#3]            ;1848
00018c  0780              LSLS     r0,r0,#30             ;1848
00018e  0f80              LSRS     r0,r0,#30             ;1848
000190  2801              CMP      r0,#1                 ;1848
000192  d004              BEQ      |L1.414|
000194  2802              CMP      r0,#2                 ;1848
000196  d00a              BEQ      |L1.430|
000198  2803              CMP      r0,#3                 ;1848
00019a  d113              BNE      |L1.452|
00019c  e008              B        |L1.432|
                  |L1.414|
00019e  78e2              LDRB     r2,[r4,#3]            ;1852
0001a0  a1d3              ADR      r1,|L1.1264|
0001a2  2000              MOVS     r0,#0                 ;1852
0001a4  f7fffffe          BL       SEGGER_RTT_printf
0001a8  2040              MOVS     r0,#0x40              ;1853
0001aa  4306              ORRS     r6,r6,r0              ;1853
0001ac  e00a              B        |L1.452|
                  |L1.430|
0001ae  bf00              NOP                            ;1856
                  |L1.432|
0001b0  78e2              LDRB     r2,[r4,#3]            ;1858
0001b2  a1da              ADR      r1,|L1.1308|
0001b4  2000              MOVS     r0,#0                 ;1858
0001b6  f7fffffe          BL       SEGGER_RTT_printf
0001ba  2140              MOVS     r1,#0x40              ;1859
0001bc  4630              MOV      r0,r6                 ;1859
0001be  4388              BICS     r0,r0,r1              ;1859
0001c0  4606              MOV      r6,r0                 ;1859
0001c2  bf00              NOP                            ;1860
                  |L1.452|
0001c4  bf00              NOP                            ;1854
0001c6  4878              LDR      r0,|L1.936|
0001c8  7546              STRB     r6,[r0,#0x15]         ;1862
                  |L1.458|
0001ca  1ded              ADDS     r5,r5,#7              ;1868
0001cc  9803              LDR      r0,[sp,#0xc]          ;1793
0001ce  1c40              ADDS     r0,r0,#1              ;1793
0001d0  b2c0              UXTB     r0,r0                 ;1793
0001d2  9003              STR      r0,[sp,#0xc]          ;1793
                  |L1.468|
0001d4  9902              LDR      r1,[sp,#8]            ;1793
0001d6  9803              LDR      r0,[sp,#0xc]          ;1793
0001d8  4288              CMP      r0,r1                 ;1793
0001da  da00              BGE      |L1.478|
0001dc  e770              B        |L1.192|
                  |L1.478|
0001de  9805              LDR      r0,[sp,#0x14]         ;1757
0001e0  1c40              ADDS     r0,r0,#1              ;1757
0001e2  b2c0              UXTB     r0,r0                 ;1757
0001e4  9005              STR      r0,[sp,#0x14]         ;1757
0001e6  9801              LDR      r0,[sp,#4]            ;1757
0001e8  1c40              ADDS     r0,r0,#1              ;1757
0001ea  9001              STR      r0,[sp,#4]            ;1757
                  |L1.492|
0001ec  9806              LDR      r0,[sp,#0x18]         ;1757
0001ee  7901              LDRB     r1,[r0,#4]            ;1757
0001f0  9805              LDR      r0,[sp,#0x14]         ;1757
0001f2  4281              CMP      r1,r0                 ;1757
0001f4  dd00              BLE      |L1.504|
0001f6  e718              B        |L1.42|
                  |L1.504|
0001f8  2001              MOVS     r0,#1                 ;1872
0001fa  e73d              B        |L1.120|
;;;1874   
                          ENDP

                  |L1.508|
                          DCD      gpCurCfg
                  |L1.512|
                          DCD      gbyCurIfVal
                  |L1.516|
000204  436f6e66          DCB      "ConfigureIfs;  pcfg->bNumInterfaces=%d\n",0
000208  69677572
00020c  65496673
000210  3b202070
000214  6366672d
000218  3e624e75
00021c  6d496e74
000220  65726661
000224  6365733d
000228  25640a00
                  |L1.556|
00022c  436f6e66          DCB      "ConfigureIfs; byIf=%d\tbyAltIf=%d pbyIfVal=%d\n",0
000230  69677572
000234  65496673
000238  3b206279
00023c  49663d25
000240  64096279
000244  416c7449
000248  663d2564
00024c  20706279
000250  49665661
000254  6c3d2564
000258  0a00    
00025a  00                DCB      0
00025b  00                DCB      0
                  |L1.604|
00025c  436f6e66          DCB      "ConfigureIfs; byAltIf=%d\tbyNumEPs=%d\n",0
000260  69677572
000264  65496673
000268  3b206279
00026c  416c7449
000270  663d2564
000274  0962794e
000278  756d4550
00027c  733d2564
000280  0a00    
000282  00                DCB      0
000283  00                DCB      0
                  |L1.644|
000284  436f6e66          DCB      "ConfigureIfs; byAltIf=%d\tbyNumEPs=%d !pif->bAlternateS"
000288  69677572
00028c  65496673
000290  3b206279
000294  416c7449
000298  663d2564
00029c  0962794e
0002a0  756d4550
0002a4  733d2564
0002a8  20217069
0002ac  662d3e62
0002b0  416c7465
0002b4  726e6174
0002b8  6553    
0002ba  65747469          DCB      "etting\n",0
0002be  6e670a00
0002c2  00                DCB      0
0002c3  00                DCB      0
                  |L1.708|
                          DCD      gpCurIf
                  |L1.712|
0002c8  61612043          DCB      "aa ConfigureIfs;\tpif->bNumEndpoints=%d\n",0
0002cc  6f6e6669
0002d0  67757265
0002d4  4966733b
0002d8  09706966
0002dc  2d3e624e
0002e0  756d456e
0002e4  64706f69
0002e8  6e74733d
0002ec  25640a00
                  |L1.752|
0002f0  62626220          DCB      "bbb ConfigureIfs;\tpif->bNumEndpoints=%d\n",0
0002f4  436f6e66
0002f8  69677572
0002fc  65496673
000300  3b097069
000304  662d3e62
000308  4e756d45
00030c  6e64706f
000310  696e7473
000314  3d25640a
000318  00      
000319  00                DCB      0
00031a  00                DCB      0
00031b  00                DCB      0
                  |L1.796|
00031c  63636320          DCB      "ccc ConfigureIfs;\tpif->bNumEndpoints=%d\n",0
000320  436f6e66
000324  69677572
000328  65496673
00032c  3b097069
000330  662d3e62
000334  4e756d45
000338  6e64706f
00033c  696e7473
000340  3d25640a
000344  00      
000345  00                DCB      0
000346  00                DCB      0
000347  00                DCB      0
                  |L1.840|
000348  64646420          DCB      "ddd ConfigureIfs;\tpep->bEndpointAddress=0x%02x\n",0
00034c  436f6e66
000350  69677572
000354  65496673
000358  3b097065
00035c  702d3e62
000360  456e6470
000364  6f696e74
000368  41646472
00036c  6573733d
000370  30782530
000374  32780a00
                  |L1.888|
000378  65652043          DCB      "ee ConfigureIfs;\tpep->bEndpointAddress=0x%02x\n",0
00037c  6f6e6669
000380  67757265
000384  4966733b
000388  09706570
00038c  2d3e6245
000390  6e64706f
000394  696e7441
000398  64647265
00039c  73733d30
0003a0  78253032
0003a4  780a00  
0003a7  00                DCB      0
                  |L1.936|
                          DCD      0x40005c00
                  |L1.940|
0003ac  66662043          DCB      "ff ConfigureIfs;\tpep->bEndpointAddress=0x%02x\n",0
0003b0  6f6e6669
0003b4  67757265
0003b8  4966733b
0003bc  09706570
0003c0  2d3e6245
0003c4  6e64706f
0003c8  696e7441
0003cc  64647265
0003d0  73733d30
0003d4  78253032
0003d8  780a00  
0003db  00                DCB      0
                  |L1.988|
0003dc  33332043          DCB      "33 ConfigureIfs;\tpep->bEndpointAddress=0x%02x\n",0
0003e0  6f6e6669
0003e4  67757265
0003e8  4966733b
0003ec  09706570
0003f0  2d3e6245
0003f4  6e64706f
0003f8  696e7441
0003fc  64647265
000400  73733d30
000404  78253032
000408  780a00  
00040b  00                DCB      0
                  |L1.1036|
00040c  34343420          DCB      "444 ConfigureIfs;\tpep->bEndpointAddress=0x%02x\n",0
000410  436f6e66
000414  69677572
000418  65496673
00041c  3b097065
000420  702d3e62
000424  456e6470
000428  6f696e74
00042c  41646472
000430  6573733d
000434  30782530
000438  32780a00
                  |L1.1084|
00043c  36362043          DCB      "66 ConfigureIfs;\tpep->bmAttributes=0x%02x\n",0
000440  6f6e6669
000444  67757265
000448  4966733b
00044c  09706570
000450  2d3e626d
000454  41747472
000458  69627574
00045c  65733d30
000460  78253032
000464  780a00  
000467  00                DCB      0
                  |L1.1128|
000468  35353520          DCB      "555 ConfigureIfs;\tpep->bEndpointAddress=0x%02x\n",0
00046c  436f6e66
000470  69677572
000474  65496673
000478  3b097065
00047c  702d3e62
000480  456e6470
000484  6f696e74
000488  41646472
00048c  6573733d
000490  30782530
000494  32780a00
                  |L1.1176|
000498  37373720          DCB      "777 ConfigureIfs;\tpep->bmAttributes=0x%02x\n",0
00049c  436f6e66
0004a0  69677572
0004a4  65496673
0004a8  3b097065
0004ac  702d3e62
0004b0  6d417474
0004b4  72696275
0004b8  7465733d
0004bc  30782530
0004c0  32780a00
                  |L1.1220|
0004c4  39393920          DCB      "999 ConfigureIfs;\tpep->bmAttributes=0x%02x\n",0
0004c8  436f6e66
0004cc  69677572
0004d0  65496673
0004d4  3b097065
0004d8  702d3e62
0004dc  6d417474
0004e0  72696275
0004e4  7465733d
0004e8  30782530
0004ec  32780a00
                  |L1.1264|
0004f0  68686820          DCB      "hhh ConfigureIfs;\tpep->bmAttributes=0x%02x\n",0
0004f4  436f6e66
0004f8  69677572
0004fc  65496673
000500  3b097065
000504  702d3e62
000508  6d417474
00050c  72696275
000510  7465733d
000514  30782530
000518  32780a00
                  |L1.1308|
00051c  66666666          DCB      "ffff ConfigureIfs;\tpep->bmAttributes=0x%02x\n",0
000520  20436f6e
000524  66696775
000528  72654966
00052c  733b0970
000530  65702d3e
000534  626d4174
000538  74726962
00053c  75746573
000540  3d307825
000544  3032780a
000548  00      
000549  00                DCB      0
00054a  00                DCB      0
00054b  00                DCB      0

                          AREA ||i.EndpointBulkIn||, CODE, READONLY, ALIGN=2

                  EndpointBulkIn PROC
;;;364    */
;;;365    void EndpointBulkIn(M_EPBIN_STATUS pbistate, int nCallState)
000000  b57f              PUSH     {r0-r6,lr}
;;;366    {
000002  461e              MOV      r6,r3
;;;367    	int     nBytes;
;;;368    	BYTE    byInCSR;
;;;369    
;;;370    	/* Reset endpoint */
;;;371    	if(nCallState == M_EP_RESET)
000004  2e01              CMP      r6,#1
000006  d107              BNE      |L2.24|
;;;372    	{
;;;373    		/*切换端点号*/
;;;374    		MWRITE_BYTE(M_REG_INDEX, pbistate.byEP);
000008  4668              MOV      r0,sp
00000a  7a00              LDRB     r0,[r0,#8]
00000c  491a              LDR      r1,|L2.120|
00000e  7388              STRB     r0,[r1,#0xe]
;;;375    		/*清除相应端点的数据翻转状态和清空FIFO中要发送的数据*/
;;;376    		byInCSR = M_INCSR_CDT | M_INCSR_FF;
000010  2548              MOVS     r5,#0x48
;;;377    		MWRITE_BYTE(M_REG_INCSR1, byInCSR);
000012  4608              MOV      r0,r1
000014  7445              STRB     r5,[r0,#0x11]
000016  e02e              B        |L2.118|
                  |L2.24|
;;;378    	}
;;;379    	else
;;;380    	{
;;;381    	
;;;382    	SEGGER_RTT_printf(0,"EndpointBulkIn pbistate.nBytesLeft=%d\n",pbistate.nBytesLeft);
000018  a118              ADR      r1,|L2.124|
00001a  2000              MOVS     r0,#0
00001c  9a01              LDR      r2,[sp,#4]
00001e  f7fffffe          BL       SEGGER_RTT_printf
;;;383    		/* Check whether there is any data to send */ 
;;;384    		if(pbistate.nBytesLeft != M_EP_NODATA)
000022  9801              LDR      r0,[sp,#4]
000024  1c40              ADDS     r0,r0,#1
000026  2800              CMP      r0,#0
000028  d025              BEQ      |L2.118|
;;;385    		{
;;;386    			/* Determine number of bytes to send */
;;;387    			if(pbistate.nBytesLeft < M_EP_MAXP)
00002a  9801              LDR      r0,[sp,#4]
00002c  2840              CMP      r0,#0x40
00002e  da04              BGE      |L2.58|
;;;388    			{
;;;389    				nBytes = pbistate.nBytesLeft;
000030  9c01              LDR      r4,[sp,#4]
;;;390    				pbistate.nBytesLeft = M_EP_NODATA;
000032  2000              MOVS     r0,#0
000034  43c0              MVNS     r0,r0
000036  9001              STR      r0,[sp,#4]
000038  e003              B        |L2.66|
                  |L2.58|
;;;391    			}
;;;392    			else 
;;;393    			{
;;;394    				nBytes = M_EP_MAXP;
00003a  2440              MOVS     r4,#0x40
;;;395    				pbistate.nBytesLeft -= M_EP_MAXP;
00003c  9801              LDR      r0,[sp,#4]
00003e  3840              SUBS     r0,r0,#0x40
000040  9001              STR      r0,[sp,#4]
                  |L2.66|
;;;396    			}
;;;397    			SEGGER_RTT_printf(0,"222 EndpointBulkIn pbistate.nBytesLeft=%d\n",pbistate.nBytesLeft);
000042  a118              ADR      r1,|L2.164|
000044  2000              MOVS     r0,#0
000046  9a01              LDR      r2,[sp,#4]
000048  f7fffffe          BL       SEGGER_RTT_printf
;;;398    
;;;399    			/* Load FIFO */
;;;400    			FIFOWrite((int)pbistate.byEP, nBytes, pbistate.pData);
00004c  4669              MOV      r1,sp
00004e  7a08              LDRB     r0,[r1,#8]
000050  4621              MOV      r1,r4
000052  9a00              LDR      r2,[sp,#0]
000054  f7fffffe          BL       FIFOWrite
;;;401    			
;;;402    			SEGGER_RTT_printf(0,"333 EndpointBulkIn nBytes=%d\n",nBytes);
000058  4622              MOV      r2,r4
00005a  a11d              ADR      r1,|L2.208|
00005c  2000              MOVS     r0,#0
00005e  f7fffffe          BL       SEGGER_RTT_printf
;;;403    			pbistate.pData = (BYTE *)pbistate.pData + nBytes;
000062  9800              LDR      r0,[sp,#0]
000064  1900              ADDS     r0,r0,r4
000066  9000              STR      r0,[sp,#0]
;;;404    
;;;405    			MWRITE_BYTE(M_REG_INDEX, pbistate.byEP);
000068  4669              MOV      r1,sp
00006a  7a08              LDRB     r0,[r1,#8]
00006c  4902              LDR      r1,|L2.120|
00006e  7388              STRB     r0,[r1,#0xe]
;;;406    			/*表示要发送的数据已经装入相应端点的FIFO中*/
;;;407    			byInCSR = M_INCSR_IPR;
000070  2501              MOVS     r5,#1
;;;408    			MWRITE_BYTE(M_REG_INCSR1, byInCSR);
000072  4608              MOV      r0,r1
000074  7445              STRB     r5,[r0,#0x11]
                  |L2.118|
;;;409    		}
;;;410    	}
;;;411    }
000076  bd7f              POP      {r0-r6,pc}
;;;412    
                          ENDP

                  |L2.120|
                          DCD      0x40005c00
                  |L2.124|
00007c  456e6470          DCB      "EndpointBulkIn pbistate.nBytesLeft=%d\n",0
000080  6f696e74
000084  42756c6b
000088  496e2070
00008c  62697374
000090  6174652e
000094  6e427974
000098  65734c65
00009c  66743d25
0000a0  640a00  
0000a3  00                DCB      0
                  |L2.164|
0000a4  32323220          DCB      "222 EndpointBulkIn pbistate.nBytesLeft=%d\n",0
0000a8  456e6470
0000ac  6f696e74
0000b0  42756c6b
0000b4  496e2070
0000b8  62697374
0000bc  6174652e
0000c0  6e427974
0000c4  65734c65
0000c8  66743d25
0000cc  640a00  
0000cf  00                DCB      0
                  |L2.208|
0000d0  33333320          DCB      "333 EndpointBulkIn nBytes=%d\n",0
0000d4  456e6470
0000d8  6f696e74
0000dc  42756c6b
0000e0  496e206e
0000e4  42797465
0000e8  733d2564
0000ec  0a00    
0000ee  00                DCB      0
0000ef  00                DCB      0

                          AREA ||i.EndpointBulkOut||, CODE, READONLY, ALIGN=2

                  EndpointBulkOut PROC
;;;424    */
;;;425    void EndpointBulkOut(M_EPBOUT_STATUS pbostate, int nCallState)
000000  b57f              PUSH     {r0-r6,lr}
;;;426    {
000002  9e08              LDR      r6,[sp,#0x20]
;;;427    	int     nBytes;
;;;428    	BYTE    byOutCSR;
;;;429    
;;;430    	/* Reset endpoint */
;;;431    	if(nCallState == M_EP_RESET)
000004  2e01              CMP      r6,#1
000006  d107              BNE      |L3.24|
;;;432    	{
;;;433    		/***配置端点号***/
;;;434    		MWRITE_BYTE(M_REG_INDEX, pbostate.byEP);
000008  4668              MOV      r0,sp
00000a  7b00              LDRB     r0,[r0,#0xc]
00000c  4918              LDR      r1,|L3.112|
00000e  7388              STRB     r0,[r1,#0xe]
;;;435    		byOutCSR = M_OUTCSR_CDT | M_OUTCSR_FF;
000010  2590              MOVS     r5,#0x90
;;;436    		/***复位端点的数据反转状态,清空接收 FIFO 中的数据***/
;;;437    		MWRITE_BYTE(M_REG_OUTCSR1, byOutCSR);
000012  4608              MOV      r0,r1
000014  7505              STRB     r5,[r0,#0x14]
000016  e029              B        |L3.108|
                  |L3.24|
;;;438    	}
;;;439    	else
;;;440    	{
;;;441    		/* Set index register */
;;;442    		MWRITE_BYTE(M_REG_INDEX, pbostate.byEP);
000018  4668              MOV      r0,sp
00001a  7b00              LDRB     r0,[r0,#0xc]
00001c  4914              LDR      r1,|L3.112|
00001e  7388              STRB     r0,[r1,#0xe]
;;;443    
;;;444    		/* Read OUT CSR register */
;;;445    		byOutCSR = MREAD_BYTE(M_REG_OUTCSR1);
000020  4608              MOV      r0,r1
000022  7d05              LDRB     r5,[r0,#0x14]
;;;446    
;;;447    		/* Get packet, */
;;;448    		/* may need to unload more than one packet if double buffering enabled */
;;;449    		/*端点FIFO 中有数据*/
;;;450    		while(byOutCSR & M_OUTCSR_OPR)
000024  e01e              B        |L3.100|
                  |L3.38|
;;;451    		{
;;;452    			/* Get packet size */
;;;453    			nBytes = (int)MREAD_BYTE(M_REG_OUTCOUNT2);
000026  4812              LDR      r0,|L3.112|
000028  7dc4              LDRB     r4,[r0,#0x17]
;;;454    			nBytes <<= 8;
00002a  0224              LSLS     r4,r4,#8
;;;455    			nBytes |= (int)MREAD_BYTE(M_REG_OUTCOUNT1);
00002c  7d80              LDRB     r0,[r0,#0x16]
00002e  4304              ORRS     r4,r4,r0
;;;456    
;;;457    			/* Check there is room in the buffer */
;;;458    			if(pbostate.nBytesRecv + nBytes > pbostate.nBuffLen)
000030  9802              LDR      r0,[sp,#8]
000032  1900              ADDS     r0,r0,r4
000034  9901              LDR      r1,[sp,#4]
000036  4288              CMP      r0,r1
000038  dd03              BLE      |L3.66|
;;;459    			{
;;;460    				/* Call to function to handle buffer over run */
;;;461    				MWRITE_BYTE(M_REG_OUTCSR1, 0);
00003a  2000              MOVS     r0,#0
00003c  490c              LDR      r1,|L3.112|
00003e  7508              STRB     r0,[r1,#0x14]
                  |L3.64|
;;;462    				return;
;;;463    			}
;;;464    
;;;465    			/* Unload FIFO */
;;;466    			FIFORead((int)pbostate.byEP, nBytes, pbostate.pData);
;;;467    
;;;468    			/* Update status */
;;;469    			pbostate.nBytesRecv += nBytes;
;;;470    			pbostate.pData = (BYTE *)pbostate.pData + nBytes;
;;;471    
;;;472    			/* Check for end of transfer */
;;;473    			if (nBytes <= M_EP_MAXP) 
;;;474    			{
;;;475    				/* Call function to handle received data */	
;;;476    			}
;;;477    
;;;478    			/* Clear OutPktRdy */
;;;479    			MWRITE_BYTE(M_REG_OUTCSR1, 0);
;;;480    
;;;481    			/* Check for another packet */
;;;482    			byOutCSR = MREAD_BYTE(M_REG_OUTCSR1);
;;;483    		}
;;;484    	}
;;;485    }
000040  bd7f              POP      {r0-r6,pc}
                  |L3.66|
000042  4669              MOV      r1,sp                 ;466
000044  7b08              LDRB     r0,[r1,#0xc]          ;466
000046  4621              MOV      r1,r4                 ;466
000048  9a00              LDR      r2,[sp,#0]            ;466
00004a  f7fffffe          BL       FIFORead
00004e  9802              LDR      r0,[sp,#8]            ;469
000050  1900              ADDS     r0,r0,r4              ;469
000052  9002              STR      r0,[sp,#8]            ;469
000054  9800              LDR      r0,[sp,#0]            ;470
000056  1900              ADDS     r0,r0,r4              ;470
000058  9000              STR      r0,[sp,#0]            ;470
00005a  2000              MOVS     r0,#0                 ;479
00005c  4904              LDR      r1,|L3.112|
00005e  7508              STRB     r0,[r1,#0x14]         ;479
000060  4608              MOV      r0,r1                 ;482
000062  7d05              LDRB     r5,[r0,#0x14]         ;482
                  |L3.100|
000064  07e8              LSLS     r0,r5,#31             ;450
000066  0fc0              LSRS     r0,r0,#31             ;450
000068  2800              CMP      r0,#0                 ;450
00006a  d1dc              BNE      |L3.38|
                  |L3.108|
00006c  bf00              NOP      
00006e  e7e7              B        |L3.64|
;;;486    
                          ENDP

                  |L3.112|
                          DCD      0x40005c00

                          AREA ||i.FIFORead||, CODE, READONLY, ALIGN=2

                  FIFORead PROC
;;;533    */
;;;534    void FIFORead(int nEP, int nBytes, void * pDst)		
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;535    {
000002  b082              SUB      sp,sp,#8
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
;;;536    	int     nCount;
;;;537    	BYTE *  pby;
;;;538    	int     nAddr;
;;;539    	int i;
;;;540    	SEGGER_RTT_printf(0,"start FIFORead nBytes = %d nEP=%d\n",nBytes,nEP);
000008  4633              MOV      r3,r6
00000a  4622              MOV      r2,r4
00000c  a115              ADR      r1,|L4.100|
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       SEGGER_RTT_printf
;;;541    
;;;542    	if(nBytes) 
000014  2c00              CMP      r4,#0
000016  d01c              BEQ      |L4.82|
;;;543    	{
;;;544    		nAddr = M_FIFO_EP0+(nEP<<2);
000018  00b0              LSLS     r0,r6,#2
00001a  491b              LDR      r1,|L4.136|
00001c  1840              ADDS     r0,r0,r1
00001e  9001              STR      r0,[sp,#4]
;;;545    		nCount = nBytes;
000020  4627              MOV      r7,r4
;;;546    		pby = (BYTE *)pDst;
000022  9d04              LDR      r5,[sp,#0x10]
;;;547    		while(nCount) 
000024  e013              B        |L4.78|
                  |L4.38|
;;;548    		{
;;;549    
;;;550    		 SEGGER_RTT_printf(0," 0x%02x ",*pby);
000026  782a              LDRB     r2,[r5,#0]
000028  a118              ADR      r1,|L4.140|
00002a  2000              MOVS     r0,#0
00002c  f7fffffe          BL       SEGGER_RTT_printf
;;;551    		 i++;
000030  9800              LDR      r0,[sp,#0]
000032  1c40              ADDS     r0,r0,#1
000034  9000              STR      r0,[sp,#0]
;;;552    		if(i==10)
000036  9800              LDR      r0,[sp,#0]
000038  280a              CMP      r0,#0xa
00003a  d103              BNE      |L4.68|
;;;553    			SEGGER_RTT_printf(0,"\n");
00003c  a116              ADR      r1,|L4.152|
00003e  2000              MOVS     r0,#0
000040  f7fffffe          BL       SEGGER_RTT_printf
                  |L4.68|
;;;554    			*pby++ = *((BYTE *)nAddr);
000044  9801              LDR      r0,[sp,#4]
000046  7800              LDRB     r0,[r0,#0]
000048  7028              STRB     r0,[r5,#0]
00004a  1c6d              ADDS     r5,r5,#1
;;;555    			
;;;556    			nCount--;
00004c  1e7f              SUBS     r7,r7,#1
                  |L4.78|
00004e  2f00              CMP      r7,#0                 ;547
000050  d1e9              BNE      |L4.38|
                  |L4.82|
;;;557    			
;;;558    		}
;;;559    	}
;;;560    	
;;;561    	SEGGER_RTT_printf(0,"\n  end FIFORead nBytes = %d nEP=%d\n",nBytes,nEP);
000052  4633              MOV      r3,r6
000054  4622              MOV      r2,r4
000056  a111              ADR      r1,|L4.156|
000058  2000              MOVS     r0,#0
00005a  f7fffffe          BL       SEGGER_RTT_printf
;;;562    }
00005e  b005              ADD      sp,sp,#0x14
000060  bdf0              POP      {r4-r7,pc}
;;;563    
                          ENDP

000062  0000              DCW      0x0000
                  |L4.100|
000064  73746172          DCB      "start FIFORead nBytes = %d nEP=%d\n",0
000068  74204649
00006c  464f5265
000070  6164206e
000074  42797465
000078  73203d20
00007c  2564206e
000080  45503d25
000084  640a00  
000087  00                DCB      0
                  |L4.136|
                          DCD      0x40005c20
                  |L4.140|
00008c  20307825          DCB      " 0x%02x ",0
000090  30327820
000094  00      
000095  00                DCB      0
000096  00                DCB      0
000097  00                DCB      0
                  |L4.152|
000098  0a00              DCB      "\n",0
00009a  00                DCB      0
00009b  00                DCB      0
                  |L4.156|
00009c  0a202065          DCB      "\n  end FIFORead nBytes = %d nEP=%d\n",0
0000a0  6e642046
0000a4  49464f52
0000a8  65616420
0000ac  6e427974
0000b0  6573203d
0000b4  20256420
0000b8  6e45503d
0000bc  25640a00

                          AREA ||i.FIFOWrite||, CODE, READONLY, ALIGN=2

                  FIFOWrite PROC
;;;572    */
;;;573    void FIFOWrite(int nEP, int nBytes, void * pSrc)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;574    {
000002  b082              SUB      sp,sp,#8
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
;;;575    	int     nCount;
;;;576    	BYTE *  pby;
;;;577    	int     nAddr;
;;;578    	int i = 0;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;579    	SEGGER_RTT_printf(0,"start FIFOWrite nBytes = %d nEP=%d\n",nBytes,nEP);
00000c  4633              MOV      r3,r6
00000e  4622              MOV      r2,r4
000010  a114              ADR      r1,|L5.100|
000012  f7fffffe          BL       SEGGER_RTT_printf
;;;580    	
;;;581    	if(nBytes)
000016  2c00              CMP      r4,#0
000018  d01c              BEQ      |L5.84|
;;;582    	{
;;;583    		nAddr = M_FIFO_EP0+(nEP<<2);
00001a  00b0              LSLS     r0,r6,#2
00001c  491a              LDR      r1,|L5.136|
00001e  1840              ADDS     r0,r0,r1
000020  9001              STR      r0,[sp,#4]
;;;584    		nCount = nBytes;
000022  4627              MOV      r7,r4
;;;585    		pby = (BYTE *)pSrc;
000024  9d04              LDR      r5,[sp,#0x10]
;;;586    		while (nCount)
000026  e013              B        |L5.80|
                  |L5.40|
;;;587    		{
;;;588    		 SEGGER_RTT_printf(0," 0x%02x ",*pby);
000028  782a              LDRB     r2,[r5,#0]
00002a  a118              ADR      r1,|L5.140|
00002c  2000              MOVS     r0,#0
00002e  f7fffffe          BL       SEGGER_RTT_printf
;;;589    		 *((BYTE *)nAddr) = *pby++;
000032  7829              LDRB     r1,[r5,#0]
000034  9801              LDR      r0,[sp,#4]
000036  7001              STRB     r1,[r0,#0]
000038  1c6d              ADDS     r5,r5,#1
;;;590    		 i++;
00003a  9800              LDR      r0,[sp,#0]
00003c  1c40              ADDS     r0,r0,#1
00003e  9000              STR      r0,[sp,#0]
;;;591    		if(i==10)
000040  9800              LDR      r0,[sp,#0]
000042  280a              CMP      r0,#0xa
000044  d103              BNE      |L5.78|
;;;592    			SEGGER_RTT_printf(0,"\n");
000046  a114              ADR      r1,|L5.152|
000048  2000              MOVS     r0,#0
00004a  f7fffffe          BL       SEGGER_RTT_printf
                  |L5.78|
;;;593    			nCount--;
00004e  1e7f              SUBS     r7,r7,#1
                  |L5.80|
000050  2f00              CMP      r7,#0                 ;586
000052  d1e9              BNE      |L5.40|
                  |L5.84|
;;;594    		}
;;;595    	}
;;;596    	
;;;597    	SEGGER_RTT_printf(0,"\n end FIFOWrite nBytes = %d nEP=%d\n",nBytes,nEP);
000054  4633              MOV      r3,r6
000056  4622              MOV      r2,r4
000058  a110              ADR      r1,|L5.156|
00005a  2000              MOVS     r0,#0
00005c  f7fffffe          BL       SEGGER_RTT_printf
;;;598    	
;;;599    }
000060  b005              ADD      sp,sp,#0x14
000062  bdf0              POP      {r4-r7,pc}
;;;600    
                          ENDP

                  |L5.100|
000064  73746172          DCB      "start FIFOWrite nBytes = %d nEP=%d\n",0
000068  74204649
00006c  464f5772
000070  69746520
000074  6e427974
000078  6573203d
00007c  20256420
000080  6e45503d
000084  25640a00
                  |L5.136|
                          DCD      0x40005c20
                  |L5.140|
00008c  20307825          DCB      " 0x%02x ",0
000090  30327820
000094  00      
000095  00                DCB      0
000096  00                DCB      0
000097  00                DCB      0
                  |L5.152|
000098  0a00              DCB      "\n",0
00009a  00                DCB      0
00009b  00                DCB      0
                  |L5.156|
00009c  0a20656e          DCB      "\n end FIFOWrite nBytes = %d nEP=%d\n",0
0000a0  64204649
0000a4  464f5772
0000a8  69746520
0000ac  6e427974
0000b0  6573203d
0000b4  20256420
0000b8  6e45503d
0000bc  25640a00

                          AREA ||i.HID_GetIdleEvent||, CODE, READONLY, ALIGN=2

                  HID_GetIdleEvent PROC
;;;852    */
;;;853    void HID_GetIdleEvent(PM_EP0_STATUS pep0state,PCOMMAND pcmd)
000000  b570              PUSH     {r4-r6,lr}
;;;854    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;855    	/*保存请求类型*/
;;;856    	c_hid_data.wHID_Status = HID_REQUEST_GET_IDLE;
000006  490b              LDR      r1,|L6.52|
000008  2002              MOVS     r0,#2
00000a  f7fffffe          BL       __aeabi_uwrite4
;;;857    	
;;;858    	pep0state->nBytesLeft = 0x01;
00000e  1d21              ADDS     r1,r4,#4
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       __aeabi_uwrite4
;;;859    	pep0state->pData = (void*)&c_hid_data.wHID_IdleTimeIf0ID;
000016  4621              MOV      r1,r4
000018  3108              ADDS     r1,r1,#8
00001a  4806              LDR      r0,|L6.52|
00001c  3843              SUBS     r0,r0,#0x43
00001e  f7fffffe          BL       __aeabi_uwrite4
;;;860    	pep0state->nState = M_EP0_TX;
000022  4621              MOV      r1,r4
000024  2002              MOVS     r0,#2
000026  f7fffffe          BL       __aeabi_uwrite4
;;;861    	MWRITE_BYTE(M_REG_CSR0,M_CSR0_SVDOUTPKTRDY);	
00002a  2040              MOVS     r0,#0x40
00002c  4902              LDR      r1,|L6.56|
00002e  7448              STRB     r0,[r1,#0x11]
;;;862    }
000030  bd70              POP      {r4-r6,pc}
;;;863    /******************************************************************************
                          ENDP

000032  0000              DCW      0x0000
                  |L6.52|
                          DCD      c_hid_data+0x53
                  |L6.56|
                          DCD      0x40005c00

                          AREA ||i.HID_GetProtocolEvent||, CODE, READONLY, ALIGN=2

                  HID_GetProtocolEvent PROC
;;;888    */
;;;889    void HID_GetProtocolEvent(PM_EP0_STATUS pep0state,PCOMMAND pcmd)
000000  b570              PUSH     {r4-r6,lr}
;;;890    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;891    	/*保存请求类型*/
;;;892    	c_hid_data.wHID_Status = HID_REQUEST_GET_PROTOCOL;
000006  490b              LDR      r1,|L7.52|
000008  2003              MOVS     r0,#3
00000a  f7fffffe          BL       __aeabi_uwrite4
;;;893    	
;;;894    	pep0state->nBytesLeft = 0x01;
00000e  1d21              ADDS     r1,r4,#4
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       __aeabi_uwrite4
;;;895    	pep0state->pData = (void*)&c_hid_data.wHID_Protocol;
000016  4621              MOV      r1,r4
000018  3108              ADDS     r1,r1,#8
00001a  4806              LDR      r0,|L7.52|
00001c  3842              SUBS     r0,r0,#0x42
00001e  f7fffffe          BL       __aeabi_uwrite4
;;;896    	pep0state->nState = M_EP0_TX;
000022  4621              MOV      r1,r4
000024  2002              MOVS     r0,#2
000026  f7fffffe          BL       __aeabi_uwrite4
;;;897    	MWRITE_BYTE(M_REG_CSR0,M_CSR0_SVDOUTPKTRDY);		
00002a  2040              MOVS     r0,#0x40
00002c  4902              LDR      r1,|L7.56|
00002e  7448              STRB     r0,[r1,#0x11]
;;;898    }
000030  bd70              POP      {r4-r6,pc}
;;;899    /******************************************************************************
                          ENDP

000032  0000              DCW      0x0000
                  |L7.52|
                          DCD      c_hid_data+0x53
                  |L7.56|
                          DCD      0x40005c00

                          AREA ||i.HID_GetReportEvent||, CODE, READONLY, ALIGN=2

                  HID_GetReportEvent PROC
;;;824    */
;;;825    void HID_GetReportEvent(PM_EP0_STATUS pep0state,PCOMMAND pcmd)
000000  b570              PUSH     {r4-r6,lr}
;;;826    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;827    	if(gnDevState > DEVSTATE_ADDRESS)
000006  4815              LDR      r0,|L8.92|
000008  6800              LDR      r0,[r0,#0]  ; gnDevState
00000a  2801              CMP      r0,#1
00000c  d924              BLS      |L8.88|
;;;828    	{
;;;829    		switch(pcmd->USBwValue >>8)
00000e  78e8              LDRB     r0,[r5,#3]
000010  78a9              LDRB     r1,[r5,#2]
000012  0200              LSLS     r0,r0,#8
000014  4308              ORRS     r0,r0,r1
000016  1200              ASRS     r0,r0,#8
000018  2801              CMP      r0,#1
00001a  d004              BEQ      |L8.38|
00001c  2802              CMP      r0,#2
00001e  d004              BEQ      |L8.42|
000020  2803              CMP      r0,#3
000022  d118              BNE      |L8.86|
000024  e000              B        |L8.40|
                  |L8.38|
;;;830    		{
;;;831    			case	HID_REPORT_INPUT:
;;;832    			case	HID_REPORT_FEATURE:
000026  bf00              NOP      
                  |L8.40|
;;;833    			case	HID_REPORT_OUTPUT:
000028  bf00              NOP      
                  |L8.42|
;;;834    				/*保存请求类型*/
;;;835    				c_hid_data.wHID_Status = HID_REQUEST_GET_REPORT;
00002a  490d              LDR      r1,|L8.96|
00002c  2001              MOVS     r0,#1
00002e  f7fffffe          BL       __aeabi_uwrite4
;;;836    			
;;;837    				pep0state->nBytesLeft = 0x01;
000032  1d21              ADDS     r1,r4,#4
000034  2001              MOVS     r0,#1
000036  f7fffffe          BL       __aeabi_uwrite4
;;;838    				pep0state->pData = (void*)&c_hid_data.wHID_SetRptByte[0];
00003a  4621              MOV      r1,r4
00003c  3108              ADDS     r1,r1,#8
00003e  4808              LDR      r0,|L8.96|
000040  3853              SUBS     r0,r0,#0x53
000042  f7fffffe          BL       __aeabi_uwrite4
;;;839    				pep0state->nState = M_EP0_TX;
000046  4621              MOV      r1,r4
000048  2002              MOVS     r0,#2
00004a  f7fffffe          BL       __aeabi_uwrite4
;;;840    				MWRITE_BYTE(M_REG_CSR0,M_CSR0_SVDOUTPKTRDY);
00004e  2040              MOVS     r0,#0x40
000050  4904              LDR      r1,|L8.100|
000052  7448              STRB     r0,[r1,#0x11]
;;;841    				break;
000054  bf00              NOP      
                  |L8.86|
000056  bf00              NOP      
                  |L8.88|
;;;842    		}
;;;843    	}	
;;;844    }
000058  bd70              POP      {r4-r6,pc}
;;;845    /******************************************************************************
                          ENDP

00005a  0000              DCW      0x0000
                  |L8.92|
                          DCD      gnDevState
                  |L8.96|
                          DCD      c_hid_data+0x53
                  |L8.100|
                          DCD      0x40005c00

                          AREA ||i.HID_SetIdleEvent||, CODE, READONLY, ALIGN=2

                  HID_SetIdleEvent PROC
;;;870    */
;;;871    void HID_SetIdleEvent(PM_EP0_STATUS pep0state,PCOMMAND pcmd)
000000  b570              PUSH     {r4-r6,lr}
;;;872    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;873    	/*保存请求类型*/
;;;874    	c_hid_data.wHID_Status = HID_REQUEST_SET_IDLE;
000006  490a              LDR      r1,|L9.48|
000008  200a              MOVS     r0,#0xa
00000a  f7fffffe          BL       __aeabi_uwrite4
;;;875    
;;;876    	pep0state->nState = M_EP0_IDLE;
00000e  4621              MOV      r1,r4
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       __aeabi_uwrite4
;;;877    	c_hid_data.wHID_IdleTimeIf0ID = (pcmd->USBwValue>>8);
000016  78e8              LDRB     r0,[r5,#3]
000018  78a9              LDRB     r1,[r5,#2]
00001a  0200              LSLS     r0,r0,#8
00001c  4308              ORRS     r0,r0,r1
00001e  1200              ASRS     r0,r0,#8
000020  4903              LDR      r1,|L9.48|
000022  3953              SUBS     r1,r1,#0x53
000024  7408              STRB     r0,[r1,#0x10]
;;;878    	MWRITE_BYTE(M_REG_CSR0,M_CSR0_SVDOUTPKTRDY);		
000026  2040              MOVS     r0,#0x40
000028  4902              LDR      r1,|L9.52|
00002a  7448              STRB     r0,[r1,#0x11]
;;;879    }
00002c  bd70              POP      {r4-r6,pc}
;;;880    
                          ENDP

00002e  0000              DCW      0x0000
                  |L9.48|
                          DCD      c_hid_data+0x53
                  |L9.52|
                          DCD      0x40005c00

                          AREA ||i.HID_SetProtocolEvent||, CODE, READONLY, ALIGN=2

                  HID_SetProtocolEvent PROC
;;;906    */
;;;907    void HID_SetProtocolEvent(PM_EP0_STATUS pep0state,PCOMMAND pcmd)
000000  b570              PUSH     {r4-r6,lr}
;;;908    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;909    	/*保存请求类型*/
;;;910    	c_hid_data.wHID_Status = HID_REQUEST_SET_PROTOCOL;
000006  4909              LDR      r1,|L10.44|
000008  200b              MOVS     r0,#0xb
00000a  f7fffffe          BL       __aeabi_uwrite4
;;;911    
;;;912    	pep0state->nState = M_EP0_IDLE;
00000e  4621              MOV      r1,r4
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       __aeabi_uwrite4
;;;913    	c_hid_data.wHID_Protocol = (pcmd->USBwValue & 0x00ff);
000016  78e8              LDRB     r0,[r5,#3]
000018  78a9              LDRB     r1,[r5,#2]
00001a  0200              LSLS     r0,r0,#8
00001c  4308              ORRS     r0,r0,r1
00001e  4903              LDR      r1,|L10.44|
000020  3953              SUBS     r1,r1,#0x53
000022  7448              STRB     r0,[r1,#0x11]
;;;914    	MWRITE_BYTE(M_REG_CSR0,M_CSR0_SVDOUTPKTRDY);		
000024  2040              MOVS     r0,#0x40
000026  4902              LDR      r1,|L10.48|
000028  7448              STRB     r0,[r1,#0x11]
;;;915    }
00002a  bd70              POP      {r4-r6,pc}
;;;916    /******************************************************************************
                          ENDP

                  |L10.44|
                          DCD      c_hid_data+0x53
                  |L10.48|
                          DCD      0x40005c00

                          AREA ||i.HID_SetReportEvent||, CODE, READONLY, ALIGN=2

                  HID_SetReportEvent PROC
;;;796    */
;;;797    void HID_SetReportEvent(PM_EP0_STATUS pep0state,PCOMMAND pcmd)
000000  b570              PUSH     {r4-r6,lr}
;;;798    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;799    	//if ((pcmd->bmRequestType == HID_REQUEST_SET) && (pcmd->USBwIndex == 1))// Interface 1
;;;800    	{
;;;801    		switch(pcmd->USBwValue >>8)
000006  78e8              LDRB     r0,[r5,#3]
000008  78a9              LDRB     r1,[r5,#2]
00000a  0200              LSLS     r0,r0,#8
00000c  4308              ORRS     r0,r0,r1
00000e  1200              ASRS     r0,r0,#8
000010  2801              CMP      r0,#1
000012  d004              BEQ      |L11.30|
000014  2802              CMP      r0,#2
000016  d003              BEQ      |L11.32|
000018  2803              CMP      r0,#3
00001a  d11c              BNE      |L11.86|
00001c  e01a              B        |L11.84|
                  |L11.30|
;;;802    		{
;;;803    			case	HID_REPORT_INPUT:break;
00001e  e01a              B        |L11.86|
                  |L11.32|
;;;804    			case	HID_REPORT_OUTPUT:
;;;805    				/*保存请求类型*/
;;;806    				c_hid_data.wHID_Status = HID_REQUEST_SET_REPORT;
000020  490e              LDR      r1,|L11.92|
000022  2009              MOVS     r0,#9
000024  f7fffffe          BL       __aeabi_uwrite4
;;;807    			
;;;808    				pep0state->nBytesLeft = pcmd->USBwLength;
000028  79e9              LDRB     r1,[r5,#7]
00002a  79aa              LDRB     r2,[r5,#6]
00002c  0209              LSLS     r1,r1,#8
00002e  4311              ORRS     r1,r1,r2
000030  4608              MOV      r0,r1
000032  1d21              ADDS     r1,r4,#4
000034  f7fffffe          BL       __aeabi_uwrite4
;;;809    				pep0state->nState = M_EP0_RX;
000038  4621              MOV      r1,r4
00003a  2001              MOVS     r0,#1
00003c  f7fffffe          BL       __aeabi_uwrite4
;;;810    				pep0state->pData = (void*)&c_hid_data.wHID_SetRptByte[0];
000040  4621              MOV      r1,r4
000042  3108              ADDS     r1,r1,#8
000044  4805              LDR      r0,|L11.92|
000046  3853              SUBS     r0,r0,#0x53
000048  f7fffffe          BL       __aeabi_uwrite4
;;;811    				MWRITE_BYTE(M_REG_CSR0,M_CSR0_SVDOUTPKTRDY);				
00004c  2040              MOVS     r0,#0x40
00004e  4904              LDR      r1,|L11.96|
000050  7448              STRB     r0,[r1,#0x11]
;;;812    				break;
000052  e000              B        |L11.86|
                  |L11.84|
;;;813    			case	HID_REPORT_FEATURE:break;
000054  bf00              NOP      
                  |L11.86|
000056  bf00              NOP                            ;803
;;;814    		}
;;;815    	}	
;;;816    }
000058  bd70              POP      {r4-r6,pc}
;;;817    /******************************************************************************
                          ENDP

00005a  0000              DCW      0x0000
                  |L11.92|
                          DCD      c_hid_data+0x53
                  |L11.96|
                          DCD      0x40005c00

                          AREA ||i.USB_EP_Rx||, CODE, READONLY, ALIGN=1

                  USB_EP_Rx PROC
;;;1930   */
;;;1931   int USB_EP_Rx(uint8_t Ep,uint8_t *ptr,uint8_t data_len)
000000  b570              PUSH     {r4-r6,lr}
;;;1932   {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;1933   	M_EPBOUT_STATUS    tEp1out;
;;;1934   	
;;;1935   	tEp1out.byEP = Ep;
00000a  4668              MOV      r0,sp
00000c  7504              STRB     r4,[r0,#0x14]
;;;1936   	tEp1out.nBuffLen = data_len; 	//M_EP_MAXP
00000e  9603              STR      r6,[sp,#0xc]
;;;1937   	tEp1out.pData = ptr;
000010  9502              STR      r5,[sp,#8]
;;;1938   	tEp1out.nBytesRecv = 0;
000012  2000              MOVS     r0,#0
000014  9004              STR      r0,[sp,#0x10]
;;;1939   
;;;1940   	EndpointBulkOut(tEp1out, M_EP_NORMAL);
000016  9000              STR      r0,[sp,#0]
000018  a802              ADD      r0,sp,#8
00001a  c80f              LDM      r0,{r0-r3}
00001c  f7fffffe          BL       EndpointBulkOut
;;;1941   	return tEp1out.nBytesRecv;
000020  9804              LDR      r0,[sp,#0x10]
;;;1942   }
000022  b006              ADD      sp,sp,#0x18
000024  bd70              POP      {r4-r6,pc}
;;;1943   
                          ENDP


                          AREA ||i.USB_EP_Tx||, CODE, READONLY, ALIGN=2

                  USB_EP_Tx PROC
;;;1883   */
;;;1884   ErrorStatus USB_EP_Tx(uint8_t Ep,uint8_t *ptr,uint8_t data_len)
000000  b5fe              PUSH     {r1-r7,lr}
;;;1885   {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
;;;1886   	M_EPBIN_STATUS tEp0in;
;;;1887   	uint32_t timeout = 0;
000008  2400              MOVS     r4,#0
;;;1888   	
;;;1889   	SEGGER_RTT_printf(0,"USB_EP_Tx gnDevState=%d\n",gnDevState);
00000a  4822              LDR      r0,|L13.148|
00000c  a122              ADR      r1,|L13.152|
00000e  6802              LDR      r2,[r0,#0]  ; gnDevState
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       SEGGER_RTT_printf
;;;1890   	if(gnDevState > DEVSTATE_ADDRESS)
000016  481f              LDR      r0,|L13.148|
000018  6800              LDR      r0,[r0,#0]  ; gnDevState
00001a  2801              CMP      r0,#1
00001c  d932              BLS      |L13.132|
;;;1891   	{
;;;1892   	
;;;1893   	SEGGER_RTT_printf(0,"2 USB_EP_Tx gnDevState=%d\n",gnDevState);
00001e  481d              LDR      r0,|L13.148|
000020  a124              ADR      r1,|L13.180|
000022  6802              LDR      r2,[r0,#0]  ; gnDevState
000024  2000              MOVS     r0,#0
000026  f7fffffe          BL       SEGGER_RTT_printf
;;;1894   		tEp0in.byEP = Ep;
00002a  4668              MOV      r0,sp
00002c  7205              STRB     r5,[r0,#8]
;;;1895   		tEp0in.nBytesLeft = data_len;
00002e  9701              STR      r7,[sp,#4]
;;;1896   		tEp0in.pData = ptr;
000030  9600              STR      r6,[sp,#0]
;;;1897   		EndpointBulkIn(tEp0in, M_EP_NORMAL);
000032  2300              MOVS     r3,#0
000034  4668              MOV      r0,sp
000036  c807              LDM      r0,{r0-r2}
000038  f7fffffe          BL       EndpointBulkIn
;;;1898   
;;;1899   		
;;;1900   		SEGGER_RTT_printf(0,"3 USB_EP_Tx MREAD_BYTE(M_REG_INCSR1)=0x%02x\n",MREAD_BYTE(M_REG_INCSR1));
00003c  4824              LDR      r0,|L13.208|
00003e  7c42              LDRB     r2,[r0,#0x11]
000040  a124              ADR      r1,|L13.212|
000042  2000              MOVS     r0,#0
000044  f7fffffe          BL       SEGGER_RTT_printf
;;;1901   		while(MREAD_BYTE(M_REG_INCSR1) & 0x01)
000048  e00e              B        |L13.104|
                  |L13.74|
;;;1902   		{
;;;1903   		
;;;1904   		SEGGER_RTT_printf(0,"4 USB_EP_Tx timeout=%d\n",timeout);
00004a  4622              MOV      r2,r4
00004c  a12d              ADR      r1,|L13.260|
00004e  2000              MOVS     r0,#0
000050  f7fffffe          BL       SEGGER_RTT_printf
;;;1905   			timeout++;
000054  1c64              ADDS     r4,r4,#1
;;;1906   			if(timeout>=0xffffffff)
000056  1c60              ADDS     r0,r4,#1
000058  2800              CMP      r0,#0
00005a  d105              BNE      |L13.104|
;;;1907   			{
;;;1908   			
;;;1909   			SEGGER_RTT_printf(0,"5 USB_EP_Tx timeout=%d\n",timeout);
00005c  4622              MOV      r2,r4
00005e  a12f              ADR      r1,|L13.284|
000060  f7fffffe          BL       SEGGER_RTT_printf
;;;1910   				return ERROR;
000064  2000              MOVS     r0,#0
                  |L13.102|
;;;1911   			}
;;;1912   		}
;;;1913   		
;;;1914   		SEGGER_RTT_printf(0,"6 USB_EP_Tx gnDevState=%d\n",gnDevState);
;;;1915   		return SUCCESS;
;;;1916   	}
;;;1917   	
;;;1918   	SEGGER_RTT_printf(0,"7 USB_EP_Tx gnDevState=%d\n",gnDevState);
;;;1919   	return ERROR;
;;;1920   }
000066  bdfe              POP      {r1-r7,pc}
                  |L13.104|
000068  4819              LDR      r0,|L13.208|
00006a  7c40              LDRB     r0,[r0,#0x11]         ;1901
00006c  07c0              LSLS     r0,r0,#31             ;1901
00006e  0fc0              LSRS     r0,r0,#31             ;1901
000070  2800              CMP      r0,#0                 ;1901
000072  d1ea              BNE      |L13.74|
000074  4807              LDR      r0,|L13.148|
000076  a12f              ADR      r1,|L13.308|
000078  6802              LDR      r2,[r0,#0]            ;1914  ; gnDevState
00007a  2000              MOVS     r0,#0                 ;1914
00007c  f7fffffe          BL       SEGGER_RTT_printf
000080  2001              MOVS     r0,#1                 ;1915
000082  e7f0              B        |L13.102|
                  |L13.132|
000084  4803              LDR      r0,|L13.148|
000086  a132              ADR      r1,|L13.336|
000088  6802              LDR      r2,[r0,#0]            ;1918  ; gnDevState
00008a  2000              MOVS     r0,#0                 ;1918
00008c  f7fffffe          BL       SEGGER_RTT_printf
000090  2000              MOVS     r0,#0                 ;1919
000092  e7e8              B        |L13.102|
;;;1921   
                          ENDP

                  |L13.148|
                          DCD      gnDevState
                  |L13.152|
000098  5553425f          DCB      "USB_EP_Tx gnDevState=%d\n",0
00009c  45505f54
0000a0  7820676e
0000a4  44657653
0000a8  74617465
0000ac  3d25640a
0000b0  00      
0000b1  00                DCB      0
0000b2  00                DCB      0
0000b3  00                DCB      0
                  |L13.180|
0000b4  32205553          DCB      "2 USB_EP_Tx gnDevState=%d\n",0
0000b8  425f4550
0000bc  5f547820
0000c0  676e4465
0000c4  76537461
0000c8  74653d25
0000cc  640a00  
0000cf  00                DCB      0
                  |L13.208|
                          DCD      0x40005c00
                  |L13.212|
0000d4  33205553          DCB      "3 USB_EP_Tx MREAD_BYTE(M_REG_INCSR1)=0x%02x\n",0
0000d8  425f4550
0000dc  5f547820
0000e0  4d524541
0000e4  445f4259
0000e8  5445284d
0000ec  5f524547
0000f0  5f494e43
0000f4  53523129
0000f8  3d307825
0000fc  3032780a
000100  00      
000101  00                DCB      0
000102  00                DCB      0
000103  00                DCB      0
                  |L13.260|
000104  34205553          DCB      "4 USB_EP_Tx timeout=%d\n",0
000108  425f4550
00010c  5f547820
000110  74696d65
000114  6f75743d
000118  25640a00
                  |L13.284|
00011c  35205553          DCB      "5 USB_EP_Tx timeout=%d\n",0
000120  425f4550
000124  5f547820
000128  74696d65
00012c  6f75743d
000130  25640a00
                  |L13.308|
000134  36205553          DCB      "6 USB_EP_Tx gnDevState=%d\n",0
000138  425f4550
00013c  5f547820
000140  676e4465
000144  76537461
000148  74653d25
00014c  640a00  
00014f  00                DCB      0
                  |L13.336|
000150  37205553          DCB      "7 USB_EP_Tx gnDevState=%d\n",0
000154  425f4550
000158  5f547820
00015c  676e4465
000160  76537461
000164  74653d25
000168  640a00  
00016b  00                DCB      0

                          AREA ||i.USB_Endpoint0||, CODE, READONLY, ALIGN=2

                  USB_Endpoint0 PROC
;;;693    */
;;;694    void USB_Endpoint0(int nCallState)
000000  b570              PUSH     {r4-r6,lr}
;;;695    {
000002  4605              MOV      r5,r0
;;;696    	static M_EP0_STATUS	ep0state;
;;;697    	static COMMAND	cmd;
;;;698    	BYTE	byCSR0;
;;;699    
;;;700    	
;;;701    	SEGGER_RTT_printf(0,"USB_Endpoint0  xxx nCallState =%d\n",nCallState);
000004  462a              MOV      r2,r5
000006  a146              ADR      r1,|L14.288|
000008  2000              MOVS     r0,#0
00000a  f7fffffe          BL       SEGGER_RTT_printf
;;;702    	/* Check for USB reset of endpoint 0 */
;;;703    	if (nCallState == M_EP_RESET)
00000e  2d01              CMP      r5,#1
000010  d10a              BNE      |L14.40|
;;;704    	{
;;;705    		ep0state.nState = M_EP0_IDLE;
000012  494c              LDR      r1,|L14.324|
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       __aeabi_uwrite4
;;;706    		ep0state.byFAddr = 0xFF;
00001a  20ff              MOVS     r0,#0xff
00001c  4949              LDR      r1,|L14.324|
00001e  7408              STRB     r0,[r1,#0x10]
;;;707    		/* Clear current configuration pointer */
;;;708    		gpCurCfg = NULL;
000020  2000              MOVS     r0,#0
000022  4949              LDR      r1,|L14.328|
000024  6008              STR      r0,[r1,#0]  ; gpCurCfg
                  |L14.38|
;;;709    		return;
;;;710    	}
;;;711    
;;;712    	/* Read CSR0 */
;;;713    	MWRITE_BYTE(M_REG_INDEX, 0);							//选择endpoint0
;;;714    	byCSR0 = MREAD_BYTE(M_REG_CSR0);						//读取CSR0，各种通信状态
;;;715    
;;;716    	/* Check for status stage of a request */
;;;717    	/*接收已完成状态*/
;;;718    	if(!(byCSR0 & M_CSR0_OUTPKTRDY)) 
;;;719    	{
;;;720    		/* Complete SET_ADDRESS command */
;;;721    		if(ep0state.byFAddr != 0xFF)
;;;722    		{
;;;723    			MWRITE_BYTE(M_REG_FADDR, ep0state.byFAddr);		//如果地址不为FF，reset，地址设置为byFAddr
;;;724    			if((gnDevState == DEVSTATE_DEFAULT) && ep0state.byFAddr)
;;;725    			{
;;;726    			
;;;727    			SEGGER_RTT_printf(0,"gnDevState = DEVSTATE_ADDRESS;	 xxx 111\n");
;;;728    				gnDevState = DEVSTATE_ADDRESS;				//地址不为0，且设备状态为 DEVSTATE_DEFAULT
;;;729    			}
;;;730    			else if((gnDevState == DEVSTATE_ADDRESS) && !ep0state.byFAddr)
;;;731    			{
;;;732    			
;;;733    			SEGGER_RTT_printf(0,"gnDevState = DEVSTATE_ADDRESS;	 222\n");
;;;734    				gnDevState = DEVSTATE_DEFAULT;				//地址为0，且设备状态为 DEVSTATE_ADDRESS
;;;735    			}
;;;736    		}
;;;737    	}
;;;738    	/* Clear pending commands */
;;;739    	ep0state.byFAddr = 0xFF;	
;;;740    
;;;741    	/* Check for SentStall */
;;;742    	if(byCSR0 & M_CSR0_SENTSTALL)
;;;743    	{
;;;744    		/*清除STALL 位*/
;;;745    		MWRITE_BYTE(M_REG_CSR0, (byCSR0 & ~M_CSR0_SENDSTALL));
;;;746    		ep0state.nState = M_EP0_IDLE;
;;;747    	}
;;;748    
;;;749    	/* Check for SetupEnd */
;;;750    	if(byCSR0 & M_CSR0_SETUPEND)
;;;751    	{
;;;752    		/*清除setupend位*/
;;;753    		MWRITE_BYTE(M_REG_CSR0, (byCSR0 | M_CSR0_SVDSETUPEND));
;;;754    		ep0state.nState = M_EP0_IDLE;
;;;755    	}
;;;756    
;;;757    	/* Call relevant routines for endpoint 0 state */
;;;758    	if(ep0state.nState == M_EP0_IDLE) 
;;;759    	{
;;;760    		/* If no packet has been received, */
;;;761    		/* assume that this was a STATUS phase complete. */
;;;762    		/* Otherwise load new command */
;;;763    		if(byCSR0 & M_CSR0_OUTPKTRDY) 
;;;764    		{
;;;765    			/* Read the 8-byte command from the FIFO */
;;;766    			/* There is no need to check that OutCount is set to 8 */
;;;767    			/* as the MUSBFSFC will reject SETUP packets that are not 8 bytes long. */
;;;768    			FIFORead(0, 8, &cmd);	
;;;769    			SEGGER_RTT_printf(0,"USB_Endpoint0  aaa\n");
;;;770    			//传入cmd地址存放数据到结构体中
;;;771    			USB_Endpoint0_Command(&ep0state, &cmd);			//数据解析
;;;772    		}
;;;773    	}
;;;774    	
;;;775    	if(ep0state.nState == M_EP0_TX)
;;;776    	{
;;;777    	
;;;778    	SEGGER_RTT_printf(0,"USB_Endpoint0_Tx 1111\n");
;;;779    		USB_Endpoint0_Tx(&ep0state);
;;;780    	}
;;;781    	else if(ep0state.nState == M_EP0_RX)
;;;782    	{
;;;783    	
;;;784    	SEGGER_RTT_printf(0,"USB_Endpoint0_Tx 2222\n");
;;;785    		USB_Endpoint0_Rx(&ep0state);
;;;786    	}
;;;787    }
000026  bd70              POP      {r4-r6,pc}
                  |L14.40|
000028  2000              MOVS     r0,#0                 ;713
00002a  4948              LDR      r1,|L14.332|
00002c  7388              STRB     r0,[r1,#0xe]          ;713
00002e  4608              MOV      r0,r1                 ;714
000030  7c44              LDRB     r4,[r0,#0x11]         ;714
000032  07e0              LSLS     r0,r4,#31             ;718
000034  0fc0              LSRS     r0,r0,#31             ;718
000036  2800              CMP      r0,#0                 ;718
000038  d124              BNE      |L14.132|
00003a  4842              LDR      r0,|L14.324|
00003c  7c00              LDRB     r0,[r0,#0x10]         ;721  ; ep0state
00003e  28ff              CMP      r0,#0xff              ;721
000040  d020              BEQ      |L14.132|
000042  4840              LDR      r0,|L14.324|
000044  7c00              LDRB     r0,[r0,#0x10]         ;723  ; ep0state
000046  7008              STRB     r0,[r1,#0]            ;723
000048  4841              LDR      r0,|L14.336|
00004a  6800              LDR      r0,[r0,#0]            ;724  ; gnDevState
00004c  2800              CMP      r0,#0                 ;724
00004e  d10b              BNE      |L14.104|
000050  483c              LDR      r0,|L14.324|
000052  7c00              LDRB     r0,[r0,#0x10]         ;724  ; ep0state
000054  2800              CMP      r0,#0                 ;724
000056  d007              BEQ      |L14.104|
000058  a13e              ADR      r1,|L14.340|
00005a  2000              MOVS     r0,#0                 ;727
00005c  f7fffffe          BL       SEGGER_RTT_printf
000060  2001              MOVS     r0,#1                 ;728
000062  493b              LDR      r1,|L14.336|
000064  6008              STR      r0,[r1,#0]            ;728  ; gnDevState
000066  e00d              B        |L14.132|
                  |L14.104|
000068  4839              LDR      r0,|L14.336|
00006a  6800              LDR      r0,[r0,#0]            ;730  ; gnDevState
00006c  2801              CMP      r0,#1                 ;730
00006e  d109              BNE      |L14.132|
000070  4834              LDR      r0,|L14.324|
000072  7c00              LDRB     r0,[r0,#0x10]         ;730  ; ep0state
000074  2800              CMP      r0,#0                 ;730
000076  d105              BNE      |L14.132|
000078  a141              ADR      r1,|L14.384|
00007a  f7fffffe          BL       SEGGER_RTT_printf
00007e  2000              MOVS     r0,#0                 ;734
000080  4933              LDR      r1,|L14.336|
000082  6008              STR      r0,[r1,#0]            ;734  ; gnDevState
                  |L14.132|
000084  20ff              MOVS     r0,#0xff              ;739
000086  492f              LDR      r1,|L14.324|
000088  7408              STRB     r0,[r1,#0x10]         ;739
00008a  2004              MOVS     r0,#4                 ;742
00008c  4020              ANDS     r0,r0,r4              ;742
00008e  2800              CMP      r0,#0                 ;742
000090  d008              BEQ      |L14.164|
000092  2120              MOVS     r1,#0x20              ;745
000094  4620              MOV      r0,r4                 ;745
000096  4388              BICS     r0,r0,r1              ;745
000098  492c              LDR      r1,|L14.332|
00009a  7448              STRB     r0,[r1,#0x11]         ;745
00009c  4929              LDR      r1,|L14.324|
00009e  2000              MOVS     r0,#0                 ;746
0000a0  f7fffffe          BL       __aeabi_uwrite4
                  |L14.164|
0000a4  2010              MOVS     r0,#0x10              ;750
0000a6  4020              ANDS     r0,r0,r4              ;750
0000a8  2800              CMP      r0,#0                 ;750
0000aa  d007              BEQ      |L14.188|
0000ac  2080              MOVS     r0,#0x80              ;753
0000ae  4320              ORRS     r0,r0,r4              ;753
0000b0  4926              LDR      r1,|L14.332|
0000b2  7448              STRB     r0,[r1,#0x11]         ;753
0000b4  4923              LDR      r1,|L14.324|
0000b6  2000              MOVS     r0,#0                 ;754
0000b8  f7fffffe          BL       __aeabi_uwrite4
                  |L14.188|
0000bc  4821              LDR      r0,|L14.324|
0000be  f7fffffe          BL       __aeabi_uread4
0000c2  2800              CMP      r0,#0                 ;758
0000c4  d110              BNE      |L14.232|
0000c6  07e0              LSLS     r0,r4,#31             ;763
0000c8  0fc0              LSRS     r0,r0,#31             ;763
0000ca  2800              CMP      r0,#0                 ;763
0000cc  d00c              BEQ      |L14.232|
0000ce  4a36              LDR      r2,|L14.424|
0000d0  2108              MOVS     r1,#8                 ;768
0000d2  2000              MOVS     r0,#0                 ;768
0000d4  f7fffffe          BL       FIFORead
0000d8  a134              ADR      r1,|L14.428|
0000da  2000              MOVS     r0,#0                 ;769
0000dc  f7fffffe          BL       SEGGER_RTT_printf
0000e0  4931              LDR      r1,|L14.424|
0000e2  4818              LDR      r0,|L14.324|
0000e4  f7fffffe          BL       USB_Endpoint0_Command
                  |L14.232|
0000e8  4816              LDR      r0,|L14.324|
0000ea  f7fffffe          BL       __aeabi_uread4
0000ee  2802              CMP      r0,#2                 ;775
0000f0  d107              BNE      |L14.258|
0000f2  a133              ADR      r1,|L14.448|
0000f4  2000              MOVS     r0,#0                 ;778
0000f6  f7fffffe          BL       SEGGER_RTT_printf
0000fa  4812              LDR      r0,|L14.324|
0000fc  f7fffffe          BL       USB_Endpoint0_Tx
000100  e00b              B        |L14.282|
                  |L14.258|
000102  4810              LDR      r0,|L14.324|
000104  f7fffffe          BL       __aeabi_uread4
000108  2801              CMP      r0,#1                 ;781
00010a  d106              BNE      |L14.282|
00010c  a132              ADR      r1,|L14.472|
00010e  2000              MOVS     r0,#0                 ;784
000110  f7fffffe          BL       SEGGER_RTT_printf
000114  480b              LDR      r0,|L14.324|
000116  f7fffffe          BL       USB_Endpoint0_Rx
                  |L14.282|
00011a  bf00              NOP      
00011c  e783              B        |L14.38|
;;;788    
                          ENDP

00011e  0000              DCW      0x0000
                  |L14.288|
000120  5553425f          DCB      "USB_Endpoint0  xxx nCallState =%d\n",0
000124  456e6470
000128  6f696e74
00012c  30202078
000130  7878206e
000134  43616c6c
000138  53746174
00013c  65203d25
000140  640a00  
000143  00                DCB      0
                  |L14.324|
                          DCD      ep0state
                  |L14.328|
                          DCD      gpCurCfg
                  |L14.332|
                          DCD      0x40005c00
                  |L14.336|
                          DCD      gnDevState
                  |L14.340|
000154  676e4465          DCB      "gnDevState = DEVSTATE_ADDRESS;\t xxx 111\n",0
000158  76537461
00015c  7465203d
000160  20444556
000164  53544154
000168  455f4144
00016c  44524553
000170  533b0920
000174  78787820
000178  3131310a
00017c  00      
00017d  00                DCB      0
00017e  00                DCB      0
00017f  00                DCB      0
                  |L14.384|
000180  676e4465          DCB      "gnDevState = DEVSTATE_ADDRESS;\t 222\n",0
000184  76537461
000188  7465203d
00018c  20444556
000190  53544154
000194  455f4144
000198  44524553
00019c  533b0920
0001a0  3232320a
0001a4  00      
0001a5  00                DCB      0
0001a6  00                DCB      0
0001a7  00                DCB      0
                  |L14.424|
                          DCD      ||cmd||
                  |L14.428|
0001ac  5553425f          DCB      "USB_Endpoint0  aaa\n",0
0001b0  456e6470
0001b4  6f696e74
0001b8  30202061
0001bc  61610a00
                  |L14.448|
0001c0  5553425f          DCB      "USB_Endpoint0_Tx 1111\n",0
0001c4  456e6470
0001c8  6f696e74
0001cc  305f5478
0001d0  20313131
0001d4  310a00  
0001d7  00                DCB      0
                  |L14.472|
0001d8  5553425f          DCB      "USB_Endpoint0_Tx 2222\n",0
0001dc  456e6470
0001e0  6f696e74
0001e4  305f5478
0001e8  20323232
0001ec  320a00  
0001ef  00                DCB      0

                          AREA ||i.USB_Endpoint0_Command||, CODE, READONLY, ALIGN=2

                  USB_Endpoint0_Command PROC
;;;972    */
;;;973    static void USB_Endpoint0_Command(PM_EP0_STATUS pep0state, PCOMMAND pcmd)
000000  b570              PUSH     {r4-r6,lr}
;;;974    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;975    
;;;976    
;;;977    	/* Check request type */
;;;978    	switch(pcmd->bmRequestType & M_CMD_TYPEMASK)	//判断数据中为何种命令
000006  7820              LDRB     r0,[r4,#0]
000008  2160              MOVS     r1,#0x60
00000a  4008              ANDS     r0,r0,r1
00000c  2800              CMP      r0,#0
00000e  d004              BEQ      |L15.26|
000010  2820              CMP      r0,#0x20
000012  d007              BEQ      |L15.36|
000014  2840              CMP      r0,#0x40
000016  d10a              BNE      |L15.46|
000018  e00a              B        |L15.48|
                  |L15.26|
;;;979    	{
;;;980    		/***主机到设备，标准请求命令，接收者为设备***/
;;;981    		case M_CMD_STDREQ:
;;;982    			USB_StdDev_Req(pep0state, pcmd);
00001a  4621              MOV      r1,r4
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       USB_StdDev_Req
;;;983    			break;
000022  e009              B        |L15.56|
                  |L15.36|
;;;984    
;;;985    		/***主机到设备，类请求命令，接收者为设备***/
;;;986    		case M_CMD_CLASSREQ:
;;;987    			/* Add call to external routine for handling class requests */
;;;988    			USB_HID_Class_Req(pep0state,pcmd);
000024  4621              MOV      r1,r4
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       USB_HID_Class_Req
;;;989    			break;
00002c  e004              B        |L15.56|
                  |L15.46|
;;;990    		/***主机到设备，用户定义的命令，接收者为设备***/
;;;991    		case M_CMD_VENDREQ:
00002e  bf00              NOP      
                  |L15.48|
;;;992    		/* Add call to external routine for handling vendor requests */
;;;993    			
;;;994    		/***保留***/
;;;995    		default:
;;;996    			/* Stall the command if a reserved request is received */
;;;997    			MWRITE_BYTE(M_REG_CSR0, M_CSR0_SVDOUTPKTRDY | M_CSR0_SENDSTALL);
000030  2060              MOVS     r0,#0x60
000032  4902              LDR      r1,|L15.60|
000034  7448              STRB     r0,[r1,#0x11]
;;;998    		break;
000036  bf00              NOP      
                  |L15.56|
000038  bf00              NOP                            ;983
;;;999      }
;;;1000   
;;;1001   	return;
;;;1002   }
00003a  bd70              POP      {r4-r6,pc}
;;;1003   
                          ENDP

                  |L15.60|
                          DCD      0x40005c00

                          AREA ||i.USB_Endpoint0_Rx||, CODE, READONLY, ALIGN=2

                  USB_Endpoint0_Rx PROC
;;;1698   */
;;;1699   static void USB_Endpoint0_Rx(PM_EP0_STATUS pep0state)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1700   {
000002  4604              MOV      r4,r0
;;;1701   	BYTE    byOutCSR;
;;;1702   	
;;;1703   	/* Set index register */
;;;1704   	MWRITE_BYTE(M_REG_INDEX, 0);
000004  2000              MOVS     r0,#0
000006  4910              LDR      r1,|L16.72|
000008  7388              STRB     r0,[r1,#0xe]
;;;1705   	/* Read OUT CSR register */
;;;1706   	byOutCSR = MREAD_BYTE(M_REG_CSR0);
00000a  4608              MOV      r0,r1
00000c  7c45              LDRB     r5,[r0,#0x11]
;;;1707   
;;;1708   	/* Get packet, */
;;;1709   	/* may need to unload more than one packet if double buffering enabled */
;;;1710   	/*端点FIFO 中有数据*/
;;;1711   	while(byOutCSR & M_CSR0_OUTPKTRDY)
00000e  e016              B        |L16.62|
                  |L16.16|
;;;1712   	{
;;;1713   		pep0state->nState = M_EP0_IDLE;
000010  4621              MOV      r1,r4
000012  2000              MOVS     r0,#0
000014  f7fffffe          BL       __aeabi_uwrite4
;;;1714   
;;;1715   		/* Unload FIFO */
;;;1716   		//FIFORead(0, 1, pep0state->pData);//NUM CAP SCR指示灯信息
;;;1717   		FIFORead(0, pep0state->nBytesLeft, pep0state->pData);//NUM CAP SCR指示灯信息
000018  4620              MOV      r0,r4
00001a  3008              ADDS     r0,r0,#8
00001c  f7fffffe          BL       __aeabi_uread4
000020  4606              MOV      r6,r0
000022  1d20              ADDS     r0,r4,#4
000024  f7fffffe          BL       __aeabi_uread4
000028  4607              MOV      r7,r0
00002a  4632              MOV      r2,r6
00002c  4639              MOV      r1,r7
00002e  2000              MOVS     r0,#0
000030  f7fffffe          BL       FIFORead
;;;1718   		
;;;1719   		/*Cear flag*/
;;;1720   		MWRITE_BYTE(M_REG_CSR0,M_CSR0_SVDOUTPKTRDY);
000034  2040              MOVS     r0,#0x40
000036  4904              LDR      r1,|L16.72|
000038  7448              STRB     r0,[r1,#0x11]
;;;1721   		/* Check for another packet */
;;;1722   		byOutCSR = MREAD_BYTE(M_REG_CSR0);
00003a  4608              MOV      r0,r1
00003c  7c45              LDRB     r5,[r0,#0x11]
                  |L16.62|
00003e  07e8              LSLS     r0,r5,#31             ;1711
000040  0fc0              LSRS     r0,r0,#31             ;1711
000042  2800              CMP      r0,#0                 ;1711
000044  d1e4              BNE      |L16.16|
;;;1723   	}
;;;1724   		
;;;1725   }
000046  bdf8              POP      {r3-r7,pc}
;;;1726   
                          ENDP

                  |L16.72|
                          DCD      0x40005c00

                          AREA ||i.USB_Endpoint0_Tx||, CODE, READONLY, ALIGN=2

                  USB_Endpoint0_Tx PROC
;;;1656   */
;;;1657   static void USB_Endpoint0_Tx(PM_EP0_STATUS pep0state)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1658   {
000002  4604              MOV      r4,r0
;;;1659   	int	nBytes;
;;;1660   	BYTE	by;
;;;1661   
;;;1662   	/* Determine number of bytes to send */
;;;1663   	if(pep0state->nBytesLeft <= M_EP0_MAXP)
000004  1d20              ADDS     r0,r4,#4
000006  f7fffffe          BL       __aeabi_uread4
00000a  2840              CMP      r0,#0x40
00000c  dc08              BGT      |L17.32|
;;;1664   	{
;;;1665   		nBytes = pep0state->nBytesLeft;
00000e  1d20              ADDS     r0,r4,#4
000010  f7fffffe          BL       __aeabi_uread4
000014  4605              MOV      r5,r0
;;;1666   		pep0state->nBytesLeft = 0;
000016  1d21              ADDS     r1,r4,#4
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       __aeabi_uwrite4
00001e  e008              B        |L17.50|
                  |L17.32|
;;;1667   	}
;;;1668   	else
;;;1669   	{
;;;1670   		nBytes = M_EP0_MAXP;
000020  2540              MOVS     r5,#0x40
;;;1671   		pep0state->nBytesLeft -= M_EP0_MAXP;
000022  1d20              ADDS     r0,r4,#4
000024  f7fffffe          BL       __aeabi_uread4
000028  1b47              SUBS     r7,r0,r5
00002a  1d21              ADDS     r1,r4,#4
00002c  4638              MOV      r0,r7
00002e  f7fffffe          BL       __aeabi_uwrite4
                  |L17.50|
;;;1672   	}
;;;1673   
;;;1674   	FIFOWrite(0, nBytes, pep0state->pData);
000032  4620              MOV      r0,r4
000034  3008              ADDS     r0,r0,#8
000036  f7fffffe          BL       __aeabi_uread4
00003a  4607              MOV      r7,r0
00003c  463a              MOV      r2,r7
00003e  4629              MOV      r1,r5
000040  2000              MOVS     r0,#0
000042  f7fffffe          BL       FIFOWrite
;;;1675   	pep0state->pData = (BYTE *)pep0state->pData + nBytes;
000046  4620              MOV      r0,r4
000048  3008              ADDS     r0,r0,#8
00004a  f7fffffe          BL       __aeabi_uread4
00004e  1947              ADDS     r7,r0,r5
000050  4621              MOV      r1,r4
000052  3108              ADDS     r1,r1,#8
000054  4638              MOV      r0,r7
000056  f7fffffe          BL       __aeabi_uwrite4
;;;1676   	if(nBytes < M_EP0_MAXP)
00005a  2d40              CMP      r5,#0x40
00005c  da05              BGE      |L17.106|
;;;1677   	{
;;;1678   		/***数据已经写入 FIFO 中,将要发送的时最后一包数据***/
;;;1679   		by = M_CSR0_INPKTRDY | M_CSR0_DATAEND;
00005e  260a              MOVS     r6,#0xa
;;;1680   		pep0state->nState = M_EP0_IDLE;
000060  4621              MOV      r1,r4
000062  2000              MOVS     r0,#0
000064  f7fffffe          BL       __aeabi_uwrite4
000068  e000              B        |L17.108|
                  |L17.106|
;;;1681   	}
;;;1682   	else
;;;1683   	{
;;;1684   		/***数据已经写入 FIFO 中***/
;;;1685   		by = M_CSR0_INPKTRDY;
00006a  2602              MOVS     r6,#2
                  |L17.108|
;;;1686   	}
;;;1687   	
;;;1688   	MWRITE_BYTE(M_REG_CSR0, by);
00006c  4801              LDR      r0,|L17.116|
00006e  7446              STRB     r6,[r0,#0x11]
;;;1689   }
000070  bdf8              POP      {r3-r7,pc}
;;;1690   
                          ENDP

000072  0000              DCW      0x0000
                  |L17.116|
                          DCD      0x40005c00

                          AREA ||i.USB_GetITStatus||, CODE, READONLY, ALIGN=2

                  USB_GetITStatus PROC
;;;648    */
;;;649    ITStatus USB_GetITStatus(uint32_t USB_IT)
000000  b570              PUSH     {r4-r6,lr}
;;;650    {
000002  4601              MOV      r1,r0
;;;651        __IO uint8_t *tmp = (__IO uint8_t *)USB_BASE;
000004  4a16              LDR      r2,|L18.96|
;;;652        uint8_t tmp_flag = 0;
000006  2300              MOVS     r3,#0
;;;653    		uint32_t IT_FLAG = 0;
000008  2400              MOVS     r4,#0
;;;654        ITStatus bitstatus = RESET;
00000a  2000              MOVS     r0,#0
;;;655    
;;;656        assert_param(IS_USB_CONFIG_IT(USB_IT));
;;;657    
;;;658        if(USB_IT & 0x00000100)
00000c  1595              ASRS     r5,r2,#22
00000e  400d              ANDS     r5,r5,r1
000010  2d00              CMP      r5,#0
000012  d005              BEQ      |L18.32|
;;;659        {
;;;660          tmp = &USB->INTRIN;
000014  1c92              ADDS     r2,r2,#2
;;;661          IT_FLAG = USB_IT & 0xfffffeff;
000016  1596              ASRS     r6,r2,#22
000018  460d              MOV      r5,r1
00001a  43b5              BICS     r5,r5,r6
00001c  462c              MOV      r4,r5
00001e  e016              B        |L18.78|
                  |L18.32|
;;;662        }
;;;663        else if(USB_IT & 0x00000200)
000020  2501              MOVS     r5,#1
000022  026d              LSLS     r5,r5,#9
000024  400d              ANDS     r5,r5,r1
000026  2d00              CMP      r5,#0
000028  d006              BEQ      |L18.56|
;;;664        {
;;;665          tmp = &USB->INTROUT;
00002a  4a0d              LDR      r2,|L18.96|
00002c  1d12              ADDS     r2,r2,#4
;;;666          IT_FLAG = USB_IT & 0xfffffdff;
00002e  1556              ASRS     r6,r2,#21
000030  460d              MOV      r5,r1
000032  43b5              BICS     r5,r5,r6
000034  462c              MOV      r4,r5
000036  e00a              B        |L18.78|
                  |L18.56|
;;;667        }
;;;668        else if(USB_IT & 0x00000400)
000038  2501              MOVS     r5,#1
00003a  02ad              LSLS     r5,r5,#10
00003c  400d              ANDS     r5,r5,r1
00003e  2d00              CMP      r5,#0
000040  d005              BEQ      |L18.78|
;;;669        {
;;;670          tmp = &USB->INTRUSB;
000042  4a07              LDR      r2,|L18.96|
000044  1d92              ADDS     r2,r2,#6
;;;671          IT_FLAG = USB_IT & 0xfffffbff;
000046  1516              ASRS     r6,r2,#20
000048  460d              MOV      r5,r1
00004a  43b5              BICS     r5,r5,r6
00004c  462c              MOV      r4,r5
                  |L18.78|
;;;672        }
;;;673    
;;;674        tmp_flag = *(__IO uint8_t *)tmp;
00004e  7813              LDRB     r3,[r2,#0]
;;;675        if( (tmp_flag & ((uint8_t)IT_FLAG)) != ((uint8_t)RESET))
000050  461d              MOV      r5,r3
000052  4025              ANDS     r5,r5,r4
000054  2d00              CMP      r5,#0
000056  d001              BEQ      |L18.92|
;;;676        {
;;;677          bitstatus = SET;
000058  2001              MOVS     r0,#1
00005a  e000              B        |L18.94|
                  |L18.92|
;;;678        }
;;;679        else
;;;680        {
;;;681          bitstatus = RESET;
00005c  2000              MOVS     r0,#0
                  |L18.94|
;;;682        }
;;;683    
;;;684        return bitstatus;
;;;685    }
00005e  bd70              POP      {r4-r6,pc}
;;;686    
                          ENDP

                  |L18.96|
                          DCD      0x40005c00

                          AREA ||i.USB_HID_Class_Req||, CODE, READONLY, ALIGN=2

                  USB_HID_Class_Req PROC
;;;923    */
;;;924    void USB_HID_Class_Req(PM_EP0_STATUS pep0state,PCOMMAND pcmd)
000000  b570              PUSH     {r4-r6,lr}
;;;925    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;926    	switch(pcmd->bRequest)
000006  7860              LDRB     r0,[r4,#1]
000008  0003              MOVS     r3,r0
00000a  f7fffffe          BL       __ARM_common_switch8
00000e  0c25              DCB      0x0c,0x25
000010  070c1125          DCB      0x07,0x0c,0x11,0x25
000014  25252525          DCB      0x25,0x25,0x25,0x25
000018  161b2025          DCB      0x16,0x1b,0x20,0x25
;;;927    	{
;;;928    		case	HID_REQUEST_GET_REPORT:
;;;929    		{
;;;930    			HID_GetReportEvent(pep0state,pcmd);
00001c  4621              MOV      r1,r4
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       HID_GetReportEvent
                  |L19.36|
;;;931    			return;
;;;932    		}
;;;933    		case	HID_REQUEST_GET_IDLE:
;;;934    		{
;;;935    			HID_GetIdleEvent(pep0state,pcmd);
;;;936    			return;
;;;937    		}
;;;938    		case	HID_REQUEST_GET_PROTOCOL:
;;;939    		{
;;;940    			HID_GetProtocolEvent(pep0state,pcmd);
;;;941    			return;
;;;942    		}
;;;943    		case	HID_REQUEST_SET_REPORT:
;;;944    		{
;;;945    			HID_SetReportEvent(pep0state,pcmd);
;;;946    			return;
;;;947    		}
;;;948    		case	HID_REQUEST_SET_IDLE:
;;;949    		{
;;;950    			HID_SetIdleEvent(pep0state,pcmd);
;;;951    			return;
;;;952    		}
;;;953    		case	HID_REQUEST_SET_PROTOCOL:
;;;954    		{
;;;955    			HID_SetProtocolEvent(pep0state,pcmd);
;;;956    			return;
;;;957    		}
;;;958    		default:
;;;959    		{
;;;960    			break;
;;;961    		}
;;;962    	}
;;;963    	MWRITE_BYTE(M_REG_CSR0, M_CSR0_SVDOUTPKTRDY | M_CSR0_SENDSTALL);
;;;964    }
000024  bd70              POP      {r4-r6,pc}
000026  4621              MOV      r1,r4                 ;935
000028  4628              MOV      r0,r5                 ;935
00002a  f7fffffe          BL       HID_GetIdleEvent
00002e  e7f9              B        |L19.36|
000030  4621              MOV      r1,r4                 ;940
000032  4628              MOV      r0,r5                 ;940
000034  f7fffffe          BL       HID_GetProtocolEvent
000038  e7f4              B        |L19.36|
00003a  4621              MOV      r1,r4                 ;945
00003c  4628              MOV      r0,r5                 ;945
00003e  f7fffffe          BL       HID_SetReportEvent
000042  e7ef              B        |L19.36|
000044  4621              MOV      r1,r4                 ;950
000046  4628              MOV      r0,r5                 ;950
000048  f7fffffe          BL       HID_SetIdleEvent
00004c  e7ea              B        |L19.36|
00004e  4621              MOV      r1,r4                 ;955
000050  4628              MOV      r0,r5                 ;955
000052  f7fffffe          BL       HID_SetProtocolEvent
000056  e7e5              B        |L19.36|
000058  bf00              NOP                            ;960
00005a  bf00              NOP                            ;960
00005c  2060              MOVS     r0,#0x60              ;963
00005e  4902              LDR      r1,|L19.104|
000060  7448              STRB     r0,[r1,#0x11]         ;963
000062  bf00              NOP      
000064  e7de              B        |L19.36|
;;;965    /******************************************************************************
                          ENDP

000066  0000              DCW      0x0000
                  |L19.104|
                          DCD      0x40005c00

                          AREA ||i.USB_IRQHandler||, CODE, READONLY, ALIGN=2

                  USB_IRQHandler PROC
;;;123    */
;;;124    void USB_IRQHandler(void)
000000  b5fe              PUSH     {r1-r7,lr}
;;;125    {
;;;126    	uint8_t usb_intrin = 0,usb_intrusb = 0,usb_introut = 0;
000002  2000              MOVS     r0,#0
000004  9001              STR      r0,[sp,#4]
000006  2600              MOVS     r6,#0
000008  2400              MOVS     r4,#0
;;;127    			ListUsbData  *pUsbData;
;;;128    			uint16 recv_data_len;
;;;129    	usb_intrin  = USB->INTRIN;									//端点中断标志
00000a  485d              LDR      r0,|L20.384|
00000c  7880              LDRB     r0,[r0,#2]
00000e  9001              STR      r0,[sp,#4]
;;;130    	usb_intrusb = USB->INTRUSB;									//USB中断标志RESET、RESUME、SUSPEND、SOF
000010  485b              LDR      r0,|L20.384|
000012  7986              LDRB     r6,[r0,#6]
;;;131    	usb_introut = USB->INTROUT;
000014  7904              LDRB     r4,[r0,#4]
;;;132    	
;;;133    	//SEGGER_RTT_printf(0,"USB_IRQHandler ###usb_intrin =0x%02x usb_intrusb =0x%02x ###usb_introut =0x%02x\n",usb_intrin,usb_intrusb,usb_introut);
;;;134    	if(usb_introut!=0 || usb_intrin!=0)
000016  2c00              CMP      r4,#0
000018  d102              BNE      |L20.32|
00001a  9801              LDR      r0,[sp,#4]
00001c  2800              CMP      r0,#0
00001e  d006              BEQ      |L20.46|
                  |L20.32|
;;;135    		{
;;;136    		SEGGER_RTT_printf(0,"USB_IRQHandler ###usb_intrin =0x%02x usb_intrusb =0x%02x ###usb_introut =0x%02x\n",usb_intrin,usb_intrusb,usb_introut);
000020  4633              MOV      r3,r6
000022  9400              STR      r4,[sp,#0]
000024  4957              LDR      r1,|L20.388|
000026  2000              MOVS     r0,#0
000028  9a01              LDR      r2,[sp,#4]
00002a  f7fffffe          BL       SEGGER_RTT_printf
                  |L20.46|
;;;137    		}
;;;138    	if(usb_introut!=0)
00002e  2c00              CMP      r4,#0
000030  d004              BEQ      |L20.60|
;;;139    		{
;;;140    		   
;;;141    		   SEGGER_RTT_printf(0,"USB_IRQHandler ############################################# usb_introut =0x%02x \n",usb_introut);
000032  4622              MOV      r2,r4
000034  4954              LDR      r1,|L20.392|
000036  2000              MOVS     r0,#0
000038  f7fffffe          BL       SEGGER_RTT_printf
                  |L20.60|
;;;142    		}
;;;143    	/*Check for resume from suspend mode, Add call to resume routine here */
;;;144    	if((usb_intrusb & 0x02) != RESET)							//RESUME
00003c  2002              MOVS     r0,#2
00003e  4030              ANDS     r0,r0,r6
000040  2800              CMP      r0,#0
000042  d002              BEQ      |L20.74|
;;;145    	{
;;;146    		usb_state = USB_RESUME_FLAG;
000044  2002              MOVS     r0,#2
000046  4951              LDR      r1,|L20.396|
000048  7008              STRB     r0,[r1,#0]
                  |L20.74|
;;;147    	}
;;;148    
;;;149    	if(usb_intrusb & USB_IT_USB_SOF_FLAG)						//SOF
00004a  2081              MOVS     r0,#0x81
00004c  00c0              LSLS     r0,r0,#3
00004e  4030              ANDS     r0,r0,r6
000050  2800              CMP      r0,#0
000052  d00c              BEQ      |L20.110|
;;;150    	{
;;;151    		USB->INTRUSB &= ~0x08;									//sof
000054  484a              LDR      r0,|L20.384|
000056  7980              LDRB     r0,[r0,#6]
000058  2108              MOVS     r1,#8
00005a  4388              BICS     r0,r0,r1
00005c  4948              LDR      r1,|L20.384|
00005e  7188              STRB     r0,[r1,#6]
;;;152    		f_sof_flag = 1;
000060  484b              LDR      r0,|L20.400|
000062  7800              LDRB     r0,[r0,#0]  ; flag1
000064  2110              MOVS     r1,#0x10
000066  4388              BICS     r0,r0,r1
000068  3010              ADDS     r0,r0,#0x10
00006a  4949              LDR      r1,|L20.400|
00006c  7008              STRB     r0,[r1,#0]
                  |L20.110|
;;;153    	}
;;;154    	/* Check for system interrupts */
;;;155    	if((usb_intrusb &USB_IT_USB_RESET_FLAG) != RESET)
00006e  4849              LDR      r0,|L20.404|
000070  4030              ANDS     r0,r0,r6
000072  2800              CMP      r0,#0
000074  d001              BEQ      |L20.122|
;;;156    	{
;;;157    		USB_Reset();
000076  f7fffffe          BL       USB_Reset
                  |L20.122|
;;;158    	}
;;;159    
;;;160    	/* Check for endpoint 0 interrupt */
;;;161    	if((usb_intrin & USB_IT_IN_EP0_FLAG) != RESET)
00007a  21ff              MOVS     r1,#0xff
00007c  3102              ADDS     r1,#2
00007e  9801              LDR      r0,[sp,#4]
000080  4008              ANDS     r0,r0,r1
000082  2800              CMP      r0,#0
000084  d006              BEQ      |L20.148|
;;;162    	{
;;;163    	SEGGER_RTT_printf(0,"USB_Endpoint0(M_EP_NORMAL); 111");
000086  a144              ADR      r1,|L20.408|
000088  2000              MOVS     r0,#0
00008a  f7fffffe          BL       SEGGER_RTT_printf
;;;164    		USB_Endpoint0(M_EP_NORMAL);
00008e  2000              MOVS     r0,#0
000090  f7fffffe          BL       USB_Endpoint0
                  |L20.148|
;;;165    	}
;;;166    
;;;167    
;;;168    	
;;;169    		
;;;170    
;;;171    		/* Check for endpoint 5 interrupt */
;;;172    	if((usb_introut & USB_IT_OUT_EP1_FLAG) != RESET) //huanghanjing
000094  4848              LDR      r0,|L20.440|
000096  4020              ANDS     r0,r0,r4
000098  2800              CMP      r0,#0
00009a  d029              BEQ      |L20.240|
;;;173    	{
;;;174    		//USB_EP_Rx(ep_hid_vendor_rx, Vendor_data_Buffer, M_EP_MAXP);
;;;175    				SEGGER_RTT_printf(0,"US B_IT_OUT_EP1_FLAG ##   # function=%s line=%d\n",__FUNCTION__,__LINE__);
00009c  23af              MOVS     r3,#0xaf
00009e  4a47              LDR      r2,|L20.444|
0000a0  a147              ADR      r1,|L20.448|
0000a2  2000              MOVS     r0,#0
0000a4  f7fffffe          BL       SEGGER_RTT_printf
;;;176    			recv_data_len = 	USB_EP_Rx(ep_iap2_vendor_rx, Vendor_data_Buffer, M_EP_MAXP);
0000a8  2240              MOVS     r2,#0x40
0000aa  4952              LDR      r1,|L20.500|
0000ac  2000              MOVS     r0,#0
0000ae  f7fffffe          BL       USB_EP_Rx
0000b2  b287              UXTH     r7,r0
;;;177    		pUsbData = (ListUsbData *)malloc(sizeof(ListUsbData));
0000b4  200f              MOVS     r0,#0xf
0000b6  f7fffffe          BL       malloc
0000ba  4605              MOV      r5,r0
;;;178    		pUsbData->pdata = malloc(recv_data_len);
0000bc  4638              MOV      r0,r7
0000be  f7fffffe          BL       malloc
0000c2  4629              MOV      r1,r5
0000c4  310a              ADDS     r1,r1,#0xa
0000c6  9000              STR      r0,[sp,#0]
0000c8  f7fffffe          BL       __aeabi_uwrite4
;;;179    		pUsbData->m_isUsed = 0;
0000cc  2000              MOVS     r0,#0
0000ce  73a8              STRB     r0,[r5,#0xe]
;;;180    		pUsbData->m_pNext = NULL;
0000d0  4629              MOV      r1,r5
0000d2  f7fffffe          BL       __aeabi_uwrite4
;;;181    		pUsbData->m_pPre = NULL;
0000d6  1d29              ADDS     r1,r5,#4
0000d8  2000              MOVS     r0,#0
0000da  f7fffffe          BL       __aeabi_uwrite4
;;;182    		pUsbData->data_size = recv_data_len;
0000de  b238              SXTH     r0,r7
0000e0  7228              STRB     r0,[r5,#8]
0000e2  0a00              LSRS     r0,r0,#8
0000e4  7268              STRB     r0,[r5,#9]
;;;183    		
;;;184    
;;;185    			ListUsbData_AddTail(g_usbdata_list,pUsbData);
0000e6  4629              MOV      r1,r5
0000e8  4843              LDR      r0,|L20.504|
0000ea  6800              LDR      r0,[r0,#0]  ; g_usbdata_list
0000ec  f7fffffe          BL       ListUsbData_AddTail
                  |L20.240|
;;;186    		#ifdef _debug_
;;;187    		//Vendor_data_Buffer[0]++;
;;;188    		//USB_Transmit_VendorData((uint8_t*)&send, M_EP_MAXP);
;;;189    		#endif
;;;190    	}
;;;191    	
;;;192    	if((usb_introut & USB_IT_OUT_EP2_FLAG) != RESET) //huanghanjing
0000f0  2081              MOVS     r0,#0x81
0000f2  0080              LSLS     r0,r0,#2
0000f4  4020              ANDS     r0,r0,r4
0000f6  2800              CMP      r0,#0
0000f8  d012              BEQ      |L20.288|
;;;193    	{
;;;194    	
;;;195    	SEGGER_RTT_printf(0,"USB_IT_OUT_EP2_FLAG ### function=%s line=%d\n",__FUNCTION__,__LINE__);
0000fa  23c3              MOVS     r3,#0xc3
0000fc  4a2f              LDR      r2,|L20.444|
0000fe  a13f              ADR      r1,|L20.508|
000100  2000              MOVS     r0,#0
000102  f7fffffe          BL       SEGGER_RTT_printf
;;;196    	recv_data_len = 	USB_EP_Rx(2, Vendor_data_Buffer, M_EP_MAXP);
000106  2240              MOVS     r2,#0x40
000108  493a              LDR      r1,|L20.500|
00010a  2002              MOVS     r0,#2
00010c  f7fffffe          BL       USB_EP_Rx
000110  b287              UXTH     r7,r0
;;;197    	SEGGER_RTT_printf(0,"USB_IT_OUT_EP2_FLAG ### function=%s line=%d recv_data_len=%d\n",__FUNCTION__,__LINE__,recv_data_len);
000112  23c5              MOVS     r3,#0xc5
000114  4a29              LDR      r2,|L20.444|
000116  a145              ADR      r1,|L20.556|
000118  2000              MOVS     r0,#0
00011a  9700              STR      r7,[sp,#0]
00011c  f7fffffe          BL       SEGGER_RTT_printf
                  |L20.288|
;;;198    
;;;199    		#ifdef _debug_
;;;200    		//Vendor_data_Buffer[0]++;
;;;201    		//USB_Transmit_VendorData((uint8_t*)&send, M_EP_MAXP);
;;;202    		#endif
;;;203    	}
;;;204    	
;;;205    
;;;206    	
;;;207    	/* Check for endpoint 5 interrupt */
;;;208    	if((usb_introut & USB_IT_OUT_EP5_FLAG) != RESET)
000120  2011              MOVS     r0,#0x11
000122  0140              LSLS     r0,r0,#5
000124  4020              ANDS     r0,r0,r4
000126  2800              CMP      r0,#0
000128  d00a              BEQ      |L20.320|
;;;209    	{
;;;210    	
;;;211    	SEGGER_RTT_printf(0,"USB_IT_OUT_EP2_FLAG ### function=%s line=%d\n",__FUNCTION__,__LINE__);
00012a  23d3              MOVS     r3,#0xd3
00012c  4a23              LDR      r2,|L20.444|
00012e  a133              ADR      r1,|L20.508|
000130  2000              MOVS     r0,#0
000132  f7fffffe          BL       SEGGER_RTT_printf
;;;212    		USB_EP_Rx(ep_hid_vendor_rx, Vendor_data_Buffer, M_EP_MAXP);
000136  2240              MOVS     r2,#0x40
000138  492e              LDR      r1,|L20.500|
00013a  2005              MOVS     r0,#5
00013c  f7fffffe          BL       USB_EP_Rx
                  |L20.320|
;;;213    		
;;;214    		#ifdef _debug_
;;;215    		//Vendor_data_Buffer[0]++;
;;;216    		//USB_Transmit_VendorData((uint8_t*)&send, M_EP_MAXP);
;;;217    		#endif
;;;218    	}
;;;219    	
;;;220    	/* Check for endpoint 7 interrupt */
;;;221    	if((usb_introut & USB_IT_OUT_EP7_FLAG) != RESET)
000140  2005              MOVS     r0,#5
000142  01c0              LSLS     r0,r0,#7
000144  4020              ANDS     r0,r0,r4
000146  2800              CMP      r0,#0
000148  d00d              BEQ      |L20.358|
;;;222    	{	
;;;223    		USB_EP_Rx(7, Vendor_data_Buffer, M_EP_MAXP);
00014a  2240              MOVS     r2,#0x40
00014c  4929              LDR      r1,|L20.500|
00014e  2007              MOVS     r0,#7
000150  f7fffffe          BL       USB_EP_Rx
;;;224    		
;;;225    		#ifdef _debug_
;;;226    		Vendor_data_Buffer[0]++;
000154  4827              LDR      r0,|L20.500|
000156  7800              LDRB     r0,[r0,#0]  ; Vendor_data_Buffer
000158  1c40              ADDS     r0,r0,#1
00015a  4926              LDR      r1,|L20.500|
00015c  7008              STRB     r0,[r1,#0]
;;;227    		USB_EP_Tx(6, Vendor_data_Buffer, M_EP_MAXP);
00015e  2240              MOVS     r2,#0x40
000160  2006              MOVS     r0,#6
000162  f7fffffe          BL       USB_EP_Tx
                  |L20.358|
;;;228    		#endif
;;;229    	}
;;;230    
;;;231    	/* Check for suspend mode */
;;;232    	/* Add call to suspend routine here*/
;;;233    	if((usb_intrusb & 0x01) != RESET)
000166  07f0              LSLS     r0,r6,#31
000168  0fc0              LSRS     r0,r0,#31
00016a  2800              CMP      r0,#0
00016c  d006              BEQ      |L20.380|
;;;234    	{
;;;235    		if(gnDevState > DEVSTATE_ADDRESS)
00016e  483f              LDR      r0,|L20.620|
000170  6800              LDR      r0,[r0,#0]  ; gnDevState
000172  2801              CMP      r0,#1
000174  d902              BLS      |L20.380|
;;;236    		{
;;;237    			usb_state = USB_SUSPEND_FLAG;						//usb suspend
000176  2001              MOVS     r0,#1
000178  4904              LDR      r1,|L20.396|
00017a  7008              STRB     r0,[r1,#0]
                  |L20.380|
;;;238    		}
;;;239    	}
;;;240    }
00017c  bdfe              POP      {r1-r7,pc}
;;;241    /******************************************************************************
                          ENDP

00017e  0000              DCW      0x0000
                  |L20.384|
                          DCD      0x40005c00
                  |L20.388|
                          DCD      ||.conststring||
                  |L20.392|
                          DCD      ||.conststring||+0x54
                  |L20.396|
                          DCD      usb_state
                  |L20.400|
                          DCD      flag1
                  |L20.404|
                          DCD      0x00000404
                  |L20.408|
000198  5553425f          DCB      "USB_Endpoint0(M_EP_NORMAL); 111",0
00019c  456e6470
0001a0  6f696e74
0001a4  30284d5f
0001a8  45505f4e
0001ac  4f524d41
0001b0  4c293b20
0001b4  31313100
                  |L20.440|
                          DCD      0x00000202
                  |L20.444|
                          DCD      __FUNCTION__
                  |L20.448|
0001c0  55532042          DCB      "US B_IT_OUT_EP1_FLAG ##   # function=%s line=%d\n",0
0001c4  5f49545f
0001c8  4f55545f
0001cc  4550315f
0001d0  464c4147
0001d4  20232320
0001d8  20202320
0001dc  66756e63
0001e0  74696f6e
0001e4  3d257320
0001e8  6c696e65
0001ec  3d25640a
0001f0  00      
0001f1  00                DCB      0
0001f2  00                DCB      0
0001f3  00                DCB      0
                  |L20.500|
                          DCD      Vendor_data_Buffer
                  |L20.504|
                          DCD      g_usbdata_list
                  |L20.508|
0001fc  5553425f          DCB      "USB_IT_OUT_EP2_FLAG ### function=%s line=%d\n",0
000200  49545f4f
000204  55545f45
000208  50325f46
00020c  4c414720
000210  23232320
000214  66756e63
000218  74696f6e
00021c  3d257320
000220  6c696e65
000224  3d25640a
000228  00      
000229  00                DCB      0
00022a  00                DCB      0
00022b  00                DCB      0
                  |L20.556|
00022c  5553425f          DCB      "USB_IT_OUT_EP2_FLAG ### function=%s line=%d recv_data_l"
000230  49545f4f
000234  55545f45
000238  50325f46
00023c  4c414720
000240  23232320
000244  66756e63
000248  74696f6e
00024c  3d257320
000250  6c696e65
000254  3d256420
000258  72656376
00025c  5f646174
000260  615f6c  
000263  656e3d25          DCB      "en=%d\n",0
000267  640a00  
00026a  00                DCB      0
00026b  00                DCB      0
                  |L20.620|
                          DCD      gnDevState

                          AREA ||i.USB_ITConfig||, CODE, READONLY, ALIGN=2

                  USB_ITConfig PROC
;;;608    */
;;;609    void USB_ITConfig(uint32_t USB_IT, FunctionalState NewState)
000000  b530              PUSH     {r4,r5,lr}
;;;610    {
000002  460a              MOV      r2,r1
;;;611        __IO uint8_t *tmp = (__IO uint8_t *)USB_BASE;
000004  4916              LDR      r1,|L21.96|
;;;612        uint32_t IT_FLAG = 0;
000006  2300              MOVS     r3,#0
;;;613    
;;;614        assert_param(IS_USB_CONFIG_IT(USB_IT));
;;;615        assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;616    
;;;617        if(USB_IT & 0x00000100)
000008  158c              ASRS     r4,r1,#22
00000a  4004              ANDS     r4,r4,r0
00000c  2c00              CMP      r4,#0
00000e  d005              BEQ      |L21.28|
;;;618        {
;;;619          tmp = &USB->INTRINE;
000010  1dc9              ADDS     r1,r1,#7
;;;620          IT_FLAG = USB_IT & 0xfffffeff;
000012  158d              ASRS     r5,r1,#22
000014  4604              MOV      r4,r0
000016  43ac              BICS     r4,r4,r5
000018  4623              MOV      r3,r4
00001a  e016              B        |L21.74|
                  |L21.28|
;;;621        }
;;;622        else if(USB_IT & 0x00000200)
00001c  2401              MOVS     r4,#1
00001e  0264              LSLS     r4,r4,#9
000020  4004              ANDS     r4,r4,r0
000022  2c00              CMP      r4,#0
000024  d006              BEQ      |L21.52|
;;;623        {
;;;624          tmp = &USB->INTROUTE;
000026  490e              LDR      r1,|L21.96|
000028  3109              ADDS     r1,r1,#9
;;;625          IT_FLAG = USB_IT & 0xfffffdff;
00002a  154d              ASRS     r5,r1,#21
00002c  4604              MOV      r4,r0
00002e  43ac              BICS     r4,r4,r5
000030  4623              MOV      r3,r4
000032  e00a              B        |L21.74|
                  |L21.52|
;;;626        }
;;;627        else if(USB_IT & 0x00000400)
000034  2401              MOVS     r4,#1
000036  02a4              LSLS     r4,r4,#10
000038  4004              ANDS     r4,r4,r0
00003a  2c00              CMP      r4,#0
00003c  d005              BEQ      |L21.74|
;;;628        {
;;;629          tmp = &USB->INTRUSBE;
00003e  4908              LDR      r1,|L21.96|
000040  310b              ADDS     r1,r1,#0xb
;;;630          IT_FLAG = USB_IT & 0xfffffbff;
000042  150d              ASRS     r5,r1,#20
000044  4604              MOV      r4,r0
000046  43ac              BICS     r4,r4,r5
000048  4623              MOV      r3,r4
                  |L21.74|
;;;631        }
;;;632    
;;;633        if(NewState != DISABLE)
00004a  2a00              CMP      r2,#0
00004c  d004              BEQ      |L21.88|
;;;634        {
;;;635          *((__IO uint8_t *)tmp) |= (uint8_t)IT_FLAG;
00004e  780c              LDRB     r4,[r1,#0]
000050  b2dd              UXTB     r5,r3
000052  432c              ORRS     r4,r4,r5
000054  700c              STRB     r4,[r1,#0]
000056  e002              B        |L21.94|
                  |L21.88|
;;;636        }
;;;637        else
;;;638        {
;;;639          *((__IO uint8_t *)tmp) &= ~((uint8_t)IT_FLAG);
000058  780c              LDRB     r4,[r1,#0]
00005a  439c              BICS     r4,r4,r3
00005c  700c              STRB     r4,[r1,#0]
                  |L21.94|
;;;640        }
;;;641    }
00005e  bd30              POP      {r4,r5,pc}
;;;642    /******************************************************************************
                          ENDP

                  |L21.96|
                          DCD      0x40005c00

                          AREA ||i.USB_Init||, CODE, READONLY, ALIGN=2

                  USB_Init PROC
;;;86     */
;;;87     void USB_Init(void)
000000  b508              PUSH     {r3,lr}
;;;88     {
;;;89       NVIC_InitTypeDef NVIC_InitStructure;
;;;90     
;;;91     	if(RCC_GetFlagStatus(RCC_FLAG_HSI48RDY) != SET)
000002  2071              MOVS     r0,#0x71
000004  f7fffffe          BL       RCC_GetFlagStatus
000008  2801              CMP      r0,#1
00000a  d008              BEQ      |L22.30|
;;;92     	{
;;;93     		RCC_HSI48Cmd(ENABLE);
00000c  2001              MOVS     r0,#1
00000e  f7fffffe          BL       RCC_HSI48Cmd
;;;94     		while(RCC_GetFlagStatus(RCC_FLAG_HSI48RDY) != SET);
000012  bf00              NOP      
                  |L22.20|
000014  2071              MOVS     r0,#0x71
000016  f7fffffe          BL       RCC_GetFlagStatus
00001a  2801              CMP      r0,#1
00001c  d1fa              BNE      |L22.20|
                  |L22.30|
;;;95     	}
;;;96       RCC_USBCLKConfig(RCC_USBCLK_HSI48);
00001e  2000              MOVS     r0,#0
000020  f7fffffe          BL       RCC_USBCLKConfig
;;;97     	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USB,ENABLE);
000024  2101              MOVS     r1,#1
000026  05c8              LSLS     r0,r1,#23
000028  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;98     
;;;99     		
;;;100    	USB_ITConfig(USB_IT_USB_RESUME_FLAG,ENABLE);
00002c  2101              MOVS     r1,#1
00002e  4814              LDR      r0,|L22.128|
000030  f7fffffe          BL       USB_ITConfig
;;;101    	USB_ITConfig(USB_IT_USB_SUSPEND_FLAG,ENABLE);
000034  2101              MOVS     r1,#1
000036  4812              LDR      r0,|L22.128|
000038  1e40              SUBS     r0,r0,#1
00003a  f7fffffe          BL       USB_ITConfig
;;;102    	USB_ITConfig(USB_IT_USB_SOF_FLAG,ENABLE);
00003e  2101              MOVS     r1,#1
000040  2081              MOVS     r0,#0x81
000042  00c0              LSLS     r0,r0,#3
000044  f7fffffe          BL       USB_ITConfig
;;;103    	USB_ITConfig(USB_IT_USB_RESET_FLAG,ENABLE);
000048  2101              MOVS     r1,#1
00004a  480d              LDR      r0,|L22.128|
00004c  1c80              ADDS     r0,r0,#2
00004e  f7fffffe          BL       USB_ITConfig
;;;104    		
;;;105      USB_PDCTRLConfig(USB_PDCTRL_PU_ENABLE);
000052  2001              MOVS     r0,#1
000054  f7fffffe          BL       USB_PDCTRLConfig
;;;106    	
;;;107      NVIC_InitStructure.NVIC_IRQChannel = USB_IRQn;
000058  211f              MOVS     r1,#0x1f
00005a  4668              MOV      r0,sp
00005c  7001              STRB     r1,[r0,#0]
;;;108      NVIC_InitStructure.NVIC_IRQChannelPriority = 0;
00005e  2100              MOVS     r1,#0
000060  7041              STRB     r1,[r0,#1]
;;;109      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000062  2101              MOVS     r1,#1
000064  7081              STRB     r1,[r0,#2]
;;;110      NVIC_Init(&NVIC_InitStructure);
000066  f7fffffe          BL       NVIC_Init
;;;111    	
;;;112    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_CRS,ENABLE);
00006a  2101              MOVS     r1,#1
00006c  06c8              LSLS     r0,r1,#27
00006e  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;113    	CRS_FrequencyErrorCounterCmd(ENABLE);
000072  2001              MOVS     r0,#1
000074  f7fffffe          BL       CRS_FrequencyErrorCounterCmd
;;;114    	CRS_AutomaticCalibrationCmd(ENABLE);
000078  2001              MOVS     r0,#1
00007a  f7fffffe          BL       CRS_AutomaticCalibrationCmd
;;;115    }
00007e  bd08              POP      {r3,pc}
;;;116    
                          ENDP

                  |L22.128|
                          DCD      0x00000402

                          AREA ||i.USB_PDCTRLConfig||, CODE, READONLY, ALIGN=2

                  USB_PDCTRLConfig PROC
;;;513    */
;;;514    void USB_PDCTRLConfig(uint8_t PDCT)
000000  4601              MOV      r1,r0
;;;515    {
;;;516        uint8_t temp = 0;
000002  2000              MOVS     r0,#0
;;;517    
;;;518        assert_param(IS_USB_PDCTRL(PDCT));
;;;519    
;;;520        temp = USB->PDCTRL;
000004  4a04              LDR      r2,|L23.24|
000006  7bd0              LDRB     r0,[r2,#0xf]
;;;521        temp &= ~USB_PDCTRL_FLAG;
000008  0880              LSRS     r0,r0,#2
00000a  0080              LSLS     r0,r0,#2
;;;522        temp |= PDCT;
00000c  4602              MOV      r2,r0
00000e  430a              ORRS     r2,r2,r1
000010  4610              MOV      r0,r2
;;;523        USB->PDCTRL = temp;
000012  4a01              LDR      r2,|L23.24|
000014  73d0              STRB     r0,[r2,#0xf]
;;;524    
;;;525    }
000016  4770              BX       lr
;;;526    /******************************************************************************
                          ENDP

                  |L23.24|
                          DCD      0x40005c00

                          AREA ||i.USB_ReadRegister||, CODE, READONLY, ALIGN=2

                  USB_ReadRegister PROC
;;;493    */
;;;494    uint8_t USB_ReadRegister(uint8_t USB_Refister)
000000  b508              PUSH     {r3,lr}
;;;495    {
000002  4601              MOV      r1,r0
;;;496        __IO uint32_t tmp = 0;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;497    
;;;498        /* Check the parameters */
;;;499        assert_param(IS_USB_REGISTER(USB_Refister));
;;;500    
;;;501        tmp = (uint32_t)USB;
000008  4803              LDR      r0,|L24.24|
00000a  9000              STR      r0,[sp,#0]
;;;502        tmp += USB_Refister;
00000c  9800              LDR      r0,[sp,#0]
00000e  1840              ADDS     r0,r0,r1
000010  9000              STR      r0,[sp,#0]
;;;503    
;;;504        /* Return the selected register value */
;;;505        return (*(__IO uint8_t *) tmp);	
000012  9800              LDR      r0,[sp,#0]
000014  7800              LDRB     r0,[r0,#0]
;;;506    }
000016  bd08              POP      {r3,pc}
;;;507    /******************************************************************************
                          ENDP

                  |L24.24|
                          DCD      0x40005c00

                          AREA ||i.USB_Remote_Wakeup||, CODE, READONLY, ALIGN=2

                  USB_Remote_Wakeup PROC
;;;343    */
;;;344    void USB_Remote_Wakeup(void)
000000  4806              LDR      r0,|L25.28|
;;;345    {
;;;346    	USB->POWER |= 0x04;
000002  7840              LDRB     r0,[r0,#1]
000004  2104              MOVS     r1,#4
000006  4308              ORRS     r0,r0,r1
000008  4904              LDR      r1,|L25.28|
00000a  7048              STRB     r0,[r1,#1]
;;;347    //	SysTick_Delay_Ms(12);
;;;348    	USB->POWER &= ~0x04;			
00000c  4608              MOV      r0,r1
00000e  7840              LDRB     r0,[r0,#1]
000010  2104              MOVS     r1,#4
000012  4388              BICS     r0,r0,r1
000014  4901              LDR      r1,|L25.28|
000016  7048              STRB     r0,[r1,#1]
;;;349    }
000018  4770              BX       lr
;;;350    
                          ENDP

00001a  0000              DCW      0x0000
                  |L25.28|
                          DCD      0x40005c00

                          AREA ||i.USB_Reset||, CODE, READONLY, ALIGN=2

                  USB_Reset PROC
;;;287    */
;;;288    void USB_Reset(void)
000000  b500              PUSH     {lr}
;;;289    {
000002  b089              SUB      sp,sp,#0x24
;;;290    	M_EPBIN_STATUS  tEpin;
;;;291    	M_EPBOUT_STATUS tEpout;
;;;292    	
;;;293    	/* Set device into default state */
;;;294    	gnDevState = DEVSTATE_DEFAULT;
000004  2000              MOVS     r0,#0
000006  492c              LDR      r1,|L26.184|
000008  6008              STR      r0,[r1,#0]  ; gnDevState
;;;295    //    pInformation->Current_Feature = USB_FSConfigDescriptor[7];
;;;296    	/* Reset any state machines for each endpoint */
;;;297    	/* This example assumes 2 bulk IN endpoints with endpoint numbers 1,2, */
;;;298    	/* and 2 bulk out endpoints with endpoint numbers 1,2 */
;;;299    	USB_Endpoint0(M_EP_RESET);
00000a  2001              MOVS     r0,#1
00000c  f7fffffe          BL       USB_Endpoint0
;;;300    
;;;301    	/* Initialise endpoint status structures with endpoint numbers */
;;;302    
;;;303    	tEpin.byEP = 1;
000010  2101              MOVS     r1,#1
000012  a808              ADD      r0,sp,#0x20
000014  7001              STRB     r1,[r0,#0]
;;;304    	tEpin.nBytesLeft = M_EP_NODATA;
000016  1e88              SUBS     r0,r1,#2
000018  9007              STR      r0,[sp,#0x1c]
;;;305    	EndpointBulkIn(tEpin, M_EP_RESET);
00001a  2301              MOVS     r3,#1
00001c  a806              ADD      r0,sp,#0x18
00001e  c807              LDM      r0,{r0-r2}
000020  f7fffffe          BL       EndpointBulkIn
;;;306    	
;;;307    	tEpin.byEP = 2;
000024  2102              MOVS     r1,#2
000026  a808              ADD      r0,sp,#0x20
000028  7001              STRB     r1,[r0,#0]
;;;308    	tEpin.nBytesLeft = M_EP_NODATA;
00002a  1ec8              SUBS     r0,r1,#3
00002c  9007              STR      r0,[sp,#0x1c]
;;;309    	EndpointBulkIn(tEpin, M_EP_RESET);
00002e  2301              MOVS     r3,#1
000030  a806              ADD      r0,sp,#0x18
000032  c807              LDM      r0,{r0-r2}
000034  f7fffffe          BL       EndpointBulkIn
;;;310    	
;;;311    	tEpin.byEP = 3;
000038  2103              MOVS     r1,#3
00003a  a808              ADD      r0,sp,#0x20
00003c  7001              STRB     r1,[r0,#0]
;;;312    	tEpin.nBytesLeft = M_EP_NODATA;
00003e  1f08              SUBS     r0,r1,#4
000040  9007              STR      r0,[sp,#0x1c]
;;;313    	EndpointBulkIn(tEpin, M_EP_RESET);
000042  2301              MOVS     r3,#1
000044  a806              ADD      r0,sp,#0x18
000046  c807              LDM      r0,{r0-r2}
000048  f7fffffe          BL       EndpointBulkIn
;;;314    	
;;;315    	tEpin.byEP = 4;
00004c  2104              MOVS     r1,#4
00004e  a808              ADD      r0,sp,#0x20
000050  7001              STRB     r1,[r0,#0]
;;;316    	tEpin.nBytesLeft = M_EP_NODATA;
000052  1f48              SUBS     r0,r1,#5
000054  9007              STR      r0,[sp,#0x1c]
;;;317    	EndpointBulkIn(tEpin, M_EP_RESET);
000056  2301              MOVS     r3,#1
000058  a806              ADD      r0,sp,#0x18
00005a  c807              LDM      r0,{r0-r2}
00005c  f7fffffe          BL       EndpointBulkIn
;;;318    	
;;;319    	tEpin.byEP = 6;
000060  2106              MOVS     r1,#6
000062  a808              ADD      r0,sp,#0x20
000064  7001              STRB     r1,[r0,#0]
;;;320    	tEpin.nBytesLeft = M_EP_NODATA;
000066  1fc8              SUBS     r0,r1,#7
000068  9007              STR      r0,[sp,#0x1c]
;;;321    	EndpointBulkIn(tEpin, M_EP_RESET);
00006a  2301              MOVS     r3,#1
00006c  a806              ADD      r0,sp,#0x18
00006e  c807              LDM      r0,{r0-r2}
000070  f7fffffe          BL       EndpointBulkIn
;;;322    	
;;;323    	//--------------------------------------//
;;;324    	
;;;325    	tEpout.byEP = 5;
000074  2105              MOVS     r1,#5
000076  4668              MOV      r0,sp
000078  7501              STRB     r1,[r0,#0x14]
;;;326    	tEpout.nBuffLen = M_EP_MAXP;
00007a  2040              MOVS     r0,#0x40
00007c  9003              STR      r0,[sp,#0xc]
;;;327    	tEpout.nBytesRecv = 0;
00007e  2000              MOVS     r0,#0
000080  9004              STR      r0,[sp,#0x10]
;;;328    	EndpointBulkOut(tEpout, M_EP_RESET);
000082  2001              MOVS     r0,#1
000084  9000              STR      r0,[sp,#0]
000086  a802              ADD      r0,sp,#8
000088  c80f              LDM      r0,{r0-r3}
00008a  f7fffffe          BL       EndpointBulkOut
;;;329    	
;;;330    	tEpout.byEP = 7;
00008e  2107              MOVS     r1,#7
000090  4668              MOV      r0,sp
000092  7501              STRB     r1,[r0,#0x14]
;;;331    	tEpout.nBuffLen = M_EP_MAXP;
000094  2040              MOVS     r0,#0x40
000096  9003              STR      r0,[sp,#0xc]
;;;332    	tEpout.nBytesRecv = 0;
000098  2000              MOVS     r0,#0
00009a  9004              STR      r0,[sp,#0x10]
;;;333    	EndpointBulkOut(tEpout, M_EP_RESET);
00009c  2001              MOVS     r0,#1
00009e  9000              STR      r0,[sp,#0]
0000a0  a802              ADD      r0,sp,#8
0000a2  c80f              LDM      r0,{r0-r3}
0000a4  f7fffffe          BL       EndpointBulkOut
;;;334    	
;;;335    	USB->POWER |= 0x01;												//允许挂起模块
0000a8  4804              LDR      r0,|L26.188|
0000aa  7840              LDRB     r0,[r0,#1]
0000ac  2101              MOVS     r1,#1
0000ae  4308              ORRS     r0,r0,r1
0000b0  4902              LDR      r1,|L26.188|
0000b2  7048              STRB     r0,[r1,#1]
;;;336    }
0000b4  b009              ADD      sp,sp,#0x24
0000b6  bd00              POP      {pc}
;;;337    /******************************************************************************
                          ENDP

                  |L26.184|
                          DCD      gnDevState
                  |L26.188|
                          DCD      0x40005c00

                          AREA ||i.USB_StdDev_Req||, CODE, READONLY, ALIGN=2

                  USB_StdDev_Req PROC
;;;1013   */
;;;1014   static void USB_StdDev_Req(PM_EP0_STATUS pep0state, PCOMMAND pcmd)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1015   {
000002  b089              SUB      sp,sp,#0x24
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;1016   	int	bError = FALSE, bNoData = FALSE, n;
000008  2000              MOVS     r0,#0
00000a  9008              STR      r0,[sp,#0x20]
00000c  9007              STR      r0,[sp,#0x1c]
;;;1017   	BYTE	by;
;;;1018   	BYTE	byConfig;
;;;1019   	PSTD_CFG_DSCR	pcfg;	
;;;1020   	
;;;1021   	uint8_t Related_Endpoint;
;;;1022   	uint8_t wIndex0 = pcmd->USBwIndex0;
00000e  7928              LDRB     r0,[r5,#4]
000010  9002              STR      r0,[sp,#8]
;;;1023   	Related_Endpoint = (wIndex0 & 0x0f);		
000012  9802              LDR      r0,[sp,#8]
000014  0700              LSLS     r0,r0,#28
000016  0f00              LSRS     r0,r0,#28
000018  9003              STR      r0,[sp,#0xc]
;;;1024   	uint8_t srbuff;
;;;1025   	uint8_t txdat[2] = {0};
00001a  2000              MOVS     r0,#0
00001c  9001              STR      r0,[sp,#4]
;;;1026   	
;;;1027   	SEGGER_RTT_printf(0,"USB_StdDev_Req;  333 pcmd->bRequest=%d\n",pcmd->bRequest);
00001e  786a              LDRB     r2,[r5,#1]
000020  a1fa              ADR      r1,|L27.1036|
000022  f7fffffe          BL       SEGGER_RTT_printf
;;;1028   	switch(pcmd->bRequest) 
000026  7868              LDRB     r0,[r5,#1]
000028  280c              CMP      r0,#0xc
00002a  d270              BCS      |L27.270|
00002c  0043              LSLS     r3,r0,#1
00002e  447b              ADD      r3,r3,pc
000030  889b              LDRH     r3,[r3,#4]
000032  005b              LSLS     r3,r3,#1
000034  449f              ADD      pc,pc,r3
000036  04f8              DCW      0x04f8
000038  03b6006b          DCW      0x03b6,0x006b
00003c  0351006b          DCW      0x0351,0x006b
000040  000b0020          DCW      0x000b,0x0020
000044  006b02f9          DCW      0x006b,0x02f9
000048  0280032a          DCW      0x0280,0x032a
00004c  02d1              DCW      0x02d1
;;;1029   	{
;;;1030   		/***用来给设备分配地址***/
;;;1031   		case SET_ADDRESS:
;;;1032   			/* Store device function address until status stage of request */
;;;1033   			if (pcmd->bmRequestType != M_CMD_STDDEVOUT)
00004e  7828              LDRB     r0,[r5,#0]
000050  2800              CMP      r0,#0
000052  d002              BEQ      |L27.90|
;;;1034   			{
;;;1035   				bError = TRUE;
000054  2001              MOVS     r0,#1
000056  9008              STR      r0,[sp,#0x20]
000058  e00d              B        |L27.118|
                  |L27.90|
;;;1036   			}
;;;1037   			else if (gnDevState <= DEVSTATE_ADDRESS) 
00005a  48f6              LDR      r0,|L27.1076|
00005c  6800              LDR      r0,[r0,#0]  ; gnDevState
00005e  2801              CMP      r0,#1
000060  d807              BHI      |L27.114|
;;;1038   			{
;;;1039   				pep0state->byFAddr = (BYTE)pcmd->USBwValue;
000062  78e8              LDRB     r0,[r5,#3]
000064  78a9              LDRB     r1,[r5,#2]
000066  0200              LSLS     r0,r0,#8
000068  4308              ORRS     r0,r0,r1
00006a  7420              STRB     r0,[r4,#0x10]
;;;1040   				bNoData = TRUE;
00006c  2001              MOVS     r0,#1
00006e  9007              STR      r0,[sp,#0x1c]
000070  e001              B        |L27.118|
                  |L27.114|
;;;1041   			}
;;;1042   			else
;;;1043   			{
;;;1044   				bError = TRUE;
000072  2001              MOVS     r0,#1
000074  9008              STR      r0,[sp,#0x20]
                  |L27.118|
;;;1045   			}
;;;1046   			break;
000076  e25e              B        |L27.1334|
;;;1047   			
;;;1048   		/***用于主机获取设备的特定描述符***/		
;;;1049   		case GET_DESCRIPTOR:
;;;1050   			/* Decode the required descriptor from the command */
;;;1051   			/***报告描述符的接受者是接口，pcmd->bmRequestType = 0x81时传输HID报告描述符***/
;;;1052   			if(!(pcmd->bmRequestType & M_CMD_STDDEVIN))
000078  7828              LDRB     r0,[r5,#0]
00007a  2180              MOVS     r1,#0x80
00007c  4008              ANDS     r0,r0,r1
00007e  2800              CMP      r0,#0
000080  d102              BNE      |L27.136|
;;;1053   			{
;;;1054   				bError = TRUE;
000082  2001              MOVS     r0,#1
000084  9008              STR      r0,[sp,#0x20]
000086  e256              B        |L27.1334|
                  |L27.136|
;;;1055   			}
;;;1056   			else 
;;;1057   			{
;;;1058   				switch(pcmd->USBwValue & M_CMD_DESCMASK) 
000088  78e8              LDRB     r0,[r5,#3]
00008a  78a9              LDRB     r1,[r5,#2]
00008c  0200              LSLS     r0,r0,#8
00008e  4308              ORRS     r0,r0,r1
000090  21ff              MOVS     r1,#0xff
000092  0209              LSLS     r1,r1,#8
000094  4008              ANDS     r0,r0,r1
000096  2203              MOVS     r2,#3
000098  0252              LSLS     r2,r2,#9
00009a  1a81              SUBS     r1,r0,r2
00009c  4290              CMP      r0,r2
00009e  d037              BEQ      |L27.272|
0000a0  dc0c              BGT      |L27.188|
0000a2  38ff              SUBS     r0,r0,#0xff
0000a4  3801              SUBS     r0,#1
0000a6  2800              CMP      r0,#0
0000a8  d011              BEQ      |L27.206|
0000aa  38ff              SUBS     r0,r0,#0xff
0000ac  3801              SUBS     r0,#1
0000ae  2800              CMP      r0,#0
0000b0  d031              BEQ      |L27.278|
0000b2  38ff              SUBS     r0,r0,#0xff
0000b4  3801              SUBS     r0,#1
0000b6  2800              CMP      r0,#0
                  |L27.184|
0000b8  d17e              BNE      |L27.440|
0000ba  e112              B        |L27.738|
                  |L27.188|
0000bc  39ff              SUBS     r1,r1,#0xff
0000be  3901              SUBS     r1,#1
0000c0  2900              CMP      r1,#0
0000c2  d059              BEQ      |L27.376|
0000c4  201b              MOVS     r0,#0x1b
0000c6  0200              LSLS     r0,r0,#8
0000c8  1a08              SUBS     r0,r1,r0
0000ca  d1f5              BNE      |L27.184|
0000cc  e057              B        |L27.382|
                  |L27.206|
;;;1059   				{
;;;1060   					/***设备描述符***/
;;;1061   					case M_CMD_DEVICE:
;;;1062   						/* Prepare to return Standard Device Descriptor */
;;;1063   						pep0state->nBytesLeft = USB_FSDeviceDescriptorSize;
0000ce  1d21              ADDS     r1,r4,#4
0000d0  48d9              LDR      r0,|L27.1080|
0000d2  8800              LDRH     r0,[r0,#0]  ; USB_FSDeviceDescriptorSize
0000d4  f7fffffe          BL       __aeabi_uwrite4
;;;1064   						/* Check host is allowing a descriptor this long */
;;;1065   						if(pcmd->USBwLength < pep0state->nBytesLeft)
0000d8  1d20              ADDS     r0,r4,#4
0000da  f7fffffe          BL       __aeabi_uread4
0000de  79e9              LDRB     r1,[r5,#7]
0000e0  79aa              LDRB     r2,[r5,#6]
0000e2  0209              LSLS     r1,r1,#8
0000e4  4311              ORRS     r1,r1,r2
0000e6  4288              CMP      r0,r1
0000e8  dd07              BLE      |L27.250|
;;;1066   						{
;;;1067   							pep0state->nBytesLeft = pcmd->USBwLength;
0000ea  79e9              LDRB     r1,[r5,#7]
0000ec  79aa              LDRB     r2,[r5,#6]
0000ee  0209              LSLS     r1,r1,#8
0000f0  4311              ORRS     r1,r1,r2
0000f2  4608              MOV      r0,r1
0000f4  1d21              ADDS     r1,r4,#4
0000f6  f7fffffe          BL       __aeabi_uwrite4
                  |L27.250|
;;;1068   						}
;;;1069   						
;;;1070   						pep0state->pData = (void*)USB_FSDeviceDescriptor;
0000fa  4621              MOV      r1,r4
0000fc  3108              ADDS     r1,r1,#8
0000fe  48cf              LDR      r0,|L27.1084|
000100  f7fffffe          BL       __aeabi_uwrite4
;;;1071   						pep0state->nState = M_EP0_TX;
000104  4621              MOV      r1,r4
000106  2002              MOVS     r0,#2
000108  f7fffffe          BL       __aeabi_uwrite4
;;;1072   						break;
00010c  e212              B        |L27.1332|
                  |L27.270|
00010e  e398              B        |L27.2114|
                  |L27.272|
;;;1073   					/***设备限定描述符***/	
;;;1074   					case M_CMD_DEVQUAL:
;;;1075   						/* No alternate speed supported */
;;;1076   						bError = TRUE;
000110  2001              MOVS     r0,#1
000112  9008              STR      r0,[sp,#0x20]
;;;1077   						break;
000114  e20e              B        |L27.1332|
                  |L27.278|
;;;1078   					/***配置描述符***/					
;;;1079   					case M_CMD_CONFIG:
;;;1080   						byConfig = (BYTE)(pcmd->USBwValue & 0x00FF);
000116  78e8              LDRB     r0,[r5,#3]
000118  78a9              LDRB     r1,[r5,#2]
00011a  0200              LSLS     r0,r0,#8
00011c  4308              ORRS     r0,r0,r1
00011e  b2c0              UXTB     r0,r0
000120  9005              STR      r0,[sp,#0x14]
;;;1081   						if(byConfig>USB_FSDeviceDescriptor[USB_FSDeviceDescriptorSize-1])
000122  48c5              LDR      r0,|L27.1080|
000124  8800              LDRH     r0,[r0,#0]  ; USB_FSDeviceDescriptorSize
000126  1e40              SUBS     r0,r0,#1
000128  49c4              LDR      r1,|L27.1084|
00012a  5c09              LDRB     r1,[r1,r0]
00012c  9805              LDR      r0,[sp,#0x14]
00012e  4281              CMP      r1,r0
000130  da02              BGE      |L27.312|
;;;1082   						{
;;;1083   							bError = TRUE;
000132  2001              MOVS     r0,#1
000134  9008              STR      r0,[sp,#0x20]
000136  e01e              B        |L27.374|
                  |L27.312|
;;;1084   						}
;;;1085   						else
;;;1086   						{
;;;1087   							/* Get pointer to requested configuration descriptor */
;;;1088   							/* Prepare to return Configuration Descriptors */
;;;1089   							pep0state->nBytesLeft = USB_FSConfigDescriptorSize;
000138  1d21              ADDS     r1,r4,#4
00013a  48c1              LDR      r0,|L27.1088|
00013c  8800              LDRH     r0,[r0,#0]  ; USB_FSConfigDescriptorSize
00013e  f7fffffe          BL       __aeabi_uwrite4
;;;1090   							pep0state->pData = (void*)USB_FSConfigDescriptor;
000142  4621              MOV      r1,r4
000144  3108              ADDS     r1,r1,#8
000146  48bf              LDR      r0,|L27.1092|
000148  f7fffffe          BL       __aeabi_uwrite4
;;;1091   							pep0state->nState = M_EP0_TX;
00014c  4621              MOV      r1,r4
00014e  2002              MOVS     r0,#2
000150  f7fffffe          BL       __aeabi_uwrite4
;;;1092   							/* Check host is allowing a descriptor this long */
;;;1093   							if (pcmd->USBwLength < pep0state->nBytesLeft)
000154  1d20              ADDS     r0,r4,#4
000156  f7fffffe          BL       __aeabi_uread4
00015a  79e9              LDRB     r1,[r5,#7]
00015c  79aa              LDRB     r2,[r5,#6]
00015e  0209              LSLS     r1,r1,#8
000160  4311              ORRS     r1,r1,r2
000162  4288              CMP      r0,r1
000164  dd07              BLE      |L27.374|
;;;1094   							{
;;;1095   								pep0state->nBytesLeft = pcmd->USBwLength;
000166  79e9              LDRB     r1,[r5,#7]
000168  79aa              LDRB     r2,[r5,#6]
00016a  0209              LSLS     r1,r1,#8
00016c  4311              ORRS     r1,r1,r2
00016e  4608              MOV      r0,r1
000170  1d21              ADDS     r1,r4,#4
000172  f7fffffe          BL       __aeabi_uwrite4
                  |L27.374|
;;;1096   							}
;;;1097   						}
;;;1098   						break;
000176  e1dd              B        |L27.1332|
                  |L27.376|
;;;1099   					/***其它速度配置描述符***/						
;;;1100   					case M_CMD_OTHERSPEED:
;;;1101   						/* No alternate speed supported */
;;;1102   						bError = TRUE;
000178  2001              MOVS     r0,#1
00017a  9008              STR      r0,[sp,#0x20]
;;;1103   						break;
00017c  e1da              B        |L27.1332|
                  |L27.382|
;;;1104   					/***HID报告描述符***/
;;;1105   					case	M_CMD_HID_REPORT_DESC:		//报告描述符		0x2200
;;;1106   						/* Prepare to return Standard Device Descriptor */
;;;1107   						switch(pcmd->USBwIndex)
00017e  7968              LDRB     r0,[r5,#5]
000180  7929              LDRB     r1,[r5,#4]
000182  0200              LSLS     r0,r0,#8
000184  4308              ORRS     r0,r0,r1
000186  0003              MOVS     r3,r0
000188  f7fffffe          BL       __ARM_common_switch8
00018c  05042646          DCB      0x05,0x04,0x26,0x46
000190  6686a600          DCB      0x66,0x86,0xa6,0x00
;;;1108   						{
;;;1109   							case	0:
;;;1110   								//接口0
;;;1111   								pep0state->nBytesLeft = USB_HID_FSReportDescriptor_1Size;		//报告描述符的长度
000194  1d21              ADDS     r1,r4,#4
000196  48ac              LDR      r0,|L27.1096|
000198  8800              LDRH     r0,[r0,#0]  ; USB_HID_FSReportDescriptor_1Size
00019a  f7fffffe          BL       __aeabi_uwrite4
;;;1112   								/* Check host is allowing a descriptor this long */
;;;1113   								if (pcmd->USBwLength < pep0state->nBytesLeft)
00019e  1d20              ADDS     r0,r4,#4
0001a0  f7fffffe          BL       __aeabi_uread4
0001a4  79e9              LDRB     r1,[r5,#7]
0001a6  79aa              LDRB     r2,[r5,#6]
0001a8  0209              LSLS     r1,r1,#8
0001aa  4311              ORRS     r1,r1,r2
0001ac  4288              CMP      r0,r1
0001ae  dd09              BLE      |L27.452|
;;;1114   								{
;;;1115   									pep0state->nBytesLeft = pcmd->USBwLength;
0001b0  79e9              LDRB     r1,[r5,#7]
0001b2  79aa              LDRB     r2,[r5,#6]
0001b4  0209              LSLS     r1,r1,#8
0001b6  e000              B        |L27.442|
                  |L27.440|
0001b8  e1b9              B        |L27.1326|
                  |L27.442|
0001ba  4311              ORRS     r1,r1,r2
0001bc  4608              MOV      r0,r1
0001be  1d21              ADDS     r1,r4,#4
0001c0  f7fffffe          BL       __aeabi_uwrite4
                  |L27.452|
;;;1116   								}
;;;1117   								pep0state->pData = (void*)USB_HID_FSReportDescriptor_1;
0001c4  4621              MOV      r1,r4
0001c6  3108              ADDS     r1,r1,#8
0001c8  48a0              LDR      r0,|L27.1100|
0001ca  f7fffffe          BL       __aeabi_uwrite4
;;;1118   								pep0state->nState = M_EP0_TX;
0001ce  4621              MOV      r1,r4
0001d0  2002              MOVS     r0,#2
0001d2  f7fffffe          BL       __aeabi_uwrite4
;;;1119   								break;
0001d6  e082              B        |L27.734|
;;;1120   							case	1:
;;;1121   								//接口1
;;;1122   								pep0state->nBytesLeft = USB_HID_FSReportDescriptor_2Size;		//报告描述符的长度
0001d8  1d21              ADDS     r1,r4,#4
0001da  489d              LDR      r0,|L27.1104|
0001dc  8800              LDRH     r0,[r0,#0]  ; USB_HID_FSReportDescriptor_2Size
0001de  f7fffffe          BL       __aeabi_uwrite4
;;;1123   								/* Check host is allowing a descriptor this long */
;;;1124   								if (pcmd->USBwLength < pep0state->nBytesLeft)
0001e2  1d20              ADDS     r0,r4,#4
0001e4  f7fffffe          BL       __aeabi_uread4
0001e8  79e9              LDRB     r1,[r5,#7]
0001ea  79aa              LDRB     r2,[r5,#6]
0001ec  0209              LSLS     r1,r1,#8
0001ee  4311              ORRS     r1,r1,r2
0001f0  4288              CMP      r0,r1
0001f2  dd07              BLE      |L27.516|
;;;1125   								{
;;;1126   									pep0state->nBytesLeft = pcmd->USBwLength;
0001f4  79e9              LDRB     r1,[r5,#7]
0001f6  79aa              LDRB     r2,[r5,#6]
0001f8  0209              LSLS     r1,r1,#8
0001fa  4311              ORRS     r1,r1,r2
0001fc  4608              MOV      r0,r1
0001fe  1d21              ADDS     r1,r4,#4
000200  f7fffffe          BL       __aeabi_uwrite4
                  |L27.516|
;;;1127   								}
;;;1128   								pep0state->pData = (void*)USB_HID_FSReportDescriptor_2;
000204  4621              MOV      r1,r4
000206  3108              ADDS     r1,r1,#8
000208  4892              LDR      r0,|L27.1108|
00020a  f7fffffe          BL       __aeabi_uwrite4
;;;1129   								pep0state->nState = M_EP0_TX;
00020e  4621              MOV      r1,r4
000210  2002              MOVS     r0,#2
000212  f7fffffe          BL       __aeabi_uwrite4
;;;1130   								break;
000216  e062              B        |L27.734|
;;;1131   							case	2:
;;;1132   								//接口2
;;;1133   								pep0state->nBytesLeft = USB_HID_FSReportDescriptor_3Size;		//报告描述符的长度
000218  1d21              ADDS     r1,r4,#4
00021a  488f              LDR      r0,|L27.1112|
00021c  8800              LDRH     r0,[r0,#0]  ; USB_HID_FSReportDescriptor_3Size
00021e  f7fffffe          BL       __aeabi_uwrite4
;;;1134   								/* Check host is allowing a descriptor this long */
;;;1135   								if (pcmd->USBwLength < pep0state->nBytesLeft)
000222  1d20              ADDS     r0,r4,#4
000224  f7fffffe          BL       __aeabi_uread4
000228  79e9              LDRB     r1,[r5,#7]
00022a  79aa              LDRB     r2,[r5,#6]
00022c  0209              LSLS     r1,r1,#8
00022e  4311              ORRS     r1,r1,r2
000230  4288              CMP      r0,r1
000232  dd07              BLE      |L27.580|
;;;1136   								{
;;;1137   									pep0state->nBytesLeft = pcmd->USBwLength;
000234  79e9              LDRB     r1,[r5,#7]
000236  79aa              LDRB     r2,[r5,#6]
000238  0209              LSLS     r1,r1,#8
00023a  4311              ORRS     r1,r1,r2
00023c  4608              MOV      r0,r1
00023e  1d21              ADDS     r1,r4,#4
000240  f7fffffe          BL       __aeabi_uwrite4
                  |L27.580|
;;;1138   								}
;;;1139   								pep0state->pData = (void*)USB_HID_FSReportDescriptor_3;
000244  4621              MOV      r1,r4
000246  3108              ADDS     r1,r1,#8
000248  4884              LDR      r0,|L27.1116|
00024a  f7fffffe          BL       __aeabi_uwrite4
;;;1140   								pep0state->nState = M_EP0_TX;
00024e  4621              MOV      r1,r4
000250  2002              MOVS     r0,#2
000252  f7fffffe          BL       __aeabi_uwrite4
;;;1141   								break;
000256  e042              B        |L27.734|
;;;1142   								case	3:
;;;1143   								//接口3
;;;1144   								pep0state->nBytesLeft = USB_HID_FSReportDescriptor_4Size;		//报告描述符的长度
000258  1d21              ADDS     r1,r4,#4
00025a  4881              LDR      r0,|L27.1120|
00025c  8800              LDRH     r0,[r0,#0]  ; USB_HID_FSReportDescriptor_4Size
00025e  f7fffffe          BL       __aeabi_uwrite4
;;;1145   								/* Check host is allowing a descriptor this long */
;;;1146   								if (pcmd->USBwLength < pep0state->nBytesLeft)
000262  1d20              ADDS     r0,r4,#4
000264  f7fffffe          BL       __aeabi_uread4
000268  79e9              LDRB     r1,[r5,#7]
00026a  79aa              LDRB     r2,[r5,#6]
00026c  0209              LSLS     r1,r1,#8
00026e  4311              ORRS     r1,r1,r2
000270  4288              CMP      r0,r1
000272  dd07              BLE      |L27.644|
;;;1147   								{
;;;1148   									pep0state->nBytesLeft = pcmd->USBwLength;
000274  79e9              LDRB     r1,[r5,#7]
000276  79aa              LDRB     r2,[r5,#6]
000278  0209              LSLS     r1,r1,#8
00027a  4311              ORRS     r1,r1,r2
00027c  4608              MOV      r0,r1
00027e  1d21              ADDS     r1,r4,#4
000280  f7fffffe          BL       __aeabi_uwrite4
                  |L27.644|
;;;1149   								}
;;;1150   								pep0state->pData = (void*)USB_HID_FSReportDescriptor_4;
000284  4621              MOV      r1,r4
000286  3108              ADDS     r1,r1,#8
000288  4876              LDR      r0,|L27.1124|
00028a  f7fffffe          BL       __aeabi_uwrite4
;;;1151   								pep0state->nState = M_EP0_TX;
00028e  4621              MOV      r1,r4
000290  2002              MOVS     r0,#2
000292  f7fffffe          BL       __aeabi_uwrite4
;;;1152   								break;
000296  e022              B        |L27.734|
;;;1153   								case	4:
;;;1154   								//接口4
;;;1155   								pep0state->nBytesLeft = USB_HID_FSReportDescriptor_5Size;		//报告描述符的长度
000298  1d21              ADDS     r1,r4,#4
00029a  4873              LDR      r0,|L27.1128|
00029c  8800              LDRH     r0,[r0,#0]  ; USB_HID_FSReportDescriptor_5Size
00029e  f7fffffe          BL       __aeabi_uwrite4
;;;1156   								/* Check host is allowing a descriptor this long */
;;;1157   								if (pcmd->USBwLength < pep0state->nBytesLeft)
0002a2  1d20              ADDS     r0,r4,#4
0002a4  f7fffffe          BL       __aeabi_uread4
0002a8  79e9              LDRB     r1,[r5,#7]
0002aa  79aa              LDRB     r2,[r5,#6]
0002ac  0209              LSLS     r1,r1,#8
0002ae  4311              ORRS     r1,r1,r2
0002b0  4288              CMP      r0,r1
0002b2  dd07              BLE      |L27.708|
;;;1158   								{
;;;1159   									pep0state->nBytesLeft = pcmd->USBwLength;
0002b4  79e9              LDRB     r1,[r5,#7]
0002b6  79aa              LDRB     r2,[r5,#6]
0002b8  0209              LSLS     r1,r1,#8
0002ba  4311              ORRS     r1,r1,r2
0002bc  4608              MOV      r0,r1
0002be  1d21              ADDS     r1,r4,#4
0002c0  f7fffffe          BL       __aeabi_uwrite4
                  |L27.708|
;;;1160   								}
;;;1161   								pep0state->pData = (void*)USB_HID_FSReportDescriptor_5;
0002c4  4621              MOV      r1,r4
0002c6  3108              ADDS     r1,r1,#8
0002c8  4868              LDR      r0,|L27.1132|
0002ca  f7fffffe          BL       __aeabi_uwrite4
;;;1162   								pep0state->nState = M_EP0_TX;
0002ce  4621              MOV      r1,r4
0002d0  2002              MOVS     r0,#2
0002d2  f7fffffe          BL       __aeabi_uwrite4
;;;1163   								break;
0002d6  e002              B        |L27.734|
;;;1164   							default:
;;;1165   								//接口
;;;1166   								bError = TRUE;
0002d8  2001              MOVS     r0,#1
0002da  9008              STR      r0,[sp,#0x20]
;;;1167   								break;							
0002dc  bf00              NOP      
                  |L27.734|
0002de  bf00              NOP                            ;1119
;;;1168   						}
;;;1169   						break;
0002e0  e128              B        |L27.1332|
                  |L27.738|
;;;1170   					case	M_CMD_STRING:	//字符串描述符
;;;1171   
;;;1172   						SEGGER_RTT_printf(0,"USB_StdDev_Req;  333 pcmd->USBwValue=%d\n",pcmd->USBwValue);
0002e2  78e8              LDRB     r0,[r5,#3]
0002e4  78a9              LDRB     r1,[r5,#2]
0002e6  0200              LSLS     r0,r0,#8
0002e8  4308              ORRS     r0,r0,r1
0002ea  4602              MOV      r2,r0
0002ec  a160              ADR      r1,|L27.1136|
0002ee  2000              MOVS     r0,#0
0002f0  f7fffffe          BL       SEGGER_RTT_printf
;;;1173   						switch(pcmd->USBwValue & 0xff)
0002f4  78e8              LDRB     r0,[r5,#3]
0002f6  78a9              LDRB     r1,[r5,#2]
0002f8  0200              LSLS     r0,r0,#8
0002fa  4308              ORRS     r0,r0,r1
0002fc  b2c0              UXTB     r0,r0
0002fe  0003              MOVS     r3,r0
000300  f7fffffe          BL       __ARM_common_switch8
000304  05042444          DCB      0x05,0x04,0x24,0x44
000308  64dcef00          DCB      0x64,0xdc,0xef,0x00
;;;1174   						{
;;;1175   							case	0:	//获取语言ID
;;;1176   								pep0state->nBytesLeft = LanguageIdSize;		
00030c  1d21              ADDS     r1,r4,#4
00030e  4863              LDR      r0,|L27.1180|
000310  8800              LDRH     r0,[r0,#0]  ; LanguageIdSize
000312  f7fffffe          BL       __aeabi_uwrite4
;;;1177   								/* Check host is allowing a descriptor this long */
;;;1178   								if (pcmd->USBwLength < pep0state->nBytesLeft)
000316  1d20              ADDS     r0,r4,#4
000318  f7fffffe          BL       __aeabi_uread4
00031c  79e9              LDRB     r1,[r5,#7]
00031e  79aa              LDRB     r2,[r5,#6]
000320  0209              LSLS     r1,r1,#8
000322  4311              ORRS     r1,r1,r2
000324  4288              CMP      r0,r1
000326  dd07              BLE      |L27.824|
;;;1179   								{
;;;1180   									pep0state->nBytesLeft = pcmd->USBwLength;
000328  79e9              LDRB     r1,[r5,#7]
00032a  79aa              LDRB     r2,[r5,#6]
00032c  0209              LSLS     r1,r1,#8
00032e  4311              ORRS     r1,r1,r2
000330  4608              MOV      r0,r1
000332  1d21              ADDS     r1,r4,#4
000334  f7fffffe          BL       __aeabi_uwrite4
                  |L27.824|
;;;1181   								}
;;;1182   								pep0state->pData = (void*)LanguageId;
000338  4621              MOV      r1,r4
00033a  3108              ADDS     r1,r1,#8
00033c  4858              LDR      r0,|L27.1184|
00033e  f7fffffe          BL       __aeabi_uwrite4
;;;1183   								pep0state->nState = M_EP0_TX;
000342  4621              MOV      r1,r4
000344  2002              MOVS     r0,#2
000346  f7fffffe          BL       __aeabi_uwrite4
;;;1184   							break;
00034a  e0ee              B        |L27.1322|
;;;1185   							case	1:	//因厂商字符串索引值为1，所以这里写1
;;;1186   								pep0state->nBytesLeft = ManufacturerStringDescriptorSize;		
00034c  1d21              ADDS     r1,r4,#4
00034e  4855              LDR      r0,|L27.1188|
000350  8800              LDRH     r0,[r0,#0]  ; ManufacturerStringDescriptorSize
000352  f7fffffe          BL       __aeabi_uwrite4
;;;1187   								/* Check host is allowing a descriptor this long */
;;;1188   								if (pcmd->USBwLength < pep0state->nBytesLeft)
000356  1d20              ADDS     r0,r4,#4
000358  f7fffffe          BL       __aeabi_uread4
00035c  79e9              LDRB     r1,[r5,#7]
00035e  79aa              LDRB     r2,[r5,#6]
000360  0209              LSLS     r1,r1,#8
000362  4311              ORRS     r1,r1,r2
000364  4288              CMP      r0,r1
000366  dd07              BLE      |L27.888|
;;;1189   								{
;;;1190   									pep0state->nBytesLeft = pcmd->USBwLength;
000368  79e9              LDRB     r1,[r5,#7]
00036a  79aa              LDRB     r2,[r5,#6]
00036c  0209              LSLS     r1,r1,#8
00036e  4311              ORRS     r1,r1,r2
000370  4608              MOV      r0,r1
000372  1d21              ADDS     r1,r4,#4
000374  f7fffffe          BL       __aeabi_uwrite4
                  |L27.888|
;;;1191   								}
;;;1192   								pep0state->pData = (void*)ManufacturerStringDescriptor;
000378  4621              MOV      r1,r4
00037a  3108              ADDS     r1,r1,#8
00037c  484a              LDR      r0,|L27.1192|
00037e  f7fffffe          BL       __aeabi_uwrite4
;;;1193   								pep0state->nState = M_EP0_TX;
000382  4621              MOV      r1,r4
000384  2002              MOVS     r0,#2
000386  f7fffffe          BL       __aeabi_uwrite4
;;;1194   							break;	
00038a  e0ce              B        |L27.1322|
;;;1195   							case	2:	//因产品字符串索引值为2，所以这里写2
;;;1196   								pep0state->nBytesLeft = ProductStringDescriptorSize;		
00038c  1d21              ADDS     r1,r4,#4
00038e  4847              LDR      r0,|L27.1196|
000390  8800              LDRH     r0,[r0,#0]  ; ProductStringDescriptorSize
000392  f7fffffe          BL       __aeabi_uwrite4
;;;1197   								/* Check host is allowing a descriptor this long */
;;;1198   								if (pcmd->USBwLength < pep0state->nBytesLeft)
000396  1d20              ADDS     r0,r4,#4
000398  f7fffffe          BL       __aeabi_uread4
00039c  79e9              LDRB     r1,[r5,#7]
00039e  79aa              LDRB     r2,[r5,#6]
0003a0  0209              LSLS     r1,r1,#8
0003a2  4311              ORRS     r1,r1,r2
0003a4  4288              CMP      r0,r1
0003a6  dd07              BLE      |L27.952|
;;;1199   								{
;;;1200   									pep0state->nBytesLeft = pcmd->USBwLength;
0003a8  79e9              LDRB     r1,[r5,#7]
0003aa  79aa              LDRB     r2,[r5,#6]
0003ac  0209              LSLS     r1,r1,#8
0003ae  4311              ORRS     r1,r1,r2
0003b0  4608              MOV      r0,r1
0003b2  1d21              ADDS     r1,r4,#4
0003b4  f7fffffe          BL       __aeabi_uwrite4
                  |L27.952|
;;;1201   								}
;;;1202   								pep0state->pData = (void*)ProductStringDescriptor;
0003b8  4621              MOV      r1,r4
0003ba  3108              ADDS     r1,r1,#8
0003bc  483c              LDR      r0,|L27.1200|
0003be  f7fffffe          BL       __aeabi_uwrite4
;;;1203   								pep0state->nState = M_EP0_TX;
0003c2  4621              MOV      r1,r4
0003c4  2002              MOVS     r0,#2
0003c6  f7fffffe          BL       __aeabi_uwrite4
;;;1204   							break;			
0003ca  e0ae              B        |L27.1322|
;;;1205   							case	3:	//因产品序列号索引值为3，所以这里写3
;;;1206   								pep0state->nBytesLeft = SerialNumberSringDescriptorSize;		
0003cc  1d21              ADDS     r1,r4,#4
0003ce  4839              LDR      r0,|L27.1204|
0003d0  8800              LDRH     r0,[r0,#0]  ; SerialNumberSringDescriptorSize
0003d2  f7fffffe          BL       __aeabi_uwrite4
;;;1207   								/* Check host is allowing a descriptor this long */
;;;1208   								if (pcmd->USBwLength < pep0state->nBytesLeft)
0003d6  1d20              ADDS     r0,r4,#4
0003d8  f7fffffe          BL       __aeabi_uread4
0003dc  79e9              LDRB     r1,[r5,#7]
0003de  79aa              LDRB     r2,[r5,#6]
0003e0  0209              LSLS     r1,r1,#8
0003e2  4311              ORRS     r1,r1,r2
0003e4  4288              CMP      r0,r1
0003e6  dd07              BLE      |L27.1016|
;;;1209   								{
;;;1210   									pep0state->nBytesLeft = pcmd->USBwLength;
0003e8  79e9              LDRB     r1,[r5,#7]
0003ea  79aa              LDRB     r2,[r5,#6]
0003ec  0209              LSLS     r1,r1,#8
0003ee  4311              ORRS     r1,r1,r2
0003f0  4608              MOV      r0,r1
0003f2  1d21              ADDS     r1,r4,#4
0003f4  f7fffffe          BL       __aeabi_uwrite4
                  |L27.1016|
;;;1211   								}
;;;1212   								pep0state->pData = (void*)SerialNumberSringDescriptor;
0003f8  4621              MOV      r1,r4
0003fa  3108              ADDS     r1,r1,#8
0003fc  482e              LDR      r0,|L27.1208|
0003fe  f7fffffe          BL       __aeabi_uwrite4
;;;1213   								pep0state->nState = M_EP0_TX;
000402  4621              MOV      r1,r4
000404  2002              MOVS     r0,#2
000406  f7fffffe          BL       __aeabi_uwrite4
;;;1214   							break;
00040a  e08e              B        |L27.1322|
                  |L27.1036|
00040c  5553425f          DCB      "USB_StdDev_Req;  333 pcmd->bRequest=%d\n",0
000410  53746444
000414  65765f52
000418  65713b20
00041c  20333333
000420  2070636d
000424  642d3e62
000428  52657175
00042c  6573743d
000430  25640a00
                  |L27.1076|
                          DCD      gnDevState
                  |L27.1080|
                          DCD      USB_FSDeviceDescriptorSize
                  |L27.1084|
                          DCD      USB_FSDeviceDescriptor
                  |L27.1088|
                          DCD      USB_FSConfigDescriptorSize
                  |L27.1092|
                          DCD      USB_FSConfigDescriptor
                  |L27.1096|
                          DCD      USB_HID_FSReportDescriptor_1Size
                  |L27.1100|
                          DCD      USB_HID_FSReportDescriptor_1
                  |L27.1104|
                          DCD      USB_HID_FSReportDescriptor_2Size
                  |L27.1108|
                          DCD      USB_HID_FSReportDescriptor_2
                  |L27.1112|
                          DCD      USB_HID_FSReportDescriptor_3Size
                  |L27.1116|
                          DCD      USB_HID_FSReportDescriptor_3
                  |L27.1120|
                          DCD      USB_HID_FSReportDescriptor_4Size
                  |L27.1124|
                          DCD      USB_HID_FSReportDescriptor_4
                  |L27.1128|
                          DCD      USB_HID_FSReportDescriptor_5Size
                  |L27.1132|
                          DCD      USB_HID_FSReportDescriptor_5
                  |L27.1136|
000470  5553425f          DCB      "USB_StdDev_Req;  333 pcmd->USBwValue=%d\n",0
000474  53746444
000478  65765f52
00047c  65713b20
000480  20333333
000484  2070636d
000488  642d3e55
00048c  53427756
000490  616c7565
000494  3d25640a
000498  00      
000499  00                DCB      0
00049a  00                DCB      0
00049b  00                DCB      0
                  |L27.1180|
                          DCD      LanguageIdSize
                  |L27.1184|
                          DCD      LanguageId
                  |L27.1188|
                          DCD      ManufacturerStringDescriptorSize
                  |L27.1192|
                          DCD      ManufacturerStringDescriptor
                  |L27.1196|
                          DCD      ProductStringDescriptorSize
                  |L27.1200|
                          DCD      ProductStringDescriptor
                  |L27.1204|
                          DCD      SerialNumberSringDescriptorSize
                  |L27.1208|
                          DCD      SerialNumberSringDescriptor
;;;1215   
;;;1216   							case	4:	//因产品字符串索引值为2，所以这里写4
;;;1217   								pep0state->nBytesLeft = iapStringDescriptorSize;		
0004bc  1d21              ADDS     r1,r4,#4
0004be  48e1              LDR      r0,|L27.2116|
0004c0  8800              LDRH     r0,[r0,#0]  ; iapStringDescriptorSize
0004c2  f7fffffe          BL       __aeabi_uwrite4
;;;1218   								/* Check host is allowing a descriptor this long */
;;;1219   								
;;;1220   								SEGGER_RTT_printf(0,"USB_StdDev_Req;  444 pcmd->USBwLength=%d\n",pcmd->USBwLength);
0004c6  79e8              LDRB     r0,[r5,#7]
0004c8  79a9              LDRB     r1,[r5,#6]
0004ca  0200              LSLS     r0,r0,#8
0004cc  4308              ORRS     r0,r0,r1
0004ce  4602              MOV      r2,r0
0004d0  a1dd              ADR      r1,|L27.2120|
0004d2  2000              MOVS     r0,#0
0004d4  f7fffffe          BL       SEGGER_RTT_printf
;;;1221   								
;;;1222   								SEGGER_RTT_printf(0,"USB_StdDev_Req;  444 pcmd->nBytesLeft=%d\n",pep0state->nBytesLeft);
0004d8  1d20              ADDS     r0,r4,#4
0004da  f7fffffe          BL       __aeabi_uread4
0004de  4602              MOV      r2,r0
0004e0  e000              B        |L27.1252|
0004e2  e01f              B        |L27.1316|
                  |L27.1252|
0004e4  a1e3              ADR      r1,|L27.2164|
0004e6  9000              STR      r0,[sp,#0]
0004e8  2000              MOVS     r0,#0
0004ea  f7fffffe          BL       SEGGER_RTT_printf
;;;1223   								if (pcmd->USBwLength < pep0state->nBytesLeft)
0004ee  1d20              ADDS     r0,r4,#4
0004f0  f7fffffe          BL       __aeabi_uread4
0004f4  79e9              LDRB     r1,[r5,#7]
0004f6  79aa              LDRB     r2,[r5,#6]
0004f8  0209              LSLS     r1,r1,#8
0004fa  4311              ORRS     r1,r1,r2
0004fc  4288              CMP      r0,r1
0004fe  dd07              BLE      |L27.1296|
;;;1224   								{
;;;1225   									pep0state->nBytesLeft = pcmd->USBwLength;
000500  79e9              LDRB     r1,[r5,#7]
000502  79aa              LDRB     r2,[r5,#6]
000504  0209              LSLS     r1,r1,#8
000506  4311              ORRS     r1,r1,r2
000508  4608              MOV      r0,r1
00050a  1d21              ADDS     r1,r4,#4
00050c  f7fffffe          BL       __aeabi_uwrite4
                  |L27.1296|
;;;1226   								}
;;;1227   								pep0state->pData = (void*)iapStringDescriptor;
000510  4621              MOV      r1,r4
000512  3108              ADDS     r1,r1,#8
000514  48e2              LDR      r0,|L27.2208|
000516  f7fffffe          BL       __aeabi_uwrite4
;;;1228   								pep0state->nState = M_EP0_TX;
00051a  4621              MOV      r1,r4
00051c  2002              MOVS     r0,#2
00051e  f7fffffe          BL       __aeabi_uwrite4
;;;1229   							break;		
000522  e002              B        |L27.1322|
                  |L27.1316|
;;;1230   							default:
;;;1231   								bError = TRUE;								
000524  2001              MOVS     r0,#1
000526  9008              STR      r0,[sp,#0x20]
;;;1232   							break;
000528  bf00              NOP      
                  |L27.1322|
00052a  bf00              NOP                            ;1184
;;;1233   						}
;;;1234   					break;
00052c  e002              B        |L27.1332|
                  |L27.1326|
;;;1235   					/***保留***/
;;;1236   					default: bError = TRUE;
00052e  2001              MOVS     r0,#1
000530  9008              STR      r0,[sp,#0x20]
000532  bf00              NOP                            ;1058
                  |L27.1332|
000534  bf00              NOP                            ;1072
                  |L27.1334|
;;;1237   				}
;;;1238   			}
;;;1239   			break;
000536  e32c              B        |L27.2962|
;;;1240   
;;;1241   		/***用于主机指示设备采用的要求的配置***/
;;;1242   		case SET_CONFIGURATION:
;;;1243   			byConfig = (BYTE)(pcmd->USBwValue & 0x00FF);
000538  78e8              LDRB     r0,[r5,#3]
00053a  78a9              LDRB     r1,[r5,#2]
00053c  0200              LSLS     r0,r0,#8
00053e  4308              ORRS     r0,r0,r1
000540  b2c0              UXTB     r0,r0
000542  9005              STR      r0,[sp,#0x14]
;;;1244   			if(gnDevState == DEVSTATE_DEFAULT)
000544  48d7              LDR      r0,|L27.2212|
000546  6800              LDR      r0,[r0,#0]  ; gnDevState
000548  2800              CMP      r0,#0
00054a  d106              BNE      |L27.1370|
;;;1245   			{
;;;1246   			SEGGER_RTT_printf(0,"gnDevState = DEVSTATE_ADDRESS;	 777 byConfig=%d\n",byConfig);
00054c  a1d6              ADR      r1,|L27.2216|
00054e  9a05              LDR      r2,[sp,#0x14]
000550  f7fffffe          BL       SEGGER_RTT_printf
;;;1247   				bError = TRUE;
000554  2001              MOVS     r0,#1
000556  9008              STR      r0,[sp,#0x20]
000558  e037              B        |L27.1482|
                  |L27.1370|
;;;1248   			}
;;;1249   			/* Assumes configurations are numbered 1 to NumConfigurations */
;;;1250   			else if(byConfig >USB_FSDeviceDescriptor[USB_FSDeviceDescriptorSize-1])
00055a  48e0              LDR      r0,|L27.2268|
00055c  8800              LDRH     r0,[r0,#0]  ; USB_FSDeviceDescriptorSize
00055e  1e40              SUBS     r0,r0,#1
000560  49df              LDR      r1,|L27.2272|
000562  5c09              LDRB     r1,[r1,r0]
000564  9805              LDR      r0,[sp,#0x14]
000566  4281              CMP      r1,r0
000568  da07              BGE      |L27.1402|
;;;1251   			{
;;;1252   			SEGGER_RTT_printf(0,"gnDevState = DEVSTATE_ADDRESS;	 666 byConfig=%d\n",byConfig);
00056a  a1de              ADR      r1,|L27.2276|
00056c  2000              MOVS     r0,#0
00056e  9a05              LDR      r2,[sp,#0x14]
000570  f7fffffe          BL       SEGGER_RTT_printf
;;;1253   				bError = TRUE;
000574  2001              MOVS     r0,#1
000576  9008              STR      r0,[sp,#0x20]
000578  e027              B        |L27.1482|
                  |L27.1402|
;;;1254   			}
;;;1255   			else if(!byConfig)
00057a  9805              LDR      r0,[sp,#0x14]
00057c  2800              CMP      r0,#0
00057e  d106              BNE      |L27.1422|
;;;1256   			{
;;;1257   			
;;;1258   			SEGGER_RTT_printf(0,"gnDevState = DEVSTATE_ADDRESS;	 333\n");
000580  a1e5              ADR      r1,|L27.2328|
000582  f7fffffe          BL       SEGGER_RTT_printf
;;;1259   				gnDevState = DEVSTATE_ADDRESS;
000586  2001              MOVS     r0,#1
000588  49c6              LDR      r1,|L27.2212|
00058a  6008              STR      r0,[r1,#0]  ; gnDevState
00058c  e01d              B        |L27.1482|
                  |L27.1422|
;;;1260   			}
;;;1261   			else
;;;1262   			{
;;;1263   			
;;;1264   			SEGGER_RTT_printf(0,"gnDevState = DEVSTATE_ADDRESS;	 555 byConfig=%d\n",byConfig);
00058e  a1ec              ADR      r1,|L27.2368|
000590  2000              MOVS     r0,#0
000592  9a05              LDR      r2,[sp,#0x14]
000594  f7fffffe          BL       SEGGER_RTT_printf
;;;1265   				/* Get pointer to requested configuration descriptor */
;;;1266   				gpCurCfg = (void *)USB_FSConfigDescriptor;
000598  48f6              LDR      r0,|L27.2420|
00059a  49f7              LDR      r1,|L27.2424|
00059c  6008              STR      r0,[r1,#0]  ; gpCurCfg
;;;1267   				/* Set all alternate settings to zero */
;;;1268   				for (n=0; n<M_MAXIFS; n++)
00059e  2700              MOVS     r7,#0
0005a0  e003              B        |L27.1450|
                  |L27.1442|
;;;1269   					gbyCurIfVal[n] = 0;
0005a2  2000              MOVS     r0,#0
0005a4  49f5              LDR      r1,|L27.2428|
0005a6  55c8              STRB     r0,[r1,r7]
0005a8  1c7f              ADDS     r7,r7,#1              ;1268
                  |L27.1450|
0005aa  2f07              CMP      r7,#7                 ;1268
0005ac  dbf9              BLT      |L27.1442|
;;;1270   				/* Configure endpoints */
;;;1271   				ConfigureIfs();
0005ae  f7fffffe          BL       ConfigureIfs
;;;1272   				
;;;1273   				SEGGER_RTT_printf(0,"gnDevState = DEVSTATE_ADDRESS;  444\n");
0005b2  a1f3              ADR      r1,|L27.2432|
0005b4  2000              MOVS     r0,#0
0005b6  f7fffffe          BL       SEGGER_RTT_printf
;;;1274   				gnDevState = DEVSTATE_CONFIG;
0005ba  2002              MOVS     r0,#2
0005bc  49b9              LDR      r1,|L27.2212|
0005be  6008              STR      r0,[r1,#0]  ; gnDevState
;;;1275   				MWRITE_BYTE(M_REG_INDEX, 0);
0005c0  2000              MOVS     r0,#0
0005c2  49f9              LDR      r1,|L27.2472|
0005c4  7388              STRB     r0,[r1,#0xe]
;;;1276   				bNoData = TRUE;
0005c6  2001              MOVS     r0,#1
0005c8  9007              STR      r0,[sp,#0x1c]
                  |L27.1482|
;;;1277   			}
;;;1278   			
;;;1279   			SEGGER_RTT_printf(0,"b_config == 1\n");
0005ca  a1f8              ADR      r1,|L27.2476|
0005cc  2000              MOVS     r0,#0
0005ce  f7fffffe          BL       SEGGER_RTT_printf
;;;1280   			b_config = 1;
0005d2  2001              MOVS     r0,#1
0005d4  49f9              LDR      r1,|L27.2492|
0005d6  6008              STR      r0,[r1,#0]  ; b_config
;;;1281   			break;
0005d8  e2db              B        |L27.2962|
;;;1282   
;;;1283   		/***用于主机要求设备用某个描述符来描述接口***/		
;;;1284   		case SET_INTERFACE:
;;;1285   			if(gnDevState > DEVSTATE_ADDRESS)
0005da  48b2              LDR      r0,|L27.2212|
0005dc  6800              LDR      r0,[r0,#0]  ; gnDevState
0005de  2801              CMP      r0,#1
0005e0  d920              BLS      |L27.1572|
;;;1286   			{
;;;1287   				n = (int)pcmd->USBwIndex;
0005e2  7968              LDRB     r0,[r5,#5]
0005e4  7929              LDRB     r1,[r5,#4]
0005e6  0207              LSLS     r7,r0,#8
0005e8  430f              ORRS     r7,r7,r1
;;;1288   				pcfg = (PSTD_CFG_DSCR)gpCurCfg;
0005ea  48e3              LDR      r0,|L27.2424|
0005ec  6800              LDR      r0,[r0,#0]  ; gpCurCfg
0005ee  9004              STR      r0,[sp,#0x10]
;;;1289   				if((BYTE)n >= pcfg->bNumInterfaces)
0005f0  b2f9              UXTB     r1,r7
0005f2  9804              LDR      r0,[sp,#0x10]
0005f4  7900              LDRB     r0,[r0,#4]
0005f6  4281              CMP      r1,r0
0005f8  db02              BLT      |L27.1536|
;;;1290   				{
;;;1291   					bError = TRUE;
0005fa  2001              MOVS     r0,#1
0005fc  9008              STR      r0,[sp,#0x20]
0005fe  e013              B        |L27.1576|
                  |L27.1536|
;;;1292   				}
;;;1293   				else 
;;;1294   				{
;;;1295   					gbyCurIfVal[n] = (BYTE)pcmd->USBwValue;
000600  78e8              LDRB     r0,[r5,#3]
000602  78a9              LDRB     r1,[r5,#2]
000604  0200              LSLS     r0,r0,#8
000606  4308              ORRS     r0,r0,r1
000608  49dc              LDR      r1,|L27.2428|
00060a  55c8              STRB     r0,[r1,r7]
;;;1296   					if (ConfigureIfs() == FALSE)
00060c  f7fffffe          BL       ConfigureIfs
000610  2800              CMP      r0,#0
000612  d101              BNE      |L27.1560|
;;;1297   					{
;;;1298   						bError = TRUE;
000614  2001              MOVS     r0,#1
000616  9008              STR      r0,[sp,#0x20]
                  |L27.1560|
;;;1299   					}
;;;1300   					
;;;1301   					MWRITE_BYTE(M_REG_INDEX, 0);
000618  2000              MOVS     r0,#0
00061a  49e3              LDR      r1,|L27.2472|
00061c  7388              STRB     r0,[r1,#0xe]
;;;1302   					bNoData = TRUE;
00061e  2001              MOVS     r0,#1
000620  9007              STR      r0,[sp,#0x1c]
000622  e001              B        |L27.1576|
                  |L27.1572|
;;;1303   				}
;;;1304   			}
;;;1305   			else
;;;1306   			{
;;;1307   				bError = TRUE;
000624  2001              MOVS     r0,#1
000626  9008              STR      r0,[sp,#0x20]
                  |L27.1576|
;;;1308   			}
;;;1309   			break;
000628  e2b3              B        |L27.2962|
;;;1310   
;;;1311   		/***用于主机获取设备当前设备的配置值***/		
;;;1312   		case GET_CONFIGURATION:
;;;1313   			if ((gnDevState == DEVSTATE_ADDRESS) && (!pcmd->USBwValue))
00062a  489e              LDR      r0,|L27.2212|
00062c  6800              LDR      r0,[r0,#0]  ; gnDevState
00062e  2801              CMP      r0,#1
000630  d113              BNE      |L27.1626|
000632  78e8              LDRB     r0,[r5,#3]
000634  78a9              LDRB     r1,[r5,#2]
000636  0200              LSLS     r0,r0,#8
000638  4308              ORRS     r0,r0,r1
00063a  2800              CMP      r0,#0
00063c  d10d              BNE      |L27.1626|
;;;1314   			{
;;;1315   				/* Prepare to return zero */
;;;1316   				pep0state->nBytesLeft = 1;
00063e  1d21              ADDS     r1,r4,#4
000640  2001              MOVS     r0,#1
000642  f7fffffe          BL       __aeabi_uwrite4
;;;1317   				pep0state->pData = (void*)&pcmd->USBwValue;
000646  4621              MOV      r1,r4
000648  3108              ADDS     r1,r1,#8
00064a  1ca8              ADDS     r0,r5,#2
00064c  f7fffffe          BL       __aeabi_uwrite4
;;;1318   				pep0state->nState = M_EP0_TX;
000650  4621              MOV      r1,r4
000652  2002              MOVS     r0,#2
000654  f7fffffe          BL       __aeabi_uwrite4
000658  e017              B        |L27.1674|
                  |L27.1626|
;;;1319   			}
;;;1320   			else if(gnDevState > DEVSTATE_ADDRESS)
00065a  4892              LDR      r0,|L27.2212|
00065c  6800              LDR      r0,[r0,#0]  ; gnDevState
00065e  2801              CMP      r0,#1
000660  d911              BLS      |L27.1670|
;;;1321   			{
;;;1322   				/* Prepare to return configuration value */
;;;1323   				pcfg = (PSTD_CFG_DSCR)gpCurCfg;
000662  48c5              LDR      r0,|L27.2424|
000664  6800              LDR      r0,[r0,#0]  ; gpCurCfg
000666  9004              STR      r0,[sp,#0x10]
;;;1324   				pep0state->nBytesLeft = 1;
000668  1d21              ADDS     r1,r4,#4
00066a  2001              MOVS     r0,#1
00066c  f7fffffe          BL       __aeabi_uwrite4
;;;1325   				pep0state->pData = (void*)&pcfg->bConfigurationValue;
000670  4621              MOV      r1,r4
000672  3108              ADDS     r1,r1,#8
000674  9804              LDR      r0,[sp,#0x10]
000676  1d40              ADDS     r0,r0,#5
000678  f7fffffe          BL       __aeabi_uwrite4
;;;1326   				pep0state->nState = M_EP0_TX;
00067c  4621              MOV      r1,r4
00067e  2002              MOVS     r0,#2
000680  f7fffffe          BL       __aeabi_uwrite4
000684  e001              B        |L27.1674|
                  |L27.1670|
;;;1327   			}
;;;1328   			else
;;;1329   			{
;;;1330   				bError = TRUE;
000686  2001              MOVS     r0,#1
000688  9008              STR      r0,[sp,#0x20]
                  |L27.1674|
;;;1331   			}
;;;1332   			break;
00068a  e282              B        |L27.2962|
;;;1333   
;;;1334   		/***用于获取当前某个接口描述符编号***/	
;;;1335   		case GET_INTERFACE:
;;;1336   			if(gnDevState > DEVSTATE_ADDRESS)
00068c  4885              LDR      r0,|L27.2212|
00068e  6800              LDR      r0,[r0,#0]  ; gnDevState
000690  2801              CMP      r0,#1
000692  d91f              BLS      |L27.1748|
;;;1337   			{
;;;1338   				n = (int)pcmd->USBwIndex;
000694  7968              LDRB     r0,[r5,#5]
000696  7929              LDRB     r1,[r5,#4]
000698  0207              LSLS     r7,r0,#8
00069a  430f              ORRS     r7,r7,r1
;;;1339   				pcfg = (PSTD_CFG_DSCR)gpCurCfg;
00069c  48b6              LDR      r0,|L27.2424|
00069e  6800              LDR      r0,[r0,#0]  ; gpCurCfg
0006a0  9004              STR      r0,[sp,#0x10]
;;;1340   				if((BYTE)n >= pcfg->bNumInterfaces)
0006a2  b2f9              UXTB     r1,r7
0006a4  9804              LDR      r0,[sp,#0x10]
0006a6  7900              LDRB     r0,[r0,#4]
0006a8  4281              CMP      r1,r0
0006aa  db02              BLT      |L27.1714|
;;;1341   				{
;;;1342   					bError = TRUE;
0006ac  2001              MOVS     r0,#1
0006ae  9008              STR      r0,[sp,#0x20]
0006b0  e012              B        |L27.1752|
                  |L27.1714|
;;;1343   				}
;;;1344   				else 
;;;1345   				{
;;;1346   					/* Prepare to return interface value */
;;;1347   					pep0state->nBytesLeft = 1;
0006b2  1d21              ADDS     r1,r4,#4
0006b4  2001              MOVS     r0,#1
0006b6  f7fffffe          BL       __aeabi_uwrite4
;;;1348   					pep0state->pData = (void*)&gpCurIf[n]->bInterfaceNumber;
0006ba  00b9              LSLS     r1,r7,#2
0006bc  4ac0              LDR      r2,|L27.2496|
0006be  5851              LDR      r1,[r2,r1]
0006c0  1c88              ADDS     r0,r1,#2
0006c2  4621              MOV      r1,r4
0006c4  3108              ADDS     r1,r1,#8
0006c6  f7fffffe          BL       __aeabi_uwrite4
;;;1349   					pep0state->nState = M_EP0_TX;
0006ca  4621              MOV      r1,r4
0006cc  2002              MOVS     r0,#2
0006ce  f7fffffe          BL       __aeabi_uwrite4
0006d2  e001              B        |L27.1752|
                  |L27.1748|
;;;1350   				}
;;;1351   			}
;;;1352   			else
;;;1353   				bError = TRUE;
0006d4  2001              MOVS     r0,#1
0006d6  9008              STR      r0,[sp,#0x20]
                  |L27.1752|
;;;1354   			break;
0006d8  e25b              B        |L27.2962|
;;;1355   
;;;1356   		/***用来启用或激活命令接收者的某些特性***/
;;;1357   		case SET_FEATURE:
;;;1358   			switch (pcmd->bmRequestType) 
0006da  7828              LDRB     r0,[r5,#0]
0006dc  2800              CMP      r0,#0
0006de  d004              BEQ      |L27.1770|
0006e0  2801              CMP      r0,#1
0006e2  d018              BEQ      |L27.1814|
0006e4  2802              CMP      r0,#2
0006e6  d158              BNE      |L27.1946|
0006e8  e016              B        |L27.1816|
                  |L27.1770|
;;;1359   			{
;;;1360   					case M_CMD_STDDEVOUT:
;;;1361   						switch (pcmd->USBwValue) 
0006ea  78e8              LDRB     r0,[r5,#3]
0006ec  78a9              LDRB     r1,[r5,#2]
0006ee  0200              LSLS     r0,r0,#8
0006f0  4308              ORRS     r0,r0,r1
0006f2  2801              CMP      r0,#1
0006f4  d10a              BNE      |L27.1804|
;;;1362   						{
;;;1363   							case M_FTR_DEVREMWAKE:
;;;1364   							pInformation->Current_Feature = pInformation->Current_Feature | (0x1<<5);	
0006f6  48b3              LDR      r0,|L27.2500|
0006f8  6800              LDR      r0,[r0,#0]  ; pInformation
0006fa  7840              LDRB     r0,[r0,#1]
0006fc  2120              MOVS     r1,#0x20
0006fe  4308              ORRS     r0,r0,r1
000700  49b0              LDR      r1,|L27.2500|
000702  6809              LDR      r1,[r1,#0]  ; pInformation
000704  7048              STRB     r0,[r1,#1]
;;;1365   							bNoData = TRUE;	
000706  2001              MOVS     r0,#1
000708  9007              STR      r0,[sp,#0x1c]
;;;1366   							break;	
00070a  e002              B        |L27.1810|
                  |L27.1804|
;;;1367   							default:
;;;1368   							bError = TRUE;
00070c  2001              MOVS     r0,#1
00070e  9008              STR      r0,[sp,#0x20]
;;;1369   							break;
000710  bf00              NOP      
                  |L27.1810|
000712  bf00              NOP                            ;1366
;;;1370   						}
;;;1371   					break;
000714  e044              B        |L27.1952|
                  |L27.1814|
;;;1372   						
;;;1373   					case M_CMD_STDIFOUT:
;;;1374   
;;;1375   					/* SET FEATURE for EndPoint*/
;;;1376   					case M_CMD_STDEPOUT:
000716  bf00              NOP      
                  |L27.1816|
;;;1377   
;;;1378   						switch (pcmd->USBwValue0) 
000718  78a8              LDRB     r0,[r5,#2]
00071a  2800              CMP      r0,#0
00071c  d138              BNE      |L27.1936|
;;;1379   						{						
;;;1380   							case M_FTR_EPHALT:
;;;1381   	
;;;1382   							MWRITE_BYTE(M_REG_INDEX,Related_Endpoint);	
00071e  49a2              LDR      r1,|L27.2472|
000720  9803              LDR      r0,[sp,#0xc]
000722  7388              STRB     r0,[r1,#0xe]
;;;1383   							if (pcmd->USBwIndex0 & 0x80)
000724  7928              LDRB     r0,[r5,#4]
000726  2180              MOVS     r1,#0x80
000728  4008              ANDS     r0,r0,r1
00072a  2800              CMP      r0,#0
00072c  d016              BEQ      |L27.1884|
;;;1384   							{
;;;1385   								if(Related_Endpoint)/* IN endpoint */
00072e  9803              LDR      r0,[sp,#0xc]
000730  2800              CMP      r0,#0
000732  d00a              BEQ      |L27.1866|
;;;1386   								{
;;;1387   									srbuff = *((uint8_t*)M_REG_INCSR1);	
000734  489c              LDR      r0,|L27.2472|
000736  7c46              LDRB     r6,[r0,#0x11]
;;;1388   									srbuff = srbuff |(0x1<<4);
000738  2010              MOVS     r0,#0x10
00073a  4306              ORRS     r6,r6,r0
;;;1389   									MWRITE_BYTE(M_REG_INCSR1,srbuff);
00073c  489a              LDR      r0,|L27.2472|
00073e  7446              STRB     r6,[r0,#0x11]
;;;1390   									INCSRDATA = MREAD_BYTE(M_REG_INCSR1);	
000740  7c40              LDRB     r0,[r0,#0x11]
000742  49a1              LDR      r1,|L27.2504|
000744  7008              STRB     r0,[r1,#0]
;;;1391   									__ASM("NOP");
000746  bf00              NOP      
000748  e01c              B        |L27.1924|
                  |L27.1866|
;;;1392   								}
;;;1393   								
;;;1394   								else
;;;1395   								{
;;;1396   									srbuff = *((uint8_t*)M_REG_CSR0);	
00074a  4897              LDR      r0,|L27.2472|
00074c  7c46              LDRB     r6,[r0,#0x11]
;;;1397   									*((uint8_t*)M_REG_CSR0) = srbuff |(0x1<<5);
00074e  2020              MOVS     r0,#0x20
000750  4330              ORRS     r0,r0,r6
000752  4995              LDR      r1,|L27.2472|
000754  7448              STRB     r0,[r1,#0x11]
;;;1398   									srbuff = *((uint8_t*)M_REG_CSR0);	
000756  4608              MOV      r0,r1
000758  7c46              LDRB     r6,[r0,#0x11]
00075a  e013              B        |L27.1924|
                  |L27.1884|
;;;1399   								}
;;;1400   							
;;;1401   							}
;;;1402   
;;;1403   							else
;;;1404   							{
;;;1405   						/* OUT endpoint */
;;;1406   								if(Related_Endpoint)
00075c  9803              LDR      r0,[sp,#0xc]
00075e  2800              CMP      r0,#0
000760  d008              BEQ      |L27.1908|
;;;1407   								{
;;;1408   									srbuff = *((uint8_t*)M_REG_OUTCSR1);	
000762  4891              LDR      r0,|L27.2472|
000764  7d06              LDRB     r6,[r0,#0x14]
;;;1409   									*((uint8_t*)M_REG_OUTCSR1) = srbuff |(0x1<<5);
000766  2020              MOVS     r0,#0x20
000768  4330              ORRS     r0,r0,r6
00076a  498f              LDR      r1,|L27.2472|
00076c  7508              STRB     r0,[r1,#0x14]
;;;1410   									srbuff = *((uint8_t*)M_REG_OUTCSR1);								
00076e  4608              MOV      r0,r1
000770  7d06              LDRB     r6,[r0,#0x14]
000772  e007              B        |L27.1924|
                  |L27.1908|
;;;1411   								}
;;;1412   								
;;;1413   								else
;;;1414   								{
;;;1415   									srbuff = *((uint8_t*)M_REG_CSR0);	
000774  488c              LDR      r0,|L27.2472|
000776  7c46              LDRB     r6,[r0,#0x11]
;;;1416   									*((uint8_t*)M_REG_CSR0) = srbuff |(0x1<<5);
000778  2020              MOVS     r0,#0x20
00077a  4330              ORRS     r0,r0,r6
00077c  498a              LDR      r1,|L27.2472|
00077e  7448              STRB     r0,[r1,#0x11]
;;;1417   									srbuff = *((uint8_t*)M_REG_CSR0);								
000780  4608              MOV      r0,r1
000782  7c46              LDRB     r6,[r0,#0x11]
                  |L27.1924|
;;;1418   								}
;;;1419   													
;;;1420   							}
;;;1421   							bNoData = TRUE;	
000784  2001              MOVS     r0,#1
000786  9007              STR      r0,[sp,#0x1c]
;;;1422   							MWRITE_BYTE(M_REG_INDEX,0);	
000788  2000              MOVS     r0,#0
00078a  4987              LDR      r1,|L27.2472|
00078c  7388              STRB     r0,[r1,#0xe]
;;;1423   							break;
00078e  e002              B        |L27.1942|
                  |L27.1936|
;;;1424   							default:
;;;1425   							bError = TRUE;
000790  2001              MOVS     r0,#1
000792  9008              STR      r0,[sp,#0x20]
;;;1426   							break;
000794  bf00              NOP      
                  |L27.1942|
000796  bf00              NOP                            ;1423
;;;1427   						}
;;;1428   					break;
000798  e002              B        |L27.1952|
                  |L27.1946|
;;;1429   						
;;;1430   					default:
;;;1431   					bError = TRUE;
00079a  2001              MOVS     r0,#1
00079c  9008              STR      r0,[sp,#0x20]
;;;1432   					break;
00079e  bf00              NOP      
                  |L27.1952|
0007a0  bf00              NOP                            ;1371
;;;1433   			}
;;;1434   		break;
0007a2  e1f6              B        |L27.2962|
;;;1435   			
;;;1436   		/***用来CLEAR接收者的某些特性***/			
;;;1437   		case CLEAR_FEATURE:
;;;1438   			switch (pcmd->bmRequestType) 
0007a4  7828              LDRB     r0,[r5,#0]
0007a6  2800              CMP      r0,#0
0007a8  d004              BEQ      |L27.1972|
0007aa  2801              CMP      r0,#1
0007ac  d018              BEQ      |L27.2016|
0007ae  2802              CMP      r0,#2
0007b0  d144              BNE      |L27.2108|
0007b2  e016              B        |L27.2018|
                  |L27.1972|
;;;1439   			{
;;;1440   					case M_CMD_STDDEVOUT:
;;;1441   						switch (pcmd->USBwValue) 
0007b4  78e8              LDRB     r0,[r5,#3]
0007b6  78a9              LDRB     r1,[r5,#2]
0007b8  0200              LSLS     r0,r0,#8
0007ba  4308              ORRS     r0,r0,r1
0007bc  2801              CMP      r0,#1
0007be  d10a              BNE      |L27.2006|
;;;1442   						{
;;;1443   							case M_FTR_DEVREMWAKE:
;;;1444   							pInformation->Current_Feature = pInformation->Current_Feature & (~(0x1<<5));
0007c0  4880              LDR      r0,|L27.2500|
0007c2  6800              LDR      r0,[r0,#0]  ; pInformation
0007c4  7840              LDRB     r0,[r0,#1]
0007c6  2120              MOVS     r1,#0x20
0007c8  4388              BICS     r0,r0,r1
0007ca  497e              LDR      r1,|L27.2500|
0007cc  6809              LDR      r1,[r1,#0]  ; pInformation
0007ce  7048              STRB     r0,[r1,#1]
;;;1445   							bNoData = TRUE;	
0007d0  2001              MOVS     r0,#1
0007d2  9007              STR      r0,[sp,#0x1c]
;;;1446   							break;
0007d4  e002              B        |L27.2012|
                  |L27.2006|
;;;1447   							default:
;;;1448   							bError = TRUE;
0007d6  2001              MOVS     r0,#1
0007d8  9008              STR      r0,[sp,#0x20]
;;;1449   							break;
0007da  bf00              NOP      
                  |L27.2012|
0007dc  bf00              NOP                            ;1446
;;;1450   						}
;;;1451   					break;
0007de  e121              B        |L27.2596|
                  |L27.2016|
;;;1452   						
;;;1453   					case M_CMD_STDIFOUT:
;;;1454   
;;;1455   					/* CLEAR FEATURE for EndPoint*/
;;;1456   					case M_CMD_STDEPOUT:
0007e0  bf00              NOP      
                  |L27.2018|
;;;1457   						switch (pcmd->USBwValue0) 
0007e2  78a8              LDRB     r0,[r5,#2]
0007e4  2800              CMP      r0,#0
0007e6  d12a              BNE      |L27.2110|
;;;1458   						{
;;;1459   							case M_FTR_EPHALT:						
;;;1460   							MWRITE_BYTE(M_REG_INDEX,Related_Endpoint);	
0007e8  496f              LDR      r1,|L27.2472|
0007ea  9803              LDR      r0,[sp,#0xc]
0007ec  7388              STRB     r0,[r1,#0xe]
;;;1461   							if (pcmd->USBwIndex0 & 0x80)
0007ee  7928              LDRB     r0,[r5,#4]
0007f0  2180              MOVS     r1,#0x80
0007f2  4008              ANDS     r0,r0,r1
0007f4  2800              CMP      r0,#0
0007f6  d023              BEQ      |L27.2112|
;;;1462   							{/* IN endpoint */
;;;1463   								if(Related_Endpoint)
0007f8  9803              LDR      r0,[sp,#0xc]
0007fa  2800              CMP      r0,#0
0007fc  d014              BEQ      |L27.2088|
;;;1464   								{
;;;1465   //									*((uint8_t*)M_REG_INCSR1) = *((uint8_t*)M_REG_INCSR1) & (~(0x01<<6));
;;;1466   									srbuff = *((uint8_t*)M_REG_INCSR1);	
0007fe  486a              LDR      r0,|L27.2472|
000800  7c46              LDRB     r6,[r0,#0x11]
;;;1467   									*((uint8_t*)M_REG_INCSR1) = srbuff & (~(0x01<<6));
000802  2140              MOVS     r1,#0x40
000804  4630              MOV      r0,r6
000806  4388              BICS     r0,r0,r1
000808  4967              LDR      r1,|L27.2472|
00080a  7448              STRB     r0,[r1,#0x11]
;;;1468   									srbuff = *((uint8_t*)M_REG_INCSR1);											
00080c  4608              MOV      r0,r1
00080e  7c46              LDRB     r6,[r0,#0x11]
;;;1469   									
;;;1470   //									*((uint8_t*)M_REG_INCSR1) = *((uint8_t*)M_REG_INCSR1) & (~(0x01<<4));
;;;1471   									srbuff = *((uint8_t*)M_REG_INCSR1);	
000810  7c46              LDRB     r6,[r0,#0x11]
;;;1472   									*((uint8_t*)M_REG_INCSR1) = srbuff & (~(0x01<<4));	
000812  2110              MOVS     r1,#0x10
000814  4630              MOV      r0,r6
000816  4388              BICS     r0,r0,r1
000818  4963              LDR      r1,|L27.2472|
00081a  7448              STRB     r0,[r1,#0x11]
;;;1473   									INCSRDATA = *((uint8_t*)M_REG_INCSR1);	
00081c  4608              MOV      r0,r1
00081e  7c40              LDRB     r0,[r0,#0x11]
000820  4969              LDR      r1,|L27.2504|
000822  7008              STRB     r0,[r1,#0]
;;;1474   									__ASM("NOP");
000824  bf00              NOP      
000826  e0ef              B        |L27.2568|
                  |L27.2088|
;;;1475   								}
;;;1476   								
;;;1477   								else
;;;1478   								{
;;;1479   //									*((uint8_t*)M_REG_CSR0) = *((uint8_t*)M_REG_CSR0) & (~(0x01<<5));
;;;1480   									srbuff = *((uint8_t*)M_REG_CSR0);	
000828  485f              LDR      r0,|L27.2472|
00082a  7c46              LDRB     r6,[r0,#0x11]
;;;1481   									*((uint8_t*)M_REG_CSR0) = srbuff & (~(0x01<<5));
00082c  2120              MOVS     r1,#0x20
00082e  4630              MOV      r0,r6
000830  4388              BICS     r0,r0,r1
000832  495d              LDR      r1,|L27.2472|
000834  7448              STRB     r0,[r1,#0x11]
;;;1482   									srbuff = *((uint8_t*)M_REG_CSR0);										
000836  4608              MOV      r0,r1
000838  7c46              LDRB     r6,[r0,#0x11]
00083a  e0e5              B        |L27.2568|
                  |L27.2108|
00083c  e0ef              B        |L27.2590|
                  |L27.2110|
00083e  e0e9              B        |L27.2580|
                  |L27.2112|
000840  e0c4              B        |L27.2508|
                  |L27.2114|
000842  e1a3              B        |L27.2956|
                  |L27.2116|
                          DCD      iapStringDescriptorSize
                  |L27.2120|
000848  5553425f          DCB      "USB_StdDev_Req;  444 pcmd->USBwLength=%d\n",0
00084c  53746444
000850  65765f52
000854  65713b20
000858  20343434
00085c  2070636d
000860  642d3e55
000864  5342774c
000868  656e6774
00086c  683d2564
000870  0a00    
000872  00                DCB      0
000873  00                DCB      0
                  |L27.2164|
000874  5553425f          DCB      "USB_StdDev_Req;  444 pcmd->nBytesLeft=%d\n",0
000878  53746444
00087c  65765f52
000880  65713b20
000884  20343434
000888  2070636d
00088c  642d3e6e
000890  42797465
000894  734c6566
000898  743d2564
00089c  0a00    
00089e  00                DCB      0
00089f  00                DCB      0
                  |L27.2208|
                          DCD      iapStringDescriptor
                  |L27.2212|
                          DCD      gnDevState
                  |L27.2216|
0008a8  676e4465          DCB      "gnDevState = DEVSTATE_ADDRESS;\t 777 byConfig=%d\n",0
0008ac  76537461
0008b0  7465203d
0008b4  20444556
0008b8  53544154
0008bc  455f4144
0008c0  44524553
0008c4  533b0920
0008c8  37373720
0008cc  6279436f
0008d0  6e666967
0008d4  3d25640a
0008d8  00      
0008d9  00                DCB      0
0008da  00                DCB      0
0008db  00                DCB      0
                  |L27.2268|
                          DCD      USB_FSDeviceDescriptorSize
                  |L27.2272|
                          DCD      USB_FSDeviceDescriptor
                  |L27.2276|
0008e4  676e4465          DCB      "gnDevState = DEVSTATE_ADDRESS;\t 666 byConfig=%d\n",0
0008e8  76537461
0008ec  7465203d
0008f0  20444556
0008f4  53544154
0008f8  455f4144
0008fc  44524553
000900  533b0920
000904  36363620
000908  6279436f
00090c  6e666967
000910  3d25640a
000914  00      
000915  00                DCB      0
000916  00                DCB      0
000917  00                DCB      0
                  |L27.2328|
000918  676e4465          DCB      "gnDevState = DEVSTATE_ADDRESS;\t 333\n",0
00091c  76537461
000920  7465203d
000924  20444556
000928  53544154
00092c  455f4144
000930  44524553
000934  533b0920
000938  3333330a
00093c  00      
00093d  00                DCB      0
00093e  00                DCB      0
00093f  00                DCB      0
                  |L27.2368|
000940  676e4465          DCB      "gnDevState = DEVSTATE_ADDRESS;\t 555 byConfig=%d\n",0
000944  76537461
000948  7465203d
00094c  20444556
000950  53544154
000954  455f4144
000958  44524553
00095c  533b0920
000960  35353520
000964  6279436f
000968  6e666967
00096c  3d25640a
000970  00      
000971  00                DCB      0
000972  00                DCB      0
000973  00                DCB      0
                  |L27.2420|
                          DCD      USB_FSConfigDescriptor
                  |L27.2424|
                          DCD      gpCurCfg
                  |L27.2428|
                          DCD      gbyCurIfVal
                  |L27.2432|
000980  676e4465          DCB      "gnDevState = DEVSTATE_ADDRESS;  444\n",0
000984  76537461
000988  7465203d
00098c  20444556
000990  53544154
000994  455f4144
000998  44524553
00099c  533b2020
0009a0  3434340a
0009a4  00      
0009a5  00                DCB      0
0009a6  00                DCB      0
0009a7  00                DCB      0
                  |L27.2472|
                          DCD      0x40005c00
                  |L27.2476|
0009ac  625f636f          DCB      "b_config == 1\n",0
0009b0  6e666967
0009b4  203d3d20
0009b8  310a00  
0009bb  00                DCB      0
                  |L27.2492|
                          DCD      b_config
                  |L27.2496|
                          DCD      gpCurIf
                  |L27.2500|
                          DCD      pInformation
                  |L27.2504|
                          DCD      INCSRDATA
                  |L27.2508|
;;;1483   									
;;;1484   								}
;;;1485   									
;;;1486   							}
;;;1487   
;;;1488   							else
;;;1489   							{
;;;1490   								/* OUT endpoint */
;;;1491   								if(Related_Endpoint)
0009cc  9803              LDR      r0,[sp,#0xc]
0009ce  2800              CMP      r0,#0
0009d0  d011              BEQ      |L27.2550|
;;;1492   								{
;;;1493   //									*((uint8_t*)M_REG_OUTCSR1) = *((uint8_t*)M_REG_OUTCSR1) & (~(0x01<<7));
;;;1494   //									*((uint8_t*)M_REG_OUTCSR1) = *((uint8_t*)M_REG_OUTCSR1) & (~(0x01<<5));
;;;1495   									srbuff = *((uint8_t*)M_REG_OUTCSR1);	
0009d2  487a              LDR      r0,|L27.3004|
0009d4  7d06              LDRB     r6,[r0,#0x14]
;;;1496   									*((uint8_t*)M_REG_OUTCSR1) = srbuff & (~(0x01<<7));
0009d6  2180              MOVS     r1,#0x80
0009d8  4630              MOV      r0,r6
0009da  4388              BICS     r0,r0,r1
0009dc  4977              LDR      r1,|L27.3004|
0009de  7508              STRB     r0,[r1,#0x14]
;;;1497   									srbuff = *((uint8_t*)M_REG_OUTCSR1);											
0009e0  4608              MOV      r0,r1
0009e2  7d06              LDRB     r6,[r0,#0x14]
;;;1498   									
;;;1499   									srbuff = *((uint8_t*)M_REG_OUTCSR1);	
0009e4  7d06              LDRB     r6,[r0,#0x14]
;;;1500   									*((uint8_t*)M_REG_OUTCSR1) = srbuff & (~(0x01<<5));
0009e6  2120              MOVS     r1,#0x20
0009e8  4630              MOV      r0,r6
0009ea  4388              BICS     r0,r0,r1
0009ec  4973              LDR      r1,|L27.3004|
0009ee  7508              STRB     r0,[r1,#0x14]
;;;1501   									srbuff = *((uint8_t*)M_REG_OUTCSR1);				
0009f0  4608              MOV      r0,r1
0009f2  7d06              LDRB     r6,[r0,#0x14]
0009f4  e008              B        |L27.2568|
                  |L27.2550|
;;;1502   									
;;;1503   								}
;;;1504   								
;;;1505   								else
;;;1506   								{
;;;1507   //									*((uint8_t*)M_REG_CSR0) = *((uint8_t*)M_REG_CSR0)  & (~(0x01<<5));
;;;1508   									srbuff = *((uint8_t*)M_REG_CSR0);	
0009f6  4871              LDR      r0,|L27.3004|
0009f8  7c46              LDRB     r6,[r0,#0x11]
;;;1509   									*((uint8_t*)M_REG_CSR0) = srbuff & (~(0x01<<5));
0009fa  2120              MOVS     r1,#0x20
0009fc  4630              MOV      r0,r6
0009fe  4388              BICS     r0,r0,r1
000a00  496e              LDR      r1,|L27.3004|
000a02  7448              STRB     r0,[r1,#0x11]
;;;1510   									srbuff = *((uint8_t*)M_REG_CSR0);											
000a04  4608              MOV      r0,r1
000a06  7c46              LDRB     r6,[r0,#0x11]
                  |L27.2568|
;;;1511   								}
;;;1512   													
;;;1513   							}
;;;1514   								bNoData = TRUE;	
000a08  2001              MOVS     r0,#1
000a0a  9007              STR      r0,[sp,#0x1c]
;;;1515   								MWRITE_BYTE(M_REG_INDEX,0);
000a0c  2000              MOVS     r0,#0
000a0e  496b              LDR      r1,|L27.3004|
000a10  7388              STRB     r0,[r1,#0xe]
;;;1516   								break;
000a12  e002              B        |L27.2586|
                  |L27.2580|
;;;1517   						
;;;1518   							default:
;;;1519   							bError = TRUE;
000a14  2001              MOVS     r0,#1
000a16  9008              STR      r0,[sp,#0x20]
;;;1520   							break;
000a18  bf00              NOP      
                  |L27.2586|
000a1a  bf00              NOP                            ;1516
;;;1521   						}
;;;1522   				break;
000a1c  e002              B        |L27.2596|
                  |L27.2590|
;;;1523   						
;;;1524   				default:
;;;1525   				bError = TRUE;
000a1e  2001              MOVS     r0,#1
000a20  9008              STR      r0,[sp,#0x20]
;;;1526   				break;		
000a22  bf00              NOP      
                  |L27.2596|
000a24  bf00              NOP                            ;1451
;;;1527   			}
;;;1528   		break;	
000a26  e0b4              B        |L27.2962|
;;;1529   			
;;;1530   			
;;;1531   		/***用于主机获取设备 STATUS***/					
;;;1532   		case GET_STATUS:	
;;;1533   		
;;;1534   			switch (pcmd->bmRequestType) 
000a28  7828              LDRB     r0,[r5,#0]
000a2a  2880              CMP      r0,#0x80
000a2c  d004              BEQ      |L27.2616|
000a2e  2881              CMP      r0,#0x81
000a30  d03b              BEQ      |L27.2730|
000a32  2882              CMP      r0,#0x82
000a34  d172              BNE      |L27.2844|
000a36  e046              B        |L27.2758|
                  |L27.2616|
;;;1535   			{
;;;1536   
;;;1537   				 /* GET STATUS for Device*/
;;;1538   					case M_CMD_STDDEVIN:
;;;1539   						
;;;1540   					if (pInformation->Current_Feature & (0x1<<5))
000a38  4861              LDR      r0,|L27.3008|
000a3a  6800              LDR      r0,[r0,#0]  ; pInformation
000a3c  7840              LDRB     r0,[r0,#1]
000a3e  2120              MOVS     r1,#0x20
000a40  4008              ANDS     r0,r0,r1
000a42  2800              CMP      r0,#0
000a44  d006              BEQ      |L27.2644|
;;;1541   					{
;;;1542   						txdat[0] |=(0x1<<1);						
000a46  4669              MOV      r1,sp
000a48  7908              LDRB     r0,[r1,#4]
000a4a  2102              MOVS     r1,#2
000a4c  4308              ORRS     r0,r0,r1
000a4e  4669              MOV      r1,sp
000a50  7108              STRB     r0,[r1,#4]
000a52  e005              B        |L27.2656|
                  |L27.2644|
;;;1543   					}
;;;1544   					else
;;;1545   					{
;;;1546   						txdat[0] &= ~(0x1<<1);	
000a54  4669              MOV      r1,sp
000a56  7908              LDRB     r0,[r1,#4]
000a58  2102              MOVS     r1,#2
000a5a  4388              BICS     r0,r0,r1
000a5c  4669              MOV      r1,sp
000a5e  7108              STRB     r0,[r1,#4]
                  |L27.2656|
;;;1547   					} 
;;;1548   					if (pInformation->Current_Feature & (0x1<<6))
000a60  4857              LDR      r0,|L27.3008|
000a62  6800              LDR      r0,[r0,#0]  ; pInformation
000a64  7840              LDRB     r0,[r0,#1]
000a66  2140              MOVS     r1,#0x40
000a68  4008              ANDS     r0,r0,r1
000a6a  2800              CMP      r0,#0
000a6c  d006              BEQ      |L27.2684|
;;;1549   					{
;;;1550   						txdat[0] |=(0x1<<0);						
000a6e  4669              MOV      r1,sp
000a70  7908              LDRB     r0,[r1,#4]
000a72  2101              MOVS     r1,#1
000a74  4308              ORRS     r0,r0,r1
000a76  4669              MOV      r1,sp
000a78  7108              STRB     r0,[r1,#4]
000a7a  e005              B        |L27.2696|
                  |L27.2684|
;;;1551   					}
;;;1552   					else
;;;1553   					{
;;;1554   						txdat[0] &= ~(0x1<<0);	
000a7c  4668              MOV      r0,sp
000a7e  7900              LDRB     r0,[r0,#4]
000a80  0841              LSRS     r1,r0,#1
000a82  0049              LSLS     r1,r1,#1
000a84  4668              MOV      r0,sp
000a86  7101              STRB     r1,[r0,#4]
                  |L27.2696|
;;;1555   					} 					
;;;1556   					
;;;1557   					txdat[1]=0;
000a88  2000              MOVS     r0,#0
000a8a  4669              MOV      r1,sp
000a8c  7148              STRB     r0,[r1,#5]
;;;1558   					pep0state->nBytesLeft = 2;
000a8e  1d21              ADDS     r1,r4,#4
000a90  2002              MOVS     r0,#2
000a92  f7fffffe          BL       __aeabi_uwrite4
;;;1559   					pep0state->pData = txdat;
000a96  4621              MOV      r1,r4
000a98  3108              ADDS     r1,r1,#8
000a9a  a801              ADD      r0,sp,#4
000a9c  f7fffffe          BL       __aeabi_uwrite4
;;;1560   					pep0state->nState = M_EP0_TX;	
000aa0  4621              MOV      r1,r4
000aa2  2002              MOVS     r0,#2
000aa4  f7fffffe          BL       __aeabi_uwrite4
;;;1561   					break;
000aa8  e06e              B        |L27.2952|
                  |L27.2730|
;;;1562   					
;;;1563   				/* GET STATUS for Interface*/		
;;;1564   					case M_CMD_STDIFIN:
;;;1565   					pep0state->nBytesLeft = 2;
000aaa  1d21              ADDS     r1,r4,#4
000aac  2002              MOVS     r0,#2
000aae  f7fffffe          BL       __aeabi_uwrite4
;;;1566   					pep0state->pData = txdat;
000ab2  4621              MOV      r1,r4
000ab4  3108              ADDS     r1,r1,#8
000ab6  a801              ADD      r0,sp,#4
000ab8  f7fffffe          BL       __aeabi_uwrite4
;;;1567   					pep0state->nState = M_EP0_TX;	
000abc  4621              MOV      r1,r4
000abe  2002              MOVS     r0,#2
000ac0  f7fffffe          BL       __aeabi_uwrite4
;;;1568   					break;
000ac4  e060              B        |L27.2952|
                  |L27.2758|
;;;1569   				/* GET STATUS for EndPoint*/
;;;1570   					case M_CMD_STDEPIN:									
;;;1571   					
;;;1572   					if (pcmd->USBwIndex0 & 0x80)
000ac6  7928              LDRB     r0,[r5,#4]
000ac8  2180              MOVS     r1,#0x80
000aca  4008              ANDS     r0,r0,r1
000acc  2800              CMP      r0,#0
000ace  d026              BEQ      |L27.2846|
;;;1573   					{	
;;;1574   						if(Related_Endpoint){
000ad0  9803              LDR      r0,[sp,#0xc]
000ad2  2800              CMP      r0,#0
000ad4  d014              BEQ      |L27.2816|
;;;1575   							MWRITE_BYTE(M_REG_INDEX,Related_Endpoint);
000ad6  4939              LDR      r1,|L27.3004|
000ad8  9803              LDR      r0,[sp,#0xc]
000ada  7388              STRB     r0,[r1,#0xe]
;;;1576   							INCSRDATA = MREAD_BYTE(M_REG_INCSR1);
000adc  4608              MOV      r0,r1
000ade  7c40              LDRB     r0,[r0,#0x11]
000ae0  4938              LDR      r1,|L27.3012|
000ae2  7008              STRB     r0,[r1,#0]
;;;1577   							if(INCSRDATA & (0x1<<4))
000ae4  4608              MOV      r0,r1
000ae6  7800              LDRB     r0,[r0,#0]  ; INCSRDATA
000ae8  2110              MOVS     r1,#0x10
000aea  4008              ANDS     r0,r0,r1
000aec  2800              CMP      r0,#0
000aee  d003              BEQ      |L27.2808|
;;;1578   								txdat[0] = 1;	
000af0  2001              MOVS     r0,#1
000af2  4669              MOV      r1,sp
000af4  7108              STRB     r0,[r1,#4]
000af6  e030              B        |L27.2906|
                  |L27.2808|
;;;1579   							else txdat[0] = 0;	
000af8  2000              MOVS     r0,#0
000afa  4669              MOV      r1,sp
000afc  7108              STRB     r0,[r1,#4]
000afe  e02c              B        |L27.2906|
                  |L27.2816|
;;;1580   						}
;;;1581   						else
;;;1582   							if(*((uint8_t*)M_REG_CSR0) & (0x1<<2))
000b00  482e              LDR      r0,|L27.3004|
000b02  7c40              LDRB     r0,[r0,#0x11]
000b04  2104              MOVS     r1,#4
000b06  4008              ANDS     r0,r0,r1
000b08  2800              CMP      r0,#0
000b0a  d003              BEQ      |L27.2836|
;;;1583   							txdat[0] = 1;	
000b0c  2001              MOVS     r0,#1
000b0e  4669              MOV      r1,sp
000b10  7108              STRB     r0,[r1,#4]
000b12  e022              B        |L27.2906|
                  |L27.2836|
;;;1584   							else txdat[0] = 0;								
000b14  2000              MOVS     r0,#0
000b16  4669              MOV      r1,sp
000b18  7108              STRB     r0,[r1,#4]
000b1a  e01e              B        |L27.2906|
                  |L27.2844|
000b1c  e031              B        |L27.2946|
                  |L27.2846|
;;;1585   					}
;;;1586   
;;;1587   					else
;;;1588   					{
;;;1589   						if(Related_Endpoint){
000b1e  9803              LDR      r0,[sp,#0xc]
000b20  2800              CMP      r0,#0
000b22  d00d              BEQ      |L27.2880|
;;;1590   							if(*((uint8_t*)M_REG_OUTCSR1) & (0x1<<5))
000b24  4825              LDR      r0,|L27.3004|
000b26  7d00              LDRB     r0,[r0,#0x14]
000b28  2120              MOVS     r1,#0x20
000b2a  4008              ANDS     r0,r0,r1
000b2c  2800              CMP      r0,#0
000b2e  d003              BEQ      |L27.2872|
;;;1591   								txdat[0] = 1;	
000b30  2001              MOVS     r0,#1
000b32  4669              MOV      r1,sp
000b34  7108              STRB     r0,[r1,#4]
000b36  e010              B        |L27.2906|
                  |L27.2872|
;;;1592   							else txdat[0] = 0;	
000b38  2000              MOVS     r0,#0
000b3a  4669              MOV      r1,sp
000b3c  7108              STRB     r0,[r1,#4]
000b3e  e00c              B        |L27.2906|
                  |L27.2880|
;;;1593   						}
;;;1594   						else
;;;1595   							if(*((uint8_t*)M_REG_CSR0) & (0x1<<2))
000b40  481e              LDR      r0,|L27.3004|
000b42  7c40              LDRB     r0,[r0,#0x11]
000b44  2104              MOVS     r1,#4
000b46  4008              ANDS     r0,r0,r1
000b48  2800              CMP      r0,#0
000b4a  d003              BEQ      |L27.2900|
;;;1596   							txdat[0] = 1;	
000b4c  2001              MOVS     r0,#1
000b4e  4669              MOV      r1,sp
000b50  7108              STRB     r0,[r1,#4]
000b52  e002              B        |L27.2906|
                  |L27.2900|
;;;1597   							else txdat[0] = 0;								
000b54  2000              MOVS     r0,#0
000b56  4669              MOV      r1,sp
000b58  7108              STRB     r0,[r1,#4]
                  |L27.2906|
;;;1598   					}		
;;;1599   					txdat[1]=0;
000b5a  2000              MOVS     r0,#0
000b5c  4669              MOV      r1,sp
000b5e  7148              STRB     r0,[r1,#5]
;;;1600   					pep0state->nBytesLeft = 2;
000b60  1d21              ADDS     r1,r4,#4
000b62  2002              MOVS     r0,#2
000b64  f7fffffe          BL       __aeabi_uwrite4
;;;1601   					pep0state->pData = txdat;
000b68  4621              MOV      r1,r4
000b6a  3108              ADDS     r1,r1,#8
000b6c  a801              ADD      r0,sp,#4
000b6e  f7fffffe          BL       __aeabi_uwrite4
;;;1602   					pep0state->nState = M_EP0_TX;	
000b72  4621              MOV      r1,r4
000b74  2002              MOVS     r0,#2
000b76  f7fffffe          BL       __aeabi_uwrite4
;;;1603   					MWRITE_BYTE(M_REG_INDEX,0);	
000b7a  2000              MOVS     r0,#0
000b7c  490f              LDR      r1,|L27.3004|
000b7e  7388              STRB     r0,[r1,#0xe]
;;;1604   					break;
000b80  e002              B        |L27.2952|
                  |L27.2946|
;;;1605   					
;;;1606   					default:
;;;1607   					bError = TRUE;
000b82  2001              MOVS     r0,#1
000b84  9008              STR      r0,[sp,#0x20]
;;;1608   					break;
000b86  bf00              NOP      
                  |L27.2952|
000b88  bf00              NOP                            ;1561
;;;1609   				
;;;1610   			}
;;;1611   		break;	
000b8a  e002              B        |L27.2962|
                  |L27.2956|
;;;1612   
;;;1613   			
;;;1614   		/***不可识别的请求***/
;;;1615   		default:
;;;1616   			/* Stall the command if an unrecognized request is received */
;;;1617   			bError = TRUE;
000b8c  2001              MOVS     r0,#1
000b8e  9008              STR      r0,[sp,#0x20]
;;;1618   		break;
000b90  bf00              NOP      
                  |L27.2962|
000b92  bf00              NOP                            ;1046
;;;1619    }
;;;1620   
;;;1621   	/* Stall command if an error occurred */
;;;1622   	if (bError)
000b94  9808              LDR      r0,[sp,#0x20]
000b96  2800              CMP      r0,#0
000b98  d002              BEQ      |L27.2976|
;;;1623   	{
;;;1624   		/***清零 OUTPKTRDY 位,终止当前传输***/
;;;1625   		by = M_CSR0_SVDOUTPKTRDY | M_CSR0_SENDSTALL;
000b9a  2060              MOVS     r0,#0x60
000b9c  9006              STR      r0,[sp,#0x18]
000b9e  e007              B        |L27.2992|
                  |L27.2976|
;;;1626   	}
;;;1627   	else if(bNoData)
000ba0  9807              LDR      r0,[sp,#0x1c]
000ba2  2800              CMP      r0,#0
000ba4  d002              BEQ      |L27.2988|
;;;1628   	{
;;;1629   //		FIFOWrite(0, 0, pep0state->pData);
;;;1630   //		by = M_CSR0_INPKTRDY | M_CSR0_DATAEND;
;;;1631   //		MWRITE_BYTE(M_REG_CSR0, by);
;;;1632   		/***清零 OUTPKTRDY 位,在发送时表示，将要发送的时最后一包数据；接收时将要接收的是最后一包数据；***/
;;;1633   		by = M_CSR0_SVDOUTPKTRDY | M_CSR0_DATAEND;
000ba6  2048              MOVS     r0,#0x48
000ba8  9006              STR      r0,[sp,#0x18]
000baa  e001              B        |L27.2992|
                  |L27.2988|
;;;1634   //					pep0state->nBytesLeft = 0;
;;;1635   //					pep0state->nState = M_EP0_TX;			
;;;1636   	}
;;;1637   	else
;;;1638   	{
;;;1639   		/***清零 OUTPKTRDY 位***/
;;;1640   		by = M_CSR0_SVDOUTPKTRDY;
000bac  2040              MOVS     r0,#0x40
000bae  9006              STR      r0,[sp,#0x18]
                  |L27.2992|
;;;1641   	}
;;;1642   	
;;;1643   	MWRITE_BYTE(M_REG_CSR0, by);
000bb0  4902              LDR      r1,|L27.3004|
000bb2  9806              LDR      r0,[sp,#0x18]
000bb4  7448              STRB     r0,[r1,#0x11]
;;;1644   
;;;1645   	return;
;;;1646   	
;;;1647   }
000bb6  b009              ADD      sp,sp,#0x24
000bb8  bdf0              POP      {r4-r7,pc}
;;;1648   
                          ENDP

000bba  0000              DCW      0x0000
                  |L27.3004|
                          DCD      0x40005c00
                  |L27.3008|
                          DCD      pInformation
                  |L27.3012|
                          DCD      INCSRDATA

                          AREA ||i.USB_Suspend||, CODE, READONLY, ALIGN=2

                  USB_Suspend PROC
;;;247    */
;;;248    void USB_Suspend(void)
000000  4809              LDR      r0,|L28.40|
;;;249    {
;;;250    	if(usb_state == USB_SUSPEND_FLAG)
000002  7800              LDRB     r0,[r0,#0]  ; usb_state
000004  2801              CMP      r0,#1
000006  d106              BNE      |L28.22|
;;;251    	{
;;;252    		USB->POWER |= 0x01;//允许挂起模块
000008  4808              LDR      r0,|L28.44|
00000a  7840              LDRB     r0,[r0,#1]
00000c  2101              MOVS     r1,#1
00000e  4308              ORRS     r0,r0,r1
000010  4906              LDR      r1,|L28.44|
000012  7048              STRB     r0,[r1,#1]
000014  e006              B        |L28.36|
                  |L28.22|
;;;253    		
;;;254    		/*关闭一些时钟省电*/
;;;255    		
;;;256    		/*结束*/
;;;257    		
;;;258    //		while(USB->POWER & 0x02)								//suspend flag
;;;259    //		{	
;;;260    //			GPIOB->ODR ^= GPIO_Pin_2;
;;;261    ////			SysTick_Delay_Ms(500);
;;;262    //			if(GPIO_ReadInputDataBit(GPIOC,GPIO_Pin_11) == RESET)//按键唤醒
;;;263    //			{
;;;264    //				/*remote wakeup*/
;;;265    //				USB_Remote_Wakeup();
;;;266    //				
;;;267    //				f_send_kb = 1;
;;;268    //				USB->POWER &= ~0x01;							//不允许挂起模块	
;;;269    //				usb_state = USB_NORMAL;
;;;270    //			}
;;;271    //		}
;;;272    		
;;;273    		/*重新配置时钟*/	
;;;274    	}
;;;275    	else if(usb_state == USB_RESUME_FLAG)						//自动退出suspend
000016  4804              LDR      r0,|L28.40|
000018  7800              LDRB     r0,[r0,#0]  ; usb_state
00001a  2802              CMP      r0,#2
00001c  d102              BNE      |L28.36|
;;;276    	{
;;;277    		usb_state = USB_NORMAL;
00001e  2000              MOVS     r0,#0
000020  4901              LDR      r1,|L28.40|
000022  7008              STRB     r0,[r1,#0]
                  |L28.36|
;;;278    		/*重新配置时钟*/
;;;279    	}
;;;280    }
000024  4770              BX       lr
;;;281    /******************************************************************************
                          ENDP

000026  0000              DCW      0x0000
                  |L28.40|
                          DCD      usb_state
                  |L28.44|
                          DCD      0x40005c00

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  c_hid_data
                          %        88
                  gpCurIf
                          %        28
                  Device_Info
                          %        15
                  ep1_send_buf
                          %        64
                  ep0state
                          %        17

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  5553425f          DCB      0x55,0x53,0x42,0x5f
000004  49525148          DCB      0x49,0x52,0x51,0x48
000008  616e646c          DCB      0x61,0x6e,0x64,0x6c
00000c  657200            DCB      0x65,0x72,0x00

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  5553425f          DCB      "USB_IRQHandler ###usb_intrin =0x%02x usb_intrusb =0x%02"
000004  49525148
000008  616e646c
00000c  65722023
000010  23237573
000014  625f696e
000018  7472696e
00001c  203d3078
000020  25303278
000024  20757362
000028  5f696e74
00002c  72757362
000030  203d3078
000034  253032  
000037  78202323          DCB      "x ###usb_introut =0x%02x\n",0
00003b  23757362
00003f  5f696e74
000043  726f7574
000047  203d3078
00004b  25303278
00004f  0a00    
000051  00                DCB      0
000052  00                DCB      0
000053  00                DCB      0
000054  5553425f          DCB      "USB_IRQHandler ########################################"
000058  49525148
00005c  616e646c
000060  65722023
000064  23232323
000068  23232323
00006c  23232323
000070  23232323
000074  23232323
000078  23232323
00007c  23232323
000080  23232323
000084  23232323
000088  232323  
00008b  23232323          DCB      "##### usb_introut =0x%02x \n",0
00008f  23207573
000093  625f696e
000097  74726f75
00009b  74203d30
00009f  78253032
0000a3  78200a00

                          AREA ||.data||, DATA, ALIGN=2

                  INCSRDATA
000000  00                DCB      0x00
                  usb_state
000001  000000            DCB      0x00,0x00,0x00
                  gnDevState
                          DCD      0x00000000
                  gpCurCfg
                          DCD      0x00000000
                  gbyCurIfVal
                          DCD      0x00000000
000010  00000000          DCB      0x00,0x00,0x00,0x00
                  pInformation
                          DCD      Device_Info
                  flag1
                          DCD      0x00000000
                  ||cmd||
                          %        8

                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=1

                  __ARM_common_switch8 PROC
000000  b430              PUSH     {r4,r5}
000002  4674              MOV      r4,lr
000004  1e64              SUBS     r4,r4,#1
000006  7825              LDRB     r5,[r4,#0]
000008  1c64              ADDS     r4,r4,#1
00000a  42ab              CMP      r3,r5
00000c  d304              BCC      |L176.24|
                  |L176.14|
00000e  5d63              LDRB     r3,[r4,r5]
000010  005b              LSLS     r3,r3,#1
000012  18e3              ADDS     r3,r4,r3
000014  bc30              POP      {r4,r5}
000016  4718              BX       r3
                  |L176.24|
000018  461d              MOV      r5,r3
00001a  e7f8              B        |L176.14|
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\usb\\src\\usb_core.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_usb_core_c_cc00d2b3____REV16|
#line 129 "..\\FTLib\\CMSIS\\inc\\core_cmInstr.h"
|__asm___10_usb_core_c_cc00d2b3____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_usb_core_c_cc00d2b3____REVSH|
#line 144
|__asm___10_usb_core_c_cc00d2b3____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
