; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\usb_core.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\usb_core.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\FTLib\CMSIS\inc -I..\FTLib\Inc -I..\FTLib\Lib -I..\usb\inc -I..\user -I..\RTT -I..\iap2 -IC:\Users\dell1\AppData\Local\Arm\Packs\FMD\FT32F0xx_DFP\1.0.6\Drivers\CMSIS\FT32F0xx\Include -D__UVISION_VERSION=534 -DFT32F072x8 -DFT32F072x8 --omf_browse=.\objects\usb_core.crf ..\usb\src\usb_core.c]
                          THUMB

                          AREA ||i.ConfigureIfs||, CODE, READONLY, ALIGN=2

                  ConfigureIfs PROC
;;;1791   */
;;;1792   static uint32_t ConfigureIfs(void)
000000  b5ff              PUSH     {r0-r7,lr}
;;;1793   {
;;;1794   	PSTD_CFG_DSCR	pcfg;
;;;1795   	BYTE		byIf, byAltIf, byEP, byNumEPs, by;
;;;1796   	BYTE		*pby;
;;;1797   	BYTE		*pbyIfVal;
;;;1798   	PSTD_IF_DSCR	pif;
;;;1799   	PSTD_EP_DSCR	pep;
;;;1800   
;;;1801   	/* Set pointer to first interface descriptor in current configuration */
;;;1802   	pby = (BYTE *)(gpCurCfg) + sizeof(STD_CFG_DSCR);
000002  4844              LDR      r0,|L1.276|
000004  6800              LDR      r0,[r0,#0]  ; gpCurCfg
000006  4602              MOV      r2,r0
000008  3209              ADDS     r2,r2,#9
;;;1803   	pif = (PSTD_IF_DSCR)pby;
00000a  4614              MOV      r4,r2
;;;1804   
;;;1805   	/* Loop through all interfaces in the current configuration */
;;;1806   	pcfg = (PSTD_CFG_DSCR)gpCurCfg;
00000c  4841              LDR      r0,|L1.276|
00000e  6800              LDR      r0,[r0,#0]  ; gpCurCfg
000010  9003              STR      r0,[sp,#0xc]
;;;1807   	pbyIfVal = (BYTE*)&gbyCurIfVal;	//接口
000012  4841              LDR      r0,|L1.280|
000014  9000              STR      r0,[sp,#0]
;;;1808   
;;;1809   	//SEGGER_RTT_printf(0,"ConfigureIfs;  pcfg->bNumInterfaces=%d\n",pcfg->bNumInterfaces);
;;;1810   	for (byIf=0; byIf < pcfg->bNumInterfaces; byIf++, pbyIfVal++) 
000016  2500              MOVS     r5,#0
000018  e076              B        |L1.264|
                  |L1.26|
;;;1811   	{
;;;1812   		//SEGGER_RTT_printf(0,"ConfigureIfs; byIf=%d	byAltIf=%d pbyIfVal=%d\n",byIf,byAltIf ,*pbyIfVal);
;;;1813   		/* Advance pointer to selected alternate interface descriptor */
;;;1814   		if (*pbyIfVal) 
00001a  9800              LDR      r0,[sp,#0]
00001c  7800              LDRB     r0,[r0,#0]
00001e  2800              CMP      r0,#0
000020  d016              BEQ      |L1.80|
;;;1815   		{
;;;1816   		
;;;1817   	
;;;1818   			for (byAltIf=0; byAltIf<*pbyIfVal; byAltIf++) 
000022  2000              MOVS     r0,#0
000024  9002              STR      r0,[sp,#8]
000026  e00e              B        |L1.70|
                  |L1.40|
;;;1819   			{
;;;1820   				byNumEPs = pif->bNumEndpoints;
000028  7926              LDRB     r6,[r4,#4]
;;;1821   				
;;;1822   				//SEGGER_RTT_printf(0,"ConfigureIfs; byAltIf=%d	byNumEPs=%d\n",byNumEPs,byAltIf);
;;;1823   				pby += sizeof(STD_IF_DSCR) + byNumEPs * sizeof(STD_EP_DSCR) /*+ sizeof(STD_HID_DSCR)*/;
00002a  00f0              LSLS     r0,r6,#3
00002c  1b80              SUBS     r0,r0,r6
00002e  3009              ADDS     r0,r0,#9
000030  1812              ADDS     r2,r2,r0
;;;1824   				pif  = (PSTD_IF_DSCR)pby;
000032  4614              MOV      r4,r2
;;;1825   				/* Check an alternate setting > number of alternates not specified */
;;;1826   				if (!pif->bAlternateSetting)
000034  78e0              LDRB     r0,[r4,#3]
000036  2800              CMP      r0,#0
000038  d101              BNE      |L1.62|
                  |L1.58|
;;;1827   				{
;;;1828   				
;;;1829   				//SEGGER_RTT_printf(0,"ConfigureIfs; byAltIf=%d	byNumEPs=%d !pif->bAlternateSetting\n",byNumEPs,byAltIf);
;;;1830   					return FALSE;
;;;1831   				}
;;;1832   			} 
;;;1833   		}
;;;1834   
;;;1835   		/* Store pointer to interface in global array */
;;;1836   		gpCurIf[byIf] = pif;
;;;1837   		//SEGGER_RTT_printf(0,"aa ConfigureIfs;	pif->bNumEndpoints=%d\n",pif->bNumEndpoints);
;;;1838   
;;;1839   		/* Loop through all endpoints in interface */
;;;1840   		byNumEPs = pif->bNumEndpoints;
;;;1841   		
;;;1842   		//SEGGER_RTT_printf(0,"bbb ConfigureIfs;	pif->bNumEndpoints=%d\n",pif->bNumEndpoints);
;;;1843   		pby += sizeof(STD_IF_DSCR) /*+ sizeof(STD_HID_DSCR)*/;	//endpoint
;;;1844   		
;;;1845   		//SEGGER_RTT_printf(0,"ccc ConfigureIfs;	pif->bNumEndpoints=%d\n",pif->bNumEndpoints);
;;;1846   		for ( byEP = 0; byEP < byNumEPs; byEP++ )
;;;1847   		{
;;;1848   		
;;;1849   		//SEGGER_RTT_printf(0,"ddd ConfigureIfs;	pep->bEndpointAddress=0x%02x\n",pep->bEndpointAddress);
;;;1850   			pep = (PSTD_EP_DSCR)pby;
;;;1851   			//SEGGER_RTT_printf(0,"ee ConfigureIfs;	pep->bEndpointAddress=0x%02x\n",pep->bEndpointAddress);
;;;1852   
;;;1853   			/* Configure the endpoint */
;;;1854   			MWRITE_BYTE(M_REG_INDEX, (pep->bEndpointAddress & 0x0F));
;;;1855   			
;;;1856   			//SEGGER_RTT_printf(0,"ff ConfigureIfs;	pep->bEndpointAddress=0x%02x\n",pep->bEndpointAddress);
;;;1857   			/* Round up max packet size to a multiple of 8 for writing to MaxP registers */
;;;1858   			by = (BYTE)((pep->wMaxPacketSize + 7) >> 3);
;;;1859   			
;;;1860   			//SEGGER_RTT_printf(0,"33 ConfigureIfs;	pep->bEndpointAddress=0x%02x\n",pep->bEndpointAddress);
;;;1861   			if(pep->bEndpointAddress & 0x80)
;;;1862   			{
;;;1863   			
;;;1864   			//SEGGER_RTT_printf(0,"444 ConfigureIfs;	pep->bEndpointAddress=0x%02x\n",pep->bEndpointAddress);
;;;1865   				MWRITE_BYTE(M_REG_INMAXP, by);
;;;1866   				by = MREAD_BYTE(M_REG_INCSR2);
;;;1867   				
;;;1868   				//SEGGER_RTT_printf(0,"66 ConfigureIfs;	pep->bmAttributes=0x%02x\n",pep->bmAttributes);
;;;1869   				
;;;1870   				//SEGGER_RTT_printf(0,"66 ConfigureIfs;	pep->bmAttributes=0x%02x\n",(pep->bmAttributes & M_EP_TFMASK));
;;;1871   				switch (pep->bmAttributes & M_EP_TFMASK)
;;;1872   				{
;;;1873   					case M_EP_ISO:
;;;1874   						
;;;1875   					//	SEGGER_RTT_printf(0,"555 ConfigureIfs;	pep->bEndpointAddress=0x%02x\n",pep->bEndpointAddress);
;;;1876   						by |= M_INCSR2_ISO;
;;;1877   					break;
;;;1878   					case M_EP_BULK:
;;;1879   					case M_EP_INTR:		
;;;1880   						
;;;1881   					//	SEGGER_RTT_printf(0,"777 ConfigureIfs;	pep->bmAttributes=0x%02x\n",pep->bmAttributes);
;;;1882   						by &= ~M_INCSR2_ISO;
;;;1883   					break;
;;;1884   				}
;;;1885   				
;;;1886   				/* Set mode bit high (only strictly necessary if sharing a FIFO) */
;;;1887   				by |= M_INCSR2_MODE;
;;;1888   				
;;;1889   				MWRITE_BYTE(M_REG_INCSR2, by);
;;;1890   				
;;;1891   				/* Other configuration for an IN endpoint */
;;;1892   				/* e.g. AutoClr, DMA */
;;;1893   				/* should be added here */
;;;1894   			}
;;;1895   			else
;;;1896   			{
;;;1897   				MWRITE_BYTE(M_REG_OUTMAXP, by);
;;;1898   				by = MREAD_BYTE(M_REG_OUTCSR2);
;;;1899   				
;;;1900   				//SEGGER_RTT_printf(0,"999 ConfigureIfs;	pep->bmAttributes=0x%02x\n",pep->bmAttributes);
;;;1901   				switch (pep->bmAttributes & M_EP_TFMASK)
;;;1902   				{
;;;1903   					case M_EP_ISO:
;;;1904   						
;;;1905   					//	SEGGER_RTT_printf(0,"hhh ConfigureIfs;	pep->bmAttributes=0x%02x\n",pep->bmAttributes);
;;;1906   						by |= M_OUTCSR2_ISO;
;;;1907   					break;
;;;1908   					case M_EP_BULK:
;;;1909   					case M_EP_INTR:
;;;1910   						
;;;1911   					///	SEGGER_RTT_printf(0,"ffff ConfigureIfs;	pep->bmAttributes=0x%02x\n",pep->bmAttributes);
;;;1912   						by &= ~M_OUTCSR2_ISO;
;;;1913   					break;
;;;1914   				}
;;;1915   				MWRITE_BYTE(M_REG_OUTCSR2, by);
;;;1916   				/* Other configuration for an OUT endpoint */
;;;1917   				/* e.g. AutoSet, DMA */
;;;1918   				/* should be added here */
;;;1919   			}
;;;1920   			
;;;1921   			pby += sizeof(STD_EP_DSCR);	
;;;1922   		}
;;;1923   	}
;;;1924   
;;;1925   	return TRUE;
;;;1926   }
00003a  b004              ADD      sp,sp,#0x10
00003c  bdf0              POP      {r4-r7,pc}
                  |L1.62|
00003e  9802              LDR      r0,[sp,#8]            ;1818
000040  1c40              ADDS     r0,r0,#1              ;1818
000042  b2c0              UXTB     r0,r0                 ;1818
000044  9002              STR      r0,[sp,#8]            ;1818
                  |L1.70|
000046  9800              LDR      r0,[sp,#0]            ;1818
000048  7807              LDRB     r7,[r0,#0]            ;1818
00004a  9802              LDR      r0,[sp,#8]            ;1818
00004c  4287              CMP      r7,r0                 ;1818
00004e  dceb              BGT      |L1.40|
                  |L1.80|
000050  00a8              LSLS     r0,r5,#2              ;1836
000052  4f32              LDR      r7,|L1.284|
000054  503c              STR      r4,[r7,r0]            ;1836
000056  7926              LDRB     r6,[r4,#4]            ;1840
000058  3209              ADDS     r2,r2,#9              ;1843
00005a  2000              MOVS     r0,#0                 ;1846
00005c  9001              STR      r0,[sp,#4]            ;1846
00005e  e04b              B        |L1.248|
                  |L1.96|
000060  4613              MOV      r3,r2                 ;1850
000062  7898              LDRB     r0,[r3,#2]            ;1854
000064  0700              LSLS     r0,r0,#28             ;1854
000066  0f00              LSRS     r0,r0,#28             ;1854
000068  4f2d              LDR      r7,|L1.288|
00006a  73b8              STRB     r0,[r7,#0xe]          ;1854
00006c  7958              LDRB     r0,[r3,#5]            ;1858
00006e  791f              LDRB     r7,[r3,#4]            ;1858
000070  0200              LSLS     r0,r0,#8              ;1858
000072  4338              ORRS     r0,r0,r7              ;1858
000074  1dc0              ADDS     r0,r0,#7              ;1858
000076  0540              LSLS     r0,r0,#21             ;1858
000078  0e01              LSRS     r1,r0,#24             ;1858
00007a  7898              LDRB     r0,[r3,#2]            ;1861
00007c  2780              MOVS     r7,#0x80              ;1861
00007e  4038              ANDS     r0,r0,r7              ;1861
000080  2800              CMP      r0,#0                 ;1861
000082  d01b              BEQ      |L1.188|
000084  4826              LDR      r0,|L1.288|
000086  7401              STRB     r1,[r0,#0x10]         ;1865
000088  7c81              LDRB     r1,[r0,#0x12]         ;1866
00008a  78d8              LDRB     r0,[r3,#3]            ;1871
00008c  0780              LSLS     r0,r0,#30             ;1871
00008e  0f80              LSRS     r0,r0,#30             ;1871
000090  2801              CMP      r0,#1                 ;1871
000092  d004              BEQ      |L1.158|
000094  2802              CMP      r0,#2                 ;1871
000096  d005              BEQ      |L1.164|
000098  2803              CMP      r0,#3                 ;1871
00009a  d109              BNE      |L1.176|
00009c  e003              B        |L1.166|
                  |L1.158|
00009e  2040              MOVS     r0,#0x40              ;1876
0000a0  4301              ORRS     r1,r1,r0              ;1876
0000a2  e005              B        |L1.176|
                  |L1.164|
0000a4  bf00              NOP                            ;1879
                  |L1.166|
0000a6  2040              MOVS     r0,#0x40              ;1882
0000a8  460f              MOV      r7,r1                 ;1882
0000aa  4387              BICS     r7,r7,r0              ;1882
0000ac  4639              MOV      r1,r7                 ;1882
0000ae  bf00              NOP                            ;1883
                  |L1.176|
0000b0  bf00              NOP                            ;1877
0000b2  2020              MOVS     r0,#0x20              ;1887
0000b4  4301              ORRS     r1,r1,r0              ;1887
0000b6  481a              LDR      r0,|L1.288|
0000b8  7481              STRB     r1,[r0,#0x12]         ;1889
0000ba  e018              B        |L1.238|
                  |L1.188|
0000bc  4818              LDR      r0,|L1.288|
0000be  74c1              STRB     r1,[r0,#0x13]         ;1897
0000c0  7d41              LDRB     r1,[r0,#0x15]         ;1898
0000c2  78d8              LDRB     r0,[r3,#3]            ;1901
0000c4  0780              LSLS     r0,r0,#30             ;1901
0000c6  0f80              LSRS     r0,r0,#30             ;1901
0000c8  2801              CMP      r0,#1                 ;1901
0000ca  d004              BEQ      |L1.214|
0000cc  2802              CMP      r0,#2                 ;1901
0000ce  d005              BEQ      |L1.220|
0000d0  2803              CMP      r0,#3                 ;1901
0000d2  d109              BNE      |L1.232|
0000d4  e003              B        |L1.222|
                  |L1.214|
0000d6  2040              MOVS     r0,#0x40              ;1906
0000d8  4301              ORRS     r1,r1,r0              ;1906
0000da  e005              B        |L1.232|
                  |L1.220|
0000dc  bf00              NOP                            ;1909
                  |L1.222|
0000de  2040              MOVS     r0,#0x40              ;1912
0000e0  460f              MOV      r7,r1                 ;1912
0000e2  4387              BICS     r7,r7,r0              ;1912
0000e4  4639              MOV      r1,r7                 ;1912
0000e6  bf00              NOP                            ;1913
                  |L1.232|
0000e8  bf00              NOP                            ;1907
0000ea  480d              LDR      r0,|L1.288|
0000ec  7541              STRB     r1,[r0,#0x15]         ;1915
                  |L1.238|
0000ee  1dd2              ADDS     r2,r2,#7              ;1921
0000f0  9801              LDR      r0,[sp,#4]            ;1846
0000f2  1c40              ADDS     r0,r0,#1              ;1846
0000f4  b2c0              UXTB     r0,r0                 ;1846
0000f6  9001              STR      r0,[sp,#4]            ;1846
                  |L1.248|
0000f8  9801              LDR      r0,[sp,#4]            ;1846
0000fa  42b0              CMP      r0,r6                 ;1846
0000fc  dbb0              BLT      |L1.96|
0000fe  1c68              ADDS     r0,r5,#1              ;1810
000100  b2c5              UXTB     r5,r0                 ;1810
000102  9800              LDR      r0,[sp,#0]            ;1810
000104  1c40              ADDS     r0,r0,#1              ;1810
000106  9000              STR      r0,[sp,#0]            ;1810
                  |L1.264|
000108  9803              LDR      r0,[sp,#0xc]          ;1810
00010a  7900              LDRB     r0,[r0,#4]            ;1810
00010c  42a8              CMP      r0,r5                 ;1810
00010e  dc84              BGT      |L1.26|
000110  2001              MOVS     r0,#1                 ;1925
000112  e792              B        |L1.58|
;;;1927   
                          ENDP

                  |L1.276|
                          DCD      gpCurCfg
                  |L1.280|
                          DCD      gbyCurIfVal
                  |L1.284|
                          DCD      gpCurIf
                  |L1.288|
                          DCD      0x40005c00

                          AREA ||i.EndpointBulkIn||, CODE, READONLY, ALIGN=2

                  EndpointBulkIn PROC
;;;416    */
;;;417    void EndpointBulkIn(M_EPBIN_STATUS pbistate, int nCallState)
000000  b57f              PUSH     {r0-r6,lr}
;;;418    {
000002  461e              MOV      r6,r3
;;;419    	int     nBytes;
;;;420    	BYTE    byInCSR;
;;;421    
;;;422    	/* Reset endpoint */
;;;423    	if(nCallState == M_EP_RESET)
000004  2e01              CMP      r6,#1
000006  d107              BNE      |L2.24|
;;;424    	{
;;;425    		/*切换端点号*/
;;;426    		MWRITE_BYTE(M_REG_INDEX, pbistate.byEP);
000008  4668              MOV      r0,sp
00000a  7a00              LDRB     r0,[r0,#8]
00000c  4913              LDR      r1,|L2.92|
00000e  7388              STRB     r0,[r1,#0xe]
;;;427    		/*清除相应端点的数据翻转状态和清空FIFO中要发送的数据*/
;;;428    		byInCSR = M_INCSR_CDT | M_INCSR_FF;
000010  2548              MOVS     r5,#0x48
;;;429    		MWRITE_BYTE(M_REG_INCSR1, byInCSR);
000012  4608              MOV      r0,r1
000014  7445              STRB     r5,[r0,#0x11]
000016  e01f              B        |L2.88|
                  |L2.24|
;;;430    	}
;;;431    	else
;;;432    	{
;;;433    	
;;;434    	//SEGGER_RTT_printf(0,"EndpointBulkIn pbistate.nBytesLeft=%d\n",pbistate.nBytesLeft);
;;;435    		/* Check whether there is any data to send */ 
;;;436    		if(pbistate.nBytesLeft != M_EP_NODATA)
000018  9801              LDR      r0,[sp,#4]
00001a  1c40              ADDS     r0,r0,#1
00001c  2800              CMP      r0,#0
00001e  d01b              BEQ      |L2.88|
;;;437    		{
;;;438    			/* Determine number of bytes to send */
;;;439    			if(pbistate.nBytesLeft < M_EP_MAXP)
000020  9801              LDR      r0,[sp,#4]
000022  2840              CMP      r0,#0x40
000024  da04              BGE      |L2.48|
;;;440    			{
;;;441    				nBytes = pbistate.nBytesLeft;
000026  9c01              LDR      r4,[sp,#4]
;;;442    				pbistate.nBytesLeft = M_EP_NODATA;
000028  2000              MOVS     r0,#0
00002a  43c0              MVNS     r0,r0
00002c  9001              STR      r0,[sp,#4]
00002e  e003              B        |L2.56|
                  |L2.48|
;;;443    			}
;;;444    			else 
;;;445    			{
;;;446    				nBytes = M_EP_MAXP;
000030  2440              MOVS     r4,#0x40
;;;447    				pbistate.nBytesLeft -= M_EP_MAXP;
000032  9801              LDR      r0,[sp,#4]
000034  3840              SUBS     r0,r0,#0x40
000036  9001              STR      r0,[sp,#4]
                  |L2.56|
;;;448    			}
;;;449    		//	SEGGER_RTT_printf(0,"222 EndpointBulkIn pbistate.nBytesLeft=%d\n",pbistate.nBytesLeft);
;;;450    
;;;451    			/* Load FIFO */
;;;452    			FIFOWrite((int)pbistate.byEP, nBytes, pbistate.pData);
000038  4669              MOV      r1,sp
00003a  7a08              LDRB     r0,[r1,#8]
00003c  4621              MOV      r1,r4
00003e  9a00              LDR      r2,[sp,#0]
000040  f7fffffe          BL       FIFOWrite
;;;453    			
;;;454    			//SEGGER_RTT_printf(0,"333 EndpointBulkIn nBytes=%d\n",nBytes);
;;;455    			pbistate.pData = (BYTE *)pbistate.pData + nBytes;
000044  9800              LDR      r0,[sp,#0]
000046  1900              ADDS     r0,r0,r4
000048  9000              STR      r0,[sp,#0]
;;;456    
;;;457    			MWRITE_BYTE(M_REG_INDEX, pbistate.byEP);
00004a  4669              MOV      r1,sp
00004c  7a08              LDRB     r0,[r1,#8]
00004e  4903              LDR      r1,|L2.92|
000050  7388              STRB     r0,[r1,#0xe]
;;;458    			/*表示要发送的数据已经装入相应端点的FIFO中*/
;;;459    			byInCSR = M_INCSR_IPR;
000052  2501              MOVS     r5,#1
;;;460    			MWRITE_BYTE(M_REG_INCSR1, byInCSR);
000054  4608              MOV      r0,r1
000056  7445              STRB     r5,[r0,#0x11]
                  |L2.88|
;;;461    		}
;;;462    	}
;;;463    }
000058  bd7f              POP      {r0-r6,pc}
;;;464    
                          ENDP

00005a  0000              DCW      0x0000
                  |L2.92|
                          DCD      0x40005c00

                          AREA ||i.EndpointBulkOut||, CODE, READONLY, ALIGN=2

                  EndpointBulkOut PROC
;;;476    */
;;;477    int EndpointBulkOut(M_EPBOUT_STATUS pbostate, int nCallState)
000000  b57f              PUSH     {r0-r6,lr}
;;;478    {
000002  9e08              LDR      r6,[sp,#0x20]
;;;479    	int     nBytes;
;;;480    	BYTE    byOutCSR;
;;;481    
;;;482    	/* Reset endpoint */
;;;483    	if(nCallState == M_EP_RESET)
000004  2e01              CMP      r6,#1
000006  d107              BNE      |L3.24|
;;;484    	{
;;;485    		/***配置端点号***/
;;;486    		MWRITE_BYTE(M_REG_INDEX, pbostate.byEP);
000008  4668              MOV      r0,sp
00000a  7b00              LDRB     r0,[r0,#0xc]
00000c  4919              LDR      r1,|L3.116|
00000e  7388              STRB     r0,[r1,#0xe]
;;;487    		byOutCSR = M_OUTCSR_CDT | M_OUTCSR_FF;
000010  2590              MOVS     r5,#0x90
;;;488    		/***复位端点的数据反转状态,清空接收 FIFO 中的数据***/
;;;489    		MWRITE_BYTE(M_REG_OUTCSR1, byOutCSR);
000012  4608              MOV      r0,r1
000014  7505              STRB     r5,[r0,#0x14]
000016  e02b              B        |L3.112|
                  |L3.24|
;;;490    	}
;;;491    	else
;;;492    	{
;;;493    		/* Set index register */
;;;494    		MWRITE_BYTE(M_REG_INDEX, pbostate.byEP);
000018  4668              MOV      r0,sp
00001a  7b00              LDRB     r0,[r0,#0xc]
00001c  4915              LDR      r1,|L3.116|
00001e  7388              STRB     r0,[r1,#0xe]
;;;495    
;;;496    		/* Read OUT CSR register */
;;;497    		byOutCSR = MREAD_BYTE(M_REG_OUTCSR1);
000020  4608              MOV      r0,r1
000022  7d05              LDRB     r5,[r0,#0x14]
;;;498    
;;;499    		/* Get packet, */
;;;500    		/* may need to unload more than one packet if double buffering enabled */
;;;501    		/*端点FIFO 中有数据*/
;;;502    		while(byOutCSR & M_OUTCSR_OPR)
000024  e020              B        |L3.104|
                  |L3.38|
;;;503    		{
;;;504    			/* Get packet size */
;;;505    			nBytes = (int)MREAD_BYTE(M_REG_OUTCOUNT2);
000026  4813              LDR      r0,|L3.116|
000028  7dc4              LDRB     r4,[r0,#0x17]
;;;506    			nBytes <<= 8;
00002a  0224              LSLS     r4,r4,#8
;;;507    			nBytes |= (int)MREAD_BYTE(M_REG_OUTCOUNT1);
00002c  7d80              LDRB     r0,[r0,#0x16]
00002e  4304              ORRS     r4,r4,r0
;;;508    
;;;509    			/* Check there is room in the buffer */
;;;510    			if(pbostate.nBytesRecv + nBytes > pbostate.nBuffLen)
000030  9802              LDR      r0,[sp,#8]
000032  1900              ADDS     r0,r0,r4
000034  9901              LDR      r1,[sp,#4]
000036  4288              CMP      r0,r1
000038  dd05              BLE      |L3.70|
;;;511    			{
;;;512    				/* Call to function to handle buffer over run */
;;;513    				MWRITE_BYTE(M_REG_OUTCSR1, 0);
00003a  2000              MOVS     r0,#0
00003c  490d              LDR      r1,|L3.116|
00003e  7508              STRB     r0,[r1,#0x14]
;;;514    				return nBytes;
000040  4620              MOV      r0,r4
                  |L3.66|
;;;515    			}
;;;516    
;;;517    			/* Unload FIFO */
;;;518    			FIFORead((int)pbostate.byEP, nBytes, pbostate.pData);
;;;519    
;;;520    			/* Update status */
;;;521    			pbostate.nBytesRecv += nBytes;
;;;522    			pbostate.pData = (BYTE *)pbostate.pData + nBytes;
;;;523    
;;;524    			/* Check for end of transfer */
;;;525    			if (nBytes <= M_EP_MAXP) 
;;;526    			{
;;;527    				/* Call function to handle received data */	
;;;528    			}
;;;529    
;;;530    			/* Clear OutPktRdy */
;;;531    			MWRITE_BYTE(M_REG_OUTCSR1, 0);
;;;532    
;;;533    			/* Check for another packet */
;;;534    			byOutCSR = MREAD_BYTE(M_REG_OUTCSR1);
;;;535    		}
;;;536    	}
;;;537    	return nBytes;
;;;538    }
000042  b004              ADD      sp,sp,#0x10
000044  bd70              POP      {r4-r6,pc}
                  |L3.70|
000046  4669              MOV      r1,sp                 ;518
000048  7b08              LDRB     r0,[r1,#0xc]          ;518
00004a  4621              MOV      r1,r4                 ;518
00004c  9a00              LDR      r2,[sp,#0]            ;518
00004e  f7fffffe          BL       FIFORead
000052  9802              LDR      r0,[sp,#8]            ;521
000054  1900              ADDS     r0,r0,r4              ;521
000056  9002              STR      r0,[sp,#8]            ;521
000058  9800              LDR      r0,[sp,#0]            ;522
00005a  1900              ADDS     r0,r0,r4              ;522
00005c  9000              STR      r0,[sp,#0]            ;522
00005e  2000              MOVS     r0,#0                 ;531
000060  4904              LDR      r1,|L3.116|
000062  7508              STRB     r0,[r1,#0x14]         ;531
000064  4608              MOV      r0,r1                 ;534
000066  7d05              LDRB     r5,[r0,#0x14]         ;534
                  |L3.104|
000068  07e8              LSLS     r0,r5,#31             ;502
00006a  0fc0              LSRS     r0,r0,#31             ;502
00006c  2800              CMP      r0,#0                 ;502
00006e  d1da              BNE      |L3.38|
                  |L3.112|
000070  4620              MOV      r0,r4                 ;537
000072  e7e6              B        |L3.66|
;;;539    
                          ENDP

                  |L3.116|
                          DCD      0x40005c00

                          AREA ||i.FIFORead||, CODE, READONLY, ALIGN=2

                  FIFORead PROC
;;;586    */
;;;587    void FIFORead(int nEP, int nBytes, void * pDst)		
000000  b5f0              PUSH     {r4-r7,lr}
;;;588    {
000002  4603              MOV      r3,r0
000004  4614              MOV      r4,r2
;;;589    	int     nCount;
;;;590    	BYTE *  pby;
;;;591    	int     nAddr;
;;;592    //	int i;
;;;593    	//SEGGER_RTT_printf(0,"start FIFORead nBytes = %d nEP=%d\n",nBytes,nEP);
;;;594    
;;;595    	if(nBytes) 
000006  2900              CMP      r1,#0
000008  d00b              BEQ      |L4.34|
;;;596    	{
;;;597    		nAddr = M_FIFO_EP0+(nEP<<2);
00000a  009e              LSLS     r6,r3,#2
00000c  4f05              LDR      r7,|L4.36|
00000e  19f5              ADDS     r5,r6,r7
;;;598    		nCount = nBytes;
000010  4608              MOV      r0,r1
;;;599    		pby = (BYTE *)pDst;
000012  4622              MOV      r2,r4
;;;600    		while(nCount) 
000014  e003              B        |L4.30|
                  |L4.22|
;;;601    		{
;;;602    
;;;603    		// SEGGER_RTT_printf(0," 0x%02x ",*pby);
;;;604    		// i++;
;;;605    		//if(i==10)
;;;606    		//	SEGGER_RTT_printf(0,"\n");
;;;607    			*pby++ = *((BYTE *)nAddr);
000016  782e              LDRB     r6,[r5,#0]
000018  7016              STRB     r6,[r2,#0]
00001a  1c52              ADDS     r2,r2,#1
;;;608    			
;;;609    			nCount--;
00001c  1e40              SUBS     r0,r0,#1
                  |L4.30|
00001e  2800              CMP      r0,#0                 ;600
000020  d1f9              BNE      |L4.22|
                  |L4.34|
;;;610    			
;;;611    		}
;;;612    	}
;;;613    	
;;;614    	//SEGGER_RTT_printf(0,"\n  end FIFORead nBytes = %d nEP=%d\n",nBytes,nEP);
;;;615    }
000022  bdf0              POP      {r4-r7,pc}
;;;616    
                          ENDP

                  |L4.36|
                          DCD      0x40005c20

                          AREA ||i.FIFOWrite||, CODE, READONLY, ALIGN=2

                  FIFOWrite PROC
;;;625    */
;;;626    void FIFOWrite(int nEP, int nBytes, void * pSrc)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;627    {
000002  b082              SUB      sp,sp,#8
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
;;;628    	int     nCount;
;;;629    	BYTE *  pby;
;;;630    	int     nAddr;
;;;631    	int i = 0;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;632    	SEGGER_RTT_printf(0,"start FIFOWrite nBytes = %d nEP=%d\n",nBytes,nEP);
00000c  4633              MOV      r3,r6
00000e  4622              MOV      r2,r4
000010  a114              ADR      r1,|L5.100|
000012  f7fffffe          BL       SEGGER_RTT_printf
;;;633    	
;;;634    	if(nBytes)
000016  2c00              CMP      r4,#0
000018  d01c              BEQ      |L5.84|
;;;635    	{
;;;636    		nAddr = M_FIFO_EP0+(nEP<<2);
00001a  00b0              LSLS     r0,r6,#2
00001c  491a              LDR      r1,|L5.136|
00001e  1840              ADDS     r0,r0,r1
000020  9001              STR      r0,[sp,#4]
;;;637    		nCount = nBytes;
000022  4627              MOV      r7,r4
;;;638    		pby = (BYTE *)pSrc;
000024  9d04              LDR      r5,[sp,#0x10]
;;;639    		while (nCount)
000026  e013              B        |L5.80|
                  |L5.40|
;;;640    		{
;;;641    		 SEGGER_RTT_printf(0," 0x%02x ",*pby);
000028  782a              LDRB     r2,[r5,#0]
00002a  a118              ADR      r1,|L5.140|
00002c  2000              MOVS     r0,#0
00002e  f7fffffe          BL       SEGGER_RTT_printf
;;;642    		 *((BYTE *)nAddr) = *pby++;
000032  7829              LDRB     r1,[r5,#0]
000034  9801              LDR      r0,[sp,#4]
000036  7001              STRB     r1,[r0,#0]
000038  1c6d              ADDS     r5,r5,#1
;;;643    		 i++;
00003a  9800              LDR      r0,[sp,#0]
00003c  1c40              ADDS     r0,r0,#1
00003e  9000              STR      r0,[sp,#0]
;;;644    		if(i==10)
000040  9800              LDR      r0,[sp,#0]
000042  280a              CMP      r0,#0xa
000044  d103              BNE      |L5.78|
;;;645    			SEGGER_RTT_printf(0,"\n");
000046  a114              ADR      r1,|L5.152|
000048  2000              MOVS     r0,#0
00004a  f7fffffe          BL       SEGGER_RTT_printf
                  |L5.78|
;;;646    			nCount--;
00004e  1e7f              SUBS     r7,r7,#1
                  |L5.80|
000050  2f00              CMP      r7,#0                 ;639
000052  d1e9              BNE      |L5.40|
                  |L5.84|
;;;647    		}
;;;648    	}
;;;649    	
;;;650    	SEGGER_RTT_printf(0,"\n end FIFOWrite nBytes = %d nEP=%d\n",nBytes,nEP);
000054  4633              MOV      r3,r6
000056  4622              MOV      r2,r4
000058  a110              ADR      r1,|L5.156|
00005a  2000              MOVS     r0,#0
00005c  f7fffffe          BL       SEGGER_RTT_printf
;;;651    	
;;;652    }
000060  b005              ADD      sp,sp,#0x14
000062  bdf0              POP      {r4-r7,pc}
;;;653    
                          ENDP

                  |L5.100|
000064  73746172          DCB      "start FIFOWrite nBytes = %d nEP=%d\n",0
000068  74204649
00006c  464f5772
000070  69746520
000074  6e427974
000078  6573203d
00007c  20256420
000080  6e45503d
000084  25640a00
                  |L5.136|
                          DCD      0x40005c20
                  |L5.140|
00008c  20307825          DCB      " 0x%02x ",0
000090  30327820
000094  00      
000095  00                DCB      0
000096  00                DCB      0
000097  00                DCB      0
                  |L5.152|
000098  0a00              DCB      "\n",0
00009a  00                DCB      0
00009b  00                DCB      0
                  |L5.156|
00009c  0a20656e          DCB      "\n end FIFOWrite nBytes = %d nEP=%d\n",0
0000a0  64204649
0000a4  464f5772
0000a8  69746520
0000ac  6e427974
0000b0  6573203d
0000b4  20256420
0000b8  6e45503d
0000bc  25640a00

                          AREA ||i.HID_GetIdleEvent||, CODE, READONLY, ALIGN=2

                  HID_GetIdleEvent PROC
;;;905    */
;;;906    void HID_GetIdleEvent(PM_EP0_STATUS pep0state,PCOMMAND pcmd)
000000  b570              PUSH     {r4-r6,lr}
;;;907    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;908    	/*保存请求类型*/
;;;909    	c_hid_data.wHID_Status = HID_REQUEST_GET_IDLE;
000006  490b              LDR      r1,|L6.52|
000008  2002              MOVS     r0,#2
00000a  f7fffffe          BL       __aeabi_uwrite4
;;;910    	
;;;911    	pep0state->nBytesLeft = 0x01;
00000e  1d21              ADDS     r1,r4,#4
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       __aeabi_uwrite4
;;;912    	pep0state->pData = (void*)&c_hid_data.wHID_IdleTimeIf0ID;
000016  4621              MOV      r1,r4
000018  3108              ADDS     r1,r1,#8
00001a  4806              LDR      r0,|L6.52|
00001c  3843              SUBS     r0,r0,#0x43
00001e  f7fffffe          BL       __aeabi_uwrite4
;;;913    	pep0state->nState = M_EP0_TX;
000022  4621              MOV      r1,r4
000024  2002              MOVS     r0,#2
000026  f7fffffe          BL       __aeabi_uwrite4
;;;914    	MWRITE_BYTE(M_REG_CSR0,M_CSR0_SVDOUTPKTRDY);	
00002a  2040              MOVS     r0,#0x40
00002c  4902              LDR      r1,|L6.56|
00002e  7448              STRB     r0,[r1,#0x11]
;;;915    }
000030  bd70              POP      {r4-r6,pc}
;;;916    /******************************************************************************
                          ENDP

000032  0000              DCW      0x0000
                  |L6.52|
                          DCD      c_hid_data+0x53
                  |L6.56|
                          DCD      0x40005c00

                          AREA ||i.HID_GetProtocolEvent||, CODE, READONLY, ALIGN=2

                  HID_GetProtocolEvent PROC
;;;941    */
;;;942    void HID_GetProtocolEvent(PM_EP0_STATUS pep0state,PCOMMAND pcmd)
000000  b570              PUSH     {r4-r6,lr}
;;;943    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;944    	/*保存请求类型*/
;;;945    	c_hid_data.wHID_Status = HID_REQUEST_GET_PROTOCOL;
000006  490b              LDR      r1,|L7.52|
000008  2003              MOVS     r0,#3
00000a  f7fffffe          BL       __aeabi_uwrite4
;;;946    	
;;;947    	pep0state->nBytesLeft = 0x01;
00000e  1d21              ADDS     r1,r4,#4
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       __aeabi_uwrite4
;;;948    	pep0state->pData = (void*)&c_hid_data.wHID_Protocol;
000016  4621              MOV      r1,r4
000018  3108              ADDS     r1,r1,#8
00001a  4806              LDR      r0,|L7.52|
00001c  3842              SUBS     r0,r0,#0x42
00001e  f7fffffe          BL       __aeabi_uwrite4
;;;949    	pep0state->nState = M_EP0_TX;
000022  4621              MOV      r1,r4
000024  2002              MOVS     r0,#2
000026  f7fffffe          BL       __aeabi_uwrite4
;;;950    	MWRITE_BYTE(M_REG_CSR0,M_CSR0_SVDOUTPKTRDY);		
00002a  2040              MOVS     r0,#0x40
00002c  4902              LDR      r1,|L7.56|
00002e  7448              STRB     r0,[r1,#0x11]
;;;951    }
000030  bd70              POP      {r4-r6,pc}
;;;952    /******************************************************************************
                          ENDP

000032  0000              DCW      0x0000
                  |L7.52|
                          DCD      c_hid_data+0x53
                  |L7.56|
                          DCD      0x40005c00

                          AREA ||i.HID_GetReportEvent||, CODE, READONLY, ALIGN=2

                  HID_GetReportEvent PROC
;;;877    */
;;;878    void HID_GetReportEvent(PM_EP0_STATUS pep0state,PCOMMAND pcmd)
000000  b570              PUSH     {r4-r6,lr}
;;;879    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;880    	if(gnDevState > DEVSTATE_ADDRESS)
000006  4815              LDR      r0,|L8.92|
000008  6800              LDR      r0,[r0,#0]  ; gnDevState
00000a  2801              CMP      r0,#1
00000c  d924              BLS      |L8.88|
;;;881    	{
;;;882    		switch(pcmd->USBwValue >>8)
00000e  78e8              LDRB     r0,[r5,#3]
000010  78a9              LDRB     r1,[r5,#2]
000012  0200              LSLS     r0,r0,#8
000014  4308              ORRS     r0,r0,r1
000016  1200              ASRS     r0,r0,#8
000018  2801              CMP      r0,#1
00001a  d004              BEQ      |L8.38|
00001c  2802              CMP      r0,#2
00001e  d004              BEQ      |L8.42|
000020  2803              CMP      r0,#3
000022  d118              BNE      |L8.86|
000024  e000              B        |L8.40|
                  |L8.38|
;;;883    		{
;;;884    			case	HID_REPORT_INPUT:
;;;885    			case	HID_REPORT_FEATURE:
000026  bf00              NOP      
                  |L8.40|
;;;886    			case	HID_REPORT_OUTPUT:
000028  bf00              NOP      
                  |L8.42|
;;;887    				/*保存请求类型*/
;;;888    				c_hid_data.wHID_Status = HID_REQUEST_GET_REPORT;
00002a  490d              LDR      r1,|L8.96|
00002c  2001              MOVS     r0,#1
00002e  f7fffffe          BL       __aeabi_uwrite4
;;;889    			
;;;890    				pep0state->nBytesLeft = 0x01;
000032  1d21              ADDS     r1,r4,#4
000034  2001              MOVS     r0,#1
000036  f7fffffe          BL       __aeabi_uwrite4
;;;891    				pep0state->pData = (void*)&c_hid_data.wHID_SetRptByte[0];
00003a  4621              MOV      r1,r4
00003c  3108              ADDS     r1,r1,#8
00003e  4808              LDR      r0,|L8.96|
000040  3853              SUBS     r0,r0,#0x53
000042  f7fffffe          BL       __aeabi_uwrite4
;;;892    				pep0state->nState = M_EP0_TX;
000046  4621              MOV      r1,r4
000048  2002              MOVS     r0,#2
00004a  f7fffffe          BL       __aeabi_uwrite4
;;;893    				MWRITE_BYTE(M_REG_CSR0,M_CSR0_SVDOUTPKTRDY);
00004e  2040              MOVS     r0,#0x40
000050  4904              LDR      r1,|L8.100|
000052  7448              STRB     r0,[r1,#0x11]
;;;894    				break;
000054  bf00              NOP      
                  |L8.86|
000056  bf00              NOP      
                  |L8.88|
;;;895    		}
;;;896    	}	
;;;897    }
000058  bd70              POP      {r4-r6,pc}
;;;898    /******************************************************************************
                          ENDP

00005a  0000              DCW      0x0000
                  |L8.92|
                          DCD      gnDevState
                  |L8.96|
                          DCD      c_hid_data+0x53
                  |L8.100|
                          DCD      0x40005c00

                          AREA ||i.HID_SetIdleEvent||, CODE, READONLY, ALIGN=2

                  HID_SetIdleEvent PROC
;;;923    */
;;;924    void HID_SetIdleEvent(PM_EP0_STATUS pep0state,PCOMMAND pcmd)
000000  b570              PUSH     {r4-r6,lr}
;;;925    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;926    	/*保存请求类型*/
;;;927    	c_hid_data.wHID_Status = HID_REQUEST_SET_IDLE;
000006  490a              LDR      r1,|L9.48|
000008  200a              MOVS     r0,#0xa
00000a  f7fffffe          BL       __aeabi_uwrite4
;;;928    
;;;929    	pep0state->nState = M_EP0_IDLE;
00000e  4621              MOV      r1,r4
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       __aeabi_uwrite4
;;;930    	c_hid_data.wHID_IdleTimeIf0ID = (pcmd->USBwValue>>8);
000016  78e8              LDRB     r0,[r5,#3]
000018  78a9              LDRB     r1,[r5,#2]
00001a  0200              LSLS     r0,r0,#8
00001c  4308              ORRS     r0,r0,r1
00001e  1200              ASRS     r0,r0,#8
000020  4903              LDR      r1,|L9.48|
000022  3953              SUBS     r1,r1,#0x53
000024  7408              STRB     r0,[r1,#0x10]
;;;931    	MWRITE_BYTE(M_REG_CSR0,M_CSR0_SVDOUTPKTRDY);		
000026  2040              MOVS     r0,#0x40
000028  4902              LDR      r1,|L9.52|
00002a  7448              STRB     r0,[r1,#0x11]
;;;932    }
00002c  bd70              POP      {r4-r6,pc}
;;;933    
                          ENDP

00002e  0000              DCW      0x0000
                  |L9.48|
                          DCD      c_hid_data+0x53
                  |L9.52|
                          DCD      0x40005c00

                          AREA ||i.HID_SetProtocolEvent||, CODE, READONLY, ALIGN=2

                  HID_SetProtocolEvent PROC
;;;959    */
;;;960    void HID_SetProtocolEvent(PM_EP0_STATUS pep0state,PCOMMAND pcmd)
000000  b570              PUSH     {r4-r6,lr}
;;;961    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;962    	/*保存请求类型*/
;;;963    	c_hid_data.wHID_Status = HID_REQUEST_SET_PROTOCOL;
000006  4909              LDR      r1,|L10.44|
000008  200b              MOVS     r0,#0xb
00000a  f7fffffe          BL       __aeabi_uwrite4
;;;964    
;;;965    	pep0state->nState = M_EP0_IDLE;
00000e  4621              MOV      r1,r4
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       __aeabi_uwrite4
;;;966    	c_hid_data.wHID_Protocol = (pcmd->USBwValue & 0x00ff);
000016  78e8              LDRB     r0,[r5,#3]
000018  78a9              LDRB     r1,[r5,#2]
00001a  0200              LSLS     r0,r0,#8
00001c  4308              ORRS     r0,r0,r1
00001e  4903              LDR      r1,|L10.44|
000020  3953              SUBS     r1,r1,#0x53
000022  7448              STRB     r0,[r1,#0x11]
;;;967    	MWRITE_BYTE(M_REG_CSR0,M_CSR0_SVDOUTPKTRDY);		
000024  2040              MOVS     r0,#0x40
000026  4902              LDR      r1,|L10.48|
000028  7448              STRB     r0,[r1,#0x11]
;;;968    }
00002a  bd70              POP      {r4-r6,pc}
;;;969    /******************************************************************************
                          ENDP

                  |L10.44|
                          DCD      c_hid_data+0x53
                  |L10.48|
                          DCD      0x40005c00

                          AREA ||i.HID_SetReportEvent||, CODE, READONLY, ALIGN=2

                  HID_SetReportEvent PROC
;;;849    */
;;;850    void HID_SetReportEvent(PM_EP0_STATUS pep0state,PCOMMAND pcmd)
000000  b570              PUSH     {r4-r6,lr}
;;;851    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;852    	//if ((pcmd->bmRequestType == HID_REQUEST_SET) && (pcmd->USBwIndex == 1))// Interface 1
;;;853    	{
;;;854    		switch(pcmd->USBwValue >>8)
000006  78e8              LDRB     r0,[r5,#3]
000008  78a9              LDRB     r1,[r5,#2]
00000a  0200              LSLS     r0,r0,#8
00000c  4308              ORRS     r0,r0,r1
00000e  1200              ASRS     r0,r0,#8
000010  2801              CMP      r0,#1
000012  d004              BEQ      |L11.30|
000014  2802              CMP      r0,#2
000016  d003              BEQ      |L11.32|
000018  2803              CMP      r0,#3
00001a  d11c              BNE      |L11.86|
00001c  e01a              B        |L11.84|
                  |L11.30|
;;;855    		{
;;;856    			case	HID_REPORT_INPUT:break;
00001e  e01a              B        |L11.86|
                  |L11.32|
;;;857    			case	HID_REPORT_OUTPUT:
;;;858    				/*保存请求类型*/
;;;859    				c_hid_data.wHID_Status = HID_REQUEST_SET_REPORT;
000020  490e              LDR      r1,|L11.92|
000022  2009              MOVS     r0,#9
000024  f7fffffe          BL       __aeabi_uwrite4
;;;860    			
;;;861    				pep0state->nBytesLeft = pcmd->USBwLength;
000028  79e9              LDRB     r1,[r5,#7]
00002a  79aa              LDRB     r2,[r5,#6]
00002c  0209              LSLS     r1,r1,#8
00002e  4311              ORRS     r1,r1,r2
000030  4608              MOV      r0,r1
000032  1d21              ADDS     r1,r4,#4
000034  f7fffffe          BL       __aeabi_uwrite4
;;;862    				pep0state->nState = M_EP0_RX;
000038  4621              MOV      r1,r4
00003a  2001              MOVS     r0,#1
00003c  f7fffffe          BL       __aeabi_uwrite4
;;;863    				pep0state->pData = (void*)&c_hid_data.wHID_SetRptByte[0];
000040  4621              MOV      r1,r4
000042  3108              ADDS     r1,r1,#8
000044  4805              LDR      r0,|L11.92|
000046  3853              SUBS     r0,r0,#0x53
000048  f7fffffe          BL       __aeabi_uwrite4
;;;864    				MWRITE_BYTE(M_REG_CSR0,M_CSR0_SVDOUTPKTRDY);				
00004c  2040              MOVS     r0,#0x40
00004e  4904              LDR      r1,|L11.96|
000050  7448              STRB     r0,[r1,#0x11]
;;;865    				break;
000052  e000              B        |L11.86|
                  |L11.84|
;;;866    			case	HID_REPORT_FEATURE:break;
000054  bf00              NOP      
                  |L11.86|
000056  bf00              NOP                            ;856
;;;867    		}
;;;868    	}	
;;;869    }
000058  bd70              POP      {r4-r6,pc}
;;;870    /******************************************************************************
                          ENDP

00005a  0000              DCW      0x0000
                  |L11.92|
                          DCD      c_hid_data+0x53
                  |L11.96|
                          DCD      0x40005c00

                          AREA ||i.USB_EP_Rx||, CODE, READONLY, ALIGN=1

                  USB_EP_Rx PROC
;;;1983   */
;;;1984   int USB_EP_Rx(uint8_t Ep,uint8_t *ptr,uint8_t data_len)
000000  b570              PUSH     {r4-r6,lr}
;;;1985   {
000002  b085              SUB      sp,sp,#0x14
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;1986   	M_EPBOUT_STATUS    tEp1out;
;;;1987   	
;;;1988   	tEp1out.byEP = Ep;
00000a  4668              MOV      r0,sp
00000c  7404              STRB     r4,[r0,#0x10]
;;;1989   	tEp1out.nBuffLen = data_len; 	//M_EP_MAXP
00000e  9602              STR      r6,[sp,#8]
;;;1990   	tEp1out.pData = ptr;
000010  9501              STR      r5,[sp,#4]
;;;1991   	tEp1out.nBytesRecv = 0;
000012  2000              MOVS     r0,#0
000014  9003              STR      r0,[sp,#0xc]
;;;1992   
;;;1993   	return EndpointBulkOut(tEp1out, M_EP_NORMAL);
000016  9000              STR      r0,[sp,#0]
000018  a801              ADD      r0,sp,#4
00001a  c80f              LDM      r0,{r0-r3}
00001c  f7fffffe          BL       EndpointBulkOut
;;;1994   	//return tEp1out.nBytesRecv;
;;;1995   }
000020  b005              ADD      sp,sp,#0x14
000022  bd70              POP      {r4-r6,pc}
;;;1996   
                          ENDP


                          AREA ||i.USB_EP_Tx||, CODE, READONLY, ALIGN=2

                  USB_EP_Tx PROC
;;;1936   */
;;;1937   ErrorStatus USB_EP_Tx(uint8_t Ep,uint8_t *ptr,uint8_t data_len)
000000  b5fe              PUSH     {r1-r7,lr}
;;;1938   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;1939   	M_EPBIN_STATUS tEp0in;
;;;1940   	uint32_t timeout = 0;
000008  2700              MOVS     r7,#0
;;;1941   	
;;;1942   	//SEGGER_RTT_printf(0,"USB_EP_Tx gnDevState=%d\n",gnDevState);
;;;1943   	if(gnDevState > DEVSTATE_ADDRESS)
00000a  480e              LDR      r0,|L13.68|
00000c  6800              LDR      r0,[r0,#0]  ; gnDevState
00000e  2801              CMP      r0,#1
000010  d916              BLS      |L13.64|
;;;1944   	{
;;;1945   	
;;;1946   	//SEGGER_RTT_printf(0,"2 USB_EP_Tx gnDevState=%d\n",gnDevState);
;;;1947   		tEp0in.byEP = Ep;
000012  4668              MOV      r0,sp
000014  7204              STRB     r4,[r0,#8]
;;;1948   		tEp0in.nBytesLeft = data_len;
000016  9601              STR      r6,[sp,#4]
;;;1949   		tEp0in.pData = ptr;
000018  9500              STR      r5,[sp,#0]
;;;1950   		EndpointBulkIn(tEp0in, M_EP_NORMAL);
00001a  2300              MOVS     r3,#0
00001c  4668              MOV      r0,sp
00001e  c807              LDM      r0,{r0-r2}
000020  f7fffffe          BL       EndpointBulkIn
;;;1951   
;;;1952   		
;;;1953   		//SEGGER_RTT_printf(0,"3 USB_EP_Tx MREAD_BYTE(M_REG_INCSR1)=0x%02x\n",MREAD_BYTE(M_REG_INCSR1));
;;;1954   		while(MREAD_BYTE(M_REG_INCSR1) & 0x01)
000024  e004              B        |L13.48|
                  |L13.38|
;;;1955   		{
;;;1956   		
;;;1957   		//SEGGER_RTT_printf(0,"4 USB_EP_Tx timeout=%d\n",timeout);
;;;1958   			timeout++;
000026  1c7f              ADDS     r7,r7,#1
;;;1959   			if(timeout>=0xffffffff)
000028  1c78              ADDS     r0,r7,#1
00002a  2800              CMP      r0,#0
00002c  d100              BNE      |L13.48|
                  |L13.46|
;;;1960   			{
;;;1961   			
;;;1962   			//SEGGER_RTT_printf(0,"5 USB_EP_Tx timeout=%d\n",timeout);
;;;1963   				return ERROR;
;;;1964   			}
;;;1965   		}
;;;1966   		
;;;1967   		//SEGGER_RTT_printf(0,"6 USB_EP_Tx gnDevState=%d\n",gnDevState);
;;;1968   		return SUCCESS;
;;;1969   	}
;;;1970   	
;;;1971   	//SEGGER_RTT_printf(0,"7 USB_EP_Tx gnDevState=%d\n",gnDevState);
;;;1972   	return ERROR;
;;;1973   }
00002e  bdfe              POP      {r1-r7,pc}
                  |L13.48|
000030  4805              LDR      r0,|L13.72|
000032  7c40              LDRB     r0,[r0,#0x11]         ;1954
000034  07c0              LSLS     r0,r0,#31             ;1954
000036  0fc0              LSRS     r0,r0,#31             ;1954
000038  2800              CMP      r0,#0                 ;1954
00003a  d1f4              BNE      |L13.38|
00003c  2001              MOVS     r0,#1                 ;1968
00003e  e7f6              B        |L13.46|
                  |L13.64|
000040  2000              MOVS     r0,#0                 ;1972
000042  e7f4              B        |L13.46|
;;;1974   
                          ENDP

                  |L13.68|
                          DCD      gnDevState
                  |L13.72|
                          DCD      0x40005c00

                          AREA ||i.USB_Endpoint0||, CODE, READONLY, ALIGN=2

                  USB_Endpoint0 PROC
;;;746    */
;;;747    void USB_Endpoint0(int nCallState)
000000  b570              PUSH     {r4-r6,lr}
;;;748    {
000002  4605              MOV      r5,r0
;;;749    	static M_EP0_STATUS	ep0state;
;;;750    	static COMMAND	cmd;
;;;751    	BYTE	byCSR0;
;;;752    
;;;753    	
;;;754    	//SEGGER_RTT_printf(0,"USB_Endpoint0  xxx nCallState =%d\n",nCallState);
;;;755    	/* Check for USB reset of endpoint 0 */
;;;756    	if (nCallState == M_EP_RESET)
000004  2d01              CMP      r5,#1
000006  d10a              BNE      |L14.30|
;;;757    	{
;;;758    		ep0state.nState = M_EP0_IDLE;
000008  4938              LDR      r1,|L14.236|
00000a  2000              MOVS     r0,#0
00000c  f7fffffe          BL       __aeabi_uwrite4
;;;759    		ep0state.byFAddr = 0xFF;
000010  20ff              MOVS     r0,#0xff
000012  4936              LDR      r1,|L14.236|
000014  7408              STRB     r0,[r1,#0x10]
;;;760    		/* Clear current configuration pointer */
;;;761    		gpCurCfg = NULL;
000016  2000              MOVS     r0,#0
000018  4935              LDR      r1,|L14.240|
00001a  6008              STR      r0,[r1,#0]  ; gpCurCfg
                  |L14.28|
;;;762    		return;
;;;763    	}
;;;764    
;;;765    	/* Read CSR0 */
;;;766    	MWRITE_BYTE(M_REG_INDEX, 0);							//选择endpoint0
;;;767    	byCSR0 = MREAD_BYTE(M_REG_CSR0);						//读取CSR0，各种通信状态
;;;768    
;;;769    	/* Check for status stage of a request */
;;;770    	/*接收已完成状态*/
;;;771    	if(!(byCSR0 & M_CSR0_OUTPKTRDY)) 
;;;772    	{
;;;773    		/* Complete SET_ADDRESS command */
;;;774    		if(ep0state.byFAddr != 0xFF)
;;;775    		{
;;;776    			MWRITE_BYTE(M_REG_FADDR, ep0state.byFAddr);		//如果地址不为FF，reset，地址设置为byFAddr
;;;777    			if((gnDevState == DEVSTATE_DEFAULT) && ep0state.byFAddr)
;;;778    			{
;;;779    			
;;;780    			//SEGGER_RTT_printf(0,"gnDevState = DEVSTATE_ADDRESS;	 xxx 111\n");
;;;781    				gnDevState = DEVSTATE_ADDRESS;				//地址不为0，且设备状态为 DEVSTATE_DEFAULT
;;;782    			}
;;;783    			else if((gnDevState == DEVSTATE_ADDRESS) && !ep0state.byFAddr)
;;;784    			{
;;;785    			
;;;786    			//SEGGER_RTT_printf(0,"gnDevState = DEVSTATE_ADDRESS;	 222\n");
;;;787    				gnDevState = DEVSTATE_DEFAULT;				//地址为0，且设备状态为 DEVSTATE_ADDRESS
;;;788    			}
;;;789    		}
;;;790    	}
;;;791    	/* Clear pending commands */
;;;792    	ep0state.byFAddr = 0xFF;	
;;;793    
;;;794    	/* Check for SentStall */
;;;795    	if(byCSR0 & M_CSR0_SENTSTALL)
;;;796    	{
;;;797    		/*清除STALL 位*/
;;;798    		MWRITE_BYTE(M_REG_CSR0, (byCSR0 & ~M_CSR0_SENDSTALL));
;;;799    		ep0state.nState = M_EP0_IDLE;
;;;800    	}
;;;801    
;;;802    	/* Check for SetupEnd */
;;;803    	if(byCSR0 & M_CSR0_SETUPEND)
;;;804    	{
;;;805    		/*清除setupend位*/
;;;806    		MWRITE_BYTE(M_REG_CSR0, (byCSR0 | M_CSR0_SVDSETUPEND));
;;;807    		ep0state.nState = M_EP0_IDLE;
;;;808    	}
;;;809    
;;;810    	/* Call relevant routines for endpoint 0 state */
;;;811    	if(ep0state.nState == M_EP0_IDLE) 
;;;812    	{
;;;813    		/* If no packet has been received, */
;;;814    		/* assume that this was a STATUS phase complete. */
;;;815    		/* Otherwise load new command */
;;;816    		if(byCSR0 & M_CSR0_OUTPKTRDY) 
;;;817    		{
;;;818    			/* Read the 8-byte command from the FIFO */
;;;819    			/* There is no need to check that OutCount is set to 8 */
;;;820    			/* as the MUSBFSFC will reject SETUP packets that are not 8 bytes long. */
;;;821    			FIFORead(0, 8, &cmd);	
;;;822    		//	SEGGER_RTT_printf(0,"USB_Endpoint0  aaa\n");
;;;823    			//传入cmd地址存放数据到结构体中
;;;824    			USB_Endpoint0_Command(&ep0state, &cmd);			//数据解析
;;;825    		}
;;;826    	}
;;;827    	
;;;828    	if(ep0state.nState == M_EP0_TX)
;;;829    	{
;;;830    	
;;;831    	//SEGGER_RTT_printf(0,"USB_Endpoint0_Tx 1111\n");
;;;832    		USB_Endpoint0_Tx(&ep0state);
;;;833    	}
;;;834    	else if(ep0state.nState == M_EP0_RX)
;;;835    	{
;;;836    	
;;;837    	//SEGGER_RTT_printf(0,"USB_Endpoint0_Tx 2222\n");
;;;838    		USB_Endpoint0_Rx(&ep0state);
;;;839    	}
;;;840    }
00001c  bd70              POP      {r4-r6,pc}
                  |L14.30|
00001e  2000              MOVS     r0,#0                 ;766
000020  4934              LDR      r1,|L14.244|
000022  7388              STRB     r0,[r1,#0xe]          ;766
000024  4608              MOV      r0,r1                 ;767
000026  7c44              LDRB     r4,[r0,#0x11]         ;767
000028  07e0              LSLS     r0,r4,#31             ;771
00002a  0fc0              LSRS     r0,r0,#31             ;771
00002c  2800              CMP      r0,#0                 ;771
00002e  d11c              BNE      |L14.106|
000030  482e              LDR      r0,|L14.236|
000032  7c00              LDRB     r0,[r0,#0x10]         ;774  ; ep0state
000034  28ff              CMP      r0,#0xff              ;774
000036  d018              BEQ      |L14.106|
000038  482c              LDR      r0,|L14.236|
00003a  7c00              LDRB     r0,[r0,#0x10]         ;776  ; ep0state
00003c  7008              STRB     r0,[r1,#0]            ;776
00003e  482e              LDR      r0,|L14.248|
000040  6800              LDR      r0,[r0,#0]            ;777  ; gnDevState
000042  2800              CMP      r0,#0                 ;777
000044  d107              BNE      |L14.86|
000046  4829              LDR      r0,|L14.236|
000048  7c00              LDRB     r0,[r0,#0x10]         ;777  ; ep0state
00004a  2800              CMP      r0,#0                 ;777
00004c  d003              BEQ      |L14.86|
00004e  2001              MOVS     r0,#1                 ;781
000050  4929              LDR      r1,|L14.248|
000052  6008              STR      r0,[r1,#0]            ;781  ; gnDevState
000054  e009              B        |L14.106|
                  |L14.86|
000056  4828              LDR      r0,|L14.248|
000058  6800              LDR      r0,[r0,#0]            ;783  ; gnDevState
00005a  2801              CMP      r0,#1                 ;783
00005c  d105              BNE      |L14.106|
00005e  4823              LDR      r0,|L14.236|
000060  7c00              LDRB     r0,[r0,#0x10]         ;783  ; ep0state
000062  2800              CMP      r0,#0                 ;783
000064  d101              BNE      |L14.106|
000066  4924              LDR      r1,|L14.248|
000068  6008              STR      r0,[r1,#0]            ;787  ; gnDevState
                  |L14.106|
00006a  20ff              MOVS     r0,#0xff              ;792
00006c  491f              LDR      r1,|L14.236|
00006e  7408              STRB     r0,[r1,#0x10]         ;792
000070  2004              MOVS     r0,#4                 ;795
000072  4020              ANDS     r0,r0,r4              ;795
000074  2800              CMP      r0,#0                 ;795
000076  d008              BEQ      |L14.138|
000078  2120              MOVS     r1,#0x20              ;798
00007a  4620              MOV      r0,r4                 ;798
00007c  4388              BICS     r0,r0,r1              ;798
00007e  491d              LDR      r1,|L14.244|
000080  7448              STRB     r0,[r1,#0x11]         ;798
000082  491a              LDR      r1,|L14.236|
000084  2000              MOVS     r0,#0                 ;799
000086  f7fffffe          BL       __aeabi_uwrite4
                  |L14.138|
00008a  2010              MOVS     r0,#0x10              ;803
00008c  4020              ANDS     r0,r0,r4              ;803
00008e  2800              CMP      r0,#0                 ;803
000090  d007              BEQ      |L14.162|
000092  2080              MOVS     r0,#0x80              ;806
000094  4320              ORRS     r0,r0,r4              ;806
000096  4917              LDR      r1,|L14.244|
000098  7448              STRB     r0,[r1,#0x11]         ;806
00009a  4914              LDR      r1,|L14.236|
00009c  2000              MOVS     r0,#0                 ;807
00009e  f7fffffe          BL       __aeabi_uwrite4
                  |L14.162|
0000a2  4812              LDR      r0,|L14.236|
0000a4  f7fffffe          BL       __aeabi_uread4
0000a8  2800              CMP      r0,#0                 ;811
0000aa  d10c              BNE      |L14.198|
0000ac  07e0              LSLS     r0,r4,#31             ;816
0000ae  0fc0              LSRS     r0,r0,#31             ;816
0000b0  2800              CMP      r0,#0                 ;816
0000b2  d008              BEQ      |L14.198|
0000b4  4a11              LDR      r2,|L14.252|
0000b6  2108              MOVS     r1,#8                 ;821
0000b8  2000              MOVS     r0,#0                 ;821
0000ba  f7fffffe          BL       FIFORead
0000be  490f              LDR      r1,|L14.252|
0000c0  480a              LDR      r0,|L14.236|
0000c2  f7fffffe          BL       USB_Endpoint0_Command
                  |L14.198|
0000c6  4809              LDR      r0,|L14.236|
0000c8  f7fffffe          BL       __aeabi_uread4
0000cc  2802              CMP      r0,#2                 ;828
0000ce  d103              BNE      |L14.216|
0000d0  4806              LDR      r0,|L14.236|
0000d2  f7fffffe          BL       USB_Endpoint0_Tx
0000d6  e007              B        |L14.232|
                  |L14.216|
0000d8  4804              LDR      r0,|L14.236|
0000da  f7fffffe          BL       __aeabi_uread4
0000de  2801              CMP      r0,#1                 ;834
0000e0  d102              BNE      |L14.232|
0000e2  4802              LDR      r0,|L14.236|
0000e4  f7fffffe          BL       USB_Endpoint0_Rx
                  |L14.232|
0000e8  bf00              NOP      
0000ea  e797              B        |L14.28|
;;;841    
                          ENDP

                  |L14.236|
                          DCD      ep0state
                  |L14.240|
                          DCD      gpCurCfg
                  |L14.244|
                          DCD      0x40005c00
                  |L14.248|
                          DCD      gnDevState
                  |L14.252|
                          DCD      ||cmd||

                          AREA ||i.USB_Endpoint0_Command||, CODE, READONLY, ALIGN=2

                  USB_Endpoint0_Command PROC
;;;1025   */
;;;1026   static void USB_Endpoint0_Command(PM_EP0_STATUS pep0state, PCOMMAND pcmd)
000000  b570              PUSH     {r4-r6,lr}
;;;1027   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1028   
;;;1029   
;;;1030   	/* Check request type */
;;;1031   	switch(pcmd->bmRequestType & M_CMD_TYPEMASK)	//判断数据中为何种命令
000006  7820              LDRB     r0,[r4,#0]
000008  2160              MOVS     r1,#0x60
00000a  4008              ANDS     r0,r0,r1
00000c  2800              CMP      r0,#0
00000e  d004              BEQ      |L15.26|
000010  2820              CMP      r0,#0x20
000012  d007              BEQ      |L15.36|
000014  2840              CMP      r0,#0x40
000016  d10a              BNE      |L15.46|
000018  e00a              B        |L15.48|
                  |L15.26|
;;;1032   	{
;;;1033   		/***主机到设备，标准请求命令，接收者为设备***/
;;;1034   		case M_CMD_STDREQ:
;;;1035   			USB_StdDev_Req(pep0state, pcmd);
00001a  4621              MOV      r1,r4
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       USB_StdDev_Req
;;;1036   			break;
000022  e009              B        |L15.56|
                  |L15.36|
;;;1037   
;;;1038   		/***主机到设备，类请求命令，接收者为设备***/
;;;1039   		case M_CMD_CLASSREQ:
;;;1040   			/* Add call to external routine for handling class requests */
;;;1041   			USB_HID_Class_Req(pep0state,pcmd);
000024  4621              MOV      r1,r4
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       USB_HID_Class_Req
;;;1042   			break;
00002c  e004              B        |L15.56|
                  |L15.46|
;;;1043   		/***主机到设备，用户定义的命令，接收者为设备***/
;;;1044   		case M_CMD_VENDREQ:
00002e  bf00              NOP      
                  |L15.48|
;;;1045   		/* Add call to external routine for handling vendor requests */
;;;1046   			
;;;1047   		/***保留***/
;;;1048   		default:
;;;1049   			/* Stall the command if a reserved request is received */
;;;1050   			MWRITE_BYTE(M_REG_CSR0, M_CSR0_SVDOUTPKTRDY | M_CSR0_SENDSTALL);
000030  2060              MOVS     r0,#0x60
000032  4902              LDR      r1,|L15.60|
000034  7448              STRB     r0,[r1,#0x11]
;;;1051   		break;
000036  bf00              NOP      
                  |L15.56|
000038  bf00              NOP                            ;1036
;;;1052     }
;;;1053   
;;;1054   	return;
;;;1055   }
00003a  bd70              POP      {r4-r6,pc}
;;;1056   
                          ENDP

                  |L15.60|
                          DCD      0x40005c00

                          AREA ||i.USB_Endpoint0_Rx||, CODE, READONLY, ALIGN=2

                  USB_Endpoint0_Rx PROC
;;;1751   */
;;;1752   static void USB_Endpoint0_Rx(PM_EP0_STATUS pep0state)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1753   {
000002  4604              MOV      r4,r0
;;;1754   	BYTE    byOutCSR;
;;;1755   	
;;;1756   	/* Set index register */
;;;1757   	MWRITE_BYTE(M_REG_INDEX, 0);
000004  2000              MOVS     r0,#0
000006  4910              LDR      r1,|L16.72|
000008  7388              STRB     r0,[r1,#0xe]
;;;1758   	/* Read OUT CSR register */
;;;1759   	byOutCSR = MREAD_BYTE(M_REG_CSR0);
00000a  4608              MOV      r0,r1
00000c  7c45              LDRB     r5,[r0,#0x11]
;;;1760   
;;;1761   	/* Get packet, */
;;;1762   	/* may need to unload more than one packet if double buffering enabled */
;;;1763   	/*端点FIFO 中有数据*/
;;;1764   	while(byOutCSR & M_CSR0_OUTPKTRDY)
00000e  e016              B        |L16.62|
                  |L16.16|
;;;1765   	{
;;;1766   		pep0state->nState = M_EP0_IDLE;
000010  4621              MOV      r1,r4
000012  2000              MOVS     r0,#0
000014  f7fffffe          BL       __aeabi_uwrite4
;;;1767   
;;;1768   		/* Unload FIFO */
;;;1769   		//FIFORead(0, 1, pep0state->pData);//NUM CAP SCR指示灯信息
;;;1770   		FIFORead(0, pep0state->nBytesLeft, pep0state->pData);//NUM CAP SCR指示灯信息
000018  4620              MOV      r0,r4
00001a  3008              ADDS     r0,r0,#8
00001c  f7fffffe          BL       __aeabi_uread4
000020  4606              MOV      r6,r0
000022  1d20              ADDS     r0,r4,#4
000024  f7fffffe          BL       __aeabi_uread4
000028  4607              MOV      r7,r0
00002a  4632              MOV      r2,r6
00002c  4639              MOV      r1,r7
00002e  2000              MOVS     r0,#0
000030  f7fffffe          BL       FIFORead
;;;1771   		
;;;1772   		/*Cear flag*/
;;;1773   		MWRITE_BYTE(M_REG_CSR0,M_CSR0_SVDOUTPKTRDY);
000034  2040              MOVS     r0,#0x40
000036  4904              LDR      r1,|L16.72|
000038  7448              STRB     r0,[r1,#0x11]
;;;1774   		/* Check for another packet */
;;;1775   		byOutCSR = MREAD_BYTE(M_REG_CSR0);
00003a  4608              MOV      r0,r1
00003c  7c45              LDRB     r5,[r0,#0x11]
                  |L16.62|
00003e  07e8              LSLS     r0,r5,#31             ;1764
000040  0fc0              LSRS     r0,r0,#31             ;1764
000042  2800              CMP      r0,#0                 ;1764
000044  d1e4              BNE      |L16.16|
;;;1776   	}
;;;1777   		
;;;1778   }
000046  bdf8              POP      {r3-r7,pc}
;;;1779   
                          ENDP

                  |L16.72|
                          DCD      0x40005c00

                          AREA ||i.USB_Endpoint0_Tx||, CODE, READONLY, ALIGN=2

                  USB_Endpoint0_Tx PROC
;;;1709   */
;;;1710   static void USB_Endpoint0_Tx(PM_EP0_STATUS pep0state)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1711   {
000002  4604              MOV      r4,r0
;;;1712   	int	nBytes;
;;;1713   	BYTE	by;
;;;1714   
;;;1715   	/* Determine number of bytes to send */
;;;1716   	if(pep0state->nBytesLeft <= M_EP0_MAXP)
000004  1d20              ADDS     r0,r4,#4
000006  f7fffffe          BL       __aeabi_uread4
00000a  2840              CMP      r0,#0x40
00000c  dc08              BGT      |L17.32|
;;;1717   	{
;;;1718   		nBytes = pep0state->nBytesLeft;
00000e  1d20              ADDS     r0,r4,#4
000010  f7fffffe          BL       __aeabi_uread4
000014  4605              MOV      r5,r0
;;;1719   		pep0state->nBytesLeft = 0;
000016  1d21              ADDS     r1,r4,#4
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       __aeabi_uwrite4
00001e  e008              B        |L17.50|
                  |L17.32|
;;;1720   	}
;;;1721   	else
;;;1722   	{
;;;1723   		nBytes = M_EP0_MAXP;
000020  2540              MOVS     r5,#0x40
;;;1724   		pep0state->nBytesLeft -= M_EP0_MAXP;
000022  1d20              ADDS     r0,r4,#4
000024  f7fffffe          BL       __aeabi_uread4
000028  1b47              SUBS     r7,r0,r5
00002a  1d21              ADDS     r1,r4,#4
00002c  4638              MOV      r0,r7
00002e  f7fffffe          BL       __aeabi_uwrite4
                  |L17.50|
;;;1725   	}
;;;1726   
;;;1727   	FIFOWrite(0, nBytes, pep0state->pData);
000032  4620              MOV      r0,r4
000034  3008              ADDS     r0,r0,#8
000036  f7fffffe          BL       __aeabi_uread4
00003a  4607              MOV      r7,r0
00003c  463a              MOV      r2,r7
00003e  4629              MOV      r1,r5
000040  2000              MOVS     r0,#0
000042  f7fffffe          BL       FIFOWrite
;;;1728   	pep0state->pData = (BYTE *)pep0state->pData + nBytes;
000046  4620              MOV      r0,r4
000048  3008              ADDS     r0,r0,#8
00004a  f7fffffe          BL       __aeabi_uread4
00004e  1947              ADDS     r7,r0,r5
000050  4621              MOV      r1,r4
000052  3108              ADDS     r1,r1,#8
000054  4638              MOV      r0,r7
000056  f7fffffe          BL       __aeabi_uwrite4
;;;1729   	if(nBytes < M_EP0_MAXP)
00005a  2d40              CMP      r5,#0x40
00005c  da05              BGE      |L17.106|
;;;1730   	{
;;;1731   		/***数据已经写入 FIFO 中,将要发送的时最后一包数据***/
;;;1732   		by = M_CSR0_INPKTRDY | M_CSR0_DATAEND;
00005e  260a              MOVS     r6,#0xa
;;;1733   		pep0state->nState = M_EP0_IDLE;
000060  4621              MOV      r1,r4
000062  2000              MOVS     r0,#0
000064  f7fffffe          BL       __aeabi_uwrite4
000068  e000              B        |L17.108|
                  |L17.106|
;;;1734   	}
;;;1735   	else
;;;1736   	{
;;;1737   		/***数据已经写入 FIFO 中***/
;;;1738   		by = M_CSR0_INPKTRDY;
00006a  2602              MOVS     r6,#2
                  |L17.108|
;;;1739   	}
;;;1740   	
;;;1741   	MWRITE_BYTE(M_REG_CSR0, by);
00006c  4801              LDR      r0,|L17.116|
00006e  7446              STRB     r6,[r0,#0x11]
;;;1742   }
000070  bdf8              POP      {r3-r7,pc}
;;;1743   
                          ENDP

000072  0000              DCW      0x0000
                  |L17.116|
                          DCD      0x40005c00

                          AREA ||i.USB_GetITStatus||, CODE, READONLY, ALIGN=2

                  USB_GetITStatus PROC
;;;701    */
;;;702    ITStatus USB_GetITStatus(uint32_t USB_IT)
000000  b570              PUSH     {r4-r6,lr}
;;;703    {
000002  4601              MOV      r1,r0
;;;704        __IO uint8_t *tmp = (__IO uint8_t *)USB_BASE;
000004  4a16              LDR      r2,|L18.96|
;;;705        uint8_t tmp_flag = 0;
000006  2300              MOVS     r3,#0
;;;706    		uint32_t IT_FLAG = 0;
000008  2400              MOVS     r4,#0
;;;707        ITStatus bitstatus = RESET;
00000a  2000              MOVS     r0,#0
;;;708    
;;;709        assert_param(IS_USB_CONFIG_IT(USB_IT));
;;;710    
;;;711        if(USB_IT & 0x00000100)
00000c  1595              ASRS     r5,r2,#22
00000e  400d              ANDS     r5,r5,r1
000010  2d00              CMP      r5,#0
000012  d005              BEQ      |L18.32|
;;;712        {
;;;713          tmp = &USB->INTRIN;
000014  1c92              ADDS     r2,r2,#2
;;;714          IT_FLAG = USB_IT & 0xfffffeff;
000016  1596              ASRS     r6,r2,#22
000018  460d              MOV      r5,r1
00001a  43b5              BICS     r5,r5,r6
00001c  462c              MOV      r4,r5
00001e  e016              B        |L18.78|
                  |L18.32|
;;;715        }
;;;716        else if(USB_IT & 0x00000200)
000020  2501              MOVS     r5,#1
000022  026d              LSLS     r5,r5,#9
000024  400d              ANDS     r5,r5,r1
000026  2d00              CMP      r5,#0
000028  d006              BEQ      |L18.56|
;;;717        {
;;;718          tmp = &USB->INTROUT;
00002a  4a0d              LDR      r2,|L18.96|
00002c  1d12              ADDS     r2,r2,#4
;;;719          IT_FLAG = USB_IT & 0xfffffdff;
00002e  1556              ASRS     r6,r2,#21
000030  460d              MOV      r5,r1
000032  43b5              BICS     r5,r5,r6
000034  462c              MOV      r4,r5
000036  e00a              B        |L18.78|
                  |L18.56|
;;;720        }
;;;721        else if(USB_IT & 0x00000400)
000038  2501              MOVS     r5,#1
00003a  02ad              LSLS     r5,r5,#10
00003c  400d              ANDS     r5,r5,r1
00003e  2d00              CMP      r5,#0
000040  d005              BEQ      |L18.78|
;;;722        {
;;;723          tmp = &USB->INTRUSB;
000042  4a07              LDR      r2,|L18.96|
000044  1d92              ADDS     r2,r2,#6
;;;724          IT_FLAG = USB_IT & 0xfffffbff;
000046  1516              ASRS     r6,r2,#20
000048  460d              MOV      r5,r1
00004a  43b5              BICS     r5,r5,r6
00004c  462c              MOV      r4,r5
                  |L18.78|
;;;725        }
;;;726    
;;;727        tmp_flag = *(__IO uint8_t *)tmp;
00004e  7813              LDRB     r3,[r2,#0]
;;;728        if( (tmp_flag & ((uint8_t)IT_FLAG)) != ((uint8_t)RESET))
000050  461d              MOV      r5,r3
000052  4025              ANDS     r5,r5,r4
000054  2d00              CMP      r5,#0
000056  d001              BEQ      |L18.92|
;;;729        {
;;;730          bitstatus = SET;
000058  2001              MOVS     r0,#1
00005a  e000              B        |L18.94|
                  |L18.92|
;;;731        }
;;;732        else
;;;733        {
;;;734          bitstatus = RESET;
00005c  2000              MOVS     r0,#0
                  |L18.94|
;;;735        }
;;;736    
;;;737        return bitstatus;
;;;738    }
00005e  bd70              POP      {r4-r6,pc}
;;;739    
                          ENDP

                  |L18.96|
                          DCD      0x40005c00

                          AREA ||i.USB_HID_Class_Req||, CODE, READONLY, ALIGN=2

                  USB_HID_Class_Req PROC
;;;976    */
;;;977    void USB_HID_Class_Req(PM_EP0_STATUS pep0state,PCOMMAND pcmd)
000000  b570              PUSH     {r4-r6,lr}
;;;978    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;979    	switch(pcmd->bRequest)
000006  7860              LDRB     r0,[r4,#1]
000008  0003              MOVS     r3,r0
00000a  f7fffffe          BL       __ARM_common_switch8
00000e  0c25              DCB      0x0c,0x25
000010  070c1125          DCB      0x07,0x0c,0x11,0x25
000014  25252525          DCB      0x25,0x25,0x25,0x25
000018  161b2025          DCB      0x16,0x1b,0x20,0x25
;;;980    	{
;;;981    		case	HID_REQUEST_GET_REPORT:
;;;982    		{
;;;983    			HID_GetReportEvent(pep0state,pcmd);
00001c  4621              MOV      r1,r4
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       HID_GetReportEvent
                  |L19.36|
;;;984    			return;
;;;985    		}
;;;986    		case	HID_REQUEST_GET_IDLE:
;;;987    		{
;;;988    			HID_GetIdleEvent(pep0state,pcmd);
;;;989    			return;
;;;990    		}
;;;991    		case	HID_REQUEST_GET_PROTOCOL:
;;;992    		{
;;;993    			HID_GetProtocolEvent(pep0state,pcmd);
;;;994    			return;
;;;995    		}
;;;996    		case	HID_REQUEST_SET_REPORT:
;;;997    		{
;;;998    			HID_SetReportEvent(pep0state,pcmd);
;;;999    			return;
;;;1000   		}
;;;1001   		case	HID_REQUEST_SET_IDLE:
;;;1002   		{
;;;1003   			HID_SetIdleEvent(pep0state,pcmd);
;;;1004   			return;
;;;1005   		}
;;;1006   		case	HID_REQUEST_SET_PROTOCOL:
;;;1007   		{
;;;1008   			HID_SetProtocolEvent(pep0state,pcmd);
;;;1009   			return;
;;;1010   		}
;;;1011   		default:
;;;1012   		{
;;;1013   			break;
;;;1014   		}
;;;1015   	}
;;;1016   	MWRITE_BYTE(M_REG_CSR0, M_CSR0_SVDOUTPKTRDY | M_CSR0_SENDSTALL);
;;;1017   }
000024  bd70              POP      {r4-r6,pc}
000026  4621              MOV      r1,r4                 ;988
000028  4628              MOV      r0,r5                 ;988
00002a  f7fffffe          BL       HID_GetIdleEvent
00002e  e7f9              B        |L19.36|
000030  4621              MOV      r1,r4                 ;993
000032  4628              MOV      r0,r5                 ;993
000034  f7fffffe          BL       HID_GetProtocolEvent
000038  e7f4              B        |L19.36|
00003a  4621              MOV      r1,r4                 ;998
00003c  4628              MOV      r0,r5                 ;998
00003e  f7fffffe          BL       HID_SetReportEvent
000042  e7ef              B        |L19.36|
000044  4621              MOV      r1,r4                 ;1003
000046  4628              MOV      r0,r5                 ;1003
000048  f7fffffe          BL       HID_SetIdleEvent
00004c  e7ea              B        |L19.36|
00004e  4621              MOV      r1,r4                 ;1008
000050  4628              MOV      r0,r5                 ;1008
000052  f7fffffe          BL       HID_SetProtocolEvent
000056  e7e5              B        |L19.36|
000058  bf00              NOP                            ;1013
00005a  bf00              NOP                            ;1013
00005c  2060              MOVS     r0,#0x60              ;1016
00005e  4902              LDR      r1,|L19.104|
000060  7448              STRB     r0,[r1,#0x11]         ;1016
000062  bf00              NOP      
000064  e7de              B        |L19.36|
;;;1018   /******************************************************************************
                          ENDP

000066  0000              DCW      0x0000
                  |L19.104|
                          DCD      0x40005c00

                          AREA ||i.USB_IRQHandler||, CODE, READONLY, ALIGN=2

                  USB_IRQHandler PROC
;;;158    */
;;;159    void USB_IRQHandler(void)
000000  b5fe              PUSH     {r1-r7,lr}
;;;160    {
;;;161    	uint8_t usb_intrin = 0,usb_intrusb = 0,usb_introut = 0;
000002  2000              MOVS     r0,#0
000004  9001              STR      r0,[sp,#4]
000006  2600              MOVS     r6,#0
000008  2700              MOVS     r7,#0
;;;162    			ListUsbData  *pUsbData;
;;;163    			uint16 recv_data_len;
;;;164    	usb_intrin  = USB->INTRIN;									//端点中断标志
00000a  485a              LDR      r0,|L20.372|
00000c  7880              LDRB     r0,[r0,#2]
00000e  9001              STR      r0,[sp,#4]
;;;165    	usb_intrusb = USB->INTRUSB;									//USB中断标志RESET、RESUME、SUSPEND、SOF
000010  4858              LDR      r0,|L20.372|
000012  7986              LDRB     r6,[r0,#6]
;;;166    	usb_introut = USB->INTROUT;
000014  7907              LDRB     r7,[r0,#4]
;;;167    	
;;;168    	//SEGGER_RTT_printf(0,"USB_IRQHandler ###usb_intrin =0x%02x usb_intrusb =0x%02x ###usb_introut =0x%02x\n",usb_intrin,usb_intrusb,usb_introut);
;;;169    	if(usb_introut!=0 || usb_intrin!=0)
;;;170    		{
;;;171    		//SEGGER_RTT_printf(0,"USB_IRQHandler ###usb_intrin =0x%02x usb_intrusb =0x%02x ###usb_introut =0x%02x\n",usb_intrin,usb_intrusb,usb_introut);
;;;172    		}
;;;173    	if(usb_introut!=0)
;;;174    		{
;;;175    		   
;;;176    		 //  SEGGER_RTT_printf(0,"USB_IRQHandler ############################################# usb_introut =0x%02x \n",usb_introut);
;;;177    		}
;;;178    	/*Check for resume from suspend mode, Add call to resume routine here */
;;;179    	if((usb_intrusb & 0x02) != RESET)							//RESUME
000016  2002              MOVS     r0,#2
000018  4030              ANDS     r0,r0,r6
00001a  2800              CMP      r0,#0
00001c  d002              BEQ      |L20.36|
;;;180    	{
;;;181    		usb_state = USB_RESUME_FLAG;
00001e  2002              MOVS     r0,#2
000020  4955              LDR      r1,|L20.376|
000022  7008              STRB     r0,[r1,#0]
                  |L20.36|
;;;182    	}
;;;183    
;;;184    	if(usb_intrusb & USB_IT_USB_SOF_FLAG)						//SOF
000024  2081              MOVS     r0,#0x81
000026  00c0              LSLS     r0,r0,#3
000028  4030              ANDS     r0,r0,r6
00002a  2800              CMP      r0,#0
00002c  d00c              BEQ      |L20.72|
;;;185    	{
;;;186    		USB->INTRUSB &= ~0x08;									//sof
00002e  4851              LDR      r0,|L20.372|
000030  7980              LDRB     r0,[r0,#6]
000032  2108              MOVS     r1,#8
000034  4388              BICS     r0,r0,r1
000036  494f              LDR      r1,|L20.372|
000038  7188              STRB     r0,[r1,#6]
;;;187    		f_sof_flag = 1;
00003a  4850              LDR      r0,|L20.380|
00003c  7800              LDRB     r0,[r0,#0]  ; flag1
00003e  2110              MOVS     r1,#0x10
000040  4388              BICS     r0,r0,r1
000042  3010              ADDS     r0,r0,#0x10
000044  494d              LDR      r1,|L20.380|
000046  7008              STRB     r0,[r1,#0]
                  |L20.72|
;;;188    	}
;;;189    	/* Check for system interrupts */
;;;190    	if((usb_intrusb &USB_IT_USB_RESET_FLAG) != RESET)
000048  484d              LDR      r0,|L20.384|
00004a  4030              ANDS     r0,r0,r6
00004c  2800              CMP      r0,#0
00004e  d001              BEQ      |L20.84|
;;;191    	{
;;;192    		USB_Reset();
000050  f7fffffe          BL       USB_Reset
                  |L20.84|
;;;193    	}
;;;194    
;;;195    	/* Check for endpoint 0 interrupt */
;;;196    	if((usb_intrin & USB_IT_IN_EP0_FLAG) != RESET)
000054  21ff              MOVS     r1,#0xff
000056  3102              ADDS     r1,#2
000058  9801              LDR      r0,[sp,#4]
00005a  4008              ANDS     r0,r0,r1
00005c  2800              CMP      r0,#0
00005e  d002              BEQ      |L20.102|
;;;197    	{
;;;198    //	SEGGER_RTT_printf(0,"USB_Endpoint0(M_EP_NORMAL); 111");
;;;199    		USB_Endpoint0(M_EP_NORMAL);
000060  2000              MOVS     r0,#0
000062  f7fffffe          BL       USB_Endpoint0
                  |L20.102|
;;;200    	}
;;;201    
;;;202    
;;;203    	
;;;204    		
;;;205    
;;;206    		/* Check for endpoint 5 interrupt */
;;;207    	if((usb_introut & USB_IT_OUT_EP1_FLAG) != RESET) //huanghanjing
000066  4847              LDR      r0,|L20.388|
000068  4038              ANDS     r0,r0,r7
00006a  2800              CMP      r0,#0
00006c  d023              BEQ      |L20.182|
;;;208    	{
;;;209    		//USB_EP_Rx(ep_hid_vendor_rx, Vendor_data_Buffer, M_EP_MAXP);
;;;210    				//SEGGER_RTT_printf(0,"US B_IT_OUT_EP1_FLAG ##   # function=%s line=%d\n",__FUNCTION__,__LINE__);
;;;211    			recv_data_len = 	USB_EP_Rx(ep_iap2_vendor_rx, Vendor_data_Buffer, M_EP_MAXP);
00006e  2240              MOVS     r2,#0x40
000070  4945              LDR      r1,|L20.392|
000072  2000              MOVS     r0,#0
000074  f7fffffe          BL       USB_EP_Rx
000078  b285              UXTH     r5,r0
;;;212    		pUsbData = (ListUsbData *)malloc(sizeof(ListUsbData));
00007a  200f              MOVS     r0,#0xf
00007c  f7fffffe          BL       malloc
000080  4604              MOV      r4,r0
;;;213    		pUsbData->pdata = malloc(recv_data_len);
000082  4628              MOV      r0,r5
000084  f7fffffe          BL       malloc
000088  4621              MOV      r1,r4
00008a  310a              ADDS     r1,r1,#0xa
00008c  9000              STR      r0,[sp,#0]
00008e  f7fffffe          BL       __aeabi_uwrite4
;;;214    		pUsbData->m_isUsed = 0;
000092  2000              MOVS     r0,#0
000094  73a0              STRB     r0,[r4,#0xe]
;;;215    		pUsbData->m_pNext = NULL;
000096  4621              MOV      r1,r4
000098  f7fffffe          BL       __aeabi_uwrite4
;;;216    		pUsbData->m_pPre = NULL;
00009c  1d21              ADDS     r1,r4,#4
00009e  2000              MOVS     r0,#0
0000a0  f7fffffe          BL       __aeabi_uwrite4
;;;217    		pUsbData->data_size = recv_data_len;
0000a4  b228              SXTH     r0,r5
0000a6  7220              STRB     r0,[r4,#8]
0000a8  0a00              LSRS     r0,r0,#8
0000aa  7260              STRB     r0,[r4,#9]
;;;218    		
;;;219    
;;;220    			ListUsbData_AddTail(g_usbdata_list,pUsbData);
0000ac  4621              MOV      r1,r4
0000ae  4837              LDR      r0,|L20.396|
0000b0  6800              LDR      r0,[r0,#0]  ; g_usbdata_list
0000b2  f7fffffe          BL       ListUsbData_AddTail
                  |L20.182|
;;;221    		#ifdef _debug_
;;;222    		//Vendor_data_Buffer[0]++;
;;;223    		//USB_Transmit_VendorData((uint8_t*)&send, M_EP_MAXP);
;;;224    		#endif
;;;225    	}
;;;226    	
;;;227    	if((usb_introut & USB_IT_OUT_EP2_FLAG) != RESET) //huanghanjing
0000b6  2081              MOVS     r0,#0x81
0000b8  0080              LSLS     r0,r0,#2
0000ba  4038              ANDS     r0,r0,r7
0000bc  2800              CMP      r0,#0
0000be  d030              BEQ      |L20.290|
;;;228    	{
;;;229    	startCriticalSection();
0000c0  f7fffffe          BL       startCriticalSection
;;;230    	//SEGGER_RTT_printf(0,"USB_IT_OUT_EP2_FLAG USB_EP_Rx(2 \n");
;;;231    	recv_data_len = 	USB_EP_Rx(2, Vendor_data_Buffer, M_EP_MAXP);
0000c4  2240              MOVS     r2,#0x40
0000c6  4930              LDR      r1,|L20.392|
0000c8  2002              MOVS     r0,#2
0000ca  f7fffffe          BL       USB_EP_Rx
0000ce  b285              UXTH     r5,r0
;;;232    	//SEGGER_RTT_printf(0,"USB_IT_OUT_EP2_FLAG rr ### function=%s line=%d recv_data_len=%d\n",__FUNCTION__,__LINE__,recv_data_len);
;;;233    	//for(int i=0;i<recv_data_len;i++)
;;;234    		//SEGGER_RTT_printf(0,"22 0x%02x ",Vendor_data_Buffer[i]);
;;;235    		pUsbData = (ListUsbData *)malloc(sizeof(ListUsbData));
0000d0  200f              MOVS     r0,#0xf
0000d2  f7fffffe          BL       malloc
0000d6  4604              MOV      r4,r0
;;;236    		
;;;237    		//SEGGER_RTT_printf(0,"\n ### function=%s line=%d recv_data_len=%d\n",__FUNCTION__,__LINE__,recv_data_len);
;;;238    		pUsbData->pdata = malloc(recv_data_len);
0000d8  4628              MOV      r0,r5
0000da  f7fffffe          BL       malloc
0000de  4621              MOV      r1,r4
0000e0  310a              ADDS     r1,r1,#0xa
0000e2  9000              STR      r0,[sp,#0]
0000e4  f7fffffe          BL       __aeabi_uwrite4
;;;239    		memcpy(pUsbData->pdata,Vendor_data_Buffer,recv_data_len);
0000e8  4620              MOV      r0,r4
0000ea  300a              ADDS     r0,r0,#0xa
0000ec  f7fffffe          BL       __aeabi_uread4
0000f0  462a              MOV      r2,r5
0000f2  4925              LDR      r1,|L20.392|
0000f4  9000              STR      r0,[sp,#0]
0000f6  f7fffffe          BL       __aeabi_memcpy
;;;240    	//	SEGGER_RTT_printf(0,"\n ### function=%s line=%d recv_data_len=%d\n",__FUNCTION__,__LINE__,recv_data_len);
;;;241    		pUsbData->m_isUsed = 0;
0000fa  2000              MOVS     r0,#0
0000fc  73a0              STRB     r0,[r4,#0xe]
;;;242    		pUsbData->m_pNext = NULL;
0000fe  4621              MOV      r1,r4
000100  f7fffffe          BL       __aeabi_uwrite4
;;;243    		pUsbData->m_pPre = NULL;
000104  1d21              ADDS     r1,r4,#4
000106  2000              MOVS     r0,#0
000108  f7fffffe          BL       __aeabi_uwrite4
;;;244    		pUsbData->data_size = recv_data_len;
00010c  b228              SXTH     r0,r5
00010e  7220              STRB     r0,[r4,#8]
000110  0a00              LSRS     r0,r0,#8
000112  7260              STRB     r0,[r4,#9]
;;;245    		
;;;246    
;;;247    			ListUsbData_AddTail(g_usbdata_list,pUsbData);
000114  4621              MOV      r1,r4
000116  481d              LDR      r0,|L20.396|
000118  6800              LDR      r0,[r0,#0]  ; g_usbdata_list
00011a  f7fffffe          BL       ListUsbData_AddTail
;;;248    			endCriticalSection();
00011e  f7fffffe          BL       endCriticalSection
                  |L20.290|
;;;249    	//SEGGER_RTT_printf(0,"\n USB_IT_OUT_EP2_FLAG 222 ### function=%s line=%d recv_data_len=%d\n",__FUNCTION__,__LINE__,recv_data_len);
;;;250    
;;;251    		#ifdef _debug_
;;;252    		//Vendor_data_Buffer[0]++;
;;;253    		//USB_Transmit_VendorData((uint8_t*)&send, M_EP_MAXP);
;;;254    		#endif
;;;255    	}
;;;256    	
;;;257    
;;;258    	
;;;259    	/* Check for endpoint 5 interrupt */
;;;260    	if((usb_introut & USB_IT_OUT_EP5_FLAG) != RESET)
000122  2011              MOVS     r0,#0x11
000124  0140              LSLS     r0,r0,#5
000126  4038              ANDS     r0,r0,r7
000128  2800              CMP      r0,#0
00012a  d004              BEQ      |L20.310|
;;;261    	{
;;;262    	
;;;263    	//SEGGER_RTT_printf(0,"USB_IT_OUT_EP2_FLAG ### function=%s line=%d\n",__FUNCTION__,__LINE__);
;;;264    		USB_EP_Rx(ep_hid_vendor_rx, Vendor_data_Buffer, M_EP_MAXP);
00012c  2240              MOVS     r2,#0x40
00012e  4916              LDR      r1,|L20.392|
000130  2005              MOVS     r0,#5
000132  f7fffffe          BL       USB_EP_Rx
                  |L20.310|
;;;265    		
;;;266    		#ifdef _debug_
;;;267    		//Vendor_data_Buffer[0]++;
;;;268    		//USB_Transmit_VendorData((uint8_t*)&send, M_EP_MAXP);
;;;269    		#endif
;;;270    	}
;;;271    	
;;;272    	/* Check for endpoint 7 interrupt */
;;;273    	if((usb_introut & USB_IT_OUT_EP7_FLAG) != RESET)
000136  2005              MOVS     r0,#5
000138  01c0              LSLS     r0,r0,#7
00013a  4038              ANDS     r0,r0,r7
00013c  2800              CMP      r0,#0
00013e  d00d              BEQ      |L20.348|
;;;274    	{	
;;;275    		USB_EP_Rx(7, Vendor_data_Buffer, M_EP_MAXP);
000140  2240              MOVS     r2,#0x40
000142  4911              LDR      r1,|L20.392|
000144  2007              MOVS     r0,#7
000146  f7fffffe          BL       USB_EP_Rx
;;;276    		
;;;277    		#ifdef _debug_
;;;278    		Vendor_data_Buffer[0]++;
00014a  480f              LDR      r0,|L20.392|
00014c  7800              LDRB     r0,[r0,#0]  ; Vendor_data_Buffer
00014e  1c40              ADDS     r0,r0,#1
000150  490d              LDR      r1,|L20.392|
000152  7008              STRB     r0,[r1,#0]
;;;279    		USB_EP_Tx(6, Vendor_data_Buffer, M_EP_MAXP);
000154  2240              MOVS     r2,#0x40
000156  2006              MOVS     r0,#6
000158  f7fffffe          BL       USB_EP_Tx
                  |L20.348|
;;;280    		#endif
;;;281    	}
;;;282    
;;;283    	/* Check for suspend mode */
;;;284    	/* Add call to suspend routine here*/
;;;285    	if((usb_intrusb & 0x01) != RESET)
00015c  07f0              LSLS     r0,r6,#31
00015e  0fc0              LSRS     r0,r0,#31
000160  2800              CMP      r0,#0
000162  d006              BEQ      |L20.370|
;;;286    	{
;;;287    		if(gnDevState > DEVSTATE_ADDRESS)
000164  480a              LDR      r0,|L20.400|
000166  6800              LDR      r0,[r0,#0]  ; gnDevState
000168  2801              CMP      r0,#1
00016a  d902              BLS      |L20.370|
;;;288    		{
;;;289    			usb_state = USB_SUSPEND_FLAG;						//usb suspend
00016c  2001              MOVS     r0,#1
00016e  4902              LDR      r1,|L20.376|
000170  7008              STRB     r0,[r1,#0]
                  |L20.370|
;;;290    		}
;;;291    	}
;;;292    }
000172  bdfe              POP      {r1-r7,pc}
;;;293    /******************************************************************************
                          ENDP

                  |L20.372|
                          DCD      0x40005c00
                  |L20.376|
                          DCD      usb_state
                  |L20.380|
                          DCD      flag1
                  |L20.384|
                          DCD      0x00000404
                  |L20.388|
                          DCD      0x00000202
                  |L20.392|
                          DCD      Vendor_data_Buffer
                  |L20.396|
                          DCD      g_usbdata_list
                  |L20.400|
                          DCD      gnDevState

                          AREA ||i.USB_ITConfig||, CODE, READONLY, ALIGN=2

                  USB_ITConfig PROC
;;;661    */
;;;662    void USB_ITConfig(uint32_t USB_IT, FunctionalState NewState)
000000  b530              PUSH     {r4,r5,lr}
;;;663    {
000002  460a              MOV      r2,r1
;;;664        __IO uint8_t *tmp = (__IO uint8_t *)USB_BASE;
000004  4916              LDR      r1,|L21.96|
;;;665        uint32_t IT_FLAG = 0;
000006  2300              MOVS     r3,#0
;;;666    
;;;667        assert_param(IS_USB_CONFIG_IT(USB_IT));
;;;668        assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;669    
;;;670        if(USB_IT & 0x00000100)
000008  158c              ASRS     r4,r1,#22
00000a  4004              ANDS     r4,r4,r0
00000c  2c00              CMP      r4,#0
00000e  d005              BEQ      |L21.28|
;;;671        {
;;;672          tmp = &USB->INTRINE;
000010  1dc9              ADDS     r1,r1,#7
;;;673          IT_FLAG = USB_IT & 0xfffffeff;
000012  158d              ASRS     r5,r1,#22
000014  4604              MOV      r4,r0
000016  43ac              BICS     r4,r4,r5
000018  4623              MOV      r3,r4
00001a  e016              B        |L21.74|
                  |L21.28|
;;;674        }
;;;675        else if(USB_IT & 0x00000200)
00001c  2401              MOVS     r4,#1
00001e  0264              LSLS     r4,r4,#9
000020  4004              ANDS     r4,r4,r0
000022  2c00              CMP      r4,#0
000024  d006              BEQ      |L21.52|
;;;676        {
;;;677          tmp = &USB->INTROUTE;
000026  490e              LDR      r1,|L21.96|
000028  3109              ADDS     r1,r1,#9
;;;678          IT_FLAG = USB_IT & 0xfffffdff;
00002a  154d              ASRS     r5,r1,#21
00002c  4604              MOV      r4,r0
00002e  43ac              BICS     r4,r4,r5
000030  4623              MOV      r3,r4
000032  e00a              B        |L21.74|
                  |L21.52|
;;;679        }
;;;680        else if(USB_IT & 0x00000400)
000034  2401              MOVS     r4,#1
000036  02a4              LSLS     r4,r4,#10
000038  4004              ANDS     r4,r4,r0
00003a  2c00              CMP      r4,#0
00003c  d005              BEQ      |L21.74|
;;;681        {
;;;682          tmp = &USB->INTRUSBE;
00003e  4908              LDR      r1,|L21.96|
000040  310b              ADDS     r1,r1,#0xb
;;;683          IT_FLAG = USB_IT & 0xfffffbff;
000042  150d              ASRS     r5,r1,#20
000044  4604              MOV      r4,r0
000046  43ac              BICS     r4,r4,r5
000048  4623              MOV      r3,r4
                  |L21.74|
;;;684        }
;;;685    
;;;686        if(NewState != DISABLE)
00004a  2a00              CMP      r2,#0
00004c  d004              BEQ      |L21.88|
;;;687        {
;;;688          *((__IO uint8_t *)tmp) |= (uint8_t)IT_FLAG;
00004e  780c              LDRB     r4,[r1,#0]
000050  b2dd              UXTB     r5,r3
000052  432c              ORRS     r4,r4,r5
000054  700c              STRB     r4,[r1,#0]
000056  e002              B        |L21.94|
                  |L21.88|
;;;689        }
;;;690        else
;;;691        {
;;;692          *((__IO uint8_t *)tmp) &= ~((uint8_t)IT_FLAG);
000058  780c              LDRB     r4,[r1,#0]
00005a  439c              BICS     r4,r4,r3
00005c  700c              STRB     r4,[r1,#0]
                  |L21.94|
;;;693        }
;;;694    }
00005e  bd30              POP      {r4,r5,pc}
;;;695    /******************************************************************************
                          ENDP

                  |L21.96|
                          DCD      0x40005c00

                          AREA ||i.USB_Init||, CODE, READONLY, ALIGN=2

                  USB_Init PROC
;;;121    */
;;;122    void USB_Init(void)
000000  b508              PUSH     {r3,lr}
;;;123    {
;;;124      NVIC_InitTypeDef NVIC_InitStructure;
;;;125    
;;;126    	if(RCC_GetFlagStatus(RCC_FLAG_HSI48RDY) != SET)
000002  2071              MOVS     r0,#0x71
000004  f7fffffe          BL       RCC_GetFlagStatus
000008  2801              CMP      r0,#1
00000a  d008              BEQ      |L22.30|
;;;127    	{
;;;128    		RCC_HSI48Cmd(ENABLE);
00000c  2001              MOVS     r0,#1
00000e  f7fffffe          BL       RCC_HSI48Cmd
;;;129    		while(RCC_GetFlagStatus(RCC_FLAG_HSI48RDY) != SET);
000012  bf00              NOP      
                  |L22.20|
000014  2071              MOVS     r0,#0x71
000016  f7fffffe          BL       RCC_GetFlagStatus
00001a  2801              CMP      r0,#1
00001c  d1fa              BNE      |L22.20|
                  |L22.30|
;;;130    	}
;;;131      RCC_USBCLKConfig(RCC_USBCLK_HSI48);
00001e  2000              MOVS     r0,#0
000020  f7fffffe          BL       RCC_USBCLKConfig
;;;132    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USB,ENABLE);
000024  2101              MOVS     r1,#1
000026  05c8              LSLS     r0,r1,#23
000028  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;133    
;;;134    		
;;;135    	USB_ITConfig(USB_IT_USB_RESUME_FLAG,ENABLE);
00002c  2101              MOVS     r1,#1
00002e  4814              LDR      r0,|L22.128|
000030  f7fffffe          BL       USB_ITConfig
;;;136    	USB_ITConfig(USB_IT_USB_SUSPEND_FLAG,ENABLE);
000034  2101              MOVS     r1,#1
000036  4812              LDR      r0,|L22.128|
000038  1e40              SUBS     r0,r0,#1
00003a  f7fffffe          BL       USB_ITConfig
;;;137    	USB_ITConfig(USB_IT_USB_SOF_FLAG,ENABLE);
00003e  2101              MOVS     r1,#1
000040  2081              MOVS     r0,#0x81
000042  00c0              LSLS     r0,r0,#3
000044  f7fffffe          BL       USB_ITConfig
;;;138    	USB_ITConfig(USB_IT_USB_RESET_FLAG,ENABLE);
000048  2101              MOVS     r1,#1
00004a  480d              LDR      r0,|L22.128|
00004c  1c80              ADDS     r0,r0,#2
00004e  f7fffffe          BL       USB_ITConfig
;;;139    		
;;;140      USB_PDCTRLConfig(USB_PDCTRL_PU_ENABLE);
000052  2001              MOVS     r0,#1
000054  f7fffffe          BL       USB_PDCTRLConfig
;;;141    	
;;;142      NVIC_InitStructure.NVIC_IRQChannel = USB_IRQn;
000058  211f              MOVS     r1,#0x1f
00005a  4668              MOV      r0,sp
00005c  7001              STRB     r1,[r0,#0]
;;;143      NVIC_InitStructure.NVIC_IRQChannelPriority = 0;
00005e  2100              MOVS     r1,#0
000060  7041              STRB     r1,[r0,#1]
;;;144      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000062  2101              MOVS     r1,#1
000064  7081              STRB     r1,[r0,#2]
;;;145      NVIC_Init(&NVIC_InitStructure);
000066  f7fffffe          BL       NVIC_Init
;;;146    	
;;;147    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_CRS,ENABLE);
00006a  2101              MOVS     r1,#1
00006c  06c8              LSLS     r0,r1,#27
00006e  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;148    	CRS_FrequencyErrorCounterCmd(ENABLE);
000072  2001              MOVS     r0,#1
000074  f7fffffe          BL       CRS_FrequencyErrorCounterCmd
;;;149    	CRS_AutomaticCalibrationCmd(ENABLE);
000078  2001              MOVS     r0,#1
00007a  f7fffffe          BL       CRS_AutomaticCalibrationCmd
;;;150    }
00007e  bd08              POP      {r3,pc}
;;;151    
                          ENDP

                  |L22.128|
                          DCD      0x00000402

                          AREA ||i.USB_PDCTRLConfig||, CODE, READONLY, ALIGN=2

                  USB_PDCTRLConfig PROC
;;;566    */
;;;567    void USB_PDCTRLConfig(uint8_t PDCT)
000000  4601              MOV      r1,r0
;;;568    {
;;;569        uint8_t temp = 0;
000002  2000              MOVS     r0,#0
;;;570    
;;;571        assert_param(IS_USB_PDCTRL(PDCT));
;;;572    
;;;573        temp = USB->PDCTRL;
000004  4a04              LDR      r2,|L23.24|
000006  7bd0              LDRB     r0,[r2,#0xf]
;;;574        temp &= ~USB_PDCTRL_FLAG;
000008  0880              LSRS     r0,r0,#2
00000a  0080              LSLS     r0,r0,#2
;;;575        temp |= PDCT;
00000c  4602              MOV      r2,r0
00000e  430a              ORRS     r2,r2,r1
000010  4610              MOV      r0,r2
;;;576        USB->PDCTRL = temp;
000012  4a01              LDR      r2,|L23.24|
000014  73d0              STRB     r0,[r2,#0xf]
;;;577    
;;;578    }
000016  4770              BX       lr
;;;579    /******************************************************************************
                          ENDP

                  |L23.24|
                          DCD      0x40005c00

                          AREA ||i.USB_ReadRegister||, CODE, READONLY, ALIGN=2

                  USB_ReadRegister PROC
;;;546    */
;;;547    uint8_t USB_ReadRegister(uint8_t USB_Refister)
000000  b508              PUSH     {r3,lr}
;;;548    {
000002  4601              MOV      r1,r0
;;;549        __IO uint32_t tmp = 0;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;550    
;;;551        /* Check the parameters */
;;;552        assert_param(IS_USB_REGISTER(USB_Refister));
;;;553    
;;;554        tmp = (uint32_t)USB;
000008  4803              LDR      r0,|L24.24|
00000a  9000              STR      r0,[sp,#0]
;;;555        tmp += USB_Refister;
00000c  9800              LDR      r0,[sp,#0]
00000e  1840              ADDS     r0,r0,r1
000010  9000              STR      r0,[sp,#0]
;;;556    
;;;557        /* Return the selected register value */
;;;558        return (*(__IO uint8_t *) tmp);	
000012  9800              LDR      r0,[sp,#0]
000014  7800              LDRB     r0,[r0,#0]
;;;559    }
000016  bd08              POP      {r3,pc}
;;;560    /******************************************************************************
                          ENDP

                  |L24.24|
                          DCD      0x40005c00

                          AREA ||i.USB_Remote_Wakeup||, CODE, READONLY, ALIGN=2

                  USB_Remote_Wakeup PROC
;;;395    */
;;;396    void USB_Remote_Wakeup(void)
000000  4806              LDR      r0,|L25.28|
;;;397    {
;;;398    	USB->POWER |= 0x04;
000002  7840              LDRB     r0,[r0,#1]
000004  2104              MOVS     r1,#4
000006  4308              ORRS     r0,r0,r1
000008  4904              LDR      r1,|L25.28|
00000a  7048              STRB     r0,[r1,#1]
;;;399    //	SysTick_Delay_Ms(12);
;;;400    	USB->POWER &= ~0x04;			
00000c  4608              MOV      r0,r1
00000e  7840              LDRB     r0,[r0,#1]
000010  2104              MOVS     r1,#4
000012  4388              BICS     r0,r0,r1
000014  4901              LDR      r1,|L25.28|
000016  7048              STRB     r0,[r1,#1]
;;;401    }
000018  4770              BX       lr
;;;402    
                          ENDP

00001a  0000              DCW      0x0000
                  |L25.28|
                          DCD      0x40005c00

                          AREA ||i.USB_Reset||, CODE, READONLY, ALIGN=2

                  USB_Reset PROC
;;;339    */
;;;340    void USB_Reset(void)
000000  b500              PUSH     {lr}
;;;341    {
000002  b089              SUB      sp,sp,#0x24
;;;342    	M_EPBIN_STATUS  tEpin;
;;;343    	M_EPBOUT_STATUS tEpout;
;;;344    	
;;;345    	/* Set device into default state */
;;;346    	gnDevState = DEVSTATE_DEFAULT;
000004  2000              MOVS     r0,#0
000006  492c              LDR      r1,|L26.184|
000008  6008              STR      r0,[r1,#0]  ; gnDevState
;;;347    //    pInformation->Current_Feature = USB_FSConfigDescriptor[7];
;;;348    	/* Reset any state machines for each endpoint */
;;;349    	/* This example assumes 2 bulk IN endpoints with endpoint numbers 1,2, */
;;;350    	/* and 2 bulk out endpoints with endpoint numbers 1,2 */
;;;351    	USB_Endpoint0(M_EP_RESET);
00000a  2001              MOVS     r0,#1
00000c  f7fffffe          BL       USB_Endpoint0
;;;352    
;;;353    	/* Initialise endpoint status structures with endpoint numbers */
;;;354    
;;;355    	tEpin.byEP = 1;
000010  2101              MOVS     r1,#1
000012  a808              ADD      r0,sp,#0x20
000014  7001              STRB     r1,[r0,#0]
;;;356    	tEpin.nBytesLeft = M_EP_NODATA;
000016  1e88              SUBS     r0,r1,#2
000018  9007              STR      r0,[sp,#0x1c]
;;;357    	EndpointBulkIn(tEpin, M_EP_RESET);
00001a  2301              MOVS     r3,#1
00001c  a806              ADD      r0,sp,#0x18
00001e  c807              LDM      r0,{r0-r2}
000020  f7fffffe          BL       EndpointBulkIn
;;;358    	
;;;359    	tEpin.byEP = 2;
000024  2102              MOVS     r1,#2
000026  a808              ADD      r0,sp,#0x20
000028  7001              STRB     r1,[r0,#0]
;;;360    	tEpin.nBytesLeft = M_EP_NODATA;
00002a  1ec8              SUBS     r0,r1,#3
00002c  9007              STR      r0,[sp,#0x1c]
;;;361    	EndpointBulkIn(tEpin, M_EP_RESET);
00002e  2301              MOVS     r3,#1
000030  a806              ADD      r0,sp,#0x18
000032  c807              LDM      r0,{r0-r2}
000034  f7fffffe          BL       EndpointBulkIn
;;;362    	
;;;363    	tEpin.byEP = 3;
000038  2103              MOVS     r1,#3
00003a  a808              ADD      r0,sp,#0x20
00003c  7001              STRB     r1,[r0,#0]
;;;364    	tEpin.nBytesLeft = M_EP_NODATA;
00003e  1f08              SUBS     r0,r1,#4
000040  9007              STR      r0,[sp,#0x1c]
;;;365    	EndpointBulkIn(tEpin, M_EP_RESET);
000042  2301              MOVS     r3,#1
000044  a806              ADD      r0,sp,#0x18
000046  c807              LDM      r0,{r0-r2}
000048  f7fffffe          BL       EndpointBulkIn
;;;366    	
;;;367    	tEpin.byEP = 4;
00004c  2104              MOVS     r1,#4
00004e  a808              ADD      r0,sp,#0x20
000050  7001              STRB     r1,[r0,#0]
;;;368    	tEpin.nBytesLeft = M_EP_NODATA;
000052  1f48              SUBS     r0,r1,#5
000054  9007              STR      r0,[sp,#0x1c]
;;;369    	EndpointBulkIn(tEpin, M_EP_RESET);
000056  2301              MOVS     r3,#1
000058  a806              ADD      r0,sp,#0x18
00005a  c807              LDM      r0,{r0-r2}
00005c  f7fffffe          BL       EndpointBulkIn
;;;370    	
;;;371    	tEpin.byEP = 6;
000060  2106              MOVS     r1,#6
000062  a808              ADD      r0,sp,#0x20
000064  7001              STRB     r1,[r0,#0]
;;;372    	tEpin.nBytesLeft = M_EP_NODATA;
000066  1fc8              SUBS     r0,r1,#7
000068  9007              STR      r0,[sp,#0x1c]
;;;373    	EndpointBulkIn(tEpin, M_EP_RESET);
00006a  2301              MOVS     r3,#1
00006c  a806              ADD      r0,sp,#0x18
00006e  c807              LDM      r0,{r0-r2}
000070  f7fffffe          BL       EndpointBulkIn
;;;374    	
;;;375    	//--------------------------------------//
;;;376    	
;;;377    	tEpout.byEP = 5;
000074  2105              MOVS     r1,#5
000076  4668              MOV      r0,sp
000078  7501              STRB     r1,[r0,#0x14]
;;;378    	tEpout.nBuffLen = M_EP_MAXP;
00007a  2040              MOVS     r0,#0x40
00007c  9003              STR      r0,[sp,#0xc]
;;;379    	tEpout.nBytesRecv = 0;
00007e  2000              MOVS     r0,#0
000080  9004              STR      r0,[sp,#0x10]
;;;380    	EndpointBulkOut(tEpout, M_EP_RESET);
000082  2001              MOVS     r0,#1
000084  9000              STR      r0,[sp,#0]
000086  a802              ADD      r0,sp,#8
000088  c80f              LDM      r0,{r0-r3}
00008a  f7fffffe          BL       EndpointBulkOut
;;;381    	
;;;382    	tEpout.byEP = 7;
00008e  2107              MOVS     r1,#7
000090  4668              MOV      r0,sp
000092  7501              STRB     r1,[r0,#0x14]
;;;383    	tEpout.nBuffLen = M_EP_MAXP;
000094  2040              MOVS     r0,#0x40
000096  9003              STR      r0,[sp,#0xc]
;;;384    	tEpout.nBytesRecv = 0;
000098  2000              MOVS     r0,#0
00009a  9004              STR      r0,[sp,#0x10]
;;;385    	EndpointBulkOut(tEpout, M_EP_RESET);
00009c  2001              MOVS     r0,#1
00009e  9000              STR      r0,[sp,#0]
0000a0  a802              ADD      r0,sp,#8
0000a2  c80f              LDM      r0,{r0-r3}
0000a4  f7fffffe          BL       EndpointBulkOut
;;;386    	
;;;387    	USB->POWER |= 0x01;												//允许挂起模块
0000a8  4804              LDR      r0,|L26.188|
0000aa  7840              LDRB     r0,[r0,#1]
0000ac  2101              MOVS     r1,#1
0000ae  4308              ORRS     r0,r0,r1
0000b0  4902              LDR      r1,|L26.188|
0000b2  7048              STRB     r0,[r1,#1]
;;;388    }
0000b4  b009              ADD      sp,sp,#0x24
0000b6  bd00              POP      {pc}
;;;389    /******************************************************************************
                          ENDP

                  |L26.184|
                          DCD      gnDevState
                  |L26.188|
                          DCD      0x40005c00

                          AREA ||i.USB_StdDev_Req||, CODE, READONLY, ALIGN=2

                  USB_StdDev_Req PROC
;;;1066   */
;;;1067   static void USB_StdDev_Req(PM_EP0_STATUS pep0state, PCOMMAND pcmd)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1068   {
000002  b089              SUB      sp,sp,#0x24
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;1069   	int	bError = FALSE, bNoData = FALSE, n;
000008  2000              MOVS     r0,#0
00000a  9008              STR      r0,[sp,#0x20]
00000c  9007              STR      r0,[sp,#0x1c]
;;;1070   	BYTE	by;
;;;1071   	BYTE	byConfig;
;;;1072   	PSTD_CFG_DSCR	pcfg;	
;;;1073   	
;;;1074   	uint8_t Related_Endpoint;
;;;1075   	uint8_t wIndex0 = pcmd->USBwIndex0;
00000e  7928              LDRB     r0,[r5,#4]
000010  9002              STR      r0,[sp,#8]
;;;1076   	Related_Endpoint = (wIndex0 & 0x0f);		
000012  9802              LDR      r0,[sp,#8]
000014  0700              LSLS     r0,r0,#28
000016  0f00              LSRS     r0,r0,#28
000018  9003              STR      r0,[sp,#0xc]
;;;1077   	uint8_t srbuff;
;;;1078   	uint8_t txdat[2] = {0};
00001a  2000              MOVS     r0,#0
00001c  9001              STR      r0,[sp,#4]
;;;1079   	
;;;1080   	//SEGGER_RTT_printf(0,"USB_StdDev_Req;  333 pcmd->bRequest=%d\n",pcmd->bRequest);
;;;1081   	switch(pcmd->bRequest) 
00001e  7868              LDRB     r0,[r5,#1]
000020  280c              CMP      r0,#0xc
000022  d270              BCS      |L27.262|
000024  0043              LSLS     r3,r0,#1
000026  447b              ADD      r3,r3,pc
000028  889b              LDRH     r3,[r3,#4]
00002a  005b              LSLS     r3,r3,#1
00002c  449f              ADD      pc,pc,r3
00002e  03d5              DCW      0x03d5
000030  035b006b          DCW      0x035b,0x006b
000034  02f6006b          DCW      0x02f6,0x006b
000038  000b0020          DCW      0x000b,0x0020
00003c  006b029e          DCW      0x006b,0x029e
000040  023e02cf          DCW      0x023e,0x02cf
000044  0276              DCW      0x0276
;;;1082   	{
;;;1083   		/***用来给设备分配地址***/
;;;1084   		case SET_ADDRESS:
;;;1085   			/* Store device function address until status stage of request */
;;;1086   			if (pcmd->bmRequestType != M_CMD_STDDEVOUT)
000046  7828              LDRB     r0,[r5,#0]
000048  2800              CMP      r0,#0
00004a  d002              BEQ      |L27.82|
;;;1087   			{
;;;1088   				bError = TRUE;
00004c  2001              MOVS     r0,#1
00004e  9008              STR      r0,[sp,#0x20]
000050  e00d              B        |L27.110|
                  |L27.82|
;;;1089   			}
;;;1090   			else if (gnDevState <= DEVSTATE_ADDRESS) 
000052  48f8              LDR      r0,|L27.1076|
000054  6800              LDR      r0,[r0,#0]  ; gnDevState
000056  2801              CMP      r0,#1
000058  d807              BHI      |L27.106|
;;;1091   			{
;;;1092   				pep0state->byFAddr = (BYTE)pcmd->USBwValue;
00005a  78e8              LDRB     r0,[r5,#3]
00005c  78a9              LDRB     r1,[r5,#2]
00005e  0200              LSLS     r0,r0,#8
000060  4308              ORRS     r0,r0,r1
000062  7420              STRB     r0,[r4,#0x10]
;;;1093   				bNoData = TRUE;
000064  2001              MOVS     r0,#1
000066  9007              STR      r0,[sp,#0x1c]
000068  e001              B        |L27.110|
                  |L27.106|
;;;1094   			}
;;;1095   			else
;;;1096   			{
;;;1097   				bError = TRUE;
00006a  2001              MOVS     r0,#1
00006c  9008              STR      r0,[sp,#0x20]
                  |L27.110|
;;;1098   			}
;;;1099   			break;
00006e  e21c              B        |L27.1194|
;;;1100   			
;;;1101   		/***用于主机获取设备的特定描述符***/		
;;;1102   		case GET_DESCRIPTOR:
;;;1103   			/* Decode the required descriptor from the command */
;;;1104   			/***报告描述符的接受者是接口，pcmd->bmRequestType = 0x81时传输HID报告描述符***/
;;;1105   			if(!(pcmd->bmRequestType & M_CMD_STDDEVIN))
000070  7828              LDRB     r0,[r5,#0]
000072  2180              MOVS     r1,#0x80
000074  4008              ANDS     r0,r0,r1
000076  2800              CMP      r0,#0
000078  d102              BNE      |L27.128|
;;;1106   			{
;;;1107   				bError = TRUE;
00007a  2001              MOVS     r0,#1
00007c  9008              STR      r0,[sp,#0x20]
00007e  e214              B        |L27.1194|
                  |L27.128|
;;;1108   			}
;;;1109   			else 
;;;1110   			{
;;;1111   				switch(pcmd->USBwValue & M_CMD_DESCMASK) 
000080  78e8              LDRB     r0,[r5,#3]
000082  78a9              LDRB     r1,[r5,#2]
000084  0200              LSLS     r0,r0,#8
000086  4308              ORRS     r0,r0,r1
000088  21ff              MOVS     r1,#0xff
00008a  0209              LSLS     r1,r1,#8
00008c  4008              ANDS     r0,r0,r1
00008e  2203              MOVS     r2,#3
000090  0252              LSLS     r2,r2,#9
000092  1a81              SUBS     r1,r0,r2
000094  4290              CMP      r0,r2
000096  d037              BEQ      |L27.264|
000098  dc0c              BGT      |L27.180|
00009a  38ff              SUBS     r0,r0,#0xff
00009c  3801              SUBS     r0,#1
00009e  2800              CMP      r0,#0
0000a0  d011              BEQ      |L27.198|
0000a2  38ff              SUBS     r0,r0,#0xff
0000a4  3801              SUBS     r0,#1
0000a6  2800              CMP      r0,#0
0000a8  d031              BEQ      |L27.270|
0000aa  38ff              SUBS     r0,r0,#0xff
0000ac  3801              SUBS     r0,#1
0000ae  2800              CMP      r0,#0
                  |L27.176|
0000b0  d17e              BNE      |L27.432|
0000b2  e112              B        |L27.730|
                  |L27.180|
0000b4  39ff              SUBS     r1,r1,#0xff
0000b6  3901              SUBS     r1,#1
0000b8  2900              CMP      r1,#0
0000ba  d059              BEQ      |L27.368|
0000bc  201b              MOVS     r0,#0x1b
0000be  0200              LSLS     r0,r0,#8
0000c0  1a08              SUBS     r0,r1,r0
0000c2  d1f5              BNE      |L27.176|
0000c4  e057              B        |L27.374|
                  |L27.198|
;;;1112   				{
;;;1113   					/***设备描述符***/
;;;1114   					case M_CMD_DEVICE:
;;;1115   						/* Prepare to return Standard Device Descriptor */
;;;1116   						pep0state->nBytesLeft = USB_FSDeviceDescriptorSize;
0000c6  1d21              ADDS     r1,r4,#4
0000c8  48db              LDR      r0,|L27.1080|
0000ca  8800              LDRH     r0,[r0,#0]  ; USB_FSDeviceDescriptorSize
0000cc  f7fffffe          BL       __aeabi_uwrite4
;;;1117   						/* Check host is allowing a descriptor this long */
;;;1118   						if(pcmd->USBwLength < pep0state->nBytesLeft)
0000d0  1d20              ADDS     r0,r4,#4
0000d2  f7fffffe          BL       __aeabi_uread4
0000d6  79e9              LDRB     r1,[r5,#7]
0000d8  79aa              LDRB     r2,[r5,#6]
0000da  0209              LSLS     r1,r1,#8
0000dc  4311              ORRS     r1,r1,r2
0000de  4288              CMP      r0,r1
0000e0  dd07              BLE      |L27.242|
;;;1119   						{
;;;1120   							pep0state->nBytesLeft = pcmd->USBwLength;
0000e2  79e9              LDRB     r1,[r5,#7]
0000e4  79aa              LDRB     r2,[r5,#6]
0000e6  0209              LSLS     r1,r1,#8
0000e8  4311              ORRS     r1,r1,r2
0000ea  4608              MOV      r0,r1
0000ec  1d21              ADDS     r1,r4,#4
0000ee  f7fffffe          BL       __aeabi_uwrite4
                  |L27.242|
;;;1121   						}
;;;1122   						
;;;1123   						pep0state->pData = (void*)USB_FSDeviceDescriptor;
0000f2  4621              MOV      r1,r4
0000f4  3108              ADDS     r1,r1,#8
0000f6  48d1              LDR      r0,|L27.1084|
0000f8  f7fffffe          BL       __aeabi_uwrite4
;;;1124   						pep0state->nState = M_EP0_TX;
0000fc  4621              MOV      r1,r4
0000fe  2002              MOVS     r0,#2
000100  f7fffffe          BL       __aeabi_uwrite4
;;;1125   						break;
000104  e1d0              B        |L27.1192|
                  |L27.262|
000106  e3e7              B        |L27.2264|
                  |L27.264|
;;;1126   					/***设备限定描述符***/	
;;;1127   					case M_CMD_DEVQUAL:
;;;1128   						/* No alternate speed supported */
;;;1129   						bError = TRUE;
000108  2001              MOVS     r0,#1
00010a  9008              STR      r0,[sp,#0x20]
;;;1130   						break;
00010c  e1cc              B        |L27.1192|
                  |L27.270|
;;;1131   					/***配置描述符***/					
;;;1132   					case M_CMD_CONFIG:
;;;1133   						byConfig = (BYTE)(pcmd->USBwValue & 0x00FF);
00010e  78e8              LDRB     r0,[r5,#3]
000110  78a9              LDRB     r1,[r5,#2]
000112  0200              LSLS     r0,r0,#8
000114  4308              ORRS     r0,r0,r1
000116  b2c0              UXTB     r0,r0
000118  9005              STR      r0,[sp,#0x14]
;;;1134   						if(byConfig>USB_FSDeviceDescriptor[USB_FSDeviceDescriptorSize-1])
00011a  48c7              LDR      r0,|L27.1080|
00011c  8800              LDRH     r0,[r0,#0]  ; USB_FSDeviceDescriptorSize
00011e  1e40              SUBS     r0,r0,#1
000120  49c6              LDR      r1,|L27.1084|
000122  5c09              LDRB     r1,[r1,r0]
000124  9805              LDR      r0,[sp,#0x14]
000126  4281              CMP      r1,r0
000128  da02              BGE      |L27.304|
;;;1135   						{
;;;1136   							bError = TRUE;
00012a  2001              MOVS     r0,#1
00012c  9008              STR      r0,[sp,#0x20]
00012e  e01e              B        |L27.366|
                  |L27.304|
;;;1137   						}
;;;1138   						else
;;;1139   						{
;;;1140   							/* Get pointer to requested configuration descriptor */
;;;1141   							/* Prepare to return Configuration Descriptors */
;;;1142   							pep0state->nBytesLeft = USB_FSConfigDescriptorSize;
000130  1d21              ADDS     r1,r4,#4
000132  48c3              LDR      r0,|L27.1088|
000134  8800              LDRH     r0,[r0,#0]  ; USB_FSConfigDescriptorSize
000136  f7fffffe          BL       __aeabi_uwrite4
;;;1143   							pep0state->pData = (void*)USB_FSConfigDescriptor;
00013a  4621              MOV      r1,r4
00013c  3108              ADDS     r1,r1,#8
00013e  48c1              LDR      r0,|L27.1092|
000140  f7fffffe          BL       __aeabi_uwrite4
;;;1144   							pep0state->nState = M_EP0_TX;
000144  4621              MOV      r1,r4
000146  2002              MOVS     r0,#2
000148  f7fffffe          BL       __aeabi_uwrite4
;;;1145   							/* Check host is allowing a descriptor this long */
;;;1146   							if (pcmd->USBwLength < pep0state->nBytesLeft)
00014c  1d20              ADDS     r0,r4,#4
00014e  f7fffffe          BL       __aeabi_uread4
000152  79e9              LDRB     r1,[r5,#7]
000154  79aa              LDRB     r2,[r5,#6]
000156  0209              LSLS     r1,r1,#8
000158  4311              ORRS     r1,r1,r2
00015a  4288              CMP      r0,r1
00015c  dd07              BLE      |L27.366|
;;;1147   							{
;;;1148   								pep0state->nBytesLeft = pcmd->USBwLength;
00015e  79e9              LDRB     r1,[r5,#7]
000160  79aa              LDRB     r2,[r5,#6]
000162  0209              LSLS     r1,r1,#8
000164  4311              ORRS     r1,r1,r2
000166  4608              MOV      r0,r1
000168  1d21              ADDS     r1,r4,#4
00016a  f7fffffe          BL       __aeabi_uwrite4
                  |L27.366|
;;;1149   							}
;;;1150   						}
;;;1151   						break;
00016e  e19b              B        |L27.1192|
                  |L27.368|
;;;1152   					/***其它速度配置描述符***/						
;;;1153   					case M_CMD_OTHERSPEED:
;;;1154   						/* No alternate speed supported */
;;;1155   						bError = TRUE;
000170  2001              MOVS     r0,#1
000172  9008              STR      r0,[sp,#0x20]
;;;1156   						break;
000174  e198              B        |L27.1192|
                  |L27.374|
;;;1157   					/***HID报告描述符***/
;;;1158   					case	M_CMD_HID_REPORT_DESC:		//报告描述符		0x2200
;;;1159   						/* Prepare to return Standard Device Descriptor */
;;;1160   						switch(pcmd->USBwIndex)
000176  7968              LDRB     r0,[r5,#5]
000178  7929              LDRB     r1,[r5,#4]
00017a  0200              LSLS     r0,r0,#8
00017c  4308              ORRS     r0,r0,r1
00017e  0003              MOVS     r3,r0
000180  f7fffffe          BL       __ARM_common_switch8
000184  05042646          DCB      0x05,0x04,0x26,0x46
000188  6686a600          DCB      0x66,0x86,0xa6,0x00
;;;1161   						{
;;;1162   							case	0:
;;;1163   								//接口0
;;;1164   								pep0state->nBytesLeft = USB_HID_FSReportDescriptor_1Size;		//报告描述符的长度
00018c  1d21              ADDS     r1,r4,#4
00018e  48ae              LDR      r0,|L27.1096|
000190  8800              LDRH     r0,[r0,#0]  ; USB_HID_FSReportDescriptor_1Size
000192  f7fffffe          BL       __aeabi_uwrite4
;;;1165   								/* Check host is allowing a descriptor this long */
;;;1166   								if (pcmd->USBwLength < pep0state->nBytesLeft)
000196  1d20              ADDS     r0,r4,#4
000198  f7fffffe          BL       __aeabi_uread4
00019c  79e9              LDRB     r1,[r5,#7]
00019e  79aa              LDRB     r2,[r5,#6]
0001a0  0209              LSLS     r1,r1,#8
0001a2  4311              ORRS     r1,r1,r2
0001a4  4288              CMP      r0,r1
0001a6  dd09              BLE      |L27.444|
;;;1167   								{
;;;1168   									pep0state->nBytesLeft = pcmd->USBwLength;
0001a8  79e9              LDRB     r1,[r5,#7]
0001aa  79aa              LDRB     r2,[r5,#6]
0001ac  0209              LSLS     r1,r1,#8
0001ae  e000              B        |L27.434|
                  |L27.432|
0001b0  e177              B        |L27.1186|
                  |L27.434|
0001b2  4311              ORRS     r1,r1,r2
0001b4  4608              MOV      r0,r1
0001b6  1d21              ADDS     r1,r4,#4
0001b8  f7fffffe          BL       __aeabi_uwrite4
                  |L27.444|
;;;1169   								}
;;;1170   								pep0state->pData = (void*)USB_HID_FSReportDescriptor_1;
0001bc  4621              MOV      r1,r4
0001be  3108              ADDS     r1,r1,#8
0001c0  48a2              LDR      r0,|L27.1100|
0001c2  f7fffffe          BL       __aeabi_uwrite4
;;;1171   								pep0state->nState = M_EP0_TX;
0001c6  4621              MOV      r1,r4
0001c8  2002              MOVS     r0,#2
0001ca  f7fffffe          BL       __aeabi_uwrite4
;;;1172   								break;
0001ce  e082              B        |L27.726|
;;;1173   							case	1:
;;;1174   								//接口1
;;;1175   								pep0state->nBytesLeft = USB_HID_FSReportDescriptor_2Size;		//报告描述符的长度
0001d0  1d21              ADDS     r1,r4,#4
0001d2  489f              LDR      r0,|L27.1104|
0001d4  8800              LDRH     r0,[r0,#0]  ; USB_HID_FSReportDescriptor_2Size
0001d6  f7fffffe          BL       __aeabi_uwrite4
;;;1176   								/* Check host is allowing a descriptor this long */
;;;1177   								if (pcmd->USBwLength < pep0state->nBytesLeft)
0001da  1d20              ADDS     r0,r4,#4
0001dc  f7fffffe          BL       __aeabi_uread4
0001e0  79e9              LDRB     r1,[r5,#7]
0001e2  79aa              LDRB     r2,[r5,#6]
0001e4  0209              LSLS     r1,r1,#8
0001e6  4311              ORRS     r1,r1,r2
0001e8  4288              CMP      r0,r1
0001ea  dd07              BLE      |L27.508|
;;;1178   								{
;;;1179   									pep0state->nBytesLeft = pcmd->USBwLength;
0001ec  79e9              LDRB     r1,[r5,#7]
0001ee  79aa              LDRB     r2,[r5,#6]
0001f0  0209              LSLS     r1,r1,#8
0001f2  4311              ORRS     r1,r1,r2
0001f4  4608              MOV      r0,r1
0001f6  1d21              ADDS     r1,r4,#4
0001f8  f7fffffe          BL       __aeabi_uwrite4
                  |L27.508|
;;;1180   								}
;;;1181   								pep0state->pData = (void*)USB_HID_FSReportDescriptor_2;
0001fc  4621              MOV      r1,r4
0001fe  3108              ADDS     r1,r1,#8
000200  4894              LDR      r0,|L27.1108|
000202  f7fffffe          BL       __aeabi_uwrite4
;;;1182   								pep0state->nState = M_EP0_TX;
000206  4621              MOV      r1,r4
000208  2002              MOVS     r0,#2
00020a  f7fffffe          BL       __aeabi_uwrite4
;;;1183   								break;
00020e  e062              B        |L27.726|
;;;1184   							case	2:
;;;1185   								//接口2
;;;1186   								pep0state->nBytesLeft = USB_HID_FSReportDescriptor_3Size;		//报告描述符的长度
000210  1d21              ADDS     r1,r4,#4
000212  4891              LDR      r0,|L27.1112|
000214  8800              LDRH     r0,[r0,#0]  ; USB_HID_FSReportDescriptor_3Size
000216  f7fffffe          BL       __aeabi_uwrite4
;;;1187   								/* Check host is allowing a descriptor this long */
;;;1188   								if (pcmd->USBwLength < pep0state->nBytesLeft)
00021a  1d20              ADDS     r0,r4,#4
00021c  f7fffffe          BL       __aeabi_uread4
000220  79e9              LDRB     r1,[r5,#7]
000222  79aa              LDRB     r2,[r5,#6]
000224  0209              LSLS     r1,r1,#8
000226  4311              ORRS     r1,r1,r2
000228  4288              CMP      r0,r1
00022a  dd07              BLE      |L27.572|
;;;1189   								{
;;;1190   									pep0state->nBytesLeft = pcmd->USBwLength;
00022c  79e9              LDRB     r1,[r5,#7]
00022e  79aa              LDRB     r2,[r5,#6]
000230  0209              LSLS     r1,r1,#8
000232  4311              ORRS     r1,r1,r2
000234  4608              MOV      r0,r1
000236  1d21              ADDS     r1,r4,#4
000238  f7fffffe          BL       __aeabi_uwrite4
                  |L27.572|
;;;1191   								}
;;;1192   								pep0state->pData = (void*)USB_HID_FSReportDescriptor_3;
00023c  4621              MOV      r1,r4
00023e  3108              ADDS     r1,r1,#8
000240  4886              LDR      r0,|L27.1116|
000242  f7fffffe          BL       __aeabi_uwrite4
;;;1193   								pep0state->nState = M_EP0_TX;
000246  4621              MOV      r1,r4
000248  2002              MOVS     r0,#2
00024a  f7fffffe          BL       __aeabi_uwrite4
;;;1194   								break;
00024e  e042              B        |L27.726|
;;;1195   								case	3:
;;;1196   								//接口3
;;;1197   								pep0state->nBytesLeft = USB_HID_FSReportDescriptor_4Size;		//报告描述符的长度
000250  1d21              ADDS     r1,r4,#4
000252  4883              LDR      r0,|L27.1120|
000254  8800              LDRH     r0,[r0,#0]  ; USB_HID_FSReportDescriptor_4Size
000256  f7fffffe          BL       __aeabi_uwrite4
;;;1198   								/* Check host is allowing a descriptor this long */
;;;1199   								if (pcmd->USBwLength < pep0state->nBytesLeft)
00025a  1d20              ADDS     r0,r4,#4
00025c  f7fffffe          BL       __aeabi_uread4
000260  79e9              LDRB     r1,[r5,#7]
000262  79aa              LDRB     r2,[r5,#6]
000264  0209              LSLS     r1,r1,#8
000266  4311              ORRS     r1,r1,r2
000268  4288              CMP      r0,r1
00026a  dd07              BLE      |L27.636|
;;;1200   								{
;;;1201   									pep0state->nBytesLeft = pcmd->USBwLength;
00026c  79e9              LDRB     r1,[r5,#7]
00026e  79aa              LDRB     r2,[r5,#6]
000270  0209              LSLS     r1,r1,#8
000272  4311              ORRS     r1,r1,r2
000274  4608              MOV      r0,r1
000276  1d21              ADDS     r1,r4,#4
000278  f7fffffe          BL       __aeabi_uwrite4
                  |L27.636|
;;;1202   								}
;;;1203   								pep0state->pData = (void*)USB_HID_FSReportDescriptor_4;
00027c  4621              MOV      r1,r4
00027e  3108              ADDS     r1,r1,#8
000280  4878              LDR      r0,|L27.1124|
000282  f7fffffe          BL       __aeabi_uwrite4
;;;1204   								pep0state->nState = M_EP0_TX;
000286  4621              MOV      r1,r4
000288  2002              MOVS     r0,#2
00028a  f7fffffe          BL       __aeabi_uwrite4
;;;1205   								break;
00028e  e022              B        |L27.726|
;;;1206   								case	4:
;;;1207   								//接口4
;;;1208   								pep0state->nBytesLeft = USB_HID_FSReportDescriptor_5Size;		//报告描述符的长度
000290  1d21              ADDS     r1,r4,#4
000292  4875              LDR      r0,|L27.1128|
000294  8800              LDRH     r0,[r0,#0]  ; USB_HID_FSReportDescriptor_5Size
000296  f7fffffe          BL       __aeabi_uwrite4
;;;1209   								/* Check host is allowing a descriptor this long */
;;;1210   								if (pcmd->USBwLength < pep0state->nBytesLeft)
00029a  1d20              ADDS     r0,r4,#4
00029c  f7fffffe          BL       __aeabi_uread4
0002a0  79e9              LDRB     r1,[r5,#7]
0002a2  79aa              LDRB     r2,[r5,#6]
0002a4  0209              LSLS     r1,r1,#8
0002a6  4311              ORRS     r1,r1,r2
0002a8  4288              CMP      r0,r1
0002aa  dd07              BLE      |L27.700|
;;;1211   								{
;;;1212   									pep0state->nBytesLeft = pcmd->USBwLength;
0002ac  79e9              LDRB     r1,[r5,#7]
0002ae  79aa              LDRB     r2,[r5,#6]
0002b0  0209              LSLS     r1,r1,#8
0002b2  4311              ORRS     r1,r1,r2
0002b4  4608              MOV      r0,r1
0002b6  1d21              ADDS     r1,r4,#4
0002b8  f7fffffe          BL       __aeabi_uwrite4
                  |L27.700|
;;;1213   								}
;;;1214   								pep0state->pData = (void*)USB_HID_FSReportDescriptor_5;
0002bc  4621              MOV      r1,r4
0002be  3108              ADDS     r1,r1,#8
0002c0  486a              LDR      r0,|L27.1132|
0002c2  f7fffffe          BL       __aeabi_uwrite4
;;;1215   								pep0state->nState = M_EP0_TX;
0002c6  4621              MOV      r1,r4
0002c8  2002              MOVS     r0,#2
0002ca  f7fffffe          BL       __aeabi_uwrite4
;;;1216   								break;
0002ce  e002              B        |L27.726|
;;;1217   							default:
;;;1218   								//接口
;;;1219   								bError = TRUE;
0002d0  2001              MOVS     r0,#1
0002d2  9008              STR      r0,[sp,#0x20]
;;;1220   								break;							
0002d4  bf00              NOP      
                  |L27.726|
0002d6  bf00              NOP                            ;1172
;;;1221   						}
;;;1222   						break;
0002d8  e0e6              B        |L27.1192|
                  |L27.730|
;;;1223   					case	M_CMD_STRING:	//字符串描述符
;;;1224   
;;;1225   						//SEGGER_RTT_printf(0,"USB_StdDev_Req;  333 pcmd->USBwValue=%d\n",pcmd->USBwValue);
;;;1226   						switch(pcmd->USBwValue & 0xff)
0002da  78e8              LDRB     r0,[r5,#3]
0002dc  78a9              LDRB     r1,[r5,#2]
0002de  0200              LSLS     r0,r0,#8
0002e0  4308              ORRS     r0,r0,r1
0002e2  b2c0              UXTB     r0,r0
0002e4  0003              MOVS     r3,r0
0002e6  f7fffffe          BL       __ARM_common_switch8
0002ea  0504              DCB      0x05,0x04
0002ec  24446484          DCB      0x24,0x44,0x64,0x84
0002f0  d700              DCB      0xd7,0x00
;;;1227   						{
;;;1228   							case	0:	//获取语言ID
;;;1229   								pep0state->nBytesLeft = LanguageIdSize;		
0002f2  1d21              ADDS     r1,r4,#4
0002f4  485e              LDR      r0,|L27.1136|
0002f6  8800              LDRH     r0,[r0,#0]  ; LanguageIdSize
0002f8  f7fffffe          BL       __aeabi_uwrite4
;;;1230   								/* Check host is allowing a descriptor this long */
;;;1231   								if (pcmd->USBwLength < pep0state->nBytesLeft)
0002fc  1d20              ADDS     r0,r4,#4
0002fe  f7fffffe          BL       __aeabi_uread4
000302  79e9              LDRB     r1,[r5,#7]
000304  79aa              LDRB     r2,[r5,#6]
000306  0209              LSLS     r1,r1,#8
000308  4311              ORRS     r1,r1,r2
00030a  4288              CMP      r0,r1
00030c  dd07              BLE      |L27.798|
;;;1232   								{
;;;1233   									pep0state->nBytesLeft = pcmd->USBwLength;
00030e  79e9              LDRB     r1,[r5,#7]
000310  79aa              LDRB     r2,[r5,#6]
000312  0209              LSLS     r1,r1,#8
000314  4311              ORRS     r1,r1,r2
000316  4608              MOV      r0,r1
000318  1d21              ADDS     r1,r4,#4
00031a  f7fffffe          BL       __aeabi_uwrite4
                  |L27.798|
;;;1234   								}
;;;1235   								pep0state->pData = (void*)LanguageId;
00031e  4621              MOV      r1,r4
000320  3108              ADDS     r1,r1,#8
000322  4854              LDR      r0,|L27.1140|
000324  f7fffffe          BL       __aeabi_uwrite4
;;;1236   								pep0state->nState = M_EP0_TX;
000328  4621              MOV      r1,r4
00032a  2002              MOVS     r0,#2
00032c  f7fffffe          BL       __aeabi_uwrite4
;;;1237   							break;
000330  e0b5              B        |L27.1182|
;;;1238   							case	1:	//因厂商字符串索引值为1，所以这里写1
;;;1239   								pep0state->nBytesLeft = ManufacturerStringDescriptorSize;		
000332  1d21              ADDS     r1,r4,#4
000334  4850              LDR      r0,|L27.1144|
000336  8800              LDRH     r0,[r0,#0]  ; ManufacturerStringDescriptorSize
000338  f7fffffe          BL       __aeabi_uwrite4
;;;1240   								/* Check host is allowing a descriptor this long */
;;;1241   								if (pcmd->USBwLength < pep0state->nBytesLeft)
00033c  1d20              ADDS     r0,r4,#4
00033e  f7fffffe          BL       __aeabi_uread4
000342  79e9              LDRB     r1,[r5,#7]
000344  79aa              LDRB     r2,[r5,#6]
000346  0209              LSLS     r1,r1,#8
000348  4311              ORRS     r1,r1,r2
00034a  4288              CMP      r0,r1
00034c  dd07              BLE      |L27.862|
;;;1242   								{
;;;1243   									pep0state->nBytesLeft = pcmd->USBwLength;
00034e  79e9              LDRB     r1,[r5,#7]
000350  79aa              LDRB     r2,[r5,#6]
000352  0209              LSLS     r1,r1,#8
000354  4311              ORRS     r1,r1,r2
000356  4608              MOV      r0,r1
000358  1d21              ADDS     r1,r4,#4
00035a  f7fffffe          BL       __aeabi_uwrite4
                  |L27.862|
;;;1244   								}
;;;1245   								pep0state->pData = (void*)ManufacturerStringDescriptor;
00035e  4621              MOV      r1,r4
000360  3108              ADDS     r1,r1,#8
000362  4846              LDR      r0,|L27.1148|
000364  f7fffffe          BL       __aeabi_uwrite4
;;;1246   								pep0state->nState = M_EP0_TX;
000368  4621              MOV      r1,r4
00036a  2002              MOVS     r0,#2
00036c  f7fffffe          BL       __aeabi_uwrite4
;;;1247   							break;	
000370  e095              B        |L27.1182|
;;;1248   							case	2:	//因产品字符串索引值为2，所以这里写2
;;;1249   								pep0state->nBytesLeft = ProductStringDescriptorSize;		
000372  1d21              ADDS     r1,r4,#4
000374  4842              LDR      r0,|L27.1152|
000376  8800              LDRH     r0,[r0,#0]  ; ProductStringDescriptorSize
000378  f7fffffe          BL       __aeabi_uwrite4
;;;1250   								/* Check host is allowing a descriptor this long */
;;;1251   								if (pcmd->USBwLength < pep0state->nBytesLeft)
00037c  1d20              ADDS     r0,r4,#4
00037e  f7fffffe          BL       __aeabi_uread4
000382  79e9              LDRB     r1,[r5,#7]
000384  79aa              LDRB     r2,[r5,#6]
000386  0209              LSLS     r1,r1,#8
000388  4311              ORRS     r1,r1,r2
00038a  4288              CMP      r0,r1
00038c  dd07              BLE      |L27.926|
;;;1252   								{
;;;1253   									pep0state->nBytesLeft = pcmd->USBwLength;
00038e  79e9              LDRB     r1,[r5,#7]
000390  79aa              LDRB     r2,[r5,#6]
000392  0209              LSLS     r1,r1,#8
000394  4311              ORRS     r1,r1,r2
000396  4608              MOV      r0,r1
000398  1d21              ADDS     r1,r4,#4
00039a  f7fffffe          BL       __aeabi_uwrite4
                  |L27.926|
;;;1254   								}
;;;1255   								pep0state->pData = (void*)ProductStringDescriptor;
00039e  4621              MOV      r1,r4
0003a0  3108              ADDS     r1,r1,#8
0003a2  4838              LDR      r0,|L27.1156|
0003a4  f7fffffe          BL       __aeabi_uwrite4
;;;1256   								pep0state->nState = M_EP0_TX;
0003a8  4621              MOV      r1,r4
0003aa  2002              MOVS     r0,#2
0003ac  f7fffffe          BL       __aeabi_uwrite4
;;;1257   							break;			
0003b0  e075              B        |L27.1182|
;;;1258   							case	3:	//因产品序列号索引值为3，所以这里写3
;;;1259   								pep0state->nBytesLeft = SerialNumberSringDescriptorSize;		
0003b2  1d21              ADDS     r1,r4,#4
0003b4  4834              LDR      r0,|L27.1160|
0003b6  8800              LDRH     r0,[r0,#0]  ; SerialNumberSringDescriptorSize
0003b8  f7fffffe          BL       __aeabi_uwrite4
;;;1260   								/* Check host is allowing a descriptor this long */
;;;1261   								if (pcmd->USBwLength < pep0state->nBytesLeft)
0003bc  1d20              ADDS     r0,r4,#4
0003be  f7fffffe          BL       __aeabi_uread4
0003c2  79e9              LDRB     r1,[r5,#7]
0003c4  79aa              LDRB     r2,[r5,#6]
0003c6  0209              LSLS     r1,r1,#8
0003c8  4311              ORRS     r1,r1,r2
0003ca  4288              CMP      r0,r1
0003cc  dd07              BLE      |L27.990|
;;;1262   								{
;;;1263   									pep0state->nBytesLeft = pcmd->USBwLength;
0003ce  79e9              LDRB     r1,[r5,#7]
0003d0  79aa              LDRB     r2,[r5,#6]
0003d2  0209              LSLS     r1,r1,#8
0003d4  4311              ORRS     r1,r1,r2
0003d6  4608              MOV      r0,r1
0003d8  1d21              ADDS     r1,r4,#4
0003da  f7fffffe          BL       __aeabi_uwrite4
                  |L27.990|
;;;1264   								}
;;;1265   								pep0state->pData = (void*)SerialNumberSringDescriptor;
0003de  4621              MOV      r1,r4
0003e0  3108              ADDS     r1,r1,#8
0003e2  482a              LDR      r0,|L27.1164|
0003e4  f7fffffe          BL       __aeabi_uwrite4
;;;1266   								pep0state->nState = M_EP0_TX;
0003e8  4621              MOV      r1,r4
0003ea  2002              MOVS     r0,#2
0003ec  f7fffffe          BL       __aeabi_uwrite4
;;;1267   							break;
0003f0  e055              B        |L27.1182|
;;;1268   
;;;1269   							case	4:	//因产品字符串索引值为2，所以这里写4
;;;1270   								pep0state->nBytesLeft = iapStringDescriptorSize;		
0003f2  1d21              ADDS     r1,r4,#4
0003f4  4826              LDR      r0,|L27.1168|
0003f6  8800              LDRH     r0,[r0,#0]  ; iapStringDescriptorSize
0003f8  f7fffffe          BL       __aeabi_uwrite4
;;;1271   								/* Check host is allowing a descriptor this long */
;;;1272   								
;;;1273   							//	SEGGER_RTT_printf(0,"USB_StdDev_Req;  444 pcmd->USBwLength=%d\n",pcmd->USBwLength);
;;;1274   							///	
;;;1275   							//	SEGGER_RTT_printf(0,"USB_StdDev_Req;  444 pcmd->nBytesLeft=%d\n",pep0state->nBytesLeft);
;;;1276   								if (pcmd->USBwLength < pep0state->nBytesLeft)
0003fc  1d20              ADDS     r0,r4,#4
0003fe  f7fffffe          BL       __aeabi_uread4
000402  79e9              LDRB     r1,[r5,#7]
000404  79aa              LDRB     r2,[r5,#6]
000406  0209              LSLS     r1,r1,#8
000408  4311              ORRS     r1,r1,r2
00040a  4288              CMP      r0,r1
00040c  dd07              BLE      |L27.1054|
;;;1277   								{
;;;1278   									pep0state->nBytesLeft = pcmd->USBwLength;
00040e  79e9              LDRB     r1,[r5,#7]
000410  79aa              LDRB     r2,[r5,#6]
000412  0209              LSLS     r1,r1,#8
000414  4311              ORRS     r1,r1,r2
000416  4608              MOV      r0,r1
000418  1d21              ADDS     r1,r4,#4
00041a  f7fffffe          BL       __aeabi_uwrite4
                  |L27.1054|
;;;1279   								}
;;;1280   								pep0state->pData = (void*)iapStringDescriptor;
00041e  4621              MOV      r1,r4
000420  3108              ADDS     r1,r1,#8
000422  481c              LDR      r0,|L27.1172|
000424  f7fffffe          BL       __aeabi_uwrite4
;;;1281   								pep0state->nState = M_EP0_TX;
000428  4621              MOV      r1,r4
00042a  2002              MOVS     r0,#2
00042c  f7fffffe          BL       __aeabi_uwrite4
;;;1282   							break;		
000430  e035              B        |L27.1182|
000432  0000              DCW      0x0000
                  |L27.1076|
                          DCD      gnDevState
                  |L27.1080|
                          DCD      USB_FSDeviceDescriptorSize
                  |L27.1084|
                          DCD      USB_FSDeviceDescriptor
                  |L27.1088|
                          DCD      USB_FSConfigDescriptorSize
                  |L27.1092|
                          DCD      USB_FSConfigDescriptor
                  |L27.1096|
                          DCD      USB_HID_FSReportDescriptor_1Size
                  |L27.1100|
                          DCD      USB_HID_FSReportDescriptor_1
                  |L27.1104|
                          DCD      USB_HID_FSReportDescriptor_2Size
                  |L27.1108|
                          DCD      USB_HID_FSReportDescriptor_2
                  |L27.1112|
                          DCD      USB_HID_FSReportDescriptor_3Size
                  |L27.1116|
                          DCD      USB_HID_FSReportDescriptor_3
                  |L27.1120|
                          DCD      USB_HID_FSReportDescriptor_4Size
                  |L27.1124|
                          DCD      USB_HID_FSReportDescriptor_4
                  |L27.1128|
                          DCD      USB_HID_FSReportDescriptor_5Size
                  |L27.1132|
                          DCD      USB_HID_FSReportDescriptor_5
                  |L27.1136|
                          DCD      LanguageIdSize
                  |L27.1140|
                          DCD      LanguageId
                  |L27.1144|
                          DCD      ManufacturerStringDescriptorSize
                  |L27.1148|
                          DCD      ManufacturerStringDescriptor
                  |L27.1152|
                          DCD      ProductStringDescriptorSize
                  |L27.1156|
                          DCD      ProductStringDescriptor
                  |L27.1160|
                          DCD      SerialNumberSringDescriptorSize
                  |L27.1164|
                          DCD      SerialNumberSringDescriptor
                  |L27.1168|
                          DCD      iapStringDescriptorSize
                  |L27.1172|
                          DCD      iapStringDescriptor
;;;1283   							default:
;;;1284   								bError = TRUE;								
000498  2001              MOVS     r0,#1
00049a  9008              STR      r0,[sp,#0x20]
;;;1285   							break;
00049c  bf00              NOP      
                  |L27.1182|
00049e  bf00              NOP                            ;1237
;;;1286   						}
;;;1287   					break;
0004a0  e002              B        |L27.1192|
                  |L27.1186|
;;;1288   					/***保留***/
;;;1289   					default: bError = TRUE;
0004a2  2001              MOVS     r0,#1
0004a4  9008              STR      r0,[sp,#0x20]
0004a6  bf00              NOP                            ;1111
                  |L27.1192|
0004a8  bf00              NOP                            ;1125
                  |L27.1194|
;;;1290   				}
;;;1291   			}
;;;1292   			break;
0004aa  e262              B        |L27.2418|
;;;1293   
;;;1294   		/***用于主机指示设备采用的要求的配置***/
;;;1295   		case SET_CONFIGURATION:
;;;1296   			byConfig = (BYTE)(pcmd->USBwValue & 0x00FF);
0004ac  78e8              LDRB     r0,[r5,#3]
0004ae  78a9              LDRB     r1,[r5,#2]
0004b0  0200              LSLS     r0,r0,#8
0004b2  4308              ORRS     r0,r0,r1
0004b4  b2c0              UXTB     r0,r0
0004b6  9005              STR      r0,[sp,#0x14]
;;;1297   			if(gnDevState == DEVSTATE_DEFAULT)
0004b8  48fc              LDR      r0,|L27.2220|
0004ba  6800              LDR      r0,[r0,#0]  ; gnDevState
0004bc  2800              CMP      r0,#0
0004be  d102              BNE      |L27.1222|
;;;1298   			{
;;;1299   		//	SEGGER_RTT_printf(0,"gnDevState = DEVSTATE_ADDRESS;	 777 byConfig=%d\n",byConfig);
;;;1300   				bError = TRUE;
0004c0  2001              MOVS     r0,#1
0004c2  9008              STR      r0,[sp,#0x20]
0004c4  e026              B        |L27.1300|
                  |L27.1222|
;;;1301   			}
;;;1302   			/* Assumes configurations are numbered 1 to NumConfigurations */
;;;1303   			else if(byConfig >USB_FSDeviceDescriptor[USB_FSDeviceDescriptorSize-1])
0004c6  48fa              LDR      r0,|L27.2224|
0004c8  8800              LDRH     r0,[r0,#0]  ; USB_FSDeviceDescriptorSize
0004ca  1e40              SUBS     r0,r0,#1
0004cc  49f9              LDR      r1,|L27.2228|
0004ce  5c09              LDRB     r1,[r1,r0]
0004d0  9805              LDR      r0,[sp,#0x14]
0004d2  4281              CMP      r1,r0
0004d4  da02              BGE      |L27.1244|
;;;1304   			{
;;;1305   			//SEGGER_RTT_printf(0,"gnDevState = DEVSTATE_ADDRESS;	 666 byConfig=%d\n",byConfig);
;;;1306   				bError = TRUE;
0004d6  2001              MOVS     r0,#1
0004d8  9008              STR      r0,[sp,#0x20]
0004da  e01b              B        |L27.1300|
                  |L27.1244|
;;;1307   			}
;;;1308   			else if(!byConfig)
0004dc  9805              LDR      r0,[sp,#0x14]
0004de  2800              CMP      r0,#0
0004e0  d103              BNE      |L27.1258|
;;;1309   			{
;;;1310   			
;;;1311   			//SEGGER_RTT_printf(0,"gnDevState = DEVSTATE_ADDRESS;	 333\n");
;;;1312   				gnDevState = DEVSTATE_ADDRESS;
0004e2  2001              MOVS     r0,#1
0004e4  49f1              LDR      r1,|L27.2220|
0004e6  6008              STR      r0,[r1,#0]  ; gnDevState
0004e8  e014              B        |L27.1300|
                  |L27.1258|
;;;1313   			}
;;;1314   			else
;;;1315   			{
;;;1316   			
;;;1317   			//SEGGER_RTT_printf(0,"gnDevState = DEVSTATE_ADDRESS;	 555 byConfig=%d\n",byConfig);
;;;1318   				/* Get pointer to requested configuration descriptor */
;;;1319   				gpCurCfg = (void *)USB_FSConfigDescriptor;
0004ea  48f3              LDR      r0,|L27.2232|
0004ec  49f3              LDR      r1,|L27.2236|
0004ee  6008              STR      r0,[r1,#0]  ; gpCurCfg
;;;1320   				/* Set all alternate settings to zero */
;;;1321   				for (n=0; n<M_MAXIFS; n++)
0004f0  2700              MOVS     r7,#0
0004f2  e003              B        |L27.1276|
                  |L27.1268|
;;;1322   					gbyCurIfVal[n] = 0;
0004f4  2000              MOVS     r0,#0
0004f6  49f2              LDR      r1,|L27.2240|
0004f8  55c8              STRB     r0,[r1,r7]
0004fa  1c7f              ADDS     r7,r7,#1              ;1321
                  |L27.1276|
0004fc  2f07              CMP      r7,#7                 ;1321
0004fe  dbf9              BLT      |L27.1268|
;;;1323   				/* Configure endpoints */
;;;1324   				ConfigureIfs();
000500  f7fffffe          BL       ConfigureIfs
;;;1325   				
;;;1326   				//SEGGER_RTT_printf(0,"gnDevState = DEVSTATE_ADDRESS;  444\n");
;;;1327   				gnDevState = DEVSTATE_CONFIG;
000504  2002              MOVS     r0,#2
000506  49e9              LDR      r1,|L27.2220|
000508  6008              STR      r0,[r1,#0]  ; gnDevState
;;;1328   				MWRITE_BYTE(M_REG_INDEX, 0);
00050a  2000              MOVS     r0,#0
00050c  49ed              LDR      r1,|L27.2244|
00050e  7388              STRB     r0,[r1,#0xe]
;;;1329   				bNoData = TRUE;
000510  2001              MOVS     r0,#1
000512  9007              STR      r0,[sp,#0x1c]
                  |L27.1300|
;;;1330   			}
;;;1331   			
;;;1332   			//SEGGER_RTT_printf(0,"b_config == 1\n");
;;;1333   			b_config = 1;
000514  2001              MOVS     r0,#1
000516  49ec              LDR      r1,|L27.2248|
000518  6008              STR      r0,[r1,#0]  ; b_config
;;;1334   			break;
00051a  e22a              B        |L27.2418|
;;;1335   
;;;1336   		/***用于主机要求设备用某个描述符来描述接口***/		
;;;1337   		case SET_INTERFACE:
;;;1338   			if(gnDevState > DEVSTATE_ADDRESS)
00051c  48e3              LDR      r0,|L27.2220|
00051e  6800              LDR      r0,[r0,#0]  ; gnDevState
000520  2801              CMP      r0,#1
000522  d920              BLS      |L27.1382|
;;;1339   			{
;;;1340   				n = (int)pcmd->USBwIndex;
000524  7968              LDRB     r0,[r5,#5]
000526  7929              LDRB     r1,[r5,#4]
000528  0207              LSLS     r7,r0,#8
00052a  430f              ORRS     r7,r7,r1
;;;1341   				pcfg = (PSTD_CFG_DSCR)gpCurCfg;
00052c  48e3              LDR      r0,|L27.2236|
00052e  6800              LDR      r0,[r0,#0]  ; gpCurCfg
000530  9004              STR      r0,[sp,#0x10]
;;;1342   				if((BYTE)n >= pcfg->bNumInterfaces)
000532  b2f9              UXTB     r1,r7
000534  9804              LDR      r0,[sp,#0x10]
000536  7900              LDRB     r0,[r0,#4]
000538  4281              CMP      r1,r0
00053a  db02              BLT      |L27.1346|
;;;1343   				{
;;;1344   					bError = TRUE;
00053c  2001              MOVS     r0,#1
00053e  9008              STR      r0,[sp,#0x20]
000540  e013              B        |L27.1386|
                  |L27.1346|
;;;1345   				}
;;;1346   				else 
;;;1347   				{
;;;1348   					gbyCurIfVal[n] = (BYTE)pcmd->USBwValue;
000542  78e8              LDRB     r0,[r5,#3]
000544  78a9              LDRB     r1,[r5,#2]
000546  0200              LSLS     r0,r0,#8
000548  4308              ORRS     r0,r0,r1
00054a  49dd              LDR      r1,|L27.2240|
00054c  55c8              STRB     r0,[r1,r7]
;;;1349   					if (ConfigureIfs() == FALSE)
00054e  f7fffffe          BL       ConfigureIfs
000552  2800              CMP      r0,#0
000554  d101              BNE      |L27.1370|
;;;1350   					{
;;;1351   						bError = TRUE;
000556  2001              MOVS     r0,#1
000558  9008              STR      r0,[sp,#0x20]
                  |L27.1370|
;;;1352   					}
;;;1353   					
;;;1354   					MWRITE_BYTE(M_REG_INDEX, 0);
00055a  2000              MOVS     r0,#0
00055c  49d9              LDR      r1,|L27.2244|
00055e  7388              STRB     r0,[r1,#0xe]
;;;1355   					bNoData = TRUE;
000560  2001              MOVS     r0,#1
000562  9007              STR      r0,[sp,#0x1c]
000564  e001              B        |L27.1386|
                  |L27.1382|
;;;1356   				}
;;;1357   			}
;;;1358   			else
;;;1359   			{
;;;1360   				bError = TRUE;
000566  2001              MOVS     r0,#1
000568  9008              STR      r0,[sp,#0x20]
                  |L27.1386|
;;;1361   			}
;;;1362   			break;
00056a  e202              B        |L27.2418|
;;;1363   
;;;1364   		/***用于主机获取设备当前设备的配置值***/		
;;;1365   		case GET_CONFIGURATION:
;;;1366   			if ((gnDevState == DEVSTATE_ADDRESS) && (!pcmd->USBwValue))
00056c  48cf              LDR      r0,|L27.2220|
00056e  6800              LDR      r0,[r0,#0]  ; gnDevState
000570  2801              CMP      r0,#1
000572  d113              BNE      |L27.1436|
000574  78e8              LDRB     r0,[r5,#3]
000576  78a9              LDRB     r1,[r5,#2]
000578  0200              LSLS     r0,r0,#8
00057a  4308              ORRS     r0,r0,r1
00057c  2800              CMP      r0,#0
00057e  d10d              BNE      |L27.1436|
;;;1367   			{
;;;1368   				/* Prepare to return zero */
;;;1369   				pep0state->nBytesLeft = 1;
000580  1d21              ADDS     r1,r4,#4
000582  2001              MOVS     r0,#1
000584  f7fffffe          BL       __aeabi_uwrite4
;;;1370   				pep0state->pData = (void*)&pcmd->USBwValue;
000588  4621              MOV      r1,r4
00058a  3108              ADDS     r1,r1,#8
00058c  1ca8              ADDS     r0,r5,#2
00058e  f7fffffe          BL       __aeabi_uwrite4
;;;1371   				pep0state->nState = M_EP0_TX;
000592  4621              MOV      r1,r4
000594  2002              MOVS     r0,#2
000596  f7fffffe          BL       __aeabi_uwrite4
00059a  e017              B        |L27.1484|
                  |L27.1436|
;;;1372   			}
;;;1373   			else if(gnDevState > DEVSTATE_ADDRESS)
00059c  48c3              LDR      r0,|L27.2220|
00059e  6800              LDR      r0,[r0,#0]  ; gnDevState
0005a0  2801              CMP      r0,#1
0005a2  d911              BLS      |L27.1480|
;;;1374   			{
;;;1375   				/* Prepare to return configuration value */
;;;1376   				pcfg = (PSTD_CFG_DSCR)gpCurCfg;
0005a4  48c5              LDR      r0,|L27.2236|
0005a6  6800              LDR      r0,[r0,#0]  ; gpCurCfg
0005a8  9004              STR      r0,[sp,#0x10]
;;;1377   				pep0state->nBytesLeft = 1;
0005aa  1d21              ADDS     r1,r4,#4
0005ac  2001              MOVS     r0,#1
0005ae  f7fffffe          BL       __aeabi_uwrite4
;;;1378   				pep0state->pData = (void*)&pcfg->bConfigurationValue;
0005b2  4621              MOV      r1,r4
0005b4  3108              ADDS     r1,r1,#8
0005b6  9804              LDR      r0,[sp,#0x10]
0005b8  1d40              ADDS     r0,r0,#5
0005ba  f7fffffe          BL       __aeabi_uwrite4
;;;1379   				pep0state->nState = M_EP0_TX;
0005be  4621              MOV      r1,r4
0005c0  2002              MOVS     r0,#2
0005c2  f7fffffe          BL       __aeabi_uwrite4
0005c6  e001              B        |L27.1484|
                  |L27.1480|
;;;1380   			}
;;;1381   			else
;;;1382   			{
;;;1383   				bError = TRUE;
0005c8  2001              MOVS     r0,#1
0005ca  9008              STR      r0,[sp,#0x20]
                  |L27.1484|
;;;1384   			}
;;;1385   			break;
0005cc  e1d1              B        |L27.2418|
;;;1386   
;;;1387   		/***用于获取当前某个接口描述符编号***/	
;;;1388   		case GET_INTERFACE:
;;;1389   			if(gnDevState > DEVSTATE_ADDRESS)
0005ce  48b7              LDR      r0,|L27.2220|
0005d0  6800              LDR      r0,[r0,#0]  ; gnDevState
0005d2  2801              CMP      r0,#1
0005d4  d91f              BLS      |L27.1558|
;;;1390   			{
;;;1391   				n = (int)pcmd->USBwIndex;
0005d6  7968              LDRB     r0,[r5,#5]
0005d8  7929              LDRB     r1,[r5,#4]
0005da  0207              LSLS     r7,r0,#8
0005dc  430f              ORRS     r7,r7,r1
;;;1392   				pcfg = (PSTD_CFG_DSCR)gpCurCfg;
0005de  48b7              LDR      r0,|L27.2236|
0005e0  6800              LDR      r0,[r0,#0]  ; gpCurCfg
0005e2  9004              STR      r0,[sp,#0x10]
;;;1393   				if((BYTE)n >= pcfg->bNumInterfaces)
0005e4  b2f9              UXTB     r1,r7
0005e6  9804              LDR      r0,[sp,#0x10]
0005e8  7900              LDRB     r0,[r0,#4]
0005ea  4281              CMP      r1,r0
0005ec  db02              BLT      |L27.1524|
;;;1394   				{
;;;1395   					bError = TRUE;
0005ee  2001              MOVS     r0,#1
0005f0  9008              STR      r0,[sp,#0x20]
0005f2  e012              B        |L27.1562|
                  |L27.1524|
;;;1396   				}
;;;1397   				else 
;;;1398   				{
;;;1399   					/* Prepare to return interface value */
;;;1400   					pep0state->nBytesLeft = 1;
0005f4  1d21              ADDS     r1,r4,#4
0005f6  2001              MOVS     r0,#1
0005f8  f7fffffe          BL       __aeabi_uwrite4
;;;1401   					pep0state->pData = (void*)&gpCurIf[n]->bInterfaceNumber;
0005fc  00b9              LSLS     r1,r7,#2
0005fe  4ab3              LDR      r2,|L27.2252|
000600  5851              LDR      r1,[r2,r1]
000602  1c88              ADDS     r0,r1,#2
000604  4621              MOV      r1,r4
000606  3108              ADDS     r1,r1,#8
000608  f7fffffe          BL       __aeabi_uwrite4
;;;1402   					pep0state->nState = M_EP0_TX;
00060c  4621              MOV      r1,r4
00060e  2002              MOVS     r0,#2
000610  f7fffffe          BL       __aeabi_uwrite4
000614  e001              B        |L27.1562|
                  |L27.1558|
;;;1403   				}
;;;1404   			}
;;;1405   			else
;;;1406   				bError = TRUE;
000616  2001              MOVS     r0,#1
000618  9008              STR      r0,[sp,#0x20]
                  |L27.1562|
;;;1407   			break;
00061a  e1aa              B        |L27.2418|
;;;1408   
;;;1409   		/***用来启用或激活命令接收者的某些特性***/
;;;1410   		case SET_FEATURE:
;;;1411   			switch (pcmd->bmRequestType) 
00061c  7828              LDRB     r0,[r5,#0]
00061e  2800              CMP      r0,#0
000620  d004              BEQ      |L27.1580|
000622  2801              CMP      r0,#1
000624  d018              BEQ      |L27.1624|
000626  2802              CMP      r0,#2
000628  d158              BNE      |L27.1756|
00062a  e016              B        |L27.1626|
                  |L27.1580|
;;;1412   			{
;;;1413   					case M_CMD_STDDEVOUT:
;;;1414   						switch (pcmd->USBwValue) 
00062c  78e8              LDRB     r0,[r5,#3]
00062e  78a9              LDRB     r1,[r5,#2]
000630  0200              LSLS     r0,r0,#8
000632  4308              ORRS     r0,r0,r1
000634  2801              CMP      r0,#1
000636  d10a              BNE      |L27.1614|
;;;1415   						{
;;;1416   							case M_FTR_DEVREMWAKE:
;;;1417   							pInformation->Current_Feature = pInformation->Current_Feature | (0x1<<5);	
000638  48a5              LDR      r0,|L27.2256|
00063a  6800              LDR      r0,[r0,#0]  ; pInformation
00063c  7840              LDRB     r0,[r0,#1]
00063e  2120              MOVS     r1,#0x20
000640  4308              ORRS     r0,r0,r1
000642  49a3              LDR      r1,|L27.2256|
000644  6809              LDR      r1,[r1,#0]  ; pInformation
000646  7048              STRB     r0,[r1,#1]
;;;1418   							bNoData = TRUE;	
000648  2001              MOVS     r0,#1
00064a  9007              STR      r0,[sp,#0x1c]
;;;1419   							break;	
00064c  e002              B        |L27.1620|
                  |L27.1614|
;;;1420   							default:
;;;1421   							bError = TRUE;
00064e  2001              MOVS     r0,#1
000650  9008              STR      r0,[sp,#0x20]
;;;1422   							break;
000652  bf00              NOP      
                  |L27.1620|
000654  bf00              NOP                            ;1419
;;;1423   						}
;;;1424   					break;
000656  e044              B        |L27.1762|
                  |L27.1624|
;;;1425   						
;;;1426   					case M_CMD_STDIFOUT:
;;;1427   
;;;1428   					/* SET FEATURE for EndPoint*/
;;;1429   					case M_CMD_STDEPOUT:
000658  bf00              NOP      
                  |L27.1626|
;;;1430   
;;;1431   						switch (pcmd->USBwValue0) 
00065a  78a8              LDRB     r0,[r5,#2]
00065c  2800              CMP      r0,#0
00065e  d138              BNE      |L27.1746|
;;;1432   						{						
;;;1433   							case M_FTR_EPHALT:
;;;1434   	
;;;1435   							MWRITE_BYTE(M_REG_INDEX,Related_Endpoint);	
000660  4998              LDR      r1,|L27.2244|
000662  9803              LDR      r0,[sp,#0xc]
000664  7388              STRB     r0,[r1,#0xe]
;;;1436   							if (pcmd->USBwIndex0 & 0x80)
000666  7928              LDRB     r0,[r5,#4]
000668  2180              MOVS     r1,#0x80
00066a  4008              ANDS     r0,r0,r1
00066c  2800              CMP      r0,#0
00066e  d016              BEQ      |L27.1694|
;;;1437   							{
;;;1438   								if(Related_Endpoint)/* IN endpoint */
000670  9803              LDR      r0,[sp,#0xc]
000672  2800              CMP      r0,#0
000674  d00a              BEQ      |L27.1676|
;;;1439   								{
;;;1440   									srbuff = *((uint8_t*)M_REG_INCSR1);	
000676  4893              LDR      r0,|L27.2244|
000678  7c46              LDRB     r6,[r0,#0x11]
;;;1441   									srbuff = srbuff |(0x1<<4);
00067a  2010              MOVS     r0,#0x10
00067c  4306              ORRS     r6,r6,r0
;;;1442   									MWRITE_BYTE(M_REG_INCSR1,srbuff);
00067e  4891              LDR      r0,|L27.2244|
000680  7446              STRB     r6,[r0,#0x11]
;;;1443   									INCSRDATA = MREAD_BYTE(M_REG_INCSR1);	
000682  7c40              LDRB     r0,[r0,#0x11]
000684  4993              LDR      r1,|L27.2260|
000686  7008              STRB     r0,[r1,#0]
;;;1444   									__ASM("NOP");
000688  bf00              NOP      
00068a  e01c              B        |L27.1734|
                  |L27.1676|
;;;1445   								}
;;;1446   								
;;;1447   								else
;;;1448   								{
;;;1449   									srbuff = *((uint8_t*)M_REG_CSR0);	
00068c  488d              LDR      r0,|L27.2244|
00068e  7c46              LDRB     r6,[r0,#0x11]
;;;1450   									*((uint8_t*)M_REG_CSR0) = srbuff |(0x1<<5);
000690  2020              MOVS     r0,#0x20
000692  4330              ORRS     r0,r0,r6
000694  498b              LDR      r1,|L27.2244|
000696  7448              STRB     r0,[r1,#0x11]
;;;1451   									srbuff = *((uint8_t*)M_REG_CSR0);	
000698  4608              MOV      r0,r1
00069a  7c46              LDRB     r6,[r0,#0x11]
00069c  e013              B        |L27.1734|
                  |L27.1694|
;;;1452   								}
;;;1453   							
;;;1454   							}
;;;1455   
;;;1456   							else
;;;1457   							{
;;;1458   						/* OUT endpoint */
;;;1459   								if(Related_Endpoint)
00069e  9803              LDR      r0,[sp,#0xc]
0006a0  2800              CMP      r0,#0
0006a2  d008              BEQ      |L27.1718|
;;;1460   								{
;;;1461   									srbuff = *((uint8_t*)M_REG_OUTCSR1);	
0006a4  4887              LDR      r0,|L27.2244|
0006a6  7d06              LDRB     r6,[r0,#0x14]
;;;1462   									*((uint8_t*)M_REG_OUTCSR1) = srbuff |(0x1<<5);
0006a8  2020              MOVS     r0,#0x20
0006aa  4330              ORRS     r0,r0,r6
0006ac  4985              LDR      r1,|L27.2244|
0006ae  7508              STRB     r0,[r1,#0x14]
;;;1463   									srbuff = *((uint8_t*)M_REG_OUTCSR1);								
0006b0  4608              MOV      r0,r1
0006b2  7d06              LDRB     r6,[r0,#0x14]
0006b4  e007              B        |L27.1734|
                  |L27.1718|
;;;1464   								}
;;;1465   								
;;;1466   								else
;;;1467   								{
;;;1468   									srbuff = *((uint8_t*)M_REG_CSR0);	
0006b6  4883              LDR      r0,|L27.2244|
0006b8  7c46              LDRB     r6,[r0,#0x11]
;;;1469   									*((uint8_t*)M_REG_CSR0) = srbuff |(0x1<<5);
0006ba  2020              MOVS     r0,#0x20
0006bc  4330              ORRS     r0,r0,r6
0006be  4981              LDR      r1,|L27.2244|
0006c0  7448              STRB     r0,[r1,#0x11]
;;;1470   									srbuff = *((uint8_t*)M_REG_CSR0);								
0006c2  4608              MOV      r0,r1
0006c4  7c46              LDRB     r6,[r0,#0x11]
                  |L27.1734|
;;;1471   								}
;;;1472   													
;;;1473   							}
;;;1474   							bNoData = TRUE;	
0006c6  2001              MOVS     r0,#1
0006c8  9007              STR      r0,[sp,#0x1c]
;;;1475   							MWRITE_BYTE(M_REG_INDEX,0);	
0006ca  2000              MOVS     r0,#0
0006cc  497d              LDR      r1,|L27.2244|
0006ce  7388              STRB     r0,[r1,#0xe]
;;;1476   							break;
0006d0  e002              B        |L27.1752|
                  |L27.1746|
;;;1477   							default:
;;;1478   							bError = TRUE;
0006d2  2001              MOVS     r0,#1
0006d4  9008              STR      r0,[sp,#0x20]
;;;1479   							break;
0006d6  bf00              NOP      
                  |L27.1752|
0006d8  bf00              NOP                            ;1476
;;;1480   						}
;;;1481   					break;
0006da  e002              B        |L27.1762|
                  |L27.1756|
;;;1482   						
;;;1483   					default:
;;;1484   					bError = TRUE;
0006dc  2001              MOVS     r0,#1
0006de  9008              STR      r0,[sp,#0x20]
;;;1485   					break;
0006e0  bf00              NOP      
                  |L27.1762|
0006e2  bf00              NOP                            ;1424
;;;1486   			}
;;;1487   		break;
0006e4  e145              B        |L27.2418|
;;;1488   			
;;;1489   		/***用来CLEAR接收者的某些特性***/			
;;;1490   		case CLEAR_FEATURE:
;;;1491   			switch (pcmd->bmRequestType) 
0006e6  7828              LDRB     r0,[r5,#0]
0006e8  2800              CMP      r0,#0
0006ea  d004              BEQ      |L27.1782|
0006ec  2801              CMP      r0,#1
0006ee  d018              BEQ      |L27.1826|
0006f0  2802              CMP      r0,#2
0006f2  d16d              BNE      |L27.2000|
0006f4  e016              B        |L27.1828|
                  |L27.1782|
;;;1492   			{
;;;1493   					case M_CMD_STDDEVOUT:
;;;1494   						switch (pcmd->USBwValue) 
0006f6  78e8              LDRB     r0,[r5,#3]
0006f8  78a9              LDRB     r1,[r5,#2]
0006fa  0200              LSLS     r0,r0,#8
0006fc  4308              ORRS     r0,r0,r1
0006fe  2801              CMP      r0,#1
000700  d10a              BNE      |L27.1816|
;;;1495   						{
;;;1496   							case M_FTR_DEVREMWAKE:
;;;1497   							pInformation->Current_Feature = pInformation->Current_Feature & (~(0x1<<5));
000702  4873              LDR      r0,|L27.2256|
000704  6800              LDR      r0,[r0,#0]  ; pInformation
000706  7840              LDRB     r0,[r0,#1]
000708  2120              MOVS     r1,#0x20
00070a  4388              BICS     r0,r0,r1
00070c  4970              LDR      r1,|L27.2256|
00070e  6809              LDR      r1,[r1,#0]  ; pInformation
000710  7048              STRB     r0,[r1,#1]
;;;1498   							bNoData = TRUE;	
000712  2001              MOVS     r0,#1
000714  9007              STR      r0,[sp,#0x1c]
;;;1499   							break;
000716  e002              B        |L27.1822|
                  |L27.1816|
;;;1500   							default:
;;;1501   							bError = TRUE;
000718  2001              MOVS     r0,#1
00071a  9008              STR      r0,[sp,#0x20]
;;;1502   							break;
00071c  bf00              NOP      
                  |L27.1822|
00071e  bf00              NOP                            ;1499
;;;1503   						}
;;;1504   					break;
000720  e059              B        |L27.2006|
                  |L27.1826|
;;;1505   						
;;;1506   					case M_CMD_STDIFOUT:
;;;1507   
;;;1508   					/* CLEAR FEATURE for EndPoint*/
;;;1509   					case M_CMD_STDEPOUT:
000722  bf00              NOP      
                  |L27.1828|
;;;1510   						switch (pcmd->USBwValue0) 
000724  78a8              LDRB     r0,[r5,#2]
000726  2800              CMP      r0,#0
000728  d14d              BNE      |L27.1990|
;;;1511   						{
;;;1512   							case M_FTR_EPHALT:						
;;;1513   							MWRITE_BYTE(M_REG_INDEX,Related_Endpoint);	
00072a  4966              LDR      r1,|L27.2244|
00072c  9803              LDR      r0,[sp,#0xc]
00072e  7388              STRB     r0,[r1,#0xe]
;;;1514   							if (pcmd->USBwIndex0 & 0x80)
000730  7928              LDRB     r0,[r5,#4]
000732  2180              MOVS     r1,#0x80
000734  4008              ANDS     r0,r0,r1
000736  2800              CMP      r0,#0
000738  d021              BEQ      |L27.1918|
;;;1515   							{/* IN endpoint */
;;;1516   								if(Related_Endpoint)
00073a  9803              LDR      r0,[sp,#0xc]
00073c  2800              CMP      r0,#0
00073e  d014              BEQ      |L27.1898|
;;;1517   								{
;;;1518   //									*((uint8_t*)M_REG_INCSR1) = *((uint8_t*)M_REG_INCSR1) & (~(0x01<<6));
;;;1519   									srbuff = *((uint8_t*)M_REG_INCSR1);	
000740  4860              LDR      r0,|L27.2244|
000742  7c46              LDRB     r6,[r0,#0x11]
;;;1520   									*((uint8_t*)M_REG_INCSR1) = srbuff & (~(0x01<<6));
000744  2140              MOVS     r1,#0x40
000746  4630              MOV      r0,r6
000748  4388              BICS     r0,r0,r1
00074a  495e              LDR      r1,|L27.2244|
00074c  7448              STRB     r0,[r1,#0x11]
;;;1521   									srbuff = *((uint8_t*)M_REG_INCSR1);											
00074e  4608              MOV      r0,r1
000750  7c46              LDRB     r6,[r0,#0x11]
;;;1522   									
;;;1523   //									*((uint8_t*)M_REG_INCSR1) = *((uint8_t*)M_REG_INCSR1) & (~(0x01<<4));
;;;1524   									srbuff = *((uint8_t*)M_REG_INCSR1);	
000752  7c46              LDRB     r6,[r0,#0x11]
;;;1525   									*((uint8_t*)M_REG_INCSR1) = srbuff & (~(0x01<<4));	
000754  2110              MOVS     r1,#0x10
000756  4630              MOV      r0,r6
000758  4388              BICS     r0,r0,r1
00075a  495a              LDR      r1,|L27.2244|
00075c  7448              STRB     r0,[r1,#0x11]
;;;1526   									INCSRDATA = *((uint8_t*)M_REG_INCSR1);	
00075e  4608              MOV      r0,r1
000760  7c40              LDRB     r0,[r0,#0x11]
000762  495c              LDR      r1,|L27.2260|
000764  7008              STRB     r0,[r1,#0]
;;;1527   									__ASM("NOP");
000766  bf00              NOP      
000768  e027              B        |L27.1978|
                  |L27.1898|
;;;1528   								}
;;;1529   								
;;;1530   								else
;;;1531   								{
;;;1532   //									*((uint8_t*)M_REG_CSR0) = *((uint8_t*)M_REG_CSR0) & (~(0x01<<5));
;;;1533   									srbuff = *((uint8_t*)M_REG_CSR0);	
00076a  4856              LDR      r0,|L27.2244|
00076c  7c46              LDRB     r6,[r0,#0x11]
;;;1534   									*((uint8_t*)M_REG_CSR0) = srbuff & (~(0x01<<5));
00076e  2120              MOVS     r1,#0x20
000770  4630              MOV      r0,r6
000772  4388              BICS     r0,r0,r1
000774  4953              LDR      r1,|L27.2244|
000776  7448              STRB     r0,[r1,#0x11]
;;;1535   									srbuff = *((uint8_t*)M_REG_CSR0);										
000778  4608              MOV      r0,r1
00077a  7c46              LDRB     r6,[r0,#0x11]
00077c  e01d              B        |L27.1978|
                  |L27.1918|
;;;1536   									
;;;1537   								}
;;;1538   									
;;;1539   							}
;;;1540   
;;;1541   							else
;;;1542   							{
;;;1543   								/* OUT endpoint */
;;;1544   								if(Related_Endpoint)
00077e  9803              LDR      r0,[sp,#0xc]
000780  2800              CMP      r0,#0
000782  d011              BEQ      |L27.1960|
;;;1545   								{
;;;1546   //									*((uint8_t*)M_REG_OUTCSR1) = *((uint8_t*)M_REG_OUTCSR1) & (~(0x01<<7));
;;;1547   //									*((uint8_t*)M_REG_OUTCSR1) = *((uint8_t*)M_REG_OUTCSR1) & (~(0x01<<5));
;;;1548   									srbuff = *((uint8_t*)M_REG_OUTCSR1);	
000784  484f              LDR      r0,|L27.2244|
000786  7d06              LDRB     r6,[r0,#0x14]
;;;1549   									*((uint8_t*)M_REG_OUTCSR1) = srbuff & (~(0x01<<7));
000788  2180              MOVS     r1,#0x80
00078a  4630              MOV      r0,r6
00078c  4388              BICS     r0,r0,r1
00078e  494d              LDR      r1,|L27.2244|
000790  7508              STRB     r0,[r1,#0x14]
;;;1550   									srbuff = *((uint8_t*)M_REG_OUTCSR1);											
000792  4608              MOV      r0,r1
000794  7d06              LDRB     r6,[r0,#0x14]
;;;1551   									
;;;1552   									srbuff = *((uint8_t*)M_REG_OUTCSR1);	
000796  7d06              LDRB     r6,[r0,#0x14]
;;;1553   									*((uint8_t*)M_REG_OUTCSR1) = srbuff & (~(0x01<<5));
000798  2120              MOVS     r1,#0x20
00079a  4630              MOV      r0,r6
00079c  4388              BICS     r0,r0,r1
00079e  4949              LDR      r1,|L27.2244|
0007a0  7508              STRB     r0,[r1,#0x14]
;;;1554   									srbuff = *((uint8_t*)M_REG_OUTCSR1);				
0007a2  4608              MOV      r0,r1
0007a4  7d06              LDRB     r6,[r0,#0x14]
0007a6  e008              B        |L27.1978|
                  |L27.1960|
;;;1555   									
;;;1556   								}
;;;1557   								
;;;1558   								else
;;;1559   								{
;;;1560   //									*((uint8_t*)M_REG_CSR0) = *((uint8_t*)M_REG_CSR0)  & (~(0x01<<5));
;;;1561   									srbuff = *((uint8_t*)M_REG_CSR0);	
0007a8  4846              LDR      r0,|L27.2244|
0007aa  7c46              LDRB     r6,[r0,#0x11]
;;;1562   									*((uint8_t*)M_REG_CSR0) = srbuff & (~(0x01<<5));
0007ac  2120              MOVS     r1,#0x20
0007ae  4630              MOV      r0,r6
0007b0  4388              BICS     r0,r0,r1
0007b2  4944              LDR      r1,|L27.2244|
0007b4  7448              STRB     r0,[r1,#0x11]
;;;1563   									srbuff = *((uint8_t*)M_REG_CSR0);											
0007b6  4608              MOV      r0,r1
0007b8  7c46              LDRB     r6,[r0,#0x11]
                  |L27.1978|
;;;1564   								}
;;;1565   													
;;;1566   							}
;;;1567   								bNoData = TRUE;	
0007ba  2001              MOVS     r0,#1
0007bc  9007              STR      r0,[sp,#0x1c]
;;;1568   								MWRITE_BYTE(M_REG_INDEX,0);
0007be  2000              MOVS     r0,#0
0007c0  4940              LDR      r1,|L27.2244|
0007c2  7388              STRB     r0,[r1,#0xe]
;;;1569   								break;
0007c4  e002              B        |L27.1996|
                  |L27.1990|
;;;1570   						
;;;1571   							default:
;;;1572   							bError = TRUE;
0007c6  2001              MOVS     r0,#1
0007c8  9008              STR      r0,[sp,#0x20]
;;;1573   							break;
0007ca  bf00              NOP      
                  |L27.1996|
0007cc  bf00              NOP                            ;1569
;;;1574   						}
;;;1575   				break;
0007ce  e002              B        |L27.2006|
                  |L27.2000|
;;;1576   						
;;;1577   				default:
;;;1578   				bError = TRUE;
0007d0  2001              MOVS     r0,#1
0007d2  9008              STR      r0,[sp,#0x20]
;;;1579   				break;		
0007d4  bf00              NOP      
                  |L27.2006|
0007d6  bf00              NOP                            ;1504
;;;1580   			}
;;;1581   		break;	
0007d8  e0cb              B        |L27.2418|
;;;1582   			
;;;1583   			
;;;1584   		/***用于主机获取设备 STATUS***/					
;;;1585   		case GET_STATUS:	
;;;1586   		
;;;1587   			switch (pcmd->bmRequestType) 
0007da  7828              LDRB     r0,[r5,#0]
0007dc  2880              CMP      r0,#0x80
0007de  d004              BEQ      |L27.2026|
0007e0  2881              CMP      r0,#0x81
0007e2  d03b              BEQ      |L27.2140|
0007e4  2882              CMP      r0,#0x82
0007e6  d160              BNE      |L27.2218|
0007e8  e046              B        |L27.2168|
                  |L27.2026|
;;;1588   			{
;;;1589   
;;;1590   				 /* GET STATUS for Device*/
;;;1591   					case M_CMD_STDDEVIN:
;;;1592   						
;;;1593   					if (pInformation->Current_Feature & (0x1<<5))
0007ea  4839              LDR      r0,|L27.2256|
0007ec  6800              LDR      r0,[r0,#0]  ; pInformation
0007ee  7840              LDRB     r0,[r0,#1]
0007f0  2120              MOVS     r1,#0x20
0007f2  4008              ANDS     r0,r0,r1
0007f4  2800              CMP      r0,#0
0007f6  d006              BEQ      |L27.2054|
;;;1594   					{
;;;1595   						txdat[0] |=(0x1<<1);						
0007f8  4669              MOV      r1,sp
0007fa  7908              LDRB     r0,[r1,#4]
0007fc  2102              MOVS     r1,#2
0007fe  4308              ORRS     r0,r0,r1
000800  4669              MOV      r1,sp
000802  7108              STRB     r0,[r1,#4]
000804  e005              B        |L27.2066|
                  |L27.2054|
;;;1596   					}
;;;1597   					else
;;;1598   					{
;;;1599   						txdat[0] &= ~(0x1<<1);	
000806  4669              MOV      r1,sp
000808  7908              LDRB     r0,[r1,#4]
00080a  2102              MOVS     r1,#2
00080c  4388              BICS     r0,r0,r1
00080e  4669              MOV      r1,sp
000810  7108              STRB     r0,[r1,#4]
                  |L27.2066|
;;;1600   					} 
;;;1601   					if (pInformation->Current_Feature & (0x1<<6))
000812  482f              LDR      r0,|L27.2256|
000814  6800              LDR      r0,[r0,#0]  ; pInformation
000816  7840              LDRB     r0,[r0,#1]
000818  2140              MOVS     r1,#0x40
00081a  4008              ANDS     r0,r0,r1
00081c  2800              CMP      r0,#0
00081e  d006              BEQ      |L27.2094|
;;;1602   					{
;;;1603   						txdat[0] |=(0x1<<0);						
000820  4669              MOV      r1,sp
000822  7908              LDRB     r0,[r1,#4]
000824  2101              MOVS     r1,#1
000826  4308              ORRS     r0,r0,r1
000828  4669              MOV      r1,sp
00082a  7108              STRB     r0,[r1,#4]
00082c  e005              B        |L27.2106|
                  |L27.2094|
;;;1604   					}
;;;1605   					else
;;;1606   					{
;;;1607   						txdat[0] &= ~(0x1<<0);	
00082e  4668              MOV      r0,sp
000830  7900              LDRB     r0,[r0,#4]
000832  0841              LSRS     r1,r0,#1
000834  0049              LSLS     r1,r1,#1
000836  4668              MOV      r0,sp
000838  7101              STRB     r1,[r0,#4]
                  |L27.2106|
;;;1608   					} 					
;;;1609   					
;;;1610   					txdat[1]=0;
00083a  2000              MOVS     r0,#0
00083c  4669              MOV      r1,sp
00083e  7148              STRB     r0,[r1,#5]
;;;1611   					pep0state->nBytesLeft = 2;
000840  1d21              ADDS     r1,r4,#4
000842  2002              MOVS     r0,#2
000844  f7fffffe          BL       __aeabi_uwrite4
;;;1612   					pep0state->pData = txdat;
000848  4621              MOV      r1,r4
00084a  3108              ADDS     r1,r1,#8
00084c  a801              ADD      r0,sp,#4
00084e  f7fffffe          BL       __aeabi_uwrite4
;;;1613   					pep0state->nState = M_EP0_TX;	
000852  4621              MOV      r1,r4
000854  2002              MOVS     r0,#2
000856  f7fffffe          BL       __aeabi_uwrite4
;;;1614   					break;
00085a  e085              B        |L27.2408|
                  |L27.2140|
;;;1615   					
;;;1616   				/* GET STATUS for Interface*/		
;;;1617   					case M_CMD_STDIFIN:
;;;1618   					pep0state->nBytesLeft = 2;
00085c  1d21              ADDS     r1,r4,#4
00085e  2002              MOVS     r0,#2
000860  f7fffffe          BL       __aeabi_uwrite4
;;;1619   					pep0state->pData = txdat;
000864  4621              MOV      r1,r4
000866  3108              ADDS     r1,r1,#8
000868  a801              ADD      r0,sp,#4
00086a  f7fffffe          BL       __aeabi_uwrite4
;;;1620   					pep0state->nState = M_EP0_TX;	
00086e  4621              MOV      r1,r4
000870  2002              MOVS     r0,#2
000872  f7fffffe          BL       __aeabi_uwrite4
;;;1621   					break;
000876  e077              B        |L27.2408|
                  |L27.2168|
;;;1622   				/* GET STATUS for EndPoint*/
;;;1623   					case M_CMD_STDEPIN:									
;;;1624   					
;;;1625   					if (pcmd->USBwIndex0 & 0x80)
000878  7928              LDRB     r0,[r5,#4]
00087a  2180              MOVS     r1,#0x80
00087c  4008              ANDS     r0,r0,r1
00087e  2800              CMP      r0,#0
000880  d03d              BEQ      |L27.2302|
;;;1626   					{	
;;;1627   						if(Related_Endpoint){
000882  9803              LDR      r0,[sp,#0xc]
000884  2800              CMP      r0,#0
000886  d02c              BEQ      |L27.2274|
;;;1628   							MWRITE_BYTE(M_REG_INDEX,Related_Endpoint);
000888  490e              LDR      r1,|L27.2244|
00088a  9803              LDR      r0,[sp,#0xc]
00088c  7388              STRB     r0,[r1,#0xe]
;;;1629   							INCSRDATA = MREAD_BYTE(M_REG_INCSR1);
00088e  4608              MOV      r0,r1
000890  7c40              LDRB     r0,[r0,#0x11]
000892  4910              LDR      r1,|L27.2260|
000894  7008              STRB     r0,[r1,#0]
;;;1630   							if(INCSRDATA & (0x1<<4))
000896  4608              MOV      r0,r1
000898  7800              LDRB     r0,[r0,#0]  ; INCSRDATA
00089a  2110              MOVS     r1,#0x10
00089c  4008              ANDS     r0,r0,r1
00089e  2800              CMP      r0,#0
0008a0  d01b              BEQ      |L27.2266|
;;;1631   								txdat[0] = 1;	
0008a2  2001              MOVS     r0,#1
0008a4  4669              MOV      r1,sp
0008a6  7108              STRB     r0,[r1,#4]
0008a8  e047              B        |L27.2362|
                  |L27.2218|
0008aa  e05a              B        |L27.2402|
                  |L27.2220|
                          DCD      gnDevState
                  |L27.2224|
                          DCD      USB_FSDeviceDescriptorSize
                  |L27.2228|
                          DCD      USB_FSDeviceDescriptor
                  |L27.2232|
                          DCD      USB_FSConfigDescriptor
                  |L27.2236|
                          DCD      gpCurCfg
                  |L27.2240|
                          DCD      gbyCurIfVal
                  |L27.2244|
                          DCD      0x40005c00
                  |L27.2248|
                          DCD      b_config
                  |L27.2252|
                          DCD      gpCurIf
                  |L27.2256|
                          DCD      pInformation
                  |L27.2260|
                          DCD      INCSRDATA
                  |L27.2264|
0008d8  e048              B        |L27.2412|
                  |L27.2266|
;;;1632   							else txdat[0] = 0;	
0008da  2000              MOVS     r0,#0
0008dc  4669              MOV      r1,sp
0008de  7108              STRB     r0,[r1,#4]
0008e0  e02b              B        |L27.2362|
                  |L27.2274|
;;;1633   						}
;;;1634   						else
;;;1635   							if(*((uint8_t*)M_REG_CSR0) & (0x1<<2))
0008e2  482e              LDR      r0,|L27.2460|
0008e4  7c40              LDRB     r0,[r0,#0x11]
0008e6  2104              MOVS     r1,#4
0008e8  4008              ANDS     r0,r0,r1
0008ea  2800              CMP      r0,#0
0008ec  d003              BEQ      |L27.2294|
;;;1636   							txdat[0] = 1;	
0008ee  2001              MOVS     r0,#1
0008f0  4669              MOV      r1,sp
0008f2  7108              STRB     r0,[r1,#4]
0008f4  e021              B        |L27.2362|
                  |L27.2294|
;;;1637   							else txdat[0] = 0;								
0008f6  2000              MOVS     r0,#0
0008f8  4669              MOV      r1,sp
0008fa  7108              STRB     r0,[r1,#4]
0008fc  e01d              B        |L27.2362|
                  |L27.2302|
;;;1638   					}
;;;1639   
;;;1640   					else
;;;1641   					{
;;;1642   						if(Related_Endpoint){
0008fe  9803              LDR      r0,[sp,#0xc]
000900  2800              CMP      r0,#0
000902  d00d              BEQ      |L27.2336|
;;;1643   							if(*((uint8_t*)M_REG_OUTCSR1) & (0x1<<5))
000904  4825              LDR      r0,|L27.2460|
000906  7d00              LDRB     r0,[r0,#0x14]
000908  2120              MOVS     r1,#0x20
00090a  4008              ANDS     r0,r0,r1
00090c  2800              CMP      r0,#0
00090e  d003              BEQ      |L27.2328|
;;;1644   								txdat[0] = 1;	
000910  2001              MOVS     r0,#1
000912  4669              MOV      r1,sp
000914  7108              STRB     r0,[r1,#4]
000916  e010              B        |L27.2362|
                  |L27.2328|
;;;1645   							else txdat[0] = 0;	
000918  2000              MOVS     r0,#0
00091a  4669              MOV      r1,sp
00091c  7108              STRB     r0,[r1,#4]
00091e  e00c              B        |L27.2362|
                  |L27.2336|
;;;1646   						}
;;;1647   						else
;;;1648   							if(*((uint8_t*)M_REG_CSR0) & (0x1<<2))
000920  481e              LDR      r0,|L27.2460|
000922  7c40              LDRB     r0,[r0,#0x11]
000924  2104              MOVS     r1,#4
000926  4008              ANDS     r0,r0,r1
000928  2800              CMP      r0,#0
00092a  d003              BEQ      |L27.2356|
;;;1649   							txdat[0] = 1;	
00092c  2001              MOVS     r0,#1
00092e  4669              MOV      r1,sp
000930  7108              STRB     r0,[r1,#4]
000932  e002              B        |L27.2362|
                  |L27.2356|
;;;1650   							else txdat[0] = 0;								
000934  2000              MOVS     r0,#0
000936  4669              MOV      r1,sp
000938  7108              STRB     r0,[r1,#4]
                  |L27.2362|
;;;1651   					}		
;;;1652   					txdat[1]=0;
00093a  2000              MOVS     r0,#0
00093c  4669              MOV      r1,sp
00093e  7148              STRB     r0,[r1,#5]
;;;1653   					pep0state->nBytesLeft = 2;
000940  1d21              ADDS     r1,r4,#4
000942  2002              MOVS     r0,#2
000944  f7fffffe          BL       __aeabi_uwrite4
;;;1654   					pep0state->pData = txdat;
000948  4621              MOV      r1,r4
00094a  3108              ADDS     r1,r1,#8
00094c  a801              ADD      r0,sp,#4
00094e  f7fffffe          BL       __aeabi_uwrite4
;;;1655   					pep0state->nState = M_EP0_TX;	
000952  4621              MOV      r1,r4
000954  2002              MOVS     r0,#2
000956  f7fffffe          BL       __aeabi_uwrite4
;;;1656   					MWRITE_BYTE(M_REG_INDEX,0);	
00095a  2000              MOVS     r0,#0
00095c  490f              LDR      r1,|L27.2460|
00095e  7388              STRB     r0,[r1,#0xe]
;;;1657   					break;
000960  e002              B        |L27.2408|
                  |L27.2402|
;;;1658   					
;;;1659   					default:
;;;1660   					bError = TRUE;
000962  2001              MOVS     r0,#1
000964  9008              STR      r0,[sp,#0x20]
;;;1661   					break;
000966  bf00              NOP      
                  |L27.2408|
000968  bf00              NOP                            ;1614
;;;1662   				
;;;1663   			}
;;;1664   		break;	
00096a  e002              B        |L27.2418|
                  |L27.2412|
;;;1665   
;;;1666   			
;;;1667   		/***不可识别的请求***/
;;;1668   		default:
;;;1669   			/* Stall the command if an unrecognized request is received */
;;;1670   			bError = TRUE;
00096c  2001              MOVS     r0,#1
00096e  9008              STR      r0,[sp,#0x20]
;;;1671   		break;
000970  bf00              NOP      
                  |L27.2418|
000972  bf00              NOP                            ;1099
;;;1672    }
;;;1673   
;;;1674   	/* Stall command if an error occurred */
;;;1675   	if (bError)
000974  9808              LDR      r0,[sp,#0x20]
000976  2800              CMP      r0,#0
000978  d002              BEQ      |L27.2432|
;;;1676   	{
;;;1677   		/***清零 OUTPKTRDY 位,终止当前传输***/
;;;1678   		by = M_CSR0_SVDOUTPKTRDY | M_CSR0_SENDSTALL;
00097a  2060              MOVS     r0,#0x60
00097c  9006              STR      r0,[sp,#0x18]
00097e  e007              B        |L27.2448|
                  |L27.2432|
;;;1679   	}
;;;1680   	else if(bNoData)
000980  9807              LDR      r0,[sp,#0x1c]
000982  2800              CMP      r0,#0
000984  d002              BEQ      |L27.2444|
;;;1681   	{
;;;1682   //		FIFOWrite(0, 0, pep0state->pData);
;;;1683   //		by = M_CSR0_INPKTRDY | M_CSR0_DATAEND;
;;;1684   //		MWRITE_BYTE(M_REG_CSR0, by);
;;;1685   		/***清零 OUTPKTRDY 位,在发送时表示，将要发送的时最后一包数据；接收时将要接收的是最后一包数据；***/
;;;1686   		by = M_CSR0_SVDOUTPKTRDY | M_CSR0_DATAEND;
000986  2048              MOVS     r0,#0x48
000988  9006              STR      r0,[sp,#0x18]
00098a  e001              B        |L27.2448|
                  |L27.2444|
;;;1687   //					pep0state->nBytesLeft = 0;
;;;1688   //					pep0state->nState = M_EP0_TX;			
;;;1689   	}
;;;1690   	else
;;;1691   	{
;;;1692   		/***清零 OUTPKTRDY 位***/
;;;1693   		by = M_CSR0_SVDOUTPKTRDY;
00098c  2040              MOVS     r0,#0x40
00098e  9006              STR      r0,[sp,#0x18]
                  |L27.2448|
;;;1694   	}
;;;1695   	
;;;1696   	MWRITE_BYTE(M_REG_CSR0, by);
000990  4902              LDR      r1,|L27.2460|
000992  9806              LDR      r0,[sp,#0x18]
000994  7448              STRB     r0,[r1,#0x11]
;;;1697   
;;;1698   	return;
;;;1699   	
;;;1700   }
000996  b009              ADD      sp,sp,#0x24
000998  bdf0              POP      {r4-r7,pc}
;;;1701   
                          ENDP

00099a  0000              DCW      0x0000
                  |L27.2460|
                          DCD      0x40005c00

                          AREA ||i.USB_Suspend||, CODE, READONLY, ALIGN=2

                  USB_Suspend PROC
;;;299    */
;;;300    void USB_Suspend(void)
000000  4809              LDR      r0,|L28.40|
;;;301    {
;;;302    	if(usb_state == USB_SUSPEND_FLAG)
000002  7800              LDRB     r0,[r0,#0]  ; usb_state
000004  2801              CMP      r0,#1
000006  d106              BNE      |L28.22|
;;;303    	{
;;;304    		USB->POWER |= 0x01;//允许挂起模块
000008  4808              LDR      r0,|L28.44|
00000a  7840              LDRB     r0,[r0,#1]
00000c  2101              MOVS     r1,#1
00000e  4308              ORRS     r0,r0,r1
000010  4906              LDR      r1,|L28.44|
000012  7048              STRB     r0,[r1,#1]
000014  e006              B        |L28.36|
                  |L28.22|
;;;305    		
;;;306    		/*关闭一些时钟省电*/
;;;307    		
;;;308    		/*结束*/
;;;309    		
;;;310    //		while(USB->POWER & 0x02)								//suspend flag
;;;311    //		{	
;;;312    //			GPIOB->ODR ^= GPIO_Pin_2;
;;;313    ////			SysTick_Delay_Ms(500);
;;;314    //			if(GPIO_ReadInputDataBit(GPIOC,GPIO_Pin_11) == RESET)//按键唤醒
;;;315    //			{
;;;316    //				/*remote wakeup*/
;;;317    //				USB_Remote_Wakeup();
;;;318    //				
;;;319    //				f_send_kb = 1;
;;;320    //				USB->POWER &= ~0x01;							//不允许挂起模块	
;;;321    //				usb_state = USB_NORMAL;
;;;322    //			}
;;;323    //		}
;;;324    		
;;;325    		/*重新配置时钟*/	
;;;326    	}
;;;327    	else if(usb_state == USB_RESUME_FLAG)						//自动退出suspend
000016  4804              LDR      r0,|L28.40|
000018  7800              LDRB     r0,[r0,#0]  ; usb_state
00001a  2802              CMP      r0,#2
00001c  d102              BNE      |L28.36|
;;;328    	{
;;;329    		usb_state = USB_NORMAL;
00001e  2000              MOVS     r0,#0
000020  4901              LDR      r1,|L28.40|
000022  7008              STRB     r0,[r1,#0]
                  |L28.36|
;;;330    		/*重新配置时钟*/
;;;331    	}
;;;332    }
000024  4770              BX       lr
;;;333    /******************************************************************************
                          ENDP

000026  0000              DCW      0x0000
                  |L28.40|
                          DCD      usb_state
                  |L28.44|
                          DCD      0x40005c00

                          AREA ||i.endCriticalSection||, CODE, READONLY, ALIGN=1

                  endCriticalSection PROC
;;;75     
;;;76     void endCriticalSection(void) {
000000  b510              PUSH     {r4,lr}
;;;77         localIrqEnable();
000002  f7fffffe          BL       localIrqEnable
;;;78     }
000006  bd10              POP      {r4,pc}
;;;79     
                          ENDP


                          AREA ||i.localIrqDisable||, CODE, READONLY, ALIGN=2

                  localIrqDisable PROC
;;;59     
;;;60     void localIrqDisable(void) {
000000  b508              PUSH     {r3,lr}
;;;61     	NVIC_InitTypeDef NVIC_InitStructure;
;;;62     
;;;63     		  NVIC_InitStructure.NVIC_IRQChannel = USB_IRQn;
000002  211f              MOVS     r1,#0x1f
000004  4668              MOV      r0,sp
000006  7001              STRB     r1,[r0,#0]
;;;64       NVIC_InitStructure.NVIC_IRQChannelPriority = 0;
000008  2100              MOVS     r1,#0
00000a  7041              STRB     r1,[r0,#1]
;;;65       NVIC_InitStructure.NVIC_IRQChannelCmd = DISABLE;
00000c  7081              STRB     r1,[r0,#2]
;;;66       NVIC_Init(&NVIC_InitStructure);
00000e  f7fffffe          BL       NVIC_Init
;;;67         usbIrqStatus = 0;
000012  2000              MOVS     r0,#0
000014  4901              LDR      r1,|L30.28|
000016  7008              STRB     r0,[r1,#0]
;;;68     }
000018  bd08              POP      {r3,pc}
;;;69     
                          ENDP

00001a  0000              DCW      0x0000
                  |L30.28|
                          DCD      usbIrqStatus

                          AREA ||i.localIrqEnable||, CODE, READONLY, ALIGN=2

                  localIrqEnable PROC
;;;46     // KH Tsai NOTE: Interrupt Enable, for M0
;;;47     void localIrqEnable(void) {
000000  b508              PUSH     {r3,lr}
;;;48     	NVIC_InitTypeDef NVIC_InitStructure;
;;;49     
;;;50     	usbIrqStatus = 1;
000002  2001              MOVS     r0,#1
000004  4905              LDR      r1,|L31.28|
000006  7008              STRB     r0,[r1,#0]
;;;51     
;;;52     	  NVIC_InitStructure.NVIC_IRQChannel = USB_IRQn;
000008  211f              MOVS     r1,#0x1f
00000a  4668              MOV      r0,sp
00000c  7001              STRB     r1,[r0,#0]
;;;53       NVIC_InitStructure.NVIC_IRQChannelPriority = 0;
00000e  2100              MOVS     r1,#0
000010  7041              STRB     r1,[r0,#1]
;;;54       NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000012  2101              MOVS     r1,#1
000014  7081              STRB     r1,[r0,#2]
;;;55       NVIC_Init(&NVIC_InitStructure);
000016  f7fffffe          BL       NVIC_Init
;;;56     
;;;57     }
00001a  bd08              POP      {r3,pc}
;;;58     
                          ENDP

                  |L31.28|
                          DCD      usbIrqStatus

                          AREA ||i.startCriticalSection||, CODE, READONLY, ALIGN=2

                  startCriticalSection PROC
;;;69     
;;;70     void startCriticalSection(void) {
000000  b510              PUSH     {r4,lr}
;;;71         if(usbIrqStatus) {
000002  4803              LDR      r0,|L32.16|
000004  7800              LDRB     r0,[r0,#0]  ; usbIrqStatus
000006  2800              CMP      r0,#0
000008  d001              BEQ      |L32.14|
;;;72             localIrqDisable();
00000a  f7fffffe          BL       localIrqDisable
                  |L32.14|
;;;73         }
;;;74     }
00000e  bd10              POP      {r4,pc}
;;;75     
                          ENDP

                  |L32.16|
                          DCD      usbIrqStatus

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  c_hid_data
                          %        88
                  gpCurIf
                          %        28
                  Device_Info
                          %        15
                  ep1_send_buf
                          %        64
                  ep0state
                          %        17

                          AREA ||.data||, DATA, ALIGN=2

                  usbIrqStatus
000000  00                DCB      0x00
                  INCSRDATA
000001  00                DCB      0x00
                  usb_state
000002  0000              DCB      0x00,0x00
                  gnDevState
                          DCD      0x00000000
                  gpCurCfg
                          DCD      0x00000000
                  gbyCurIfVal
                          DCD      0x00000000
000010  00000000          DCB      0x00,0x00,0x00,0x00
                  pInformation
                          DCD      Device_Info
                  flag1
                          DCD      0x00000000
                  ||cmd||
                          %        8

                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=1

                  __ARM_common_switch8 PROC
000000  b430              PUSH     {r4,r5}
000002  4674              MOV      r4,lr
000004  1e64              SUBS     r4,r4,#1
000006  7825              LDRB     r5,[r4,#0]
000008  1c64              ADDS     r4,r4,#1
00000a  42ab              CMP      r3,r5
00000c  d304              BCC      |L198.24|
                  |L198.14|
00000e  5d63              LDRB     r3,[r4,r5]
000010  005b              LSLS     r3,r3,#1
000012  18e3              ADDS     r3,r4,r3
000014  bc30              POP      {r4,r5}
000016  4718              BX       r3
                  |L198.24|
000018  461d              MOV      r5,r3
00001a  e7f8              B        |L198.14|
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\usb\\src\\usb_core.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_usb_core_c_c8c8efdf____REV16|
#line 129 "..\\FTLib\\CMSIS\\inc\\core_cmInstr.h"
|__asm___10_usb_core_c_c8c8efdf____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_usb_core_c_c8c8efdf____REVSH|
#line 144
|__asm___10_usb_core_c_c8c8efdf____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
