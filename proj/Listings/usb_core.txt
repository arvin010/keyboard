; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\usb_core.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\usb_core.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\FTLib\CMSIS\inc -I..\FTLib\Inc -I..\FTLib\Lib -I..\usb\inc -I..\user -I..\RTT -I.\RTE\_Keyboard -IC:\Users\Reidgjiao\AppData\Local\Arm\Packs\FMD\FT32F0xx_DFP\1.0.6\Drivers\CMSIS\FT32F0xx\Include -IC:\Keil_v5-MDK\ARM\CMSIS\Include -D__UVISION_VERSION=529 -DFT32F072x8 -DFT32F072x8 --omf_browse=.\objects\usb_core.crf ..\usb\src\usb_core.c]
                          THUMB

                          AREA ||i.ConfigureIfs||, CODE, READONLY, ALIGN=2

                  ConfigureIfs PROC
;;;1640   */
;;;1641   static uint32_t ConfigureIfs(void)
000000  b5ff              PUSH     {r0-r7,lr}
;;;1642   {
;;;1643   	PSTD_CFG_DSCR	pcfg;
;;;1644   	BYTE		byIf, byAltIf, byEP, byNumEPs, by;
;;;1645   	BYTE		*pby;
;;;1646   	BYTE		*pbyIfVal;
;;;1647   	PSTD_IF_DSCR	pif;
;;;1648   	PSTD_EP_DSCR	pep;
;;;1649   
;;;1650   	/* Set pointer to first interface descriptor in current configuration */
;;;1651   	pby = (BYTE *)(gpCurCfg) + sizeof(STD_CFG_DSCR);
000002  4844              LDR      r0,|L1.276|
000004  6800              LDR      r0,[r0,#0]  ; gpCurCfg
000006  4602              MOV      r2,r0
000008  3209              ADDS     r2,r2,#9
;;;1652   	pif = (PSTD_IF_DSCR)pby;
00000a  4614              MOV      r4,r2
;;;1653   
;;;1654   	/* Loop through all interfaces in the current configuration */
;;;1655   	pcfg = (PSTD_CFG_DSCR)gpCurCfg;
00000c  4841              LDR      r0,|L1.276|
00000e  6800              LDR      r0,[r0,#0]  ; gpCurCfg
000010  9003              STR      r0,[sp,#0xc]
;;;1656   	pbyIfVal = (BYTE*)&gbyCurIfVal;	//接口
000012  4841              LDR      r0,|L1.280|
000014  9000              STR      r0,[sp,#0]
;;;1657   	for (byIf=0; byIf < pcfg->bNumInterfaces; byIf++, pbyIfVal++) 
000016  2500              MOVS     r5,#0
000018  e076              B        |L1.264|
                  |L1.26|
;;;1658   	{
;;;1659   		/* Advance pointer to selected alternate interface descriptor */
;;;1660   		if (*pbyIfVal) 
00001a  9800              LDR      r0,[sp,#0]
00001c  7800              LDRB     r0,[r0,#0]
00001e  2800              CMP      r0,#0
000020  d016              BEQ      |L1.80|
;;;1661   		{
;;;1662   			for (byAltIf=0; byAltIf<*pbyIfVal; byAltIf++) 
000022  2000              MOVS     r0,#0
000024  9002              STR      r0,[sp,#8]
000026  e00e              B        |L1.70|
                  |L1.40|
;;;1663   			{
;;;1664   				byNumEPs = pif->bNumEndpoints;
000028  7926              LDRB     r6,[r4,#4]
;;;1665   				pby += sizeof(STD_IF_DSCR) + byNumEPs * sizeof(STD_EP_DSCR) + sizeof(STD_HID_DSCR);
00002a  00f0              LSLS     r0,r6,#3
00002c  1b80              SUBS     r0,r0,r6
00002e  3012              ADDS     r0,r0,#0x12
000030  1812              ADDS     r2,r2,r0
;;;1666   				pif  = (PSTD_IF_DSCR)pby;
000032  4614              MOV      r4,r2
;;;1667   				/* Check an alternate setting > number of alternates not specified */
;;;1668   				if (!pif->bAlternateSetting)
000034  78e0              LDRB     r0,[r4,#3]
000036  2800              CMP      r0,#0
000038  d101              BNE      |L1.62|
                  |L1.58|
;;;1669   				{
;;;1670   					return FALSE;
;;;1671   				}
;;;1672   			} 
;;;1673   		}
;;;1674   
;;;1675   		/* Store pointer to interface in global array */
;;;1676   		gpCurIf[byIf] = pif;
;;;1677   
;;;1678   		/* Loop through all endpoints in interface */
;;;1679   		byNumEPs = pif->bNumEndpoints;
;;;1680   		pby += sizeof(STD_IF_DSCR) + sizeof(STD_HID_DSCR);	//endpoint
;;;1681   		
;;;1682   		for ( byEP = 0; byEP < byNumEPs; byEP++ )
;;;1683   		{
;;;1684   			pep = (PSTD_EP_DSCR)pby;
;;;1685   
;;;1686   			/* Configure the endpoint */
;;;1687   			MWRITE_BYTE(M_REG_INDEX, (pep->bEndpointAddress & 0x0F));
;;;1688   			/* Round up max packet size to a multiple of 8 for writing to MaxP registers */
;;;1689   			by = (BYTE)((pep->wMaxPacketSize + 7) >> 3);
;;;1690   			
;;;1691   			if(pep->bEndpointAddress & 0x80)
;;;1692   			{
;;;1693   				MWRITE_BYTE(M_REG_INMAXP, by);
;;;1694   				by = MREAD_BYTE(M_REG_INCSR2);
;;;1695   				
;;;1696   				switch (pep->bmAttributes & M_EP_TFMASK)
;;;1697   				{
;;;1698   					case M_EP_ISO:
;;;1699   						by |= M_INCSR2_ISO;
;;;1700   					break;
;;;1701   					case M_EP_BULK:
;;;1702   					case M_EP_INTR:						
;;;1703   						by &= ~M_INCSR2_ISO;
;;;1704   					break;
;;;1705   				}
;;;1706   				
;;;1707   				/* Set mode bit high (only strictly necessary if sharing a FIFO) */
;;;1708   				by |= M_INCSR2_MODE;
;;;1709   				
;;;1710   				MWRITE_BYTE(M_REG_INCSR2, by);
;;;1711   				
;;;1712   				/* Other configuration for an IN endpoint */
;;;1713   				/* e.g. AutoClr, DMA */
;;;1714   				/* should be added here */
;;;1715   			}
;;;1716   			else
;;;1717   			{
;;;1718   				MWRITE_BYTE(M_REG_OUTMAXP, by);
;;;1719   				by = MREAD_BYTE(M_REG_OUTCSR2);
;;;1720   				
;;;1721   				switch (pep->bmAttributes & M_EP_TFMASK)
;;;1722   				{
;;;1723   					case M_EP_ISO:
;;;1724   						by |= M_OUTCSR2_ISO;
;;;1725   					break;
;;;1726   					case M_EP_BULK:
;;;1727   					case M_EP_INTR:
;;;1728   						by &= ~M_OUTCSR2_ISO;
;;;1729   					break;
;;;1730   				}
;;;1731   				MWRITE_BYTE(M_REG_OUTCSR2, by);
;;;1732   				/* Other configuration for an OUT endpoint */
;;;1733   				/* e.g. AutoSet, DMA */
;;;1734   				/* should be added here */
;;;1735   			}
;;;1736   			
;;;1737   			pby += sizeof(STD_EP_DSCR);	
;;;1738   		}
;;;1739   	}
;;;1740   
;;;1741   	return TRUE;
;;;1742   }
00003a  b004              ADD      sp,sp,#0x10
00003c  bdf0              POP      {r4-r7,pc}
                  |L1.62|
00003e  9802              LDR      r0,[sp,#8]            ;1662
000040  1c40              ADDS     r0,r0,#1              ;1662
000042  b2c0              UXTB     r0,r0                 ;1662
000044  9002              STR      r0,[sp,#8]            ;1662
                  |L1.70|
000046  9800              LDR      r0,[sp,#0]            ;1662
000048  7807              LDRB     r7,[r0,#0]            ;1662
00004a  9802              LDR      r0,[sp,#8]            ;1662
00004c  4287              CMP      r7,r0                 ;1662
00004e  dceb              BGT      |L1.40|
                  |L1.80|
000050  00a8              LSLS     r0,r5,#2              ;1676
000052  4f32              LDR      r7,|L1.284|
000054  503c              STR      r4,[r7,r0]            ;1676
000056  7926              LDRB     r6,[r4,#4]            ;1679
000058  3212              ADDS     r2,r2,#0x12           ;1680
00005a  2000              MOVS     r0,#0                 ;1682
00005c  9001              STR      r0,[sp,#4]            ;1682
00005e  e04b              B        |L1.248|
                  |L1.96|
000060  4613              MOV      r3,r2                 ;1684
000062  7898              LDRB     r0,[r3,#2]            ;1687
000064  0700              LSLS     r0,r0,#28             ;1687
000066  0f00              LSRS     r0,r0,#28             ;1687
000068  4f2d              LDR      r7,|L1.288|
00006a  73b8              STRB     r0,[r7,#0xe]          ;1687
00006c  7958              LDRB     r0,[r3,#5]            ;1689
00006e  791f              LDRB     r7,[r3,#4]            ;1689
000070  0200              LSLS     r0,r0,#8              ;1689
000072  4338              ORRS     r0,r0,r7              ;1689
000074  1dc0              ADDS     r0,r0,#7              ;1689
000076  0540              LSLS     r0,r0,#21             ;1689
000078  0e01              LSRS     r1,r0,#24             ;1689
00007a  7898              LDRB     r0,[r3,#2]            ;1691
00007c  2780              MOVS     r7,#0x80              ;1691
00007e  4038              ANDS     r0,r0,r7              ;1691
000080  2800              CMP      r0,#0                 ;1691
000082  d01b              BEQ      |L1.188|
000084  4826              LDR      r0,|L1.288|
000086  7401              STRB     r1,[r0,#0x10]         ;1693
000088  7c81              LDRB     r1,[r0,#0x12]         ;1694
00008a  78d8              LDRB     r0,[r3,#3]            ;1696
00008c  0780              LSLS     r0,r0,#30             ;1696
00008e  0f80              LSRS     r0,r0,#30             ;1696
000090  2801              CMP      r0,#1                 ;1696
000092  d004              BEQ      |L1.158|
000094  2810              CMP      r0,#0x10              ;1696
000096  d005              BEQ      |L1.164|
000098  2811              CMP      r0,#0x11              ;1696
00009a  d109              BNE      |L1.176|
00009c  e003              B        |L1.166|
                  |L1.158|
00009e  2040              MOVS     r0,#0x40              ;1699
0000a0  4301              ORRS     r1,r1,r0              ;1699
0000a2  e005              B        |L1.176|
                  |L1.164|
0000a4  bf00              NOP                            ;1702
                  |L1.166|
0000a6  2040              MOVS     r0,#0x40              ;1703
0000a8  460f              MOV      r7,r1                 ;1703
0000aa  4387              BICS     r7,r7,r0              ;1703
0000ac  4639              MOV      r1,r7                 ;1703
0000ae  bf00              NOP                            ;1704
                  |L1.176|
0000b0  bf00              NOP                            ;1700
0000b2  2020              MOVS     r0,#0x20              ;1708
0000b4  4301              ORRS     r1,r1,r0              ;1708
0000b6  481a              LDR      r0,|L1.288|
0000b8  7481              STRB     r1,[r0,#0x12]         ;1710
0000ba  e018              B        |L1.238|
                  |L1.188|
0000bc  4818              LDR      r0,|L1.288|
0000be  74c1              STRB     r1,[r0,#0x13]         ;1718
0000c0  7d41              LDRB     r1,[r0,#0x15]         ;1719
0000c2  78d8              LDRB     r0,[r3,#3]            ;1721
0000c4  0780              LSLS     r0,r0,#30             ;1721
0000c6  0f80              LSRS     r0,r0,#30             ;1721
0000c8  2801              CMP      r0,#1                 ;1721
0000ca  d004              BEQ      |L1.214|
0000cc  2810              CMP      r0,#0x10              ;1721
0000ce  d005              BEQ      |L1.220|
0000d0  2811              CMP      r0,#0x11              ;1721
0000d2  d109              BNE      |L1.232|
0000d4  e003              B        |L1.222|
                  |L1.214|
0000d6  2040              MOVS     r0,#0x40              ;1724
0000d8  4301              ORRS     r1,r1,r0              ;1724
0000da  e005              B        |L1.232|
                  |L1.220|
0000dc  bf00              NOP                            ;1727
                  |L1.222|
0000de  2040              MOVS     r0,#0x40              ;1728
0000e0  460f              MOV      r7,r1                 ;1728
0000e2  4387              BICS     r7,r7,r0              ;1728
0000e4  4639              MOV      r1,r7                 ;1728
0000e6  bf00              NOP                            ;1729
                  |L1.232|
0000e8  bf00              NOP                            ;1725
0000ea  480d              LDR      r0,|L1.288|
0000ec  7541              STRB     r1,[r0,#0x15]         ;1731
                  |L1.238|
0000ee  1dd2              ADDS     r2,r2,#7              ;1737
0000f0  9801              LDR      r0,[sp,#4]            ;1682
0000f2  1c40              ADDS     r0,r0,#1              ;1682
0000f4  b2c0              UXTB     r0,r0                 ;1682
0000f6  9001              STR      r0,[sp,#4]            ;1682
                  |L1.248|
0000f8  9801              LDR      r0,[sp,#4]            ;1682
0000fa  42b0              CMP      r0,r6                 ;1682
0000fc  dbb0              BLT      |L1.96|
0000fe  1c68              ADDS     r0,r5,#1              ;1657
000100  b2c5              UXTB     r5,r0                 ;1657
000102  9800              LDR      r0,[sp,#0]            ;1657
000104  1c40              ADDS     r0,r0,#1              ;1657
000106  9000              STR      r0,[sp,#0]            ;1657
                  |L1.264|
000108  9803              LDR      r0,[sp,#0xc]          ;1657
00010a  7900              LDRB     r0,[r0,#4]            ;1657
00010c  42a8              CMP      r0,r5                 ;1657
00010e  dc84              BGT      |L1.26|
000110  2001              MOVS     r0,#1                 ;1741
000112  e792              B        |L1.58|
;;;1743   
                          ENDP

                  |L1.276|
                          DCD      gpCurCfg
                  |L1.280|
                          DCD      gbyCurIfVal
                  |L1.284|
                          DCD      gpCurIf
                  |L1.288|
                          DCD      0x40005c00

                          AREA ||i.EndpointBulkIn||, CODE, READONLY, ALIGN=2

                  EndpointBulkIn PROC
;;;318    */
;;;319    void EndpointBulkIn(M_EPBIN_STATUS pbistate, int nCallState)
000000  b57f              PUSH     {r0-r6,lr}
;;;320    {
000002  461e              MOV      r6,r3
;;;321    	int     nBytes;
;;;322    	BYTE    byInCSR;
;;;323    
;;;324    	/* Reset endpoint */
;;;325    	if(nCallState == M_EP_RESET)
000004  2e01              CMP      r6,#1
000006  d107              BNE      |L2.24|
;;;326    	{
;;;327    		/*切换端点号*/
;;;328    		MWRITE_BYTE(M_REG_INDEX, pbistate.byEP);
000008  4668              MOV      r0,sp
00000a  7a00              LDRB     r0,[r0,#8]
00000c  4913              LDR      r1,|L2.92|
00000e  7388              STRB     r0,[r1,#0xe]
;;;329    		/*清除相应端点的数据翻转状态和清空FIFO中要发送的数据*/
;;;330    		byInCSR = M_INCSR_CDT | M_INCSR_FF;
000010  2548              MOVS     r5,#0x48
;;;331    		MWRITE_BYTE(M_REG_INCSR1, byInCSR);
000012  4608              MOV      r0,r1
000014  7445              STRB     r5,[r0,#0x11]
000016  e01f              B        |L2.88|
                  |L2.24|
;;;332    	}
;;;333    	else
;;;334    	{
;;;335    		/* Check whether there is any data to send */ 
;;;336    		if(pbistate.nBytesLeft != M_EP_NODATA)
000018  9801              LDR      r0,[sp,#4]
00001a  1c40              ADDS     r0,r0,#1
00001c  2800              CMP      r0,#0
00001e  d01b              BEQ      |L2.88|
;;;337    		{
;;;338    			/* Determine number of bytes to send */
;;;339    			if(pbistate.nBytesLeft < M_EP_MAXP)
000020  9801              LDR      r0,[sp,#4]
000022  2840              CMP      r0,#0x40
000024  da04              BGE      |L2.48|
;;;340    			{
;;;341    				nBytes = pbistate.nBytesLeft;
000026  9c01              LDR      r4,[sp,#4]
;;;342    				pbistate.nBytesLeft = M_EP_NODATA;
000028  2000              MOVS     r0,#0
00002a  43c0              MVNS     r0,r0
00002c  9001              STR      r0,[sp,#4]
00002e  e003              B        |L2.56|
                  |L2.48|
;;;343    			}
;;;344    			else 
;;;345    			{
;;;346    				nBytes = M_EP_MAXP;
000030  2440              MOVS     r4,#0x40
;;;347    				pbistate.nBytesLeft -= M_EP_MAXP;
000032  9801              LDR      r0,[sp,#4]
000034  3840              SUBS     r0,r0,#0x40
000036  9001              STR      r0,[sp,#4]
                  |L2.56|
;;;348    			}
;;;349    
;;;350    			/* Load FIFO */
;;;351    			FIFOWrite((int)pbistate.byEP, nBytes, pbistate.pData);
000038  4669              MOV      r1,sp
00003a  7a08              LDRB     r0,[r1,#8]
00003c  4621              MOV      r1,r4
00003e  9a00              LDR      r2,[sp,#0]
000040  f7fffffe          BL       FIFOWrite
;;;352    			pbistate.pData = (BYTE *)pbistate.pData + nBytes;
000044  9800              LDR      r0,[sp,#0]
000046  1900              ADDS     r0,r0,r4
000048  9000              STR      r0,[sp,#0]
;;;353    
;;;354    			MWRITE_BYTE(M_REG_INDEX, pbistate.byEP);
00004a  4669              MOV      r1,sp
00004c  7a08              LDRB     r0,[r1,#8]
00004e  4903              LDR      r1,|L2.92|
000050  7388              STRB     r0,[r1,#0xe]
;;;355    			/*表示要发送的数据已经装入相应端点的FIFO中*/
;;;356    			byInCSR = M_INCSR_IPR;
000052  2501              MOVS     r5,#1
;;;357    			MWRITE_BYTE(M_REG_INCSR1, byInCSR);
000054  4608              MOV      r0,r1
000056  7445              STRB     r5,[r0,#0x11]
                  |L2.88|
;;;358    		}
;;;359    	}
;;;360    }
000058  bd7f              POP      {r0-r6,pc}
;;;361    
                          ENDP

00005a  0000              DCW      0x0000
                  |L2.92|
                          DCD      0x40005c00

                          AREA ||i.EndpointBulkOut||, CODE, READONLY, ALIGN=2

                  EndpointBulkOut PROC
;;;373    */
;;;374    void EndpointBulkOut(M_EPBOUT_STATUS pbostate, int nCallState)
000000  b57f              PUSH     {r0-r6,lr}
;;;375    {
000002  9e08              LDR      r6,[sp,#0x20]
;;;376    	int     nBytes;
;;;377    	BYTE    byOutCSR;
;;;378    
;;;379    	/* Reset endpoint */
;;;380    	if(nCallState == M_EP_RESET)
000004  2e01              CMP      r6,#1
000006  d107              BNE      |L3.24|
;;;381    	{
;;;382    		/***配置端点号***/
;;;383    		MWRITE_BYTE(M_REG_INDEX, pbostate.byEP);
000008  4668              MOV      r0,sp
00000a  7b00              LDRB     r0,[r0,#0xc]
00000c  4918              LDR      r1,|L3.112|
00000e  7388              STRB     r0,[r1,#0xe]
;;;384    		byOutCSR = M_OUTCSR_CDT | M_OUTCSR_FF;
000010  2590              MOVS     r5,#0x90
;;;385    		/***复位端点的数据反转状态,清空接收 FIFO 中的数据***/
;;;386    		MWRITE_BYTE(M_REG_OUTCSR1, byOutCSR);
000012  4608              MOV      r0,r1
000014  7505              STRB     r5,[r0,#0x14]
000016  e029              B        |L3.108|
                  |L3.24|
;;;387    	}
;;;388    	else
;;;389    	{
;;;390    		/* Set index register */
;;;391    		MWRITE_BYTE(M_REG_INDEX, pbostate.byEP);
000018  4668              MOV      r0,sp
00001a  7b00              LDRB     r0,[r0,#0xc]
00001c  4914              LDR      r1,|L3.112|
00001e  7388              STRB     r0,[r1,#0xe]
;;;392    
;;;393    		/* Read OUT CSR register */
;;;394    		byOutCSR = MREAD_BYTE(M_REG_OUTCSR1);
000020  4608              MOV      r0,r1
000022  7d05              LDRB     r5,[r0,#0x14]
;;;395    
;;;396    		/* Get packet, */
;;;397    		/* may need to unload more than one packet if double buffering enabled */
;;;398    		/*端点FIFO 中有数据*/
;;;399    		while(byOutCSR & M_OUTCSR_OPR)
000024  e01e              B        |L3.100|
                  |L3.38|
;;;400    		{
;;;401    			/* Get packet size */
;;;402    			nBytes = (int)MREAD_BYTE(M_REG_OUTCOUNT2);
000026  4812              LDR      r0,|L3.112|
000028  7dc4              LDRB     r4,[r0,#0x17]
;;;403    			nBytes <<= 8;
00002a  0224              LSLS     r4,r4,#8
;;;404    			nBytes |= (int)MREAD_BYTE(M_REG_OUTCOUNT1);
00002c  7d80              LDRB     r0,[r0,#0x16]
00002e  4304              ORRS     r4,r4,r0
;;;405    
;;;406    			/* Check there is room in the buffer */
;;;407    			if(pbostate.nBytesRecv + nBytes > pbostate.nBuffLen)
000030  9802              LDR      r0,[sp,#8]
000032  1900              ADDS     r0,r0,r4
000034  9901              LDR      r1,[sp,#4]
000036  4288              CMP      r0,r1
000038  dd03              BLE      |L3.66|
;;;408    			{
;;;409    				/* Call to function to handle buffer over run */
;;;410    				MWRITE_BYTE(M_REG_OUTCSR1, 0);
00003a  2000              MOVS     r0,#0
00003c  490c              LDR      r1,|L3.112|
00003e  7508              STRB     r0,[r1,#0x14]
                  |L3.64|
;;;411    				return;
;;;412    			}
;;;413    
;;;414    			/* Unload FIFO */
;;;415    			FIFORead((int)pbostate.byEP, nBytes, pbostate.pData);
;;;416    
;;;417    			/* Update status */
;;;418    			pbostate.nBytesRecv += nBytes;
;;;419    			pbostate.pData = (BYTE *)pbostate.pData + nBytes;
;;;420    
;;;421    			/* Check for end of transfer */
;;;422    			if (nBytes <= M_EP_MAXP) 
;;;423    			{
;;;424    				/* Call function to handle received data */	
;;;425    			}
;;;426    
;;;427    			/* Clear OutPktRdy */
;;;428    			MWRITE_BYTE(M_REG_OUTCSR1, 0);
;;;429    
;;;430    			/* Check for another packet */
;;;431    			byOutCSR = MREAD_BYTE(M_REG_OUTCSR1);
;;;432    		}
;;;433    	}
;;;434    }
000040  bd7f              POP      {r0-r6,pc}
                  |L3.66|
000042  4669              MOV      r1,sp                 ;415
000044  7b08              LDRB     r0,[r1,#0xc]          ;415
000046  4621              MOV      r1,r4                 ;415
000048  9a00              LDR      r2,[sp,#0]            ;415
00004a  f7fffffe          BL       FIFORead
00004e  9802              LDR      r0,[sp,#8]            ;418
000050  1900              ADDS     r0,r0,r4              ;418
000052  9002              STR      r0,[sp,#8]            ;418
000054  9800              LDR      r0,[sp,#0]            ;419
000056  1900              ADDS     r0,r0,r4              ;419
000058  9000              STR      r0,[sp,#0]            ;419
00005a  2000              MOVS     r0,#0                 ;428
00005c  4904              LDR      r1,|L3.112|
00005e  7508              STRB     r0,[r1,#0x14]         ;428
000060  4608              MOV      r0,r1                 ;431
000062  7d05              LDRB     r5,[r0,#0x14]         ;431
                  |L3.100|
000064  07e8              LSLS     r0,r5,#31             ;399
000066  0fc0              LSRS     r0,r0,#31             ;399
000068  2800              CMP      r0,#0                 ;399
00006a  d1dc              BNE      |L3.38|
                  |L3.108|
00006c  bf00              NOP      
00006e  e7e7              B        |L3.64|
;;;435    
                          ENDP

                  |L3.112|
                          DCD      0x40005c00

                          AREA ||i.FIFORead||, CODE, READONLY, ALIGN=2

                  FIFORead PROC
;;;482    */
;;;483    void FIFORead(int nEP, int nBytes, void * pDst)		
000000  b5f0              PUSH     {r4-r7,lr}
;;;484    {
000002  4603              MOV      r3,r0
000004  4614              MOV      r4,r2
;;;485    	int     nCount;
;;;486    	BYTE *  pby;
;;;487    	int     nAddr;
;;;488    
;;;489    	if(nBytes) 
000006  2900              CMP      r1,#0
000008  d00b              BEQ      |L4.34|
;;;490    	{
;;;491    		nAddr = M_FIFO_EP0+(nEP<<2);
00000a  009e              LSLS     r6,r3,#2
00000c  4f05              LDR      r7,|L4.36|
00000e  19f5              ADDS     r5,r6,r7
;;;492    		nCount = nBytes;
000010  4608              MOV      r0,r1
;;;493    		pby = (BYTE *)pDst;
000012  4622              MOV      r2,r4
;;;494    		while(nCount) 
000014  e003              B        |L4.30|
                  |L4.22|
;;;495    		{
;;;496    			*pby++ = *((BYTE *)nAddr);
000016  782e              LDRB     r6,[r5,#0]
000018  7016              STRB     r6,[r2,#0]
00001a  1c52              ADDS     r2,r2,#1
;;;497    			nCount--;
00001c  1e40              SUBS     r0,r0,#1
                  |L4.30|
00001e  2800              CMP      r0,#0                 ;494
000020  d1f9              BNE      |L4.22|
                  |L4.34|
;;;498    		}
;;;499    	}
;;;500    }
000022  bdf0              POP      {r4-r7,pc}
;;;501    
                          ENDP

                  |L4.36|
                          DCD      0x40005c20

                          AREA ||i.FIFOWrite||, CODE, READONLY, ALIGN=2

                  FIFOWrite PROC
;;;510    */
;;;511    void FIFOWrite(int nEP, int nBytes, void * pSrc)
000000  b5f0              PUSH     {r4-r7,lr}
;;;512    {
000002  4603              MOV      r3,r0
000004  4614              MOV      r4,r2
;;;513    	int     nCount;
;;;514    	BYTE *  pby;
;;;515    	int     nAddr;
;;;516    
;;;517    	if(nBytes)
000006  2900              CMP      r1,#0
000008  d00b              BEQ      |L5.34|
;;;518    	{
;;;519    		nAddr = M_FIFO_EP0+(nEP<<2);
00000a  009e              LSLS     r6,r3,#2
00000c  4f05              LDR      r7,|L5.36|
00000e  19f5              ADDS     r5,r6,r7
;;;520    		nCount = nBytes;
000010  4608              MOV      r0,r1
;;;521    		pby = (BYTE *)pSrc;
000012  4622              MOV      r2,r4
;;;522    		while (nCount)
000014  e003              B        |L5.30|
                  |L5.22|
;;;523    		{
;;;524    		 *((BYTE *)nAddr) = *pby++;
000016  7816              LDRB     r6,[r2,#0]
000018  702e              STRB     r6,[r5,#0]
00001a  1c52              ADDS     r2,r2,#1
;;;525    			nCount--;
00001c  1e40              SUBS     r0,r0,#1
                  |L5.30|
00001e  2800              CMP      r0,#0                 ;522
000020  d1f9              BNE      |L5.22|
                  |L5.34|
;;;526    		}
;;;527    	}
;;;528    	
;;;529    }
000022  bdf0              POP      {r4-r7,pc}
;;;530    
                          ENDP

                  |L5.36|
                          DCD      0x40005c20

                          AREA ||i.HID_GetIdleEvent||, CODE, READONLY, ALIGN=2

                  HID_GetIdleEvent PROC
;;;771    */
;;;772    void HID_GetIdleEvent(PM_EP0_STATUS pep0state,PCOMMAND pcmd)
000000  b570              PUSH     {r4-r6,lr}
;;;773    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;774    	/*保存请求类型*/
;;;775    	c_hid_data.wHID_Status = HID_REQUEST_GET_IDLE;
000006  490b              LDR      r1,|L6.52|
000008  2002              MOVS     r0,#2
00000a  f7fffffe          BL       __aeabi_uwrite4
;;;776    	
;;;777    	pep0state->nBytesLeft = 0x01;
00000e  1d21              ADDS     r1,r4,#4
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       __aeabi_uwrite4
;;;778    	pep0state->pData = (void*)&c_hid_data.wHID_IdleTimeIf0ID;
000016  4621              MOV      r1,r4
000018  3108              ADDS     r1,r1,#8
00001a  4806              LDR      r0,|L6.52|
00001c  3843              SUBS     r0,r0,#0x43
00001e  f7fffffe          BL       __aeabi_uwrite4
;;;779    	pep0state->nState = M_EP0_TX;
000022  4621              MOV      r1,r4
000024  2002              MOVS     r0,#2
000026  f7fffffe          BL       __aeabi_uwrite4
;;;780    	MWRITE_BYTE(M_REG_CSR0,M_CSR0_SVDOUTPKTRDY);	
00002a  2040              MOVS     r0,#0x40
00002c  4902              LDR      r1,|L6.56|
00002e  7448              STRB     r0,[r1,#0x11]
;;;781    }
000030  bd70              POP      {r4-r6,pc}
;;;782    /******************************************************************************
                          ENDP

000032  0000              DCW      0x0000
                  |L6.52|
                          DCD      c_hid_data+0x53
                  |L6.56|
                          DCD      0x40005c00

                          AREA ||i.HID_GetProtocolEvent||, CODE, READONLY, ALIGN=2

                  HID_GetProtocolEvent PROC
;;;807    */
;;;808    void HID_GetProtocolEvent(PM_EP0_STATUS pep0state,PCOMMAND pcmd)
000000  b570              PUSH     {r4-r6,lr}
;;;809    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;810    	/*保存请求类型*/
;;;811    	c_hid_data.wHID_Status = HID_REQUEST_GET_PROTOCOL;
000006  490b              LDR      r1,|L7.52|
000008  2003              MOVS     r0,#3
00000a  f7fffffe          BL       __aeabi_uwrite4
;;;812    	
;;;813    	pep0state->nBytesLeft = 0x01;
00000e  1d21              ADDS     r1,r4,#4
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       __aeabi_uwrite4
;;;814    	pep0state->pData = (void*)&c_hid_data.wHID_Protocol;
000016  4621              MOV      r1,r4
000018  3108              ADDS     r1,r1,#8
00001a  4806              LDR      r0,|L7.52|
00001c  3842              SUBS     r0,r0,#0x42
00001e  f7fffffe          BL       __aeabi_uwrite4
;;;815    	pep0state->nState = M_EP0_TX;
000022  4621              MOV      r1,r4
000024  2002              MOVS     r0,#2
000026  f7fffffe          BL       __aeabi_uwrite4
;;;816    	MWRITE_BYTE(M_REG_CSR0,M_CSR0_SVDOUTPKTRDY);		
00002a  2040              MOVS     r0,#0x40
00002c  4902              LDR      r1,|L7.56|
00002e  7448              STRB     r0,[r1,#0x11]
;;;817    }
000030  bd70              POP      {r4-r6,pc}
;;;818    /******************************************************************************
                          ENDP

000032  0000              DCW      0x0000
                  |L7.52|
                          DCD      c_hid_data+0x53
                  |L7.56|
                          DCD      0x40005c00

                          AREA ||i.HID_GetReportEvent||, CODE, READONLY, ALIGN=2

                  HID_GetReportEvent PROC
;;;743    */
;;;744    void HID_GetReportEvent(PM_EP0_STATUS pep0state,PCOMMAND pcmd)
000000  b570              PUSH     {r4-r6,lr}
;;;745    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;746    	if(gnDevState > DEVSTATE_ADDRESS)
000006  4815              LDR      r0,|L8.92|
000008  6800              LDR      r0,[r0,#0]  ; gnDevState
00000a  2801              CMP      r0,#1
00000c  d924              BLS      |L8.88|
;;;747    	{
;;;748    		switch(pcmd->USBwValue >>8)
00000e  78e8              LDRB     r0,[r5,#3]
000010  78a9              LDRB     r1,[r5,#2]
000012  0200              LSLS     r0,r0,#8
000014  4308              ORRS     r0,r0,r1
000016  1200              ASRS     r0,r0,#8
000018  2801              CMP      r0,#1
00001a  d004              BEQ      |L8.38|
00001c  2802              CMP      r0,#2
00001e  d004              BEQ      |L8.42|
000020  2803              CMP      r0,#3
000022  d118              BNE      |L8.86|
000024  e000              B        |L8.40|
                  |L8.38|
;;;749    		{
;;;750    			case	HID_REPORT_INPUT:
;;;751    			case	HID_REPORT_FEATURE:
000026  bf00              NOP      
                  |L8.40|
;;;752    			case	HID_REPORT_OUTPUT:
000028  bf00              NOP      
                  |L8.42|
;;;753    				/*保存请求类型*/
;;;754    				c_hid_data.wHID_Status = HID_REQUEST_GET_REPORT;
00002a  490d              LDR      r1,|L8.96|
00002c  2001              MOVS     r0,#1
00002e  f7fffffe          BL       __aeabi_uwrite4
;;;755    			
;;;756    				pep0state->nBytesLeft = 0x01;
000032  1d21              ADDS     r1,r4,#4
000034  2001              MOVS     r0,#1
000036  f7fffffe          BL       __aeabi_uwrite4
;;;757    				pep0state->pData = (void*)&c_hid_data.wHID_SetRptByte[0];
00003a  4621              MOV      r1,r4
00003c  3108              ADDS     r1,r1,#8
00003e  4808              LDR      r0,|L8.96|
000040  3853              SUBS     r0,r0,#0x53
000042  f7fffffe          BL       __aeabi_uwrite4
;;;758    				pep0state->nState = M_EP0_TX;
000046  4621              MOV      r1,r4
000048  2002              MOVS     r0,#2
00004a  f7fffffe          BL       __aeabi_uwrite4
;;;759    				MWRITE_BYTE(M_REG_CSR0,M_CSR0_SVDOUTPKTRDY);
00004e  2040              MOVS     r0,#0x40
000050  4904              LDR      r1,|L8.100|
000052  7448              STRB     r0,[r1,#0x11]
;;;760    				break;
000054  bf00              NOP      
                  |L8.86|
000056  bf00              NOP      
                  |L8.88|
;;;761    		}
;;;762    	}	
;;;763    }
000058  bd70              POP      {r4-r6,pc}
;;;764    /******************************************************************************
                          ENDP

00005a  0000              DCW      0x0000
                  |L8.92|
                          DCD      gnDevState
                  |L8.96|
                          DCD      c_hid_data+0x53
                  |L8.100|
                          DCD      0x40005c00

                          AREA ||i.HID_SetIdleEvent||, CODE, READONLY, ALIGN=2

                  HID_SetIdleEvent PROC
;;;789    */
;;;790    void HID_SetIdleEvent(PM_EP0_STATUS pep0state,PCOMMAND pcmd)
000000  b570              PUSH     {r4-r6,lr}
;;;791    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;792    	/*保存请求类型*/
;;;793    	c_hid_data.wHID_Status = HID_REQUEST_SET_IDLE;
000006  490a              LDR      r1,|L9.48|
000008  200a              MOVS     r0,#0xa
00000a  f7fffffe          BL       __aeabi_uwrite4
;;;794    
;;;795    	pep0state->nState = M_EP0_IDLE;
00000e  4621              MOV      r1,r4
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       __aeabi_uwrite4
;;;796    	c_hid_data.wHID_IdleTimeIf0ID = (pcmd->USBwValue>>8);
000016  78e8              LDRB     r0,[r5,#3]
000018  78a9              LDRB     r1,[r5,#2]
00001a  0200              LSLS     r0,r0,#8
00001c  4308              ORRS     r0,r0,r1
00001e  1200              ASRS     r0,r0,#8
000020  4903              LDR      r1,|L9.48|
000022  3953              SUBS     r1,r1,#0x53
000024  7408              STRB     r0,[r1,#0x10]
;;;797    	MWRITE_BYTE(M_REG_CSR0,M_CSR0_SVDOUTPKTRDY);		
000026  2040              MOVS     r0,#0x40
000028  4902              LDR      r1,|L9.52|
00002a  7448              STRB     r0,[r1,#0x11]
;;;798    }
00002c  bd70              POP      {r4-r6,pc}
;;;799    
                          ENDP

00002e  0000              DCW      0x0000
                  |L9.48|
                          DCD      c_hid_data+0x53
                  |L9.52|
                          DCD      0x40005c00

                          AREA ||i.HID_SetProtocolEvent||, CODE, READONLY, ALIGN=2

                  HID_SetProtocolEvent PROC
;;;825    */
;;;826    void HID_SetProtocolEvent(PM_EP0_STATUS pep0state,PCOMMAND pcmd)
000000  b570              PUSH     {r4-r6,lr}
;;;827    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;828    	/*保存请求类型*/
;;;829    	c_hid_data.wHID_Status = HID_REQUEST_SET_PROTOCOL;
000006  4909              LDR      r1,|L10.44|
000008  200b              MOVS     r0,#0xb
00000a  f7fffffe          BL       __aeabi_uwrite4
;;;830    
;;;831    	pep0state->nState = M_EP0_IDLE;
00000e  4621              MOV      r1,r4
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       __aeabi_uwrite4
;;;832    	c_hid_data.wHID_Protocol = (pcmd->USBwValue & 0x00ff);
000016  78e8              LDRB     r0,[r5,#3]
000018  78a9              LDRB     r1,[r5,#2]
00001a  0200              LSLS     r0,r0,#8
00001c  4308              ORRS     r0,r0,r1
00001e  4903              LDR      r1,|L10.44|
000020  3953              SUBS     r1,r1,#0x53
000022  7448              STRB     r0,[r1,#0x11]
;;;833    	MWRITE_BYTE(M_REG_CSR0,M_CSR0_SVDOUTPKTRDY);		
000024  2040              MOVS     r0,#0x40
000026  4902              LDR      r1,|L10.48|
000028  7448              STRB     r0,[r1,#0x11]
;;;834    }
00002a  bd70              POP      {r4-r6,pc}
;;;835    /******************************************************************************
                          ENDP

                  |L10.44|
                          DCD      c_hid_data+0x53
                  |L10.48|
                          DCD      0x40005c00

                          AREA ||i.HID_SetReportEvent||, CODE, READONLY, ALIGN=2

                  HID_SetReportEvent PROC
;;;715    */
;;;716    void HID_SetReportEvent(PM_EP0_STATUS pep0state,PCOMMAND pcmd)
000000  b570              PUSH     {r4-r6,lr}
;;;717    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;718    	//if ((pcmd->bmRequestType == HID_REQUEST_SET) && (pcmd->USBwIndex == 1))// Interface 1
;;;719    	{
;;;720    		switch(pcmd->USBwValue >>8)
000006  78e8              LDRB     r0,[r5,#3]
000008  78a9              LDRB     r1,[r5,#2]
00000a  0200              LSLS     r0,r0,#8
00000c  4308              ORRS     r0,r0,r1
00000e  1200              ASRS     r0,r0,#8
000010  2801              CMP      r0,#1
000012  d004              BEQ      |L11.30|
000014  2802              CMP      r0,#2
000016  d003              BEQ      |L11.32|
000018  2803              CMP      r0,#3
00001a  d11c              BNE      |L11.86|
00001c  e01a              B        |L11.84|
                  |L11.30|
;;;721    		{
;;;722    			case	HID_REPORT_INPUT:break;
00001e  e01a              B        |L11.86|
                  |L11.32|
;;;723    			case	HID_REPORT_OUTPUT:
;;;724    				/*保存请求类型*/
;;;725    				c_hid_data.wHID_Status = HID_REQUEST_SET_REPORT;
000020  490e              LDR      r1,|L11.92|
000022  2009              MOVS     r0,#9
000024  f7fffffe          BL       __aeabi_uwrite4
;;;726    			
;;;727    				pep0state->nBytesLeft = pcmd->USBwLength;
000028  79e9              LDRB     r1,[r5,#7]
00002a  79aa              LDRB     r2,[r5,#6]
00002c  0209              LSLS     r1,r1,#8
00002e  4311              ORRS     r1,r1,r2
000030  4608              MOV      r0,r1
000032  1d21              ADDS     r1,r4,#4
000034  f7fffffe          BL       __aeabi_uwrite4
;;;728    				pep0state->nState = M_EP0_RX;
000038  4621              MOV      r1,r4
00003a  2001              MOVS     r0,#1
00003c  f7fffffe          BL       __aeabi_uwrite4
;;;729    				pep0state->pData = (void*)&c_hid_data.wHID_SetRptByte[0];
000040  4621              MOV      r1,r4
000042  3108              ADDS     r1,r1,#8
000044  4805              LDR      r0,|L11.92|
000046  3853              SUBS     r0,r0,#0x53
000048  f7fffffe          BL       __aeabi_uwrite4
;;;730    				MWRITE_BYTE(M_REG_CSR0,M_CSR0_SVDOUTPKTRDY);				
00004c  2040              MOVS     r0,#0x40
00004e  4904              LDR      r1,|L11.96|
000050  7448              STRB     r0,[r1,#0x11]
;;;731    				break;
000052  e000              B        |L11.86|
                  |L11.84|
;;;732    			case	HID_REPORT_FEATURE:break;
000054  bf00              NOP      
                  |L11.86|
000056  bf00              NOP                            ;722
;;;733    		}
;;;734    	}	
;;;735    }
000058  bd70              POP      {r4-r6,pc}
;;;736    /******************************************************************************
                          ENDP

00005a  0000              DCW      0x0000
                  |L11.92|
                          DCD      c_hid_data+0x53
                  |L11.96|
                          DCD      0x40005c00

                          AREA ||i.USB_EP_Rx||, CODE, READONLY, ALIGN=1

                  USB_EP_Rx PROC
;;;1788   */
;;;1789   void USB_EP_Rx(uint8_t Ep,uint8_t *ptr,uint8_t data_len)
000000  b570              PUSH     {r4-r6,lr}
;;;1790   {
000002  b085              SUB      sp,sp,#0x14
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;1791   	M_EPBOUT_STATUS    tEp1out;
;;;1792   	
;;;1793   	tEp1out.byEP = Ep;
00000a  4668              MOV      r0,sp
00000c  7406              STRB     r6,[r0,#0x10]
;;;1794   	tEp1out.nBuffLen = data_len; 	//M_EP_MAXP
00000e  9502              STR      r5,[sp,#8]
;;;1795   	tEp1out.pData = ptr;
000010  9401              STR      r4,[sp,#4]
;;;1796   	tEp1out.nBytesRecv = 0;
000012  2000              MOVS     r0,#0
000014  9003              STR      r0,[sp,#0xc]
;;;1797   
;;;1798   	EndpointBulkOut(tEp1out, M_EP_NORMAL);
000016  9000              STR      r0,[sp,#0]
000018  a801              ADD      r0,sp,#4
00001a  c80f              LDM      r0,{r0-r3}
00001c  f7fffffe          BL       EndpointBulkOut
;;;1799   }
000020  b005              ADD      sp,sp,#0x14
000022  bd70              POP      {r4-r6,pc}
;;;1800   
                          ENDP


                          AREA ||i.USB_EP_Tx||, CODE, READONLY, ALIGN=2

                  USB_EP_Tx PROC
;;;1752   */
;;;1753   ErrorStatus USB_EP_Tx(uint8_t Ep,uint8_t *ptr,uint8_t data_len)
000000  b5fe              PUSH     {r1-r7,lr}
;;;1754   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;1755   	M_EPBIN_STATUS tEp0in;
;;;1756   	uint32_t timeout = 0;
000008  2700              MOVS     r7,#0
;;;1757   	
;;;1758   	if(gnDevState > DEVSTATE_ADDRESS)
00000a  480e              LDR      r0,|L13.68|
00000c  6800              LDR      r0,[r0,#0]  ; gnDevState
00000e  2801              CMP      r0,#1
000010  d916              BLS      |L13.64|
;;;1759   	{
;;;1760   		tEp0in.byEP = Ep;
000012  4668              MOV      r0,sp
000014  7204              STRB     r4,[r0,#8]
;;;1761   		tEp0in.nBytesLeft = data_len;
000016  9601              STR      r6,[sp,#4]
;;;1762   		tEp0in.pData = ptr;
000018  9500              STR      r5,[sp,#0]
;;;1763   		EndpointBulkIn(tEp0in, M_EP_NORMAL);
00001a  2300              MOVS     r3,#0
00001c  4668              MOV      r0,sp
00001e  c807              LDM      r0,{r0-r2}
000020  f7fffffe          BL       EndpointBulkIn
;;;1764   
;;;1765   		
;;;1766   		while(MREAD_BYTE(M_REG_INCSR1) & 0x01)
000024  e004              B        |L13.48|
                  |L13.38|
;;;1767   		{
;;;1768   			timeout++;
000026  1c7f              ADDS     r7,r7,#1
;;;1769   			if(timeout>=0xffffffff)
000028  1c78              ADDS     r0,r7,#1
00002a  2800              CMP      r0,#0
00002c  d100              BNE      |L13.48|
                  |L13.46|
;;;1770   			{
;;;1771   				return ERROR;
;;;1772   			}
;;;1773   		}
;;;1774   		return SUCCESS;
;;;1775   	}
;;;1776   	
;;;1777   	return ERROR;
;;;1778   }
00002e  bdfe              POP      {r1-r7,pc}
                  |L13.48|
000030  4805              LDR      r0,|L13.72|
000032  7c40              LDRB     r0,[r0,#0x11]         ;1766
000034  07c0              LSLS     r0,r0,#31             ;1766
000036  0fc0              LSRS     r0,r0,#31             ;1766
000038  2800              CMP      r0,#0                 ;1766
00003a  d1f4              BNE      |L13.38|
00003c  2001              MOVS     r0,#1                 ;1774
00003e  e7f6              B        |L13.46|
                  |L13.64|
000040  2000              MOVS     r0,#0                 ;1777
000042  e7f4              B        |L13.46|
;;;1779   
                          ENDP

                  |L13.68|
                          DCD      gnDevState
                  |L13.72|
                          DCD      0x40005c00

                          AREA ||i.USB_Endpoint0||, CODE, READONLY, ALIGN=2

                  USB_Endpoint0 PROC
;;;623    */
;;;624    void USB_Endpoint0(int nCallState)
000000  b570              PUSH     {r4-r6,lr}
;;;625    {
000002  4605              MOV      r5,r0
;;;626    	static M_EP0_STATUS	ep0state;
;;;627    	static COMMAND	cmd;
;;;628    	BYTE	byCSR0;
;;;629    
;;;630    	
;;;631    	/* Check for USB reset of endpoint 0 */
;;;632    	if (nCallState == M_EP_RESET)
000004  2d01              CMP      r5,#1
000006  d10a              BNE      |L14.30|
;;;633    	{
;;;634    		ep0state.nState = M_EP0_IDLE;
000008  4938              LDR      r1,|L14.236|
00000a  2000              MOVS     r0,#0
00000c  f7fffffe          BL       __aeabi_uwrite4
;;;635    		ep0state.byFAddr = 0xFF;
000010  20ff              MOVS     r0,#0xff
000012  4936              LDR      r1,|L14.236|
000014  7408              STRB     r0,[r1,#0x10]
;;;636    		/* Clear current configuration pointer */
;;;637    		gpCurCfg = NULL;
000016  2000              MOVS     r0,#0
000018  4935              LDR      r1,|L14.240|
00001a  6008              STR      r0,[r1,#0]  ; gpCurCfg
                  |L14.28|
;;;638    		return;
;;;639    	}
;;;640    
;;;641    	/* Read CSR0 */
;;;642    	MWRITE_BYTE(M_REG_INDEX, 0);							//选择endpoint0
;;;643    	byCSR0 = MREAD_BYTE(M_REG_CSR0);						//读取CSR0，各种通信状态
;;;644    
;;;645    	/* Check for status stage of a request */
;;;646    	/*接收已完成状态*/
;;;647    	if(!(byCSR0 & M_CSR0_OUTPKTRDY)) 
;;;648    	{
;;;649    		/* Complete SET_ADDRESS command */
;;;650    		if(ep0state.byFAddr != 0xFF)
;;;651    		{
;;;652    			MWRITE_BYTE(M_REG_FADDR, ep0state.byFAddr);		//如果地址不为FF，reset，地址设置为byFAddr
;;;653    			if((gnDevState == DEVSTATE_DEFAULT) && ep0state.byFAddr)
;;;654    			{
;;;655    				gnDevState = DEVSTATE_ADDRESS;				//地址不为0，且设备状态为 DEVSTATE_DEFAULT
;;;656    			}
;;;657    			else if((gnDevState == DEVSTATE_ADDRESS) && !ep0state.byFAddr)
;;;658    			{
;;;659    				gnDevState = DEVSTATE_DEFAULT;				//地址为0，且设备状态为 DEVSTATE_ADDRESS
;;;660    			}
;;;661    		}
;;;662    	}
;;;663    	/* Clear pending commands */
;;;664    	ep0state.byFAddr = 0xFF;	
;;;665    
;;;666    	/* Check for SentStall */
;;;667    	if(byCSR0 & M_CSR0_SENTSTALL)
;;;668    	{
;;;669    		/*清除STALL 位*/
;;;670    		MWRITE_BYTE(M_REG_CSR0, (byCSR0 & ~M_CSR0_SENDSTALL));
;;;671    		ep0state.nState = M_EP0_IDLE;
;;;672    	}
;;;673    
;;;674    	/* Check for SetupEnd */
;;;675    	if(byCSR0 & M_CSR0_SETUPEND)
;;;676    	{
;;;677    		/*清除setupend位*/
;;;678    		MWRITE_BYTE(M_REG_CSR0, (byCSR0 | M_CSR0_SVDSETUPEND));
;;;679    		ep0state.nState = M_EP0_IDLE;
;;;680    	}
;;;681    
;;;682    	/* Call relevant routines for endpoint 0 state */
;;;683    	if(ep0state.nState == M_EP0_IDLE) 
;;;684    	{
;;;685    		/* If no packet has been received, */
;;;686    		/* assume that this was a STATUS phase complete. */
;;;687    		/* Otherwise load new command */
;;;688    		if(byCSR0 & M_CSR0_OUTPKTRDY) 
;;;689    		{
;;;690    			/* Read the 8-byte command from the FIFO */
;;;691    			/* There is no need to check that OutCount is set to 8 */
;;;692    			/* as the MUSBFSFC will reject SETUP packets that are not 8 bytes long. */
;;;693    			FIFORead(0, 8, &cmd);							//传入cmd地址存放数据到结构体中
;;;694    			USB_Endpoint0_Command(&ep0state, &cmd);			//数据解析
;;;695    		}
;;;696    	}
;;;697    	
;;;698    	if(ep0state.nState == M_EP0_TX)
;;;699    	{
;;;700    		USB_Endpoint0_Tx(&ep0state);
;;;701    	}
;;;702    	else if(ep0state.nState == M_EP0_RX)
;;;703    	{
;;;704    		USB_Endpoint0_Rx(&ep0state);
;;;705    	}
;;;706    }
00001c  bd70              POP      {r4-r6,pc}
                  |L14.30|
00001e  2000              MOVS     r0,#0                 ;642
000020  4934              LDR      r1,|L14.244|
000022  7388              STRB     r0,[r1,#0xe]          ;642
000024  4608              MOV      r0,r1                 ;643
000026  7c44              LDRB     r4,[r0,#0x11]         ;643
000028  07e0              LSLS     r0,r4,#31             ;647
00002a  0fc0              LSRS     r0,r0,#31             ;647
00002c  2800              CMP      r0,#0                 ;647
00002e  d11c              BNE      |L14.106|
000030  482e              LDR      r0,|L14.236|
000032  7c00              LDRB     r0,[r0,#0x10]         ;650  ; ep0state
000034  28ff              CMP      r0,#0xff              ;650
000036  d018              BEQ      |L14.106|
000038  482c              LDR      r0,|L14.236|
00003a  7c00              LDRB     r0,[r0,#0x10]         ;652  ; ep0state
00003c  7008              STRB     r0,[r1,#0]            ;652
00003e  482e              LDR      r0,|L14.248|
000040  6800              LDR      r0,[r0,#0]            ;653  ; gnDevState
000042  2800              CMP      r0,#0                 ;653
000044  d107              BNE      |L14.86|
000046  4829              LDR      r0,|L14.236|
000048  7c00              LDRB     r0,[r0,#0x10]         ;653  ; ep0state
00004a  2800              CMP      r0,#0                 ;653
00004c  d003              BEQ      |L14.86|
00004e  2001              MOVS     r0,#1                 ;655
000050  4929              LDR      r1,|L14.248|
000052  6008              STR      r0,[r1,#0]            ;655  ; gnDevState
000054  e009              B        |L14.106|
                  |L14.86|
000056  4828              LDR      r0,|L14.248|
000058  6800              LDR      r0,[r0,#0]            ;657  ; gnDevState
00005a  2801              CMP      r0,#1                 ;657
00005c  d105              BNE      |L14.106|
00005e  4823              LDR      r0,|L14.236|
000060  7c00              LDRB     r0,[r0,#0x10]         ;657  ; ep0state
000062  2800              CMP      r0,#0                 ;657
000064  d101              BNE      |L14.106|
000066  4924              LDR      r1,|L14.248|
000068  6008              STR      r0,[r1,#0]            ;659  ; gnDevState
                  |L14.106|
00006a  20ff              MOVS     r0,#0xff              ;664
00006c  491f              LDR      r1,|L14.236|
00006e  7408              STRB     r0,[r1,#0x10]         ;664
000070  2004              MOVS     r0,#4                 ;667
000072  4020              ANDS     r0,r0,r4              ;667
000074  2800              CMP      r0,#0                 ;667
000076  d008              BEQ      |L14.138|
000078  2120              MOVS     r1,#0x20              ;670
00007a  4620              MOV      r0,r4                 ;670
00007c  4388              BICS     r0,r0,r1              ;670
00007e  491d              LDR      r1,|L14.244|
000080  7448              STRB     r0,[r1,#0x11]         ;670
000082  491a              LDR      r1,|L14.236|
000084  2000              MOVS     r0,#0                 ;671
000086  f7fffffe          BL       __aeabi_uwrite4
                  |L14.138|
00008a  2010              MOVS     r0,#0x10              ;675
00008c  4020              ANDS     r0,r0,r4              ;675
00008e  2800              CMP      r0,#0                 ;675
000090  d007              BEQ      |L14.162|
000092  2080              MOVS     r0,#0x80              ;678
000094  4320              ORRS     r0,r0,r4              ;678
000096  4917              LDR      r1,|L14.244|
000098  7448              STRB     r0,[r1,#0x11]         ;678
00009a  4914              LDR      r1,|L14.236|
00009c  2000              MOVS     r0,#0                 ;679
00009e  f7fffffe          BL       __aeabi_uwrite4
                  |L14.162|
0000a2  4812              LDR      r0,|L14.236|
0000a4  f7fffffe          BL       __aeabi_uread4
0000a8  2800              CMP      r0,#0                 ;683
0000aa  d10c              BNE      |L14.198|
0000ac  07e0              LSLS     r0,r4,#31             ;688
0000ae  0fc0              LSRS     r0,r0,#31             ;688
0000b0  2800              CMP      r0,#0                 ;688
0000b2  d008              BEQ      |L14.198|
0000b4  4a11              LDR      r2,|L14.252|
0000b6  2108              MOVS     r1,#8                 ;693
0000b8  2000              MOVS     r0,#0                 ;693
0000ba  f7fffffe          BL       FIFORead
0000be  490f              LDR      r1,|L14.252|
0000c0  480a              LDR      r0,|L14.236|
0000c2  f7fffffe          BL       USB_Endpoint0_Command
                  |L14.198|
0000c6  4809              LDR      r0,|L14.236|
0000c8  f7fffffe          BL       __aeabi_uread4
0000cc  2802              CMP      r0,#2                 ;698
0000ce  d103              BNE      |L14.216|
0000d0  4806              LDR      r0,|L14.236|
0000d2  f7fffffe          BL       USB_Endpoint0_Tx
0000d6  e007              B        |L14.232|
                  |L14.216|
0000d8  4804              LDR      r0,|L14.236|
0000da  f7fffffe          BL       __aeabi_uread4
0000de  2801              CMP      r0,#1                 ;702
0000e0  d102              BNE      |L14.232|
0000e2  4802              LDR      r0,|L14.236|
0000e4  f7fffffe          BL       USB_Endpoint0_Rx
                  |L14.232|
0000e8  bf00              NOP      
0000ea  e797              B        |L14.28|
;;;707    
                          ENDP

                  |L14.236|
                          DCD      ep0state
                  |L14.240|
                          DCD      gpCurCfg
                  |L14.244|
                          DCD      0x40005c00
                  |L14.248|
                          DCD      gnDevState
                  |L14.252|
                          DCD      ||cmd||

                          AREA ||i.USB_Endpoint0_Command||, CODE, READONLY, ALIGN=2

                  USB_Endpoint0_Command PROC
;;;891    */
;;;892    static void USB_Endpoint0_Command(PM_EP0_STATUS pep0state, PCOMMAND pcmd)
000000  b570              PUSH     {r4-r6,lr}
;;;893    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;894    
;;;895    
;;;896    	/* Check request type */
;;;897    	switch(pcmd->bmRequestType & M_CMD_TYPEMASK)	//判断数据中为何种命令
000006  7820              LDRB     r0,[r4,#0]
000008  2160              MOVS     r1,#0x60
00000a  4008              ANDS     r0,r0,r1
00000c  2800              CMP      r0,#0
00000e  d004              BEQ      |L15.26|
000010  2820              CMP      r0,#0x20
000012  d007              BEQ      |L15.36|
000014  2840              CMP      r0,#0x40
000016  d10a              BNE      |L15.46|
000018  e00a              B        |L15.48|
                  |L15.26|
;;;898    	{
;;;899    		/***主机到设备，标准请求命令，接收者为设备***/
;;;900    		case M_CMD_STDREQ:
;;;901    			USB_StdDev_Req(pep0state, pcmd);
00001a  4621              MOV      r1,r4
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       USB_StdDev_Req
;;;902    			break;
000022  e009              B        |L15.56|
                  |L15.36|
;;;903    
;;;904    		/***主机到设备，类请求命令，接收者为设备***/
;;;905    		case M_CMD_CLASSREQ:
;;;906    			/* Add call to external routine for handling class requests */
;;;907    			USB_HID_Class_Req(pep0state,pcmd);
000024  4621              MOV      r1,r4
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       USB_HID_Class_Req
;;;908    			break;
00002c  e004              B        |L15.56|
                  |L15.46|
;;;909    		/***主机到设备，用户定义的命令，接收者为设备***/
;;;910    		case M_CMD_VENDREQ:
00002e  bf00              NOP      
                  |L15.48|
;;;911    		/* Add call to external routine for handling vendor requests */
;;;912    			
;;;913    		/***保留***/
;;;914    		default:
;;;915    			/* Stall the command if a reserved request is received */
;;;916    			MWRITE_BYTE(M_REG_CSR0, M_CSR0_SVDOUTPKTRDY | M_CSR0_SENDSTALL);
000030  2060              MOVS     r0,#0x60
000032  4902              LDR      r1,|L15.60|
000034  7448              STRB     r0,[r1,#0x11]
;;;917    		break;
000036  bf00              NOP      
                  |L15.56|
000038  bf00              NOP                            ;902
;;;918      }
;;;919    
;;;920    	return;
;;;921    }
00003a  bd70              POP      {r4-r6,pc}
;;;922    
                          ENDP

                  |L15.60|
                          DCD      0x40005c00

                          AREA ||i.USB_Endpoint0_Rx||, CODE, READONLY, ALIGN=2

                  USB_Endpoint0_Rx PROC
;;;1588   */
;;;1589   static void USB_Endpoint0_Rx(PM_EP0_STATUS pep0state)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1590   {
000002  4604              MOV      r4,r0
;;;1591   	uint8_t state = 0x00;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;1592   	uint8_t st_led = 0x00;
000008  2500              MOVS     r5,#0
;;;1593   	BYTE    byOutCSR;
;;;1594   	
;;;1595   	/* Set index register */
;;;1596   	MWRITE_BYTE(M_REG_INDEX, 0);
00000a  4919              LDR      r1,|L16.112|
00000c  7388              STRB     r0,[r1,#0xe]
;;;1597   	/* Read OUT CSR register */
;;;1598   	byOutCSR = MREAD_BYTE(M_REG_CSR0);
00000e  4608              MOV      r0,r1
000010  7c46              LDRB     r6,[r0,#0x11]
;;;1599   
;;;1600   	/* Get packet, */
;;;1601   	/* may need to unload more than one packet if double buffering enabled */
;;;1602   	/*端点FIFO 中有数据*/
;;;1603   	while(byOutCSR & M_CSR0_OUTPKTRDY)
000012  e027              B        |L16.100|
                  |L16.20|
;;;1604   	{
;;;1605   		pep0state->nState = M_EP0_IDLE;
000014  4621              MOV      r1,r4
000016  2000              MOVS     r0,#0
000018  f7fffffe          BL       __aeabi_uwrite4
;;;1606   
;;;1607   		/* Unload FIFO */
;;;1608   		//FIFORead(0, 1, pep0state->pData);//NUM CAP SCR指示灯信息
;;;1609   		//FIFORead(0, pep0state->nBytesLeft, pep0state->pData);//NUM CAP SCR指示灯信息
;;;1610   		
;;;1611   		/*设置CAPS LOCK灯*/
;;;1612   		FIFORead(0, sizeof(state), &state);
00001c  466a              MOV      r2,sp
00001e  2101              MOVS     r1,#1
000020  2000              MOVS     r0,#0
000022  f7fffffe          BL       FIFORead
;;;1613   		
;;;1614   		st_led = (state & 0x02);
000026  4668              MOV      r0,sp
000028  7800              LDRB     r0,[r0,#0]
00002a  2102              MOVS     r1,#2
00002c  4008              ANDS     r0,r0,r1
00002e  4605              MOV      r5,r0
;;;1615   		switch(st_led)
000030  2d00              CMP      r5,#0
000032  d002              BEQ      |L16.58|
000034  2d02              CMP      r5,#2
000036  d10f              BNE      |L16.88|
000038  e006              B        |L16.72|
                  |L16.58|
;;;1616   		{
;;;1617   			case 0x00: GPIO_WriteBit(CAPS_PORT, CAPS_PIN, Bit_SET); break;
00003a  2201              MOVS     r2,#1
00003c  0251              LSLS     r1,r2,#9
00003e  2009              MOVS     r0,#9
000040  06c0              LSLS     r0,r0,#27
000042  f7fffffe          BL       GPIO_WriteBit
000046  e007              B        |L16.88|
                  |L16.72|
;;;1618   			case 0x02: GPIO_WriteBit(CAPS_PORT, CAPS_PIN, Bit_RESET); break;
000048  2200              MOVS     r2,#0
00004a  2101              MOVS     r1,#1
00004c  0249              LSLS     r1,r1,#9
00004e  2009              MOVS     r0,#9
000050  06c0              LSLS     r0,r0,#27
000052  f7fffffe          BL       GPIO_WriteBit
000056  bf00              NOP      
                  |L16.88|
000058  bf00              NOP                            ;1617
;;;1619   		}
;;;1620   
;;;1621   		/*Cear flag*/
;;;1622   		MWRITE_BYTE(M_REG_CSR0,M_CSR0_SVDOUTPKTRDY);
00005a  2040              MOVS     r0,#0x40
00005c  4904              LDR      r1,|L16.112|
00005e  7448              STRB     r0,[r1,#0x11]
;;;1623   		/* Check for another packet */
;;;1624   		byOutCSR = MREAD_BYTE(M_REG_CSR0);
000060  4608              MOV      r0,r1
000062  7c46              LDRB     r6,[r0,#0x11]
                  |L16.100|
000064  07f0              LSLS     r0,r6,#31             ;1603
000066  0fc0              LSRS     r0,r0,#31             ;1603
000068  2800              CMP      r0,#0                 ;1603
00006a  d1d3              BNE      |L16.20|
;;;1625   	}
;;;1626   		
;;;1627   }
00006c  bdf8              POP      {r3-r7,pc}
;;;1628   
                          ENDP

00006e  0000              DCW      0x0000
                  |L16.112|
                          DCD      0x40005c00

                          AREA ||i.USB_Endpoint0_Tx||, CODE, READONLY, ALIGN=2

                  USB_Endpoint0_Tx PROC
;;;1546   */
;;;1547   static void USB_Endpoint0_Tx(PM_EP0_STATUS pep0state)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1548   {
000002  4604              MOV      r4,r0
;;;1549   	int	nBytes;
;;;1550   	BYTE	by;
;;;1551   
;;;1552   	/* Determine number of bytes to send */
;;;1553   	if(pep0state->nBytesLeft <= M_EP0_MAXP)
000004  1d20              ADDS     r0,r4,#4
000006  f7fffffe          BL       __aeabi_uread4
00000a  2840              CMP      r0,#0x40
00000c  dc08              BGT      |L17.32|
;;;1554   	{
;;;1555   		nBytes = pep0state->nBytesLeft;
00000e  1d20              ADDS     r0,r4,#4
000010  f7fffffe          BL       __aeabi_uread4
000014  4605              MOV      r5,r0
;;;1556   		pep0state->nBytesLeft = 0;
000016  1d21              ADDS     r1,r4,#4
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       __aeabi_uwrite4
00001e  e008              B        |L17.50|
                  |L17.32|
;;;1557   	}
;;;1558   	else
;;;1559   	{
;;;1560   		nBytes = M_EP0_MAXP;
000020  2540              MOVS     r5,#0x40
;;;1561   		pep0state->nBytesLeft -= M_EP0_MAXP;
000022  1d20              ADDS     r0,r4,#4
000024  f7fffffe          BL       __aeabi_uread4
000028  1b47              SUBS     r7,r0,r5
00002a  1d21              ADDS     r1,r4,#4
00002c  4638              MOV      r0,r7
00002e  f7fffffe          BL       __aeabi_uwrite4
                  |L17.50|
;;;1562   	}
;;;1563   
;;;1564   	FIFOWrite(0, nBytes, pep0state->pData);
000032  4620              MOV      r0,r4
000034  3008              ADDS     r0,r0,#8
000036  f7fffffe          BL       __aeabi_uread4
00003a  4607              MOV      r7,r0
00003c  463a              MOV      r2,r7
00003e  4629              MOV      r1,r5
000040  2000              MOVS     r0,#0
000042  f7fffffe          BL       FIFOWrite
;;;1565   	pep0state->pData = (BYTE *)pep0state->pData + nBytes;
000046  4620              MOV      r0,r4
000048  3008              ADDS     r0,r0,#8
00004a  f7fffffe          BL       __aeabi_uread4
00004e  1947              ADDS     r7,r0,r5
000050  4621              MOV      r1,r4
000052  3108              ADDS     r1,r1,#8
000054  4638              MOV      r0,r7
000056  f7fffffe          BL       __aeabi_uwrite4
;;;1566   	if(nBytes < M_EP0_MAXP)
00005a  2d40              CMP      r5,#0x40
00005c  da05              BGE      |L17.106|
;;;1567   	{
;;;1568   		/***数据已经写入 FIFO 中,将要发送的时最后一包数据***/
;;;1569   		by = M_CSR0_INPKTRDY | M_CSR0_DATAEND;
00005e  260a              MOVS     r6,#0xa
;;;1570   		pep0state->nState = M_EP0_IDLE;
000060  4621              MOV      r1,r4
000062  2000              MOVS     r0,#0
000064  f7fffffe          BL       __aeabi_uwrite4
000068  e000              B        |L17.108|
                  |L17.106|
;;;1571   	}
;;;1572   	else
;;;1573   	{
;;;1574   		/***数据已经写入 FIFO 中***/
;;;1575   		by = M_CSR0_INPKTRDY;
00006a  2602              MOVS     r6,#2
                  |L17.108|
;;;1576   	}
;;;1577   	
;;;1578   	MWRITE_BYTE(M_REG_CSR0, by);
00006c  4801              LDR      r0,|L17.116|
00006e  7446              STRB     r6,[r0,#0x11]
;;;1579   }
000070  bdf8              POP      {r3-r7,pc}
;;;1580   
                          ENDP

000072  0000              DCW      0x0000
                  |L17.116|
                          DCD      0x40005c00

                          AREA ||i.USB_GetITStatus||, CODE, READONLY, ALIGN=2

                  USB_GetITStatus PROC
;;;578    */
;;;579    ITStatus USB_GetITStatus(uint32_t USB_IT)
000000  b570              PUSH     {r4-r6,lr}
;;;580    {
000002  4601              MOV      r1,r0
;;;581        __IO uint8_t *tmp = (__IO uint8_t *)USB_BASE;
000004  4a16              LDR      r2,|L18.96|
;;;582        uint8_t tmp_flag = 0;
000006  2300              MOVS     r3,#0
;;;583    		uint32_t IT_FLAG = 0;
000008  2400              MOVS     r4,#0
;;;584        ITStatus bitstatus = RESET;
00000a  2000              MOVS     r0,#0
;;;585    
;;;586        assert_param(IS_USB_CONFIG_IT(USB_IT));
;;;587    
;;;588        if(USB_IT & 0x00000100)
00000c  1595              ASRS     r5,r2,#22
00000e  400d              ANDS     r5,r5,r1
000010  2d00              CMP      r5,#0
000012  d005              BEQ      |L18.32|
;;;589        {
;;;590          tmp = &USB->INTRIN;
000014  1c92              ADDS     r2,r2,#2
;;;591          IT_FLAG = USB_IT & 0xfffffeff;
000016  1596              ASRS     r6,r2,#22
000018  460d              MOV      r5,r1
00001a  43b5              BICS     r5,r5,r6
00001c  462c              MOV      r4,r5
00001e  e016              B        |L18.78|
                  |L18.32|
;;;592        }
;;;593        else if(USB_IT & 0x00000200)
000020  2501              MOVS     r5,#1
000022  026d              LSLS     r5,r5,#9
000024  400d              ANDS     r5,r5,r1
000026  2d00              CMP      r5,#0
000028  d006              BEQ      |L18.56|
;;;594        {
;;;595          tmp = &USB->INTROUT;
00002a  4a0d              LDR      r2,|L18.96|
00002c  1d12              ADDS     r2,r2,#4
;;;596          IT_FLAG = USB_IT & 0xfffffdff;
00002e  1556              ASRS     r6,r2,#21
000030  460d              MOV      r5,r1
000032  43b5              BICS     r5,r5,r6
000034  462c              MOV      r4,r5
000036  e00a              B        |L18.78|
                  |L18.56|
;;;597        }
;;;598        else if(USB_IT & 0x00000400)
000038  2501              MOVS     r5,#1
00003a  02ad              LSLS     r5,r5,#10
00003c  400d              ANDS     r5,r5,r1
00003e  2d00              CMP      r5,#0
000040  d005              BEQ      |L18.78|
;;;599        {
;;;600          tmp = &USB->INTRUSB;
000042  4a07              LDR      r2,|L18.96|
000044  1d92              ADDS     r2,r2,#6
;;;601          IT_FLAG = USB_IT & 0xfffffbff;
000046  1516              ASRS     r6,r2,#20
000048  460d              MOV      r5,r1
00004a  43b5              BICS     r5,r5,r6
00004c  462c              MOV      r4,r5
                  |L18.78|
;;;602        }
;;;603    
;;;604        tmp_flag = *(__IO uint8_t *)tmp;
00004e  7813              LDRB     r3,[r2,#0]
;;;605        if( (tmp_flag & ((uint8_t)IT_FLAG)) != ((uint8_t)RESET))
000050  461d              MOV      r5,r3
000052  4025              ANDS     r5,r5,r4
000054  2d00              CMP      r5,#0
000056  d001              BEQ      |L18.92|
;;;606        {
;;;607          bitstatus = SET;
000058  2001              MOVS     r0,#1
00005a  e000              B        |L18.94|
                  |L18.92|
;;;608        }
;;;609        else
;;;610        {
;;;611          bitstatus = RESET;
00005c  2000              MOVS     r0,#0
                  |L18.94|
;;;612        }
;;;613    
;;;614        return bitstatus;
;;;615    }
00005e  bd70              POP      {r4-r6,pc}
;;;616    
                          ENDP

                  |L18.96|
                          DCD      0x40005c00

                          AREA ||i.USB_HID_Class_Req||, CODE, READONLY, ALIGN=2

                  USB_HID_Class_Req PROC
;;;842    */
;;;843    void USB_HID_Class_Req(PM_EP0_STATUS pep0state,PCOMMAND pcmd)
000000  b570              PUSH     {r4-r6,lr}
;;;844    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;845    	switch(pcmd->bRequest)
000006  7860              LDRB     r0,[r4,#1]
000008  0003              MOVS     r3,r0
00000a  f7fffffe          BL       __ARM_common_switch8
00000e  0c25              DCB      0x0c,0x25
000010  070c1125          DCB      0x07,0x0c,0x11,0x25
000014  25252525          DCB      0x25,0x25,0x25,0x25
000018  161b2025          DCB      0x16,0x1b,0x20,0x25
;;;846    	{
;;;847    		case	HID_REQUEST_GET_REPORT:
;;;848    		{
;;;849    			HID_GetReportEvent(pep0state,pcmd);
00001c  4621              MOV      r1,r4
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       HID_GetReportEvent
                  |L19.36|
;;;850    			return;
;;;851    		}
;;;852    		case	HID_REQUEST_GET_IDLE:
;;;853    		{
;;;854    			HID_GetIdleEvent(pep0state,pcmd);
;;;855    			return;
;;;856    		}
;;;857    		case	HID_REQUEST_GET_PROTOCOL:
;;;858    		{
;;;859    			HID_GetProtocolEvent(pep0state,pcmd);
;;;860    			return;
;;;861    		}
;;;862    		case	HID_REQUEST_SET_REPORT:
;;;863    		{
;;;864    			HID_SetReportEvent(pep0state,pcmd);
;;;865    			return;
;;;866    		}
;;;867    		case	HID_REQUEST_SET_IDLE:
;;;868    		{
;;;869    			HID_SetIdleEvent(pep0state,pcmd);
;;;870    			return;
;;;871    		}
;;;872    		case	HID_REQUEST_SET_PROTOCOL:
;;;873    		{
;;;874    			HID_SetProtocolEvent(pep0state,pcmd);
;;;875    			return;
;;;876    		}
;;;877    		default:
;;;878    		{
;;;879    			break;
;;;880    		}
;;;881    	}
;;;882    	MWRITE_BYTE(M_REG_CSR0, M_CSR0_SVDOUTPKTRDY | M_CSR0_SENDSTALL);
;;;883    }
000024  bd70              POP      {r4-r6,pc}
000026  4621              MOV      r1,r4                 ;854
000028  4628              MOV      r0,r5                 ;854
00002a  f7fffffe          BL       HID_GetIdleEvent
00002e  e7f9              B        |L19.36|
000030  4621              MOV      r1,r4                 ;859
000032  4628              MOV      r0,r5                 ;859
000034  f7fffffe          BL       HID_GetProtocolEvent
000038  e7f4              B        |L19.36|
00003a  4621              MOV      r1,r4                 ;864
00003c  4628              MOV      r0,r5                 ;864
00003e  f7fffffe          BL       HID_SetReportEvent
000042  e7ef              B        |L19.36|
000044  4621              MOV      r1,r4                 ;869
000046  4628              MOV      r0,r5                 ;869
000048  f7fffffe          BL       HID_SetIdleEvent
00004c  e7ea              B        |L19.36|
00004e  4621              MOV      r1,r4                 ;874
000050  4628              MOV      r0,r5                 ;874
000052  f7fffffe          BL       HID_SetProtocolEvent
000056  e7e5              B        |L19.36|
000058  bf00              NOP                            ;879
00005a  bf00              NOP                            ;879
00005c  2060              MOVS     r0,#0x60              ;882
00005e  4902              LDR      r1,|L19.104|
000060  7448              STRB     r0,[r1,#0x11]         ;882
000062  bf00              NOP      
000064  e7de              B        |L19.36|
;;;884    /******************************************************************************
                          ENDP

000066  0000              DCW      0x0000
                  |L19.104|
                          DCD      0x40005c00

                          AREA ||i.USB_IRQHandler||, CODE, READONLY, ALIGN=2

                  USB_IRQHandler PROC
;;;120    */
;;;121    void USB_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;122    {
;;;123    	uint8_t usb_intrin = 0,usb_intrusb = 0,usb_introut = 0;
000002  2500              MOVS     r5,#0
000004  2400              MOVS     r4,#0
000006  2600              MOVS     r6,#0
;;;124    	
;;;125    	usb_intrin  = USB->INTRIN;									//端点中断标志
000008  481b              LDR      r0,|L20.120|
00000a  7885              LDRB     r5,[r0,#2]
;;;126    	usb_intrusb = USB->INTRUSB;									//USB中断标志RESET、RESUME、SUSPEND、SOF
00000c  7984              LDRB     r4,[r0,#6]
;;;127    	usb_introut = USB->INTROUT;
00000e  7906              LDRB     r6,[r0,#4]
;;;128    	
;;;129    	
;;;130    	
;;;131    	
;;;132    	/*Check for resume from suspend mode, Add call to resume routine here */
;;;133    	if((usb_intrusb & 0x02) != RESET)							//RESUME
000010  2002              MOVS     r0,#2
000012  4020              ANDS     r0,r0,r4
000014  2800              CMP      r0,#0
000016  d002              BEQ      |L20.30|
;;;134    	{
;;;135    		usb_state = USB_RESUME_FLAG;
000018  2002              MOVS     r0,#2
00001a  4918              LDR      r1,|L20.124|
00001c  7008              STRB     r0,[r1,#0]
                  |L20.30|
;;;136    	}
;;;137    
;;;138    	if(usb_intrusb & USB_IT_USB_SOF_FLAG)						//SOF
00001e  2081              MOVS     r0,#0x81
000020  00c0              LSLS     r0,r0,#3
000022  4020              ANDS     r0,r0,r4
000024  2800              CMP      r0,#0
000026  d00c              BEQ      |L20.66|
;;;139    	{
;;;140    		USB->INTRUSB &= ~0x08;									//sof
000028  4813              LDR      r0,|L20.120|
00002a  7980              LDRB     r0,[r0,#6]
00002c  2108              MOVS     r1,#8
00002e  4388              BICS     r0,r0,r1
000030  4911              LDR      r1,|L20.120|
000032  7188              STRB     r0,[r1,#6]
;;;141    		f_sof_flag = 1;
000034  4812              LDR      r0,|L20.128|
000036  7800              LDRB     r0,[r0,#0]  ; flag1
000038  2110              MOVS     r1,#0x10
00003a  4388              BICS     r0,r0,r1
00003c  3010              ADDS     r0,r0,#0x10
00003e  4910              LDR      r1,|L20.128|
000040  7008              STRB     r0,[r1,#0]
                  |L20.66|
;;;142    	}
;;;143    	/* Check for system interrupts */
;;;144    	if((usb_intrusb &USB_IT_USB_RESET_FLAG) != RESET)
000042  4810              LDR      r0,|L20.132|
000044  4020              ANDS     r0,r0,r4
000046  2800              CMP      r0,#0
000048  d001              BEQ      |L20.78|
;;;145    	{
;;;146    		USB_Reset();
00004a  f7fffffe          BL       USB_Reset
                  |L20.78|
;;;147    	}
;;;148    
;;;149    	/* Check for endpoint 0 interrupt */
;;;150    	if((usb_intrin & USB_IT_IN_EP0_FLAG) != RESET)
00004e  20ff              MOVS     r0,#0xff
000050  3002              ADDS     r0,#2
000052  4028              ANDS     r0,r0,r5
000054  2800              CMP      r0,#0
000056  d002              BEQ      |L20.94|
;;;151    	{
;;;152    		USB_Endpoint0(M_EP_NORMAL);
000058  2000              MOVS     r0,#0
00005a  f7fffffe          BL       USB_Endpoint0
                  |L20.94|
;;;153    	}
;;;154    	
;;;155    	/* Check for endpoint 5 interrupt */
;;;156    	if((usb_introut & USB_IT_OUT_EP5_FLAG) != RESET)
;;;157    	{
;;;158    		//USB_EP_Rx(ep_hid_vendor_rx, Vendor_data_Buffer, M_EP_MAXP);
;;;159    		
;;;160    		#ifdef _debug_
;;;161    		//Vendor_data_Buffer[0]++;
;;;162    		//USB_Transmit_VendorData((uint8_t*)&send, M_EP_MAXP);
;;;163    		#endif
;;;164    	}
;;;165    	
;;;166    
;;;167    	
;;;168    	/* Check for endpoint 7 interrupt */
;;;169    	if((usb_introut & USB_IT_OUT_EP7_FLAG) != RESET)
;;;170    	{	
;;;171    //		USB_EP_Rx(7, Vendor_data_Buffer, M_EP_MAXP);
;;;172    //		
;;;173    //		#ifdef _debug_
;;;174    //		Vendor_data_Buffer[0]++;
;;;175    //		USB_EP_Tx(6, Vendor_data_Buffer, M_EP_MAXP);
;;;176    //		#endif
;;;177    	}
;;;178    	
;;;179    
;;;180    	
;;;181    
;;;182    	/* Check for suspend mode */
;;;183    	/* Add call to suspend routine here*/
;;;184    	if((usb_intrusb & 0x01) != RESET)
00005e  07e0              LSLS     r0,r4,#31
000060  0fc0              LSRS     r0,r0,#31
000062  2800              CMP      r0,#0
000064  d006              BEQ      |L20.116|
;;;185    	{
;;;186    		if(gnDevState > DEVSTATE_ADDRESS)
000066  4808              LDR      r0,|L20.136|
000068  6800              LDR      r0,[r0,#0]  ; gnDevState
00006a  2801              CMP      r0,#1
00006c  d902              BLS      |L20.116|
;;;187    		{
;;;188    			usb_state = USB_SUSPEND_FLAG;						//usb suspend
00006e  2001              MOVS     r0,#1
000070  4902              LDR      r1,|L20.124|
000072  7008              STRB     r0,[r1,#0]
                  |L20.116|
;;;189    		}
;;;190    	}
;;;191    }
000074  bd70              POP      {r4-r6,pc}
;;;192    /******************************************************************************
                          ENDP

000076  0000              DCW      0x0000
                  |L20.120|
                          DCD      0x40005c00
                  |L20.124|
                          DCD      usb_state
                  |L20.128|
                          DCD      flag1
                  |L20.132|
                          DCD      0x00000404
                  |L20.136|
                          DCD      gnDevState

                          AREA ||i.USB_ITConfig||, CODE, READONLY, ALIGN=2

                  USB_ITConfig PROC
;;;538    */
;;;539    void USB_ITConfig(uint32_t USB_IT, FunctionalState NewState)
000000  b530              PUSH     {r4,r5,lr}
;;;540    {
000002  460a              MOV      r2,r1
;;;541        __IO uint8_t *tmp = (__IO uint8_t *)USB_BASE;
000004  4916              LDR      r1,|L21.96|
;;;542        uint32_t IT_FLAG = 0;
000006  2300              MOVS     r3,#0
;;;543    
;;;544        assert_param(IS_USB_CONFIG_IT(USB_IT));
;;;545        assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;546    
;;;547        if(USB_IT & 0x00000100)
000008  158c              ASRS     r4,r1,#22
00000a  4004              ANDS     r4,r4,r0
00000c  2c00              CMP      r4,#0
00000e  d005              BEQ      |L21.28|
;;;548        {
;;;549          tmp = &USB->INTRINE;
000010  1dc9              ADDS     r1,r1,#7
;;;550          IT_FLAG = USB_IT & 0xfffffeff;
000012  158d              ASRS     r5,r1,#22
000014  4604              MOV      r4,r0
000016  43ac              BICS     r4,r4,r5
000018  4623              MOV      r3,r4
00001a  e016              B        |L21.74|
                  |L21.28|
;;;551        }
;;;552        else if(USB_IT & 0x00000200)
00001c  2401              MOVS     r4,#1
00001e  0264              LSLS     r4,r4,#9
000020  4004              ANDS     r4,r4,r0
000022  2c00              CMP      r4,#0
000024  d006              BEQ      |L21.52|
;;;553        {
;;;554          tmp = &USB->INTROUTE;
000026  490e              LDR      r1,|L21.96|
000028  3109              ADDS     r1,r1,#9
;;;555          IT_FLAG = USB_IT & 0xfffffdff;
00002a  154d              ASRS     r5,r1,#21
00002c  4604              MOV      r4,r0
00002e  43ac              BICS     r4,r4,r5
000030  4623              MOV      r3,r4
000032  e00a              B        |L21.74|
                  |L21.52|
;;;556        }
;;;557        else if(USB_IT & 0x00000400)
000034  2401              MOVS     r4,#1
000036  02a4              LSLS     r4,r4,#10
000038  4004              ANDS     r4,r4,r0
00003a  2c00              CMP      r4,#0
00003c  d005              BEQ      |L21.74|
;;;558        {
;;;559          tmp = &USB->INTRUSBE;
00003e  4908              LDR      r1,|L21.96|
000040  310b              ADDS     r1,r1,#0xb
;;;560          IT_FLAG = USB_IT & 0xfffffbff;
000042  150d              ASRS     r5,r1,#20
000044  4604              MOV      r4,r0
000046  43ac              BICS     r4,r4,r5
000048  4623              MOV      r3,r4
                  |L21.74|
;;;561        }
;;;562    
;;;563        if(NewState != DISABLE)
00004a  2a00              CMP      r2,#0
00004c  d004              BEQ      |L21.88|
;;;564        {
;;;565          *((__IO uint8_t *)tmp) |= (uint8_t)IT_FLAG;
00004e  780c              LDRB     r4,[r1,#0]
000050  b2dd              UXTB     r5,r3
000052  432c              ORRS     r4,r4,r5
000054  700c              STRB     r4,[r1,#0]
000056  e002              B        |L21.94|
                  |L21.88|
;;;566        }
;;;567        else
;;;568        {
;;;569          *((__IO uint8_t *)tmp) &= ~((uint8_t)IT_FLAG);
000058  780c              LDRB     r4,[r1,#0]
00005a  439c              BICS     r4,r4,r3
00005c  700c              STRB     r4,[r1,#0]
                  |L21.94|
;;;570        }
;;;571    }
00005e  bd30              POP      {r4,r5,pc}
;;;572    /******************************************************************************
                          ENDP

                  |L21.96|
                          DCD      0x40005c00

                          AREA ||i.USB_Init||, CODE, READONLY, ALIGN=2

                  USB_Init PROC
;;;83     */
;;;84     void USB_Init(void)
000000  b508              PUSH     {r3,lr}
;;;85     {
;;;86     	NVIC_InitTypeDef NVIC_InitStructure;
;;;87     
;;;88     	if(RCC_GetFlagStatus(RCC_FLAG_HSI48RDY) != SET)
000002  2071              MOVS     r0,#0x71
000004  f7fffffe          BL       RCC_GetFlagStatus
000008  2801              CMP      r0,#1
00000a  d008              BEQ      |L22.30|
;;;89     	{
;;;90     		RCC_HSI48Cmd(ENABLE);
00000c  2001              MOVS     r0,#1
00000e  f7fffffe          BL       RCC_HSI48Cmd
;;;91     		while(RCC_GetFlagStatus(RCC_FLAG_HSI48RDY) != SET);
000012  bf00              NOP      
                  |L22.20|
000014  2071              MOVS     r0,#0x71
000016  f7fffffe          BL       RCC_GetFlagStatus
00001a  2801              CMP      r0,#1
00001c  d1fa              BNE      |L22.20|
                  |L22.30|
;;;92     	}
;;;93     	RCC_USBCLKConfig(RCC_USBCLK_HSI48);
00001e  2000              MOVS     r0,#0
000020  f7fffffe          BL       RCC_USBCLKConfig
;;;94     	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USB,ENABLE);
000024  2101              MOVS     r1,#1
000026  05c8              LSLS     r0,r1,#23
000028  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;95     
;;;96     		
;;;97     	USB_ITConfig(USB_IT_USB_RESUME_FLAG,ENABLE);
00002c  2101              MOVS     r1,#1
00002e  4814              LDR      r0,|L22.128|
000030  f7fffffe          BL       USB_ITConfig
;;;98     	USB_ITConfig(USB_IT_USB_SUSPEND_FLAG,ENABLE);
000034  2101              MOVS     r1,#1
000036  4812              LDR      r0,|L22.128|
000038  1e40              SUBS     r0,r0,#1
00003a  f7fffffe          BL       USB_ITConfig
;;;99     	USB_ITConfig(USB_IT_USB_SOF_FLAG,ENABLE);
00003e  2101              MOVS     r1,#1
000040  2081              MOVS     r0,#0x81
000042  00c0              LSLS     r0,r0,#3
000044  f7fffffe          BL       USB_ITConfig
;;;100    	USB_ITConfig(USB_IT_USB_RESET_FLAG,ENABLE);
000048  2101              MOVS     r1,#1
00004a  480d              LDR      r0,|L22.128|
00004c  1c80              ADDS     r0,r0,#2
00004e  f7fffffe          BL       USB_ITConfig
;;;101    		
;;;102    	USB_PDCTRLConfig(USB_PDCTRL_PU_ENABLE);
000052  2001              MOVS     r0,#1
000054  f7fffffe          BL       USB_PDCTRLConfig
;;;103    
;;;104    	NVIC_InitStructure.NVIC_IRQChannel = USB_IRQn;
000058  211f              MOVS     r1,#0x1f
00005a  4668              MOV      r0,sp
00005c  7001              STRB     r1,[r0,#0]
;;;105    	NVIC_InitStructure.NVIC_IRQChannelPriority = 0;
00005e  2100              MOVS     r1,#0
000060  7041              STRB     r1,[r0,#1]
;;;106    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000062  2101              MOVS     r1,#1
000064  7081              STRB     r1,[r0,#2]
;;;107    	NVIC_Init(&NVIC_InitStructure);
000066  f7fffffe          BL       NVIC_Init
;;;108    
;;;109    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_CRS,ENABLE);
00006a  2101              MOVS     r1,#1
00006c  06c8              LSLS     r0,r1,#27
00006e  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;110    	CRS_FrequencyErrorCounterCmd(ENABLE);
000072  2001              MOVS     r0,#1
000074  f7fffffe          BL       CRS_FrequencyErrorCounterCmd
;;;111    	CRS_AutomaticCalibrationCmd(ENABLE);
000078  2001              MOVS     r0,#1
00007a  f7fffffe          BL       CRS_AutomaticCalibrationCmd
;;;112    }
00007e  bd08              POP      {r3,pc}
;;;113    
                          ENDP

                  |L22.128|
                          DCD      0x00000402

                          AREA ||i.USB_PDCTRLConfig||, CODE, READONLY, ALIGN=2

                  USB_PDCTRLConfig PROC
;;;462    */
;;;463    void USB_PDCTRLConfig(uint8_t PDCT)
000000  4601              MOV      r1,r0
;;;464    {
;;;465        uint8_t temp = 0;
000002  2000              MOVS     r0,#0
;;;466    
;;;467        assert_param(IS_USB_PDCTRL(PDCT));
;;;468    
;;;469        temp = USB->PDCTRL;
000004  4a04              LDR      r2,|L23.24|
000006  7bd0              LDRB     r0,[r2,#0xf]
;;;470        temp &= ~USB_PDCTRL_FLAG;
000008  0880              LSRS     r0,r0,#2
00000a  0080              LSLS     r0,r0,#2
;;;471        temp |= PDCT;
00000c  4602              MOV      r2,r0
00000e  430a              ORRS     r2,r2,r1
000010  4610              MOV      r0,r2
;;;472        USB->PDCTRL = temp;
000012  4a01              LDR      r2,|L23.24|
000014  73d0              STRB     r0,[r2,#0xf]
;;;473    
;;;474    }
000016  4770              BX       lr
;;;475    /******************************************************************************
                          ENDP

                  |L23.24|
                          DCD      0x40005c00

                          AREA ||i.USB_ReadRegister||, CODE, READONLY, ALIGN=2

                  USB_ReadRegister PROC
;;;442    */
;;;443    uint8_t USB_ReadRegister(uint8_t USB_Refister)
000000  b508              PUSH     {r3,lr}
;;;444    {
000002  4601              MOV      r1,r0
;;;445        __IO uint32_t tmp = 0;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;446    
;;;447        /* Check the parameters */
;;;448        assert_param(IS_USB_REGISTER(USB_Refister));
;;;449    
;;;450        tmp = (uint32_t)USB;
000008  4803              LDR      r0,|L24.24|
00000a  9000              STR      r0,[sp,#0]
;;;451        tmp += USB_Refister;
00000c  9800              LDR      r0,[sp,#0]
00000e  1840              ADDS     r0,r0,r1
000010  9000              STR      r0,[sp,#0]
;;;452    
;;;453        /* Return the selected register value */
;;;454        return (*(__IO uint8_t *) tmp);	
000012  9800              LDR      r0,[sp,#0]
000014  7800              LDRB     r0,[r0,#0]
;;;455    }
000016  bd08              POP      {r3,pc}
;;;456    /******************************************************************************
                          ENDP

                  |L24.24|
                          DCD      0x40005c00

                          AREA ||i.USB_Remote_Wakeup||, CODE, READONLY, ALIGN=2

                  USB_Remote_Wakeup PROC
;;;295    */
;;;296    void USB_Remote_Wakeup(void)
000000  4806              LDR      r0,|L25.28|
;;;297    {
;;;298    	USB->POWER |= 0x04;
000002  7840              LDRB     r0,[r0,#1]
000004  2104              MOVS     r1,#4
000006  4308              ORRS     r0,r0,r1
000008  4904              LDR      r1,|L25.28|
00000a  7048              STRB     r0,[r1,#1]
;;;299    //	SysTick_Delay_Ms(12);
;;;300    	USB->POWER &= ~0x04;	
00000c  4608              MOV      r0,r1
00000e  7840              LDRB     r0,[r0,#1]
000010  2104              MOVS     r1,#4
000012  4388              BICS     r0,r0,r1
000014  4901              LDR      r1,|L25.28|
000016  7048              STRB     r0,[r1,#1]
;;;301    
;;;302    	
;;;303    }
000018  4770              BX       lr
;;;304    
                          ENDP

00001a  0000              DCW      0x0000
                  |L25.28|
                          DCD      0x40005c00

                          AREA ||i.USB_Reset||, CODE, READONLY, ALIGN=2

                  USB_Reset PROC
;;;239    */
;;;240    void USB_Reset(void)
000000  b500              PUSH     {lr}
;;;241    {
000002  b089              SUB      sp,sp,#0x24
;;;242    	M_EPBIN_STATUS  tEpin;
;;;243    	M_EPBOUT_STATUS tEpout;
;;;244    	
;;;245    	/* Set device into default state */
;;;246    	gnDevState = DEVSTATE_DEFAULT;
000004  2000              MOVS     r0,#0
000006  492c              LDR      r1,|L26.184|
000008  6008              STR      r0,[r1,#0]  ; gnDevState
;;;247    //    pInformation->Current_Feature = USB_FSConfigDescriptor[7];
;;;248    	/* Reset any state machines for each endpoint */
;;;249    	/* This example assumes 2 bulk IN endpoints with endpoint numbers 1,2, */
;;;250    	/* and 2 bulk out endpoints with endpoint numbers 1,2 */
;;;251    	USB_Endpoint0(M_EP_RESET);
00000a  2001              MOVS     r0,#1
00000c  f7fffffe          BL       USB_Endpoint0
;;;252    
;;;253    	/* Initialise endpoint status structures with endpoint numbers */
;;;254    
;;;255    	tEpin.byEP = 1;
000010  2101              MOVS     r1,#1
000012  a808              ADD      r0,sp,#0x20
000014  7001              STRB     r1,[r0,#0]
;;;256    	tEpin.nBytesLeft = M_EP_NODATA;
000016  1e88              SUBS     r0,r1,#2
000018  9007              STR      r0,[sp,#0x1c]
;;;257    	EndpointBulkIn(tEpin, M_EP_RESET);
00001a  2301              MOVS     r3,#1
00001c  a806              ADD      r0,sp,#0x18
00001e  c807              LDM      r0,{r0-r2}
000020  f7fffffe          BL       EndpointBulkIn
;;;258    	
;;;259    	tEpin.byEP = 2;
000024  2102              MOVS     r1,#2
000026  a808              ADD      r0,sp,#0x20
000028  7001              STRB     r1,[r0,#0]
;;;260    	tEpin.nBytesLeft = M_EP_NODATA;
00002a  1ec8              SUBS     r0,r1,#3
00002c  9007              STR      r0,[sp,#0x1c]
;;;261    	EndpointBulkIn(tEpin, M_EP_RESET);
00002e  2301              MOVS     r3,#1
000030  a806              ADD      r0,sp,#0x18
000032  c807              LDM      r0,{r0-r2}
000034  f7fffffe          BL       EndpointBulkIn
;;;262    	
;;;263    	tEpin.byEP = 3;
000038  2103              MOVS     r1,#3
00003a  a808              ADD      r0,sp,#0x20
00003c  7001              STRB     r1,[r0,#0]
;;;264    	tEpin.nBytesLeft = M_EP_NODATA;
00003e  1f08              SUBS     r0,r1,#4
000040  9007              STR      r0,[sp,#0x1c]
;;;265    	EndpointBulkIn(tEpin, M_EP_RESET);
000042  2301              MOVS     r3,#1
000044  a806              ADD      r0,sp,#0x18
000046  c807              LDM      r0,{r0-r2}
000048  f7fffffe          BL       EndpointBulkIn
;;;266    	
;;;267    	tEpin.byEP = 4;
00004c  2104              MOVS     r1,#4
00004e  a808              ADD      r0,sp,#0x20
000050  7001              STRB     r1,[r0,#0]
;;;268    	tEpin.nBytesLeft = M_EP_NODATA;
000052  1f48              SUBS     r0,r1,#5
000054  9007              STR      r0,[sp,#0x1c]
;;;269    	EndpointBulkIn(tEpin, M_EP_RESET);
000056  2301              MOVS     r3,#1
000058  a806              ADD      r0,sp,#0x18
00005a  c807              LDM      r0,{r0-r2}
00005c  f7fffffe          BL       EndpointBulkIn
;;;270    	
;;;271    	tEpin.byEP = 6;
000060  2106              MOVS     r1,#6
000062  a808              ADD      r0,sp,#0x20
000064  7001              STRB     r1,[r0,#0]
;;;272    	tEpin.nBytesLeft = M_EP_NODATA;
000066  1fc8              SUBS     r0,r1,#7
000068  9007              STR      r0,[sp,#0x1c]
;;;273    	EndpointBulkIn(tEpin, M_EP_RESET);
00006a  2301              MOVS     r3,#1
00006c  a806              ADD      r0,sp,#0x18
00006e  c807              LDM      r0,{r0-r2}
000070  f7fffffe          BL       EndpointBulkIn
;;;274    	
;;;275    	//--------------------------------------//
;;;276    	
;;;277    	tEpout.byEP = 5;
000074  2105              MOVS     r1,#5
000076  4668              MOV      r0,sp
000078  7501              STRB     r1,[r0,#0x14]
;;;278    	tEpout.nBuffLen = M_EP_MAXP;
00007a  2040              MOVS     r0,#0x40
00007c  9003              STR      r0,[sp,#0xc]
;;;279    	tEpout.nBytesRecv = 0;
00007e  2000              MOVS     r0,#0
000080  9004              STR      r0,[sp,#0x10]
;;;280    	EndpointBulkOut(tEpout, M_EP_RESET);
000082  2001              MOVS     r0,#1
000084  9000              STR      r0,[sp,#0]
000086  a802              ADD      r0,sp,#8
000088  c80f              LDM      r0,{r0-r3}
00008a  f7fffffe          BL       EndpointBulkOut
;;;281    	
;;;282    	tEpout.byEP = 7;
00008e  2107              MOVS     r1,#7
000090  4668              MOV      r0,sp
000092  7501              STRB     r1,[r0,#0x14]
;;;283    	tEpout.nBuffLen = M_EP_MAXP;
000094  2040              MOVS     r0,#0x40
000096  9003              STR      r0,[sp,#0xc]
;;;284    	tEpout.nBytesRecv = 0;
000098  2000              MOVS     r0,#0
00009a  9004              STR      r0,[sp,#0x10]
;;;285    	EndpointBulkOut(tEpout, M_EP_RESET);
00009c  2001              MOVS     r0,#1
00009e  9000              STR      r0,[sp,#0]
0000a0  a802              ADD      r0,sp,#8
0000a2  c80f              LDM      r0,{r0-r3}
0000a4  f7fffffe          BL       EndpointBulkOut
;;;286    	
;;;287    	USB->POWER |= 0x01;												//允许挂起模块
0000a8  4804              LDR      r0,|L26.188|
0000aa  7840              LDRB     r0,[r0,#1]
0000ac  2101              MOVS     r1,#1
0000ae  4308              ORRS     r0,r0,r1
0000b0  4902              LDR      r1,|L26.188|
0000b2  7048              STRB     r0,[r1,#1]
;;;288    }
0000b4  b009              ADD      sp,sp,#0x24
0000b6  bd00              POP      {pc}
;;;289    /******************************************************************************
                          ENDP

                  |L26.184|
                          DCD      gnDevState
                  |L26.188|
                          DCD      0x40005c00

                          AREA ||i.USB_StdDev_Req||, CODE, READONLY, ALIGN=2

                  USB_StdDev_Req PROC
;;;932    */
;;;933    static void USB_StdDev_Req(PM_EP0_STATUS pep0state, PCOMMAND pcmd)
000000  b5f0              PUSH     {r4-r7,lr}
;;;934    {
000002  b089              SUB      sp,sp,#0x24
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;935    	int	bError = FALSE, bNoData = FALSE, n;
000008  2000              MOVS     r0,#0
00000a  9008              STR      r0,[sp,#0x20]
00000c  9007              STR      r0,[sp,#0x1c]
;;;936    	BYTE	by;
;;;937    	BYTE	byConfig;
;;;938    	PSTD_CFG_DSCR	pcfg;	
;;;939    	
;;;940    	uint8_t Related_Endpoint;
;;;941    	uint8_t wIndex0 = pcmd->USBwIndex0;
00000e  7928              LDRB     r0,[r5,#4]
000010  9002              STR      r0,[sp,#8]
;;;942    	Related_Endpoint = (wIndex0 & 0x0f);		
000012  9802              LDR      r0,[sp,#8]
000014  0700              LSLS     r0,r0,#28
000016  0f00              LSRS     r0,r0,#28
000018  9003              STR      r0,[sp,#0xc]
;;;943    	uint8_t srbuff;
;;;944    	uint8_t txdat[2] = {0};
00001a  2000              MOVS     r0,#0
00001c  9001              STR      r0,[sp,#4]
;;;945    	
;;;946    	switch(pcmd->bRequest) 
00001e  7868              LDRB     r0,[r5,#1]
000020  280c              CMP      r0,#0xc
000022  d270              BCS      |L27.262|
000024  0043              LSLS     r3,r0,#1
000026  447b              ADD      r3,r3,pc
000028  889b              LDRH     r3,[r3,#4]
00002a  005b              LSLS     r3,r3,#1
00002c  449f              ADD      pc,pc,r3
00002e  03b2              DCW      0x03b2
000030  0338006b          DCW      0x0338,0x006b
000034  02d3006b          DCW      0x02d3,0x006b
000038  000b0020          DCW      0x000b,0x0020
00003c  006b027b          DCW      0x006b,0x027b
000040  01f002ac          DCW      0x01f0,0x02ac
000044  0253              DCW      0x0253
;;;947    	{
;;;948    		/***用来给设备分配地址***/
;;;949    		case SET_ADDRESS:
;;;950    			/* Store device function address until status stage of request */
;;;951    			if (pcmd->bmRequestType != M_CMD_STDDEVOUT)
000046  7828              LDRB     r0,[r5,#0]
000048  2800              CMP      r0,#0
00004a  d002              BEQ      |L27.82|
;;;952    			{
;;;953    				bError = TRUE;
00004c  2001              MOVS     r0,#1
00004e  9008              STR      r0,[sp,#0x20]
000050  e00d              B        |L27.110|
                  |L27.82|
;;;954    			}
;;;955    			else if (gnDevState <= DEVSTATE_ADDRESS) 
000052  48fb              LDR      r0,|L27.1088|
000054  6800              LDR      r0,[r0,#0]  ; gnDevState
000056  2801              CMP      r0,#1
000058  d807              BHI      |L27.106|
;;;956    			{
;;;957    				pep0state->byFAddr = (BYTE)pcmd->USBwValue;
00005a  78e8              LDRB     r0,[r5,#3]
00005c  78a9              LDRB     r1,[r5,#2]
00005e  0200              LSLS     r0,r0,#8
000060  4308              ORRS     r0,r0,r1
000062  7420              STRB     r0,[r4,#0x10]
;;;958    				bNoData = TRUE;
000064  2001              MOVS     r0,#1
000066  9007              STR      r0,[sp,#0x1c]
000068  e001              B        |L27.110|
                  |L27.106|
;;;959    			}
;;;960    			else
;;;961    			{
;;;962    				bError = TRUE;
00006a  2001              MOVS     r0,#1
00006c  9008              STR      r0,[sp,#0x20]
                  |L27.110|
;;;963    			}
;;;964    			break;
00006e  e231              B        |L27.1236|
;;;965    			
;;;966    		/***用于主机获取设备的特定描述符***/		
;;;967    		case GET_DESCRIPTOR:
;;;968    			/* Decode the required descriptor from the command */
;;;969    			/***报告描述符的接受者是接口，pcmd->bmRequestType = 0x81时传输HID报告描述符***/
;;;970    			if(!(pcmd->bmRequestType & M_CMD_STDDEVIN))
000070  7828              LDRB     r0,[r5,#0]
000072  2180              MOVS     r1,#0x80
000074  4008              ANDS     r0,r0,r1
000076  2800              CMP      r0,#0
000078  d102              BNE      |L27.128|
;;;971    			{
;;;972    				bError = TRUE;
00007a  2001              MOVS     r0,#1
00007c  9008              STR      r0,[sp,#0x20]
00007e  e1c6              B        |L27.1038|
                  |L27.128|
;;;973    			}
;;;974    			else 
;;;975    			{
;;;976    				switch(pcmd->USBwValue & M_CMD_DESCMASK) 
000080  78e8              LDRB     r0,[r5,#3]
000082  78a9              LDRB     r1,[r5,#2]
000084  0200              LSLS     r0,r0,#8
000086  4308              ORRS     r0,r0,r1
000088  21ff              MOVS     r1,#0xff
00008a  0209              LSLS     r1,r1,#8
00008c  4008              ANDS     r0,r0,r1
00008e  2203              MOVS     r2,#3
000090  0252              LSLS     r2,r2,#9
000092  1a81              SUBS     r1,r0,r2
000094  4290              CMP      r0,r2
000096  d037              BEQ      |L27.264|
000098  dc0c              BGT      |L27.180|
00009a  38ff              SUBS     r0,r0,#0xff
00009c  3801              SUBS     r0,#1
00009e  2800              CMP      r0,#0
0000a0  d011              BEQ      |L27.198|
0000a2  38ff              SUBS     r0,r0,#0xff
0000a4  3801              SUBS     r0,#1
0000a6  2800              CMP      r0,#0
0000a8  d031              BEQ      |L27.270|
0000aa  38ff              SUBS     r0,r0,#0xff
0000ac  3801              SUBS     r0,#1
0000ae  2800              CMP      r0,#0
                  |L27.176|
0000b0  d17e              BNE      |L27.432|
0000b2  e112              B        |L27.730|
                  |L27.180|
0000b4  39ff              SUBS     r1,r1,#0xff
0000b6  3901              SUBS     r1,#1
0000b8  2900              CMP      r1,#0
0000ba  d059              BEQ      |L27.368|
0000bc  201b              MOVS     r0,#0x1b
0000be  0200              LSLS     r0,r0,#8
0000c0  1a08              SUBS     r0,r1,r0
0000c2  d1f5              BNE      |L27.176|
0000c4  e057              B        |L27.374|
                  |L27.198|
;;;977    				{
;;;978    					/***设备描述符***/
;;;979    					case M_CMD_DEVICE:
;;;980    						/* Prepare to return Standard Device Descriptor */
;;;981    						pep0state->nBytesLeft = USB_FSDeviceDescriptorSize;
0000c6  1d21              ADDS     r1,r4,#4
0000c8  48de              LDR      r0,|L27.1092|
0000ca  8800              LDRH     r0,[r0,#0]  ; USB_FSDeviceDescriptorSize
0000cc  f7fffffe          BL       __aeabi_uwrite4
;;;982    						/* Check host is allowing a descriptor this long */
;;;983    						if(pcmd->USBwLength < pep0state->nBytesLeft)
0000d0  1d20              ADDS     r0,r4,#4
0000d2  f7fffffe          BL       __aeabi_uread4
0000d6  79e9              LDRB     r1,[r5,#7]
0000d8  79aa              LDRB     r2,[r5,#6]
0000da  0209              LSLS     r1,r1,#8
0000dc  4311              ORRS     r1,r1,r2
0000de  4288              CMP      r0,r1
0000e0  dd07              BLE      |L27.242|
;;;984    						{
;;;985    							pep0state->nBytesLeft = pcmd->USBwLength;
0000e2  79e9              LDRB     r1,[r5,#7]
0000e4  79aa              LDRB     r2,[r5,#6]
0000e6  0209              LSLS     r1,r1,#8
0000e8  4311              ORRS     r1,r1,r2
0000ea  4608              MOV      r0,r1
0000ec  1d21              ADDS     r1,r4,#4
0000ee  f7fffffe          BL       __aeabi_uwrite4
                  |L27.242|
;;;986    						}
;;;987    						
;;;988    						pep0state->pData = (void*)USB_FSDeviceDescriptor;
0000f2  4621              MOV      r1,r4
0000f4  3108              ADDS     r1,r1,#8
0000f6  48d4              LDR      r0,|L27.1096|
0000f8  f7fffffe          BL       __aeabi_uwrite4
;;;989    						pep0state->nState = M_EP0_TX;
0000fc  4621              MOV      r1,r4
0000fe  2002              MOVS     r0,#2
000100  f7fffffe          BL       __aeabi_uwrite4
;;;990    						break;
000104  e182              B        |L27.1036|
                  |L27.262|
000106  e3fd              B        |L27.2308|
                  |L27.264|
;;;991    					/***设备限定描述符***/	
;;;992    					case M_CMD_DEVQUAL:
;;;993    						/* No alternate speed supported */
;;;994    						bError = TRUE;
000108  2001              MOVS     r0,#1
00010a  9008              STR      r0,[sp,#0x20]
;;;995    						break;
00010c  e17e              B        |L27.1036|
                  |L27.270|
;;;996    					/***配置描述符***/					
;;;997    					case M_CMD_CONFIG:
;;;998    						byConfig = (BYTE)(pcmd->USBwValue & 0x00FF);
00010e  78e8              LDRB     r0,[r5,#3]
000110  78a9              LDRB     r1,[r5,#2]
000112  0200              LSLS     r0,r0,#8
000114  4308              ORRS     r0,r0,r1
000116  b2c0              UXTB     r0,r0
000118  9005              STR      r0,[sp,#0x14]
;;;999    						if(byConfig>USB_FSDeviceDescriptor[USB_FSDeviceDescriptorSize-1])
00011a  48ca              LDR      r0,|L27.1092|
00011c  8800              LDRH     r0,[r0,#0]  ; USB_FSDeviceDescriptorSize
00011e  1e40              SUBS     r0,r0,#1
000120  49c9              LDR      r1,|L27.1096|
000122  5c09              LDRB     r1,[r1,r0]
000124  9805              LDR      r0,[sp,#0x14]
000126  4281              CMP      r1,r0
000128  da02              BGE      |L27.304|
;;;1000   						{
;;;1001   							bError = TRUE;
00012a  2001              MOVS     r0,#1
00012c  9008              STR      r0,[sp,#0x20]
00012e  e01e              B        |L27.366|
                  |L27.304|
;;;1002   						}
;;;1003   						else
;;;1004   						{
;;;1005   							/* Get pointer to requested configuration descriptor */
;;;1006   							/* Prepare to return Configuration Descriptors */
;;;1007   							pep0state->nBytesLeft = USB_FSConfigDescriptorSize;
000130  1d21              ADDS     r1,r4,#4
000132  48c6              LDR      r0,|L27.1100|
000134  8800              LDRH     r0,[r0,#0]  ; USB_FSConfigDescriptorSize
000136  f7fffffe          BL       __aeabi_uwrite4
;;;1008   							pep0state->pData = (void*)USB_FSConfigDescriptor;
00013a  4621              MOV      r1,r4
00013c  3108              ADDS     r1,r1,#8
00013e  48c4              LDR      r0,|L27.1104|
000140  f7fffffe          BL       __aeabi_uwrite4
;;;1009   							pep0state->nState = M_EP0_TX;
000144  4621              MOV      r1,r4
000146  2002              MOVS     r0,#2
000148  f7fffffe          BL       __aeabi_uwrite4
;;;1010   							/* Check host is allowing a descriptor this long */
;;;1011   							if (pcmd->USBwLength < pep0state->nBytesLeft)
00014c  1d20              ADDS     r0,r4,#4
00014e  f7fffffe          BL       __aeabi_uread4
000152  79e9              LDRB     r1,[r5,#7]
000154  79aa              LDRB     r2,[r5,#6]
000156  0209              LSLS     r1,r1,#8
000158  4311              ORRS     r1,r1,r2
00015a  4288              CMP      r0,r1
00015c  dd07              BLE      |L27.366|
;;;1012   							{
;;;1013   								pep0state->nBytesLeft = pcmd->USBwLength;
00015e  79e9              LDRB     r1,[r5,#7]
000160  79aa              LDRB     r2,[r5,#6]
000162  0209              LSLS     r1,r1,#8
000164  4311              ORRS     r1,r1,r2
000166  4608              MOV      r0,r1
000168  1d21              ADDS     r1,r4,#4
00016a  f7fffffe          BL       __aeabi_uwrite4
                  |L27.366|
;;;1014   							}
;;;1015   						}
;;;1016   						break;
00016e  e14d              B        |L27.1036|
                  |L27.368|
;;;1017   					/***其它速度配置描述符***/						
;;;1018   					case M_CMD_OTHERSPEED:
;;;1019   						/* No alternate speed supported */
;;;1020   						bError = TRUE;
000170  2001              MOVS     r0,#1
000172  9008              STR      r0,[sp,#0x20]
;;;1021   						break;
000174  e14a              B        |L27.1036|
                  |L27.374|
;;;1022   					/***HID报告描述符***/
;;;1023   					case	M_CMD_HID_REPORT_DESC:		//报告描述符		0x2200
;;;1024   						/* Prepare to return Standard Device Descriptor */
;;;1025   						switch(pcmd->USBwIndex)
000176  7968              LDRB     r0,[r5,#5]
000178  7929              LDRB     r1,[r5,#4]
00017a  0200              LSLS     r0,r0,#8
00017c  4308              ORRS     r0,r0,r1
00017e  0003              MOVS     r3,r0
000180  f7fffffe          BL       __ARM_common_switch8
000184  05042646          DCB      0x05,0x04,0x26,0x46
000188  6686a600          DCB      0x66,0x86,0xa6,0x00
;;;1026   						{
;;;1027   							case	0:
;;;1028   								//接口0
;;;1029   								pep0state->nBytesLeft = USB_HID_FSReportDescriptor_1Size;		//报告描述符的长度
00018c  1d21              ADDS     r1,r4,#4
00018e  48b1              LDR      r0,|L27.1108|
000190  8800              LDRH     r0,[r0,#0]  ; USB_HID_FSReportDescriptor_1Size
000192  f7fffffe          BL       __aeabi_uwrite4
;;;1030   								/* Check host is allowing a descriptor this long */
;;;1031   								if (pcmd->USBwLength < pep0state->nBytesLeft)
000196  1d20              ADDS     r0,r4,#4
000198  f7fffffe          BL       __aeabi_uread4
00019c  79e9              LDRB     r1,[r5,#7]
00019e  79aa              LDRB     r2,[r5,#6]
0001a0  0209              LSLS     r1,r1,#8
0001a2  4311              ORRS     r1,r1,r2
0001a4  4288              CMP      r0,r1
0001a6  dd09              BLE      |L27.444|
;;;1032   								{
;;;1033   									pep0state->nBytesLeft = pcmd->USBwLength;
0001a8  79e9              LDRB     r1,[r5,#7]
0001aa  79aa              LDRB     r2,[r5,#6]
0001ac  0209              LSLS     r1,r1,#8
0001ae  e000              B        |L27.434|
                  |L27.432|
0001b0  e129              B        |L27.1030|
                  |L27.434|
0001b2  4311              ORRS     r1,r1,r2
0001b4  4608              MOV      r0,r1
0001b6  1d21              ADDS     r1,r4,#4
0001b8  f7fffffe          BL       __aeabi_uwrite4
                  |L27.444|
;;;1034   								}
;;;1035   								pep0state->pData = (void*)USB_HID_FSReportDescriptor_1;
0001bc  4621              MOV      r1,r4
0001be  3108              ADDS     r1,r1,#8
0001c0  48a5              LDR      r0,|L27.1112|
0001c2  f7fffffe          BL       __aeabi_uwrite4
;;;1036   								pep0state->nState = M_EP0_TX;
0001c6  4621              MOV      r1,r4
0001c8  2002              MOVS     r0,#2
0001ca  f7fffffe          BL       __aeabi_uwrite4
;;;1037   								break;
0001ce  e082              B        |L27.726|
;;;1038   							case	1:
;;;1039   								//接口1
;;;1040   								pep0state->nBytesLeft = USB_HID_FSReportDescriptor_2Size;		//报告描述符的长度
0001d0  1d21              ADDS     r1,r4,#4
0001d2  48a2              LDR      r0,|L27.1116|
0001d4  8800              LDRH     r0,[r0,#0]  ; USB_HID_FSReportDescriptor_2Size
0001d6  f7fffffe          BL       __aeabi_uwrite4
;;;1041   								/* Check host is allowing a descriptor this long */
;;;1042   								if (pcmd->USBwLength < pep0state->nBytesLeft)
0001da  1d20              ADDS     r0,r4,#4
0001dc  f7fffffe          BL       __aeabi_uread4
0001e0  79e9              LDRB     r1,[r5,#7]
0001e2  79aa              LDRB     r2,[r5,#6]
0001e4  0209              LSLS     r1,r1,#8
0001e6  4311              ORRS     r1,r1,r2
0001e8  4288              CMP      r0,r1
0001ea  dd07              BLE      |L27.508|
;;;1043   								{
;;;1044   									pep0state->nBytesLeft = pcmd->USBwLength;
0001ec  79e9              LDRB     r1,[r5,#7]
0001ee  79aa              LDRB     r2,[r5,#6]
0001f0  0209              LSLS     r1,r1,#8
0001f2  4311              ORRS     r1,r1,r2
0001f4  4608              MOV      r0,r1
0001f6  1d21              ADDS     r1,r4,#4
0001f8  f7fffffe          BL       __aeabi_uwrite4
                  |L27.508|
;;;1045   								}
;;;1046   								pep0state->pData = (void*)USB_HID_FSReportDescriptor_2;
0001fc  4621              MOV      r1,r4
0001fe  3108              ADDS     r1,r1,#8
000200  4897              LDR      r0,|L27.1120|
000202  f7fffffe          BL       __aeabi_uwrite4
;;;1047   								pep0state->nState = M_EP0_TX;
000206  4621              MOV      r1,r4
000208  2002              MOVS     r0,#2
00020a  f7fffffe          BL       __aeabi_uwrite4
;;;1048   								break;
00020e  e062              B        |L27.726|
;;;1049   							case	2:
;;;1050   								//接口2
;;;1051   								pep0state->nBytesLeft = USB_HID_FSReportDescriptor_3Size;		//报告描述符的长度
000210  1d21              ADDS     r1,r4,#4
000212  4894              LDR      r0,|L27.1124|
000214  8800              LDRH     r0,[r0,#0]  ; USB_HID_FSReportDescriptor_3Size
000216  f7fffffe          BL       __aeabi_uwrite4
;;;1052   								/* Check host is allowing a descriptor this long */
;;;1053   								if (pcmd->USBwLength < pep0state->nBytesLeft)
00021a  1d20              ADDS     r0,r4,#4
00021c  f7fffffe          BL       __aeabi_uread4
000220  79e9              LDRB     r1,[r5,#7]
000222  79aa              LDRB     r2,[r5,#6]
000224  0209              LSLS     r1,r1,#8
000226  4311              ORRS     r1,r1,r2
000228  4288              CMP      r0,r1
00022a  dd07              BLE      |L27.572|
;;;1054   								{
;;;1055   									pep0state->nBytesLeft = pcmd->USBwLength;
00022c  79e9              LDRB     r1,[r5,#7]
00022e  79aa              LDRB     r2,[r5,#6]
000230  0209              LSLS     r1,r1,#8
000232  4311              ORRS     r1,r1,r2
000234  4608              MOV      r0,r1
000236  1d21              ADDS     r1,r4,#4
000238  f7fffffe          BL       __aeabi_uwrite4
                  |L27.572|
;;;1056   								}
;;;1057   								pep0state->pData = (void*)USB_HID_FSReportDescriptor_3;
00023c  4621              MOV      r1,r4
00023e  3108              ADDS     r1,r1,#8
000240  4889              LDR      r0,|L27.1128|
000242  f7fffffe          BL       __aeabi_uwrite4
;;;1058   								pep0state->nState = M_EP0_TX;
000246  4621              MOV      r1,r4
000248  2002              MOVS     r0,#2
00024a  f7fffffe          BL       __aeabi_uwrite4
;;;1059   								break;
00024e  e042              B        |L27.726|
;;;1060   								case	3:
;;;1061   								//接口3
;;;1062   								pep0state->nBytesLeft = USB_HID_FSReportDescriptor_4Size;		//报告描述符的长度
000250  1d21              ADDS     r1,r4,#4
000252  4886              LDR      r0,|L27.1132|
000254  8800              LDRH     r0,[r0,#0]  ; USB_HID_FSReportDescriptor_4Size
000256  f7fffffe          BL       __aeabi_uwrite4
;;;1063   								/* Check host is allowing a descriptor this long */
;;;1064   								if (pcmd->USBwLength < pep0state->nBytesLeft)
00025a  1d20              ADDS     r0,r4,#4
00025c  f7fffffe          BL       __aeabi_uread4
000260  79e9              LDRB     r1,[r5,#7]
000262  79aa              LDRB     r2,[r5,#6]
000264  0209              LSLS     r1,r1,#8
000266  4311              ORRS     r1,r1,r2
000268  4288              CMP      r0,r1
00026a  dd07              BLE      |L27.636|
;;;1065   								{
;;;1066   									pep0state->nBytesLeft = pcmd->USBwLength;
00026c  79e9              LDRB     r1,[r5,#7]
00026e  79aa              LDRB     r2,[r5,#6]
000270  0209              LSLS     r1,r1,#8
000272  4311              ORRS     r1,r1,r2
000274  4608              MOV      r0,r1
000276  1d21              ADDS     r1,r4,#4
000278  f7fffffe          BL       __aeabi_uwrite4
                  |L27.636|
;;;1067   								}
;;;1068   								pep0state->pData = (void*)USB_HID_FSReportDescriptor_4;
00027c  4621              MOV      r1,r4
00027e  3108              ADDS     r1,r1,#8
000280  487b              LDR      r0,|L27.1136|
000282  f7fffffe          BL       __aeabi_uwrite4
;;;1069   								pep0state->nState = M_EP0_TX;
000286  4621              MOV      r1,r4
000288  2002              MOVS     r0,#2
00028a  f7fffffe          BL       __aeabi_uwrite4
;;;1070   								break;
00028e  e022              B        |L27.726|
;;;1071   								case	4:
;;;1072   								//接口4
;;;1073   								pep0state->nBytesLeft = USB_HID_FSReportDescriptor_5Size;		//报告描述符的长度
000290  1d21              ADDS     r1,r4,#4
000292  4878              LDR      r0,|L27.1140|
000294  8800              LDRH     r0,[r0,#0]  ; USB_HID_FSReportDescriptor_5Size
000296  f7fffffe          BL       __aeabi_uwrite4
;;;1074   								/* Check host is allowing a descriptor this long */
;;;1075   								if (pcmd->USBwLength < pep0state->nBytesLeft)
00029a  1d20              ADDS     r0,r4,#4
00029c  f7fffffe          BL       __aeabi_uread4
0002a0  79e9              LDRB     r1,[r5,#7]
0002a2  79aa              LDRB     r2,[r5,#6]
0002a4  0209              LSLS     r1,r1,#8
0002a6  4311              ORRS     r1,r1,r2
0002a8  4288              CMP      r0,r1
0002aa  dd07              BLE      |L27.700|
;;;1076   								{
;;;1077   									pep0state->nBytesLeft = pcmd->USBwLength;
0002ac  79e9              LDRB     r1,[r5,#7]
0002ae  79aa              LDRB     r2,[r5,#6]
0002b0  0209              LSLS     r1,r1,#8
0002b2  4311              ORRS     r1,r1,r2
0002b4  4608              MOV      r0,r1
0002b6  1d21              ADDS     r1,r4,#4
0002b8  f7fffffe          BL       __aeabi_uwrite4
                  |L27.700|
;;;1078   								}
;;;1079   								pep0state->pData = (void*)USB_HID_FSReportDescriptor_5;
0002bc  4621              MOV      r1,r4
0002be  3108              ADDS     r1,r1,#8
0002c0  486d              LDR      r0,|L27.1144|
0002c2  f7fffffe          BL       __aeabi_uwrite4
;;;1080   								pep0state->nState = M_EP0_TX;
0002c6  4621              MOV      r1,r4
0002c8  2002              MOVS     r0,#2
0002ca  f7fffffe          BL       __aeabi_uwrite4
;;;1081   								break;
0002ce  e002              B        |L27.726|
;;;1082   							default:
;;;1083   								//接口
;;;1084   								bError = TRUE;
0002d0  2001              MOVS     r0,#1
0002d2  9008              STR      r0,[sp,#0x20]
;;;1085   								break;							
0002d4  bf00              NOP      
                  |L27.726|
0002d6  bf00              NOP                            ;1037
;;;1086   						}
;;;1087   						break;
0002d8  e098              B        |L27.1036|
                  |L27.730|
;;;1088   					case	M_CMD_STRING:	//字符串描述符
;;;1089   						switch(pcmd->USBwValue & 0xff)
0002da  78e8              LDRB     r0,[r5,#3]
0002dc  78a9              LDRB     r1,[r5,#2]
0002de  0200              LSLS     r0,r0,#8
0002e0  4308              ORRS     r0,r0,r1
0002e2  b2c0              UXTB     r0,r0
0002e4  2800              CMP      r0,#0
0002e6  d006              BEQ      |L27.758|
0002e8  2801              CMP      r0,#1
0002ea  d025              BEQ      |L27.824|
0002ec  2802              CMP      r0,#2
0002ee  d043              BEQ      |L27.888|
0002f0  2803              CMP      r0,#3
0002f2  d17d              BNE      |L27.1008|
0002f4  e060              B        |L27.952|
                  |L27.758|
;;;1090   						{
;;;1091   							case	0:	//获取语言ID
;;;1092   								pep0state->nBytesLeft = LanguageIdSize;		
0002f6  1d21              ADDS     r1,r4,#4
0002f8  4860              LDR      r0,|L27.1148|
0002fa  8800              LDRH     r0,[r0,#0]  ; LanguageIdSize
0002fc  f7fffffe          BL       __aeabi_uwrite4
;;;1093   								/* Check host is allowing a descriptor this long */
;;;1094   								if (pcmd->USBwLength < pep0state->nBytesLeft)
000300  1d20              ADDS     r0,r4,#4
000302  f7fffffe          BL       __aeabi_uread4
000306  4601              MOV      r1,r0
000308  79e8              LDRB     r0,[r5,#7]
00030a  79aa              LDRB     r2,[r5,#6]
00030c  0200              LSLS     r0,r0,#8
00030e  4310              ORRS     r0,r0,r2
000310  4281              CMP      r1,r0
000312  dd07              BLE      |L27.804|
;;;1095   								{
;;;1096   									pep0state->nBytesLeft = pcmd->USBwLength;
000314  79e9              LDRB     r1,[r5,#7]
000316  79aa              LDRB     r2,[r5,#6]
000318  0209              LSLS     r1,r1,#8
00031a  4311              ORRS     r1,r1,r2
00031c  4608              MOV      r0,r1
00031e  1d21              ADDS     r1,r4,#4
000320  f7fffffe          BL       __aeabi_uwrite4
                  |L27.804|
;;;1097   								}
;;;1098   								pep0state->pData = (void*)LanguageId;
000324  4621              MOV      r1,r4
000326  3108              ADDS     r1,r1,#8
000328  4855              LDR      r0,|L27.1152|
00032a  f7fffffe          BL       __aeabi_uwrite4
;;;1099   								pep0state->nState = M_EP0_TX;
00032e  4621              MOV      r1,r4
000330  2002              MOVS     r0,#2
000332  f7fffffe          BL       __aeabi_uwrite4
;;;1100   							break;
000336  e064              B        |L27.1026|
                  |L27.824|
;;;1101   							case	1:	//因厂商字符串索引值为1，所以这里写1
;;;1102   								pep0state->nBytesLeft = ManufacturerStringDescriptorSize;		
000338  1d21              ADDS     r1,r4,#4
00033a  4852              LDR      r0,|L27.1156|
00033c  8800              LDRH     r0,[r0,#0]  ; ManufacturerStringDescriptorSize
00033e  f7fffffe          BL       __aeabi_uwrite4
;;;1103   								/* Check host is allowing a descriptor this long */
;;;1104   								if (pcmd->USBwLength < pep0state->nBytesLeft)
000342  1d20              ADDS     r0,r4,#4
000344  f7fffffe          BL       __aeabi_uread4
000348  79e9              LDRB     r1,[r5,#7]
00034a  79aa              LDRB     r2,[r5,#6]
00034c  0209              LSLS     r1,r1,#8
00034e  4311              ORRS     r1,r1,r2
000350  4288              CMP      r0,r1
000352  dd07              BLE      |L27.868|
;;;1105   								{
;;;1106   									pep0state->nBytesLeft = pcmd->USBwLength;
000354  79e9              LDRB     r1,[r5,#7]
000356  79aa              LDRB     r2,[r5,#6]
000358  0209              LSLS     r1,r1,#8
00035a  4311              ORRS     r1,r1,r2
00035c  4608              MOV      r0,r1
00035e  1d21              ADDS     r1,r4,#4
000360  f7fffffe          BL       __aeabi_uwrite4
                  |L27.868|
;;;1107   								}
;;;1108   								pep0state->pData = (void*)ManufacturerStringDescriptor;
000364  4621              MOV      r1,r4
000366  3108              ADDS     r1,r1,#8
000368  4847              LDR      r0,|L27.1160|
00036a  f7fffffe          BL       __aeabi_uwrite4
;;;1109   								pep0state->nState = M_EP0_TX;
00036e  4621              MOV      r1,r4
000370  2002              MOVS     r0,#2
000372  f7fffffe          BL       __aeabi_uwrite4
;;;1110   							break;	
000376  e044              B        |L27.1026|
                  |L27.888|
;;;1111   							case	2:	//因产品字符串索引值为2，所以这里写2
;;;1112   								pep0state->nBytesLeft = ProductStringDescriptorSize;		
000378  1d21              ADDS     r1,r4,#4
00037a  4844              LDR      r0,|L27.1164|
00037c  8800              LDRH     r0,[r0,#0]  ; ProductStringDescriptorSize
00037e  f7fffffe          BL       __aeabi_uwrite4
;;;1113   								/* Check host is allowing a descriptor this long */
;;;1114   								if (pcmd->USBwLength < pep0state->nBytesLeft)
000382  1d20              ADDS     r0,r4,#4
000384  f7fffffe          BL       __aeabi_uread4
000388  79e9              LDRB     r1,[r5,#7]
00038a  79aa              LDRB     r2,[r5,#6]
00038c  0209              LSLS     r1,r1,#8
00038e  4311              ORRS     r1,r1,r2
000390  4288              CMP      r0,r1
000392  dd07              BLE      |L27.932|
;;;1115   								{
;;;1116   									pep0state->nBytesLeft = pcmd->USBwLength;
000394  79e9              LDRB     r1,[r5,#7]
000396  79aa              LDRB     r2,[r5,#6]
000398  0209              LSLS     r1,r1,#8
00039a  4311              ORRS     r1,r1,r2
00039c  4608              MOV      r0,r1
00039e  1d21              ADDS     r1,r4,#4
0003a0  f7fffffe          BL       __aeabi_uwrite4
                  |L27.932|
;;;1117   								}
;;;1118   								pep0state->pData = (void*)ProductStringDescriptor;
0003a4  4621              MOV      r1,r4
0003a6  3108              ADDS     r1,r1,#8
0003a8  4839              LDR      r0,|L27.1168|
0003aa  f7fffffe          BL       __aeabi_uwrite4
;;;1119   								pep0state->nState = M_EP0_TX;
0003ae  4621              MOV      r1,r4
0003b0  2002              MOVS     r0,#2
0003b2  f7fffffe          BL       __aeabi_uwrite4
;;;1120   							break;			
0003b6  e024              B        |L27.1026|
                  |L27.952|
;;;1121   							case	3:	//因产品序列号索引值为3，所以这里写3
;;;1122   								pep0state->nBytesLeft = SerialNumberSringDescriptorSize;		
0003b8  1d21              ADDS     r1,r4,#4
0003ba  4836              LDR      r0,|L27.1172|
0003bc  8800              LDRH     r0,[r0,#0]  ; SerialNumberSringDescriptorSize
0003be  f7fffffe          BL       __aeabi_uwrite4
;;;1123   								/* Check host is allowing a descriptor this long */
;;;1124   								if (pcmd->USBwLength < pep0state->nBytesLeft)
0003c2  1d20              ADDS     r0,r4,#4
0003c4  f7fffffe          BL       __aeabi_uread4
0003c8  79e9              LDRB     r1,[r5,#7]
0003ca  79aa              LDRB     r2,[r5,#6]
0003cc  0209              LSLS     r1,r1,#8
0003ce  4311              ORRS     r1,r1,r2
0003d0  4288              CMP      r0,r1
0003d2  dd07              BLE      |L27.996|
;;;1125   								{
;;;1126   									pep0state->nBytesLeft = pcmd->USBwLength;
0003d4  79e9              LDRB     r1,[r5,#7]
0003d6  79aa              LDRB     r2,[r5,#6]
0003d8  0209              LSLS     r1,r1,#8
0003da  4311              ORRS     r1,r1,r2
0003dc  4608              MOV      r0,r1
0003de  1d21              ADDS     r1,r4,#4
0003e0  f7fffffe          BL       __aeabi_uwrite4
                  |L27.996|
;;;1127   								}
;;;1128   								pep0state->pData = (void*)SerialNumberSringDescriptor;
0003e4  4621              MOV      r1,r4
0003e6  3108              ADDS     r1,r1,#8
0003e8  482b              LDR      r0,|L27.1176|
0003ea  f7fffffe          BL       __aeabi_uwrite4
;;;1129   								pep0state->nState = M_EP0_TX;
0003ee  e000              B        |L27.1010|
                  |L27.1008|
0003f0  e004              B        |L27.1020|
                  |L27.1010|
0003f2  4621              MOV      r1,r4
0003f4  2002              MOVS     r0,#2
0003f6  f7fffffe          BL       __aeabi_uwrite4
;;;1130   							break;
0003fa  e002              B        |L27.1026|
                  |L27.1020|
;;;1131   							default:
;;;1132   								bError = TRUE;								
0003fc  2001              MOVS     r0,#1
0003fe  9008              STR      r0,[sp,#0x20]
;;;1133   							break;
000400  bf00              NOP      
                  |L27.1026|
000402  bf00              NOP                            ;1100
;;;1134   						}
;;;1135   					break;
000404  e002              B        |L27.1036|
                  |L27.1030|
;;;1136   					/***保留***/
;;;1137   					default: bError = TRUE;
000406  2001              MOVS     r0,#1
000408  9008              STR      r0,[sp,#0x20]
00040a  bf00              NOP                            ;976
                  |L27.1036|
00040c  bf00              NOP                            ;990
                  |L27.1038|
;;;1138   				}
;;;1139   			}
;;;1140   			break;
00040e  e288              B        |L27.2338|
;;;1141   
;;;1142   		/***用于主机指示设备采用的要求的配置***/
;;;1143   		case SET_CONFIGURATION:
;;;1144   			byConfig = (BYTE)(pcmd->USBwValue & 0x00FF);
000410  78e8              LDRB     r0,[r5,#3]
000412  78a9              LDRB     r1,[r5,#2]
000414  0200              LSLS     r0,r0,#8
000416  4308              ORRS     r0,r0,r1
000418  b2c0              UXTB     r0,r0
00041a  9005              STR      r0,[sp,#0x14]
;;;1145   			if(gnDevState == DEVSTATE_DEFAULT)
00041c  4808              LDR      r0,|L27.1088|
00041e  6800              LDR      r0,[r0,#0]  ; gnDevState
000420  2800              CMP      r0,#0
000422  d102              BNE      |L27.1066|
;;;1146   			{
;;;1147   				bError = TRUE;
000424  2001              MOVS     r0,#1
000426  9008              STR      r0,[sp,#0x20]
000428  e054              B        |L27.1236|
                  |L27.1066|
;;;1148   			}
;;;1149   			/* Assumes configurations are numbered 1 to NumConfigurations */
;;;1150   			else if(byConfig >USB_FSDeviceDescriptor[USB_FSDeviceDescriptorSize-1])
00042a  4806              LDR      r0,|L27.1092|
00042c  8800              LDRH     r0,[r0,#0]  ; USB_FSDeviceDescriptorSize
00042e  1e40              SUBS     r0,r0,#1
000430  4905              LDR      r1,|L27.1096|
000432  5c09              LDRB     r1,[r1,r0]
000434  9805              LDR      r0,[sp,#0x14]
000436  4281              CMP      r1,r0
000438  da30              BGE      |L27.1180|
;;;1151   			{
;;;1152   				bError = TRUE;
00043a  2001              MOVS     r0,#1
00043c  9008              STR      r0,[sp,#0x20]
00043e  e049              B        |L27.1236|
                  |L27.1088|
                          DCD      gnDevState
                  |L27.1092|
                          DCD      USB_FSDeviceDescriptorSize
                  |L27.1096|
                          DCD      USB_FSDeviceDescriptor
                  |L27.1100|
                          DCD      USB_FSConfigDescriptorSize
                  |L27.1104|
                          DCD      USB_FSConfigDescriptor
                  |L27.1108|
                          DCD      USB_HID_FSReportDescriptor_1Size
                  |L27.1112|
                          DCD      USB_HID_FSReportDescriptor_1
                  |L27.1116|
                          DCD      USB_HID_FSReportDescriptor_2Size
                  |L27.1120|
                          DCD      USB_HID_FSReportDescriptor_2
                  |L27.1124|
                          DCD      USB_HID_FSReportDescriptor_3Size
                  |L27.1128|
                          DCD      USB_HID_FSReportDescriptor_3
                  |L27.1132|
                          DCD      USB_HID_FSReportDescriptor_4Size
                  |L27.1136|
                          DCD      USB_HID_FSReportDescriptor_4
                  |L27.1140|
                          DCD      USB_HID_FSReportDescriptor_5Size
                  |L27.1144|
                          DCD      USB_HID_FSReportDescriptor_5
                  |L27.1148|
                          DCD      LanguageIdSize
                  |L27.1152|
                          DCD      LanguageId
                  |L27.1156|
                          DCD      ManufacturerStringDescriptorSize
                  |L27.1160|
                          DCD      ManufacturerStringDescriptor
                  |L27.1164|
                          DCD      ProductStringDescriptorSize
                  |L27.1168|
                          DCD      ProductStringDescriptor
                  |L27.1172|
                          DCD      SerialNumberSringDescriptorSize
                  |L27.1176|
                          DCD      SerialNumberSringDescriptor
                  |L27.1180|
;;;1153   			}
;;;1154   			else if(!byConfig)
00049c  9805              LDR      r0,[sp,#0x14]
00049e  2800              CMP      r0,#0
0004a0  d103              BNE      |L27.1194|
;;;1155   			{
;;;1156   				gnDevState = DEVSTATE_ADDRESS;
0004a2  2001              MOVS     r0,#1
0004a4  49f6              LDR      r1,|L27.2176|
0004a6  6008              STR      r0,[r1,#0]  ; gnDevState
0004a8  e014              B        |L27.1236|
                  |L27.1194|
;;;1157   			}
;;;1158   			else
;;;1159   			{
;;;1160   				/* Get pointer to requested configuration descriptor */
;;;1161   				gpCurCfg = (void *)USB_FSConfigDescriptor;
0004aa  48f6              LDR      r0,|L27.2180|
0004ac  49f6              LDR      r1,|L27.2184|
0004ae  6008              STR      r0,[r1,#0]  ; gpCurCfg
;;;1162   				/* Set all alternate settings to zero */
;;;1163   				for (n=0; n<M_MAXIFS; n++)
0004b0  2700              MOVS     r7,#0
0004b2  e003              B        |L27.1212|
                  |L27.1204|
;;;1164   					gbyCurIfVal[n] = 0;
0004b4  2000              MOVS     r0,#0
0004b6  49f5              LDR      r1,|L27.2188|
0004b8  55c8              STRB     r0,[r1,r7]
0004ba  1c7f              ADDS     r7,r7,#1              ;1163
                  |L27.1212|
0004bc  2f07              CMP      r7,#7                 ;1163
0004be  dbf9              BLT      |L27.1204|
;;;1165   				/* Configure endpoints */
;;;1166   				ConfigureIfs();
0004c0  f7fffffe          BL       ConfigureIfs
;;;1167   				gnDevState = DEVSTATE_CONFIG;
0004c4  2002              MOVS     r0,#2
0004c6  49ee              LDR      r1,|L27.2176|
0004c8  6008              STR      r0,[r1,#0]  ; gnDevState
;;;1168   				MWRITE_BYTE(M_REG_INDEX, 0);
0004ca  2000              MOVS     r0,#0
0004cc  49f0              LDR      r1,|L27.2192|
0004ce  7388              STRB     r0,[r1,#0xe]
;;;1169   				bNoData = TRUE;
0004d0  2001              MOVS     r0,#1
0004d2  9007              STR      r0,[sp,#0x1c]
                  |L27.1236|
;;;1170   			}
;;;1171   			break;
0004d4  e225              B        |L27.2338|
;;;1172   
;;;1173   		/***用于主机要求设备用某个描述符来描述接口***/		
;;;1174   		case SET_INTERFACE:
;;;1175   			if(gnDevState > DEVSTATE_ADDRESS)
0004d6  48ea              LDR      r0,|L27.2176|
0004d8  6800              LDR      r0,[r0,#0]  ; gnDevState
0004da  2801              CMP      r0,#1
0004dc  d920              BLS      |L27.1312|
;;;1176   			{
;;;1177   				n = (int)pcmd->USBwIndex;
0004de  7968              LDRB     r0,[r5,#5]
0004e0  7929              LDRB     r1,[r5,#4]
0004e2  0207              LSLS     r7,r0,#8
0004e4  430f              ORRS     r7,r7,r1
;;;1178   				pcfg = (PSTD_CFG_DSCR)gpCurCfg;
0004e6  48e8              LDR      r0,|L27.2184|
0004e8  6800              LDR      r0,[r0,#0]  ; gpCurCfg
0004ea  9004              STR      r0,[sp,#0x10]
;;;1179   				if((BYTE)n >= pcfg->bNumInterfaces)
0004ec  b2f9              UXTB     r1,r7
0004ee  9804              LDR      r0,[sp,#0x10]
0004f0  7900              LDRB     r0,[r0,#4]
0004f2  4281              CMP      r1,r0
0004f4  db02              BLT      |L27.1276|
;;;1180   				{
;;;1181   					bError = TRUE;
0004f6  2001              MOVS     r0,#1
0004f8  9008              STR      r0,[sp,#0x20]
0004fa  e013              B        |L27.1316|
                  |L27.1276|
;;;1182   				}
;;;1183   				else 
;;;1184   				{
;;;1185   					gbyCurIfVal[n] = (BYTE)pcmd->USBwValue;
0004fc  78e8              LDRB     r0,[r5,#3]
0004fe  78a9              LDRB     r1,[r5,#2]
000500  0200              LSLS     r0,r0,#8
000502  4308              ORRS     r0,r0,r1
000504  49e1              LDR      r1,|L27.2188|
000506  55c8              STRB     r0,[r1,r7]
;;;1186   					if (ConfigureIfs() == FALSE)
000508  f7fffffe          BL       ConfigureIfs
00050c  2800              CMP      r0,#0
00050e  d101              BNE      |L27.1300|
;;;1187   					{
;;;1188   						bError = TRUE;
000510  2001              MOVS     r0,#1
000512  9008              STR      r0,[sp,#0x20]
                  |L27.1300|
;;;1189   					}
;;;1190   					
;;;1191   					MWRITE_BYTE(M_REG_INDEX, 0);
000514  2000              MOVS     r0,#0
000516  49de              LDR      r1,|L27.2192|
000518  7388              STRB     r0,[r1,#0xe]
;;;1192   					bNoData = TRUE;
00051a  2001              MOVS     r0,#1
00051c  9007              STR      r0,[sp,#0x1c]
00051e  e001              B        |L27.1316|
                  |L27.1312|
;;;1193   				}
;;;1194   			}
;;;1195   			else
;;;1196   			{
;;;1197   				bError = TRUE;
000520  2001              MOVS     r0,#1
000522  9008              STR      r0,[sp,#0x20]
                  |L27.1316|
;;;1198   			}
;;;1199   			break;
000524  e1fd              B        |L27.2338|
;;;1200   
;;;1201   		/***用于主机获取设备当前设备的配置值***/		
;;;1202   		case GET_CONFIGURATION:
;;;1203   			if ((gnDevState == DEVSTATE_ADDRESS) && (!pcmd->USBwValue))
000526  48d6              LDR      r0,|L27.2176|
000528  6800              LDR      r0,[r0,#0]  ; gnDevState
00052a  2801              CMP      r0,#1
00052c  d113              BNE      |L27.1366|
00052e  78e8              LDRB     r0,[r5,#3]
000530  78a9              LDRB     r1,[r5,#2]
000532  0200              LSLS     r0,r0,#8
000534  4308              ORRS     r0,r0,r1
000536  2800              CMP      r0,#0
000538  d10d              BNE      |L27.1366|
;;;1204   			{
;;;1205   				/* Prepare to return zero */
;;;1206   				pep0state->nBytesLeft = 1;
00053a  1d21              ADDS     r1,r4,#4
00053c  2001              MOVS     r0,#1
00053e  f7fffffe          BL       __aeabi_uwrite4
;;;1207   				pep0state->pData = (void*)&pcmd->USBwValue;
000542  4621              MOV      r1,r4
000544  3108              ADDS     r1,r1,#8
000546  1ca8              ADDS     r0,r5,#2
000548  f7fffffe          BL       __aeabi_uwrite4
;;;1208   				pep0state->nState = M_EP0_TX;
00054c  4621              MOV      r1,r4
00054e  2002              MOVS     r0,#2
000550  f7fffffe          BL       __aeabi_uwrite4
000554  e017              B        |L27.1414|
                  |L27.1366|
;;;1209   			}
;;;1210   			else if(gnDevState > DEVSTATE_ADDRESS)
000556  48ca              LDR      r0,|L27.2176|
000558  6800              LDR      r0,[r0,#0]  ; gnDevState
00055a  2801              CMP      r0,#1
00055c  d911              BLS      |L27.1410|
;;;1211   			{
;;;1212   				/* Prepare to return configuration value */
;;;1213   				pcfg = (PSTD_CFG_DSCR)gpCurCfg;
00055e  48ca              LDR      r0,|L27.2184|
000560  6800              LDR      r0,[r0,#0]  ; gpCurCfg
000562  9004              STR      r0,[sp,#0x10]
;;;1214   				pep0state->nBytesLeft = 1;
000564  1d21              ADDS     r1,r4,#4
000566  2001              MOVS     r0,#1
000568  f7fffffe          BL       __aeabi_uwrite4
;;;1215   				pep0state->pData = (void*)&pcfg->bConfigurationValue;
00056c  4621              MOV      r1,r4
00056e  3108              ADDS     r1,r1,#8
000570  9804              LDR      r0,[sp,#0x10]
000572  1d40              ADDS     r0,r0,#5
000574  f7fffffe          BL       __aeabi_uwrite4
;;;1216   				pep0state->nState = M_EP0_TX;
000578  4621              MOV      r1,r4
00057a  2002              MOVS     r0,#2
00057c  f7fffffe          BL       __aeabi_uwrite4
000580  e001              B        |L27.1414|
                  |L27.1410|
;;;1217   			}
;;;1218   			else
;;;1219   			{
;;;1220   				bError = TRUE;
000582  2001              MOVS     r0,#1
000584  9008              STR      r0,[sp,#0x20]
                  |L27.1414|
;;;1221   			}
;;;1222   			break;
000586  e1cc              B        |L27.2338|
;;;1223   
;;;1224   		/***用于获取当前某个接口描述符编号***/	
;;;1225   		case GET_INTERFACE:
;;;1226   			if(gnDevState > DEVSTATE_ADDRESS)
000588  48bd              LDR      r0,|L27.2176|
00058a  6800              LDR      r0,[r0,#0]  ; gnDevState
00058c  2801              CMP      r0,#1
00058e  d91f              BLS      |L27.1488|
;;;1227   			{
;;;1228   				n = (int)pcmd->USBwIndex;
000590  7968              LDRB     r0,[r5,#5]
000592  7929              LDRB     r1,[r5,#4]
000594  0207              LSLS     r7,r0,#8
000596  430f              ORRS     r7,r7,r1
;;;1229   				pcfg = (PSTD_CFG_DSCR)gpCurCfg;
000598  48bb              LDR      r0,|L27.2184|
00059a  6800              LDR      r0,[r0,#0]  ; gpCurCfg
00059c  9004              STR      r0,[sp,#0x10]
;;;1230   				if((BYTE)n >= pcfg->bNumInterfaces)
00059e  b2f9              UXTB     r1,r7
0005a0  9804              LDR      r0,[sp,#0x10]
0005a2  7900              LDRB     r0,[r0,#4]
0005a4  4281              CMP      r1,r0
0005a6  db02              BLT      |L27.1454|
;;;1231   				{
;;;1232   					bError = TRUE;
0005a8  2001              MOVS     r0,#1
0005aa  9008              STR      r0,[sp,#0x20]
0005ac  e012              B        |L27.1492|
                  |L27.1454|
;;;1233   				}
;;;1234   				else 
;;;1235   				{
;;;1236   					/* Prepare to return interface value */
;;;1237   					pep0state->nBytesLeft = 1;
0005ae  1d21              ADDS     r1,r4,#4
0005b0  2001              MOVS     r0,#1
0005b2  f7fffffe          BL       __aeabi_uwrite4
;;;1238   					pep0state->pData = (void*)&gpCurIf[n]->bInterfaceNumber;
0005b6  00b9              LSLS     r1,r7,#2
0005b8  4ab6              LDR      r2,|L27.2196|
0005ba  5851              LDR      r1,[r2,r1]
0005bc  1c88              ADDS     r0,r1,#2
0005be  4621              MOV      r1,r4
0005c0  3108              ADDS     r1,r1,#8
0005c2  f7fffffe          BL       __aeabi_uwrite4
;;;1239   					pep0state->nState = M_EP0_TX;
0005c6  4621              MOV      r1,r4
0005c8  2002              MOVS     r0,#2
0005ca  f7fffffe          BL       __aeabi_uwrite4
0005ce  e001              B        |L27.1492|
                  |L27.1488|
;;;1240   				}
;;;1241   			}
;;;1242   			else
;;;1243   				bError = TRUE;
0005d0  2001              MOVS     r0,#1
0005d2  9008              STR      r0,[sp,#0x20]
                  |L27.1492|
;;;1244   			break;
0005d4  e1a5              B        |L27.2338|
;;;1245   
;;;1246   		/***用来启用或激活命令接收者的某些特性***/
;;;1247   		case SET_FEATURE:
;;;1248   			switch (pcmd->bmRequestType) 
0005d6  7828              LDRB     r0,[r5,#0]
0005d8  2800              CMP      r0,#0
0005da  d004              BEQ      |L27.1510|
0005dc  2801              CMP      r0,#1
0005de  d018              BEQ      |L27.1554|
0005e0  2802              CMP      r0,#2
0005e2  d158              BNE      |L27.1686|
0005e4  e016              B        |L27.1556|
                  |L27.1510|
;;;1249   			{
;;;1250   					case M_CMD_STDDEVOUT:
;;;1251   						switch (pcmd->USBwValue) 
0005e6  78e8              LDRB     r0,[r5,#3]
0005e8  78a9              LDRB     r1,[r5,#2]
0005ea  0200              LSLS     r0,r0,#8
0005ec  4308              ORRS     r0,r0,r1
0005ee  2801              CMP      r0,#1
0005f0  d10a              BNE      |L27.1544|
;;;1252   						{
;;;1253   							case M_FTR_DEVREMWAKE:
;;;1254   							pInformation->Current_Feature = pInformation->Current_Feature | (0x1<<5);	
0005f2  48a9              LDR      r0,|L27.2200|
0005f4  6800              LDR      r0,[r0,#0]  ; pInformation
0005f6  7840              LDRB     r0,[r0,#1]
0005f8  2120              MOVS     r1,#0x20
0005fa  4308              ORRS     r0,r0,r1
0005fc  49a6              LDR      r1,|L27.2200|
0005fe  6809              LDR      r1,[r1,#0]  ; pInformation
000600  7048              STRB     r0,[r1,#1]
;;;1255   							bNoData = TRUE;	
000602  2001              MOVS     r0,#1
000604  9007              STR      r0,[sp,#0x1c]
;;;1256   							break;	
000606  e002              B        |L27.1550|
                  |L27.1544|
;;;1257   							default:
;;;1258   							bError = TRUE;
000608  2001              MOVS     r0,#1
00060a  9008              STR      r0,[sp,#0x20]
;;;1259   							break;
00060c  bf00              NOP      
                  |L27.1550|
00060e  bf00              NOP                            ;1256
;;;1260   						}
;;;1261   					break;
000610  e044              B        |L27.1692|
                  |L27.1554|
;;;1262   						
;;;1263   					case M_CMD_STDIFOUT:
;;;1264   
;;;1265   					/* SET FEATURE for EndPoint*/
;;;1266   					case M_CMD_STDEPOUT:
000612  bf00              NOP      
                  |L27.1556|
;;;1267   
;;;1268   						switch (pcmd->USBwValue0) 
000614  78a8              LDRB     r0,[r5,#2]
000616  2800              CMP      r0,#0
000618  d138              BNE      |L27.1676|
;;;1269   						{						
;;;1270   							case M_FTR_EPHALT:
;;;1271   	
;;;1272   							MWRITE_BYTE(M_REG_INDEX,Related_Endpoint);	
00061a  499d              LDR      r1,|L27.2192|
00061c  9803              LDR      r0,[sp,#0xc]
00061e  7388              STRB     r0,[r1,#0xe]
;;;1273   							if (pcmd->USBwIndex0 & 0x80)
000620  7928              LDRB     r0,[r5,#4]
000622  2180              MOVS     r1,#0x80
000624  4008              ANDS     r0,r0,r1
000626  2800              CMP      r0,#0
000628  d016              BEQ      |L27.1624|
;;;1274   							{
;;;1275   								if(Related_Endpoint)/* IN endpoint */
00062a  9803              LDR      r0,[sp,#0xc]
00062c  2800              CMP      r0,#0
00062e  d00a              BEQ      |L27.1606|
;;;1276   								{
;;;1277   									srbuff = *((uint8_t*)M_REG_INCSR1);	
000630  4897              LDR      r0,|L27.2192|
000632  7c46              LDRB     r6,[r0,#0x11]
;;;1278   									srbuff = srbuff |(0x1<<4);
000634  2010              MOVS     r0,#0x10
000636  4306              ORRS     r6,r6,r0
;;;1279   									MWRITE_BYTE(M_REG_INCSR1,srbuff);
000638  4895              LDR      r0,|L27.2192|
00063a  7446              STRB     r6,[r0,#0x11]
;;;1280   									INCSRDATA = MREAD_BYTE(M_REG_INCSR1);	
00063c  7c40              LDRB     r0,[r0,#0x11]
00063e  4997              LDR      r1,|L27.2204|
000640  7008              STRB     r0,[r1,#0]
;;;1281   									__ASM("NOP");
000642  bf00              NOP      
000644  e01c              B        |L27.1664|
                  |L27.1606|
;;;1282   								}
;;;1283   								
;;;1284   								else
;;;1285   								{
;;;1286   									srbuff = *((uint8_t*)M_REG_CSR0);	
000646  4892              LDR      r0,|L27.2192|
000648  7c46              LDRB     r6,[r0,#0x11]
;;;1287   									*((uint8_t*)M_REG_CSR0) = srbuff |(0x1<<5);
00064a  2020              MOVS     r0,#0x20
00064c  4330              ORRS     r0,r0,r6
00064e  4990              LDR      r1,|L27.2192|
000650  7448              STRB     r0,[r1,#0x11]
;;;1288   									srbuff = *((uint8_t*)M_REG_CSR0);	
000652  4608              MOV      r0,r1
000654  7c46              LDRB     r6,[r0,#0x11]
000656  e013              B        |L27.1664|
                  |L27.1624|
;;;1289   								}
;;;1290   							
;;;1291   							}
;;;1292   
;;;1293   							else
;;;1294   							{
;;;1295   						/* OUT endpoint */
;;;1296   								if(Related_Endpoint)
000658  9803              LDR      r0,[sp,#0xc]
00065a  2800              CMP      r0,#0
00065c  d008              BEQ      |L27.1648|
;;;1297   								{
;;;1298   									srbuff = *((uint8_t*)M_REG_OUTCSR1);	
00065e  488c              LDR      r0,|L27.2192|
000660  7d06              LDRB     r6,[r0,#0x14]
;;;1299   									*((uint8_t*)M_REG_OUTCSR1) = srbuff |(0x1<<5);
000662  2020              MOVS     r0,#0x20
000664  4330              ORRS     r0,r0,r6
000666  498a              LDR      r1,|L27.2192|
000668  7508              STRB     r0,[r1,#0x14]
;;;1300   									srbuff = *((uint8_t*)M_REG_OUTCSR1);								
00066a  4608              MOV      r0,r1
00066c  7d06              LDRB     r6,[r0,#0x14]
00066e  e007              B        |L27.1664|
                  |L27.1648|
;;;1301   								}
;;;1302   								
;;;1303   								else
;;;1304   								{
;;;1305   									srbuff = *((uint8_t*)M_REG_CSR0);	
000670  4887              LDR      r0,|L27.2192|
000672  7c46              LDRB     r6,[r0,#0x11]
;;;1306   									*((uint8_t*)M_REG_CSR0) = srbuff |(0x1<<5);
000674  2020              MOVS     r0,#0x20
000676  4330              ORRS     r0,r0,r6
000678  4985              LDR      r1,|L27.2192|
00067a  7448              STRB     r0,[r1,#0x11]
;;;1307   									srbuff = *((uint8_t*)M_REG_CSR0);								
00067c  4608              MOV      r0,r1
00067e  7c46              LDRB     r6,[r0,#0x11]
                  |L27.1664|
;;;1308   								}
;;;1309   													
;;;1310   							}
;;;1311   							bNoData = TRUE;	
000680  2001              MOVS     r0,#1
000682  9007              STR      r0,[sp,#0x1c]
;;;1312   							MWRITE_BYTE(M_REG_INDEX,0);	
000684  2000              MOVS     r0,#0
000686  4982              LDR      r1,|L27.2192|
000688  7388              STRB     r0,[r1,#0xe]
;;;1313   							break;
00068a  e002              B        |L27.1682|
                  |L27.1676|
;;;1314   							default:
;;;1315   							bError = TRUE;
00068c  2001              MOVS     r0,#1
00068e  9008              STR      r0,[sp,#0x20]
;;;1316   							break;
000690  bf00              NOP      
                  |L27.1682|
000692  bf00              NOP                            ;1313
;;;1317   						}
;;;1318   					break;
000694  e002              B        |L27.1692|
                  |L27.1686|
;;;1319   						
;;;1320   					default:
;;;1321   					bError = TRUE;
000696  2001              MOVS     r0,#1
000698  9008              STR      r0,[sp,#0x20]
;;;1322   					break;
00069a  bf00              NOP      
                  |L27.1692|
00069c  bf00              NOP                            ;1261
;;;1323   			}
;;;1324   		break;
00069e  e140              B        |L27.2338|
;;;1325   			
;;;1326   		/***用来CLEAR接收者的某些特性***/			
;;;1327   		case CLEAR_FEATURE:
;;;1328   			switch (pcmd->bmRequestType) 
0006a0  7828              LDRB     r0,[r5,#0]
0006a2  2800              CMP      r0,#0
0006a4  d004              BEQ      |L27.1712|
0006a6  2801              CMP      r0,#1
0006a8  d018              BEQ      |L27.1756|
0006aa  2802              CMP      r0,#2
0006ac  d16d              BNE      |L27.1930|
0006ae  e016              B        |L27.1758|
                  |L27.1712|
;;;1329   			{
;;;1330   					case M_CMD_STDDEVOUT:
;;;1331   						switch (pcmd->USBwValue) 
0006b0  78e8              LDRB     r0,[r5,#3]
0006b2  78a9              LDRB     r1,[r5,#2]
0006b4  0200              LSLS     r0,r0,#8
0006b6  4308              ORRS     r0,r0,r1
0006b8  2801              CMP      r0,#1
0006ba  d10a              BNE      |L27.1746|
;;;1332   						{
;;;1333   							case M_FTR_DEVREMWAKE:
;;;1334   							pInformation->Current_Feature = pInformation->Current_Feature & (~(0x1<<5));
0006bc  4876              LDR      r0,|L27.2200|
0006be  6800              LDR      r0,[r0,#0]  ; pInformation
0006c0  7840              LDRB     r0,[r0,#1]
0006c2  2120              MOVS     r1,#0x20
0006c4  4388              BICS     r0,r0,r1
0006c6  4974              LDR      r1,|L27.2200|
0006c8  6809              LDR      r1,[r1,#0]  ; pInformation
0006ca  7048              STRB     r0,[r1,#1]
;;;1335   							bNoData = TRUE;	
0006cc  2001              MOVS     r0,#1
0006ce  9007              STR      r0,[sp,#0x1c]
;;;1336   							break;
0006d0  e002              B        |L27.1752|
                  |L27.1746|
;;;1337   							default:
;;;1338   							bError = TRUE;
0006d2  2001              MOVS     r0,#1
0006d4  9008              STR      r0,[sp,#0x20]
;;;1339   							break;
0006d6  bf00              NOP      
                  |L27.1752|
0006d8  bf00              NOP                            ;1336
;;;1340   						}
;;;1341   					break;
0006da  e059              B        |L27.1936|
                  |L27.1756|
;;;1342   						
;;;1343   					case M_CMD_STDIFOUT:
;;;1344   
;;;1345   					/* CLEAR FEATURE for EndPoint*/
;;;1346   					case M_CMD_STDEPOUT:
0006dc  bf00              NOP      
                  |L27.1758|
;;;1347   						switch (pcmd->USBwValue0) 
0006de  78a8              LDRB     r0,[r5,#2]
0006e0  2800              CMP      r0,#0
0006e2  d14d              BNE      |L27.1920|
;;;1348   						{
;;;1349   							case M_FTR_EPHALT:						
;;;1350   							MWRITE_BYTE(M_REG_INDEX,Related_Endpoint);	
0006e4  496a              LDR      r1,|L27.2192|
0006e6  9803              LDR      r0,[sp,#0xc]
0006e8  7388              STRB     r0,[r1,#0xe]
;;;1351   							if (pcmd->USBwIndex0 & 0x80)
0006ea  7928              LDRB     r0,[r5,#4]
0006ec  2180              MOVS     r1,#0x80
0006ee  4008              ANDS     r0,r0,r1
0006f0  2800              CMP      r0,#0
0006f2  d021              BEQ      |L27.1848|
;;;1352   							{/* IN endpoint */
;;;1353   								if(Related_Endpoint)
0006f4  9803              LDR      r0,[sp,#0xc]
0006f6  2800              CMP      r0,#0
0006f8  d014              BEQ      |L27.1828|
;;;1354   								{
;;;1355   //									*((uint8_t*)M_REG_INCSR1) = *((uint8_t*)M_REG_INCSR1) & (~(0x01<<6));
;;;1356   									srbuff = *((uint8_t*)M_REG_INCSR1);	
0006fa  4865              LDR      r0,|L27.2192|
0006fc  7c46              LDRB     r6,[r0,#0x11]
;;;1357   									*((uint8_t*)M_REG_INCSR1) = srbuff & (~(0x01<<6));
0006fe  2140              MOVS     r1,#0x40
000700  4630              MOV      r0,r6
000702  4388              BICS     r0,r0,r1
000704  4962              LDR      r1,|L27.2192|
000706  7448              STRB     r0,[r1,#0x11]
;;;1358   									srbuff = *((uint8_t*)M_REG_INCSR1);											
000708  4608              MOV      r0,r1
00070a  7c46              LDRB     r6,[r0,#0x11]
;;;1359   									
;;;1360   //									*((uint8_t*)M_REG_INCSR1) = *((uint8_t*)M_REG_INCSR1) & (~(0x01<<4));
;;;1361   									srbuff = *((uint8_t*)M_REG_INCSR1);	
00070c  7c46              LDRB     r6,[r0,#0x11]
;;;1362   									*((uint8_t*)M_REG_INCSR1) = srbuff & (~(0x01<<4));	
00070e  2110              MOVS     r1,#0x10
000710  4630              MOV      r0,r6
000712  4388              BICS     r0,r0,r1
000714  495e              LDR      r1,|L27.2192|
000716  7448              STRB     r0,[r1,#0x11]
;;;1363   									INCSRDATA = *((uint8_t*)M_REG_INCSR1);	
000718  4608              MOV      r0,r1
00071a  7c40              LDRB     r0,[r0,#0x11]
00071c  495f              LDR      r1,|L27.2204|
00071e  7008              STRB     r0,[r1,#0]
;;;1364   									__ASM("NOP");
000720  bf00              NOP      
000722  e027              B        |L27.1908|
                  |L27.1828|
;;;1365   								}
;;;1366   								
;;;1367   								else
;;;1368   								{
;;;1369   //									*((uint8_t*)M_REG_CSR0) = *((uint8_t*)M_REG_CSR0) & (~(0x01<<5));
;;;1370   									srbuff = *((uint8_t*)M_REG_CSR0);	
000724  485a              LDR      r0,|L27.2192|
000726  7c46              LDRB     r6,[r0,#0x11]
;;;1371   									*((uint8_t*)M_REG_CSR0) = srbuff & (~(0x01<<5));
000728  2120              MOVS     r1,#0x20
00072a  4630              MOV      r0,r6
00072c  4388              BICS     r0,r0,r1
00072e  4958              LDR      r1,|L27.2192|
000730  7448              STRB     r0,[r1,#0x11]
;;;1372   									srbuff = *((uint8_t*)M_REG_CSR0);										
000732  4608              MOV      r0,r1
000734  7c46              LDRB     r6,[r0,#0x11]
000736  e01d              B        |L27.1908|
                  |L27.1848|
;;;1373   									
;;;1374   								}
;;;1375   									
;;;1376   							}
;;;1377   
;;;1378   							else
;;;1379   							{
;;;1380   								/* OUT endpoint */
;;;1381   								if(Related_Endpoint)
000738  9803              LDR      r0,[sp,#0xc]
00073a  2800              CMP      r0,#0
00073c  d011              BEQ      |L27.1890|
;;;1382   								{
;;;1383   //									*((uint8_t*)M_REG_OUTCSR1) = *((uint8_t*)M_REG_OUTCSR1) & (~(0x01<<7));
;;;1384   //									*((uint8_t*)M_REG_OUTCSR1) = *((uint8_t*)M_REG_OUTCSR1) & (~(0x01<<5));
;;;1385   									srbuff = *((uint8_t*)M_REG_OUTCSR1);	
00073e  4854              LDR      r0,|L27.2192|
000740  7d06              LDRB     r6,[r0,#0x14]
;;;1386   									*((uint8_t*)M_REG_OUTCSR1) = srbuff & (~(0x01<<7));
000742  2180              MOVS     r1,#0x80
000744  4630              MOV      r0,r6
000746  4388              BICS     r0,r0,r1
000748  4951              LDR      r1,|L27.2192|
00074a  7508              STRB     r0,[r1,#0x14]
;;;1387   									srbuff = *((uint8_t*)M_REG_OUTCSR1);											
00074c  4608              MOV      r0,r1
00074e  7d06              LDRB     r6,[r0,#0x14]
;;;1388   									
;;;1389   									srbuff = *((uint8_t*)M_REG_OUTCSR1);	
000750  7d06              LDRB     r6,[r0,#0x14]
;;;1390   									*((uint8_t*)M_REG_OUTCSR1) = srbuff & (~(0x01<<5));
000752  2120              MOVS     r1,#0x20
000754  4630              MOV      r0,r6
000756  4388              BICS     r0,r0,r1
000758  494d              LDR      r1,|L27.2192|
00075a  7508              STRB     r0,[r1,#0x14]
;;;1391   									srbuff = *((uint8_t*)M_REG_OUTCSR1);				
00075c  4608              MOV      r0,r1
00075e  7d06              LDRB     r6,[r0,#0x14]
000760  e008              B        |L27.1908|
                  |L27.1890|
;;;1392   									
;;;1393   								}
;;;1394   								
;;;1395   								else
;;;1396   								{
;;;1397   //									*((uint8_t*)M_REG_CSR0) = *((uint8_t*)M_REG_CSR0)  & (~(0x01<<5));
;;;1398   									srbuff = *((uint8_t*)M_REG_CSR0);	
000762  484b              LDR      r0,|L27.2192|
000764  7c46              LDRB     r6,[r0,#0x11]
;;;1399   									*((uint8_t*)M_REG_CSR0) = srbuff & (~(0x01<<5));
000766  2120              MOVS     r1,#0x20
000768  4630              MOV      r0,r6
00076a  4388              BICS     r0,r0,r1
00076c  4948              LDR      r1,|L27.2192|
00076e  7448              STRB     r0,[r1,#0x11]
;;;1400   									srbuff = *((uint8_t*)M_REG_CSR0);											
000770  4608              MOV      r0,r1
000772  7c46              LDRB     r6,[r0,#0x11]
                  |L27.1908|
;;;1401   								}
;;;1402   													
;;;1403   							}
;;;1404   								bNoData = TRUE;	
000774  2001              MOVS     r0,#1
000776  9007              STR      r0,[sp,#0x1c]
;;;1405   								MWRITE_BYTE(M_REG_INDEX,0);
000778  2000              MOVS     r0,#0
00077a  4945              LDR      r1,|L27.2192|
00077c  7388              STRB     r0,[r1,#0xe]
;;;1406   								break;
00077e  e002              B        |L27.1926|
                  |L27.1920|
;;;1407   						
;;;1408   							default:
;;;1409   							bError = TRUE;
000780  2001              MOVS     r0,#1
000782  9008              STR      r0,[sp,#0x20]
;;;1410   							break;
000784  bf00              NOP      
                  |L27.1926|
000786  bf00              NOP                            ;1406
;;;1411   						}
;;;1412   				break;
000788  e002              B        |L27.1936|
                  |L27.1930|
;;;1413   						
;;;1414   				default:
;;;1415   				bError = TRUE;
00078a  2001              MOVS     r0,#1
00078c  9008              STR      r0,[sp,#0x20]
;;;1416   				break;		
00078e  bf00              NOP      
                  |L27.1936|
000790  bf00              NOP                            ;1341
;;;1417   			}
;;;1418   		break;	
000792  e0c6              B        |L27.2338|
;;;1419   			
;;;1420   			
;;;1421   		/***用于主机获取设备 STATUS***/					
;;;1422   		case GET_STATUS:	
;;;1423   		
;;;1424   			switch (pcmd->bmRequestType) 
000794  7828              LDRB     r0,[r5,#0]
000796  2880              CMP      r0,#0x80
000798  d004              BEQ      |L27.1956|
00079a  2881              CMP      r0,#0x81
00079c  d03b              BEQ      |L27.2070|
00079e  2882              CMP      r0,#0x82
0007a0  d17e              BNE      |L27.2208|
0007a2  e046              B        |L27.2098|
                  |L27.1956|
;;;1425   			{
;;;1426   
;;;1427   				 /* GET STATUS for Device*/
;;;1428   					case M_CMD_STDDEVIN:
;;;1429   						
;;;1430   					if (pInformation->Current_Feature & (0x1<<5))
0007a4  483c              LDR      r0,|L27.2200|
0007a6  6800              LDR      r0,[r0,#0]  ; pInformation
0007a8  7840              LDRB     r0,[r0,#1]
0007aa  2120              MOVS     r1,#0x20
0007ac  4008              ANDS     r0,r0,r1
0007ae  2800              CMP      r0,#0
0007b0  d006              BEQ      |L27.1984|
;;;1431   					{
;;;1432   						txdat[0] |=(0x1<<1);						
0007b2  4669              MOV      r1,sp
0007b4  7908              LDRB     r0,[r1,#4]
0007b6  2102              MOVS     r1,#2
0007b8  4308              ORRS     r0,r0,r1
0007ba  4669              MOV      r1,sp
0007bc  7108              STRB     r0,[r1,#4]
0007be  e005              B        |L27.1996|
                  |L27.1984|
;;;1433   					}
;;;1434   					else
;;;1435   					{
;;;1436   						txdat[0] &= ~(0x1<<1);	
0007c0  4669              MOV      r1,sp
0007c2  7908              LDRB     r0,[r1,#4]
0007c4  2102              MOVS     r1,#2
0007c6  4388              BICS     r0,r0,r1
0007c8  4669              MOV      r1,sp
0007ca  7108              STRB     r0,[r1,#4]
                  |L27.1996|
;;;1437   					} 
;;;1438   					if (pInformation->Current_Feature & (0x1<<6))
0007cc  4832              LDR      r0,|L27.2200|
0007ce  6800              LDR      r0,[r0,#0]  ; pInformation
0007d0  7840              LDRB     r0,[r0,#1]
0007d2  2140              MOVS     r1,#0x40
0007d4  4008              ANDS     r0,r0,r1
0007d6  2800              CMP      r0,#0
0007d8  d006              BEQ      |L27.2024|
;;;1439   					{
;;;1440   						txdat[0] |=(0x1<<0);						
0007da  4669              MOV      r1,sp
0007dc  7908              LDRB     r0,[r1,#4]
0007de  2101              MOVS     r1,#1
0007e0  4308              ORRS     r0,r0,r1
0007e2  4669              MOV      r1,sp
0007e4  7108              STRB     r0,[r1,#4]
0007e6  e005              B        |L27.2036|
                  |L27.2024|
;;;1441   					}
;;;1442   					else
;;;1443   					{
;;;1444   						txdat[0] &= ~(0x1<<0);	
0007e8  4668              MOV      r0,sp
0007ea  7900              LDRB     r0,[r0,#4]
0007ec  0841              LSRS     r1,r0,#1
0007ee  0049              LSLS     r1,r1,#1
0007f0  4668              MOV      r0,sp
0007f2  7101              STRB     r1,[r0,#4]
                  |L27.2036|
;;;1445   					} 					
;;;1446   					
;;;1447   					txdat[1]=0;
0007f4  2000              MOVS     r0,#0
0007f6  4669              MOV      r1,sp
0007f8  7148              STRB     r0,[r1,#5]
;;;1448   					pep0state->nBytesLeft = 2;
0007fa  1d21              ADDS     r1,r4,#4
0007fc  2002              MOVS     r0,#2
0007fe  f7fffffe          BL       __aeabi_uwrite4
;;;1449   					pep0state->pData = txdat;
000802  4621              MOV      r1,r4
000804  3108              ADDS     r1,r1,#8
000806  a801              ADD      r0,sp,#4
000808  f7fffffe          BL       __aeabi_uwrite4
;;;1450   					pep0state->nState = M_EP0_TX;	
00080c  4621              MOV      r1,r4
00080e  2002              MOVS     r0,#2
000810  f7fffffe          BL       __aeabi_uwrite4
;;;1451   					break;
000814  e080              B        |L27.2328|
                  |L27.2070|
;;;1452   					
;;;1453   				/* GET STATUS for Interface*/		
;;;1454   					case M_CMD_STDIFIN:
;;;1455   					pep0state->nBytesLeft = 2;
000816  1d21              ADDS     r1,r4,#4
000818  2002              MOVS     r0,#2
00081a  f7fffffe          BL       __aeabi_uwrite4
;;;1456   					pep0state->pData = txdat;
00081e  4621              MOV      r1,r4
000820  3108              ADDS     r1,r1,#8
000822  a801              ADD      r0,sp,#4
000824  f7fffffe          BL       __aeabi_uwrite4
;;;1457   					pep0state->nState = M_EP0_TX;	
000828  4621              MOV      r1,r4
00082a  2002              MOVS     r0,#2
00082c  f7fffffe          BL       __aeabi_uwrite4
;;;1458   					break;
000830  e072              B        |L27.2328|
                  |L27.2098|
;;;1459   				/* GET STATUS for EndPoint*/
;;;1460   					case M_CMD_STDEPIN:									
;;;1461   					
;;;1462   					if (pcmd->USBwIndex0 & 0x80)
000832  7928              LDRB     r0,[r5,#4]
000834  2180              MOVS     r1,#0x80
000836  4008              ANDS     r0,r0,r1
000838  2800              CMP      r0,#0
00083a  d036              BEQ      |L27.2218|
;;;1463   					{	
;;;1464   						if(Related_Endpoint){
00083c  9803              LDR      r0,[sp,#0xc]
00083e  2800              CMP      r0,#0
000840  d014              BEQ      |L27.2156|
;;;1465   							MWRITE_BYTE(M_REG_INDEX,Related_Endpoint);
000842  4913              LDR      r1,|L27.2192|
000844  9803              LDR      r0,[sp,#0xc]
000846  7388              STRB     r0,[r1,#0xe]
;;;1466   							INCSRDATA = MREAD_BYTE(M_REG_INCSR1);
000848  4608              MOV      r0,r1
00084a  7c40              LDRB     r0,[r0,#0x11]
00084c  4913              LDR      r1,|L27.2204|
00084e  7008              STRB     r0,[r1,#0]
;;;1467   							if(INCSRDATA & (0x1<<4))
000850  4608              MOV      r0,r1
000852  7800              LDRB     r0,[r0,#0]  ; INCSRDATA
000854  2110              MOVS     r1,#0x10
000856  4008              ANDS     r0,r0,r1
000858  2800              CMP      r0,#0
00085a  d003              BEQ      |L27.2148|
;;;1468   								txdat[0] = 1;	
00085c  2001              MOVS     r0,#1
00085e  4669              MOV      r1,sp
000860  7108              STRB     r0,[r1,#4]
000862  e040              B        |L27.2278|
                  |L27.2148|
;;;1469   							else txdat[0] = 0;	
000864  2000              MOVS     r0,#0
000866  4669              MOV      r1,sp
000868  7108              STRB     r0,[r1,#4]
00086a  e03c              B        |L27.2278|
                  |L27.2156|
;;;1470   						}
;;;1471   						else
;;;1472   							if(*((uint8_t*)M_REG_CSR0) & (0x1<<2))
00086c  4808              LDR      r0,|L27.2192|
00086e  7c40              LDRB     r0,[r0,#0x11]
000870  2104              MOVS     r1,#4
000872  4008              ANDS     r0,r0,r1
000874  2800              CMP      r0,#0
000876  d014              BEQ      |L27.2210|
;;;1473   							txdat[0] = 1;	
000878  2001              MOVS     r0,#1
00087a  4669              MOV      r1,sp
00087c  7108              STRB     r0,[r1,#4]
00087e  e032              B        |L27.2278|
                  |L27.2176|
                          DCD      gnDevState
                  |L27.2180|
                          DCD      USB_FSConfigDescriptor
                  |L27.2184|
                          DCD      gpCurCfg
                  |L27.2188|
                          DCD      gbyCurIfVal
                  |L27.2192|
                          DCD      0x40005c00
                  |L27.2196|
                          DCD      gpCurIf
                  |L27.2200|
                          DCD      pInformation
                  |L27.2204|
                          DCD      INCSRDATA
                  |L27.2208|
0008a0  e037              B        |L27.2322|
                  |L27.2210|
;;;1474   							else txdat[0] = 0;								
0008a2  2000              MOVS     r0,#0
0008a4  4669              MOV      r1,sp
0008a6  7108              STRB     r0,[r1,#4]
0008a8  e01d              B        |L27.2278|
                  |L27.2218|
;;;1475   					}
;;;1476   
;;;1477   					else
;;;1478   					{
;;;1479   						if(Related_Endpoint){
0008aa  9803              LDR      r0,[sp,#0xc]
0008ac  2800              CMP      r0,#0
0008ae  d00d              BEQ      |L27.2252|
;;;1480   							if(*((uint8_t*)M_REG_OUTCSR1) & (0x1<<5))
0008b0  4826              LDR      r0,|L27.2380|
0008b2  7d00              LDRB     r0,[r0,#0x14]
0008b4  2120              MOVS     r1,#0x20
0008b6  4008              ANDS     r0,r0,r1
0008b8  2800              CMP      r0,#0
0008ba  d003              BEQ      |L27.2244|
;;;1481   								txdat[0] = 1;	
0008bc  2001              MOVS     r0,#1
0008be  4669              MOV      r1,sp
0008c0  7108              STRB     r0,[r1,#4]
0008c2  e010              B        |L27.2278|
                  |L27.2244|
;;;1482   							else txdat[0] = 0;	
0008c4  2000              MOVS     r0,#0
0008c6  4669              MOV      r1,sp
0008c8  7108              STRB     r0,[r1,#4]
0008ca  e00c              B        |L27.2278|
                  |L27.2252|
;;;1483   						}
;;;1484   						else
;;;1485   							if(*((uint8_t*)M_REG_CSR0) & (0x1<<2))
0008cc  481f              LDR      r0,|L27.2380|
0008ce  7c40              LDRB     r0,[r0,#0x11]
0008d0  2104              MOVS     r1,#4
0008d2  4008              ANDS     r0,r0,r1
0008d4  2800              CMP      r0,#0
0008d6  d003              BEQ      |L27.2272|
;;;1486   							txdat[0] = 1;	
0008d8  2001              MOVS     r0,#1
0008da  4669              MOV      r1,sp
0008dc  7108              STRB     r0,[r1,#4]
0008de  e002              B        |L27.2278|
                  |L27.2272|
;;;1487   							else txdat[0] = 0;								
0008e0  2000              MOVS     r0,#0
0008e2  4669              MOV      r1,sp
0008e4  7108              STRB     r0,[r1,#4]
                  |L27.2278|
;;;1488   					}		
;;;1489   					txdat[1]=0;
0008e6  2000              MOVS     r0,#0
0008e8  4669              MOV      r1,sp
0008ea  7148              STRB     r0,[r1,#5]
;;;1490   					pep0state->nBytesLeft = 2;
0008ec  1d21              ADDS     r1,r4,#4
0008ee  2002              MOVS     r0,#2
0008f0  f7fffffe          BL       __aeabi_uwrite4
;;;1491   					pep0state->pData = txdat;
0008f4  4621              MOV      r1,r4
0008f6  3108              ADDS     r1,r1,#8
0008f8  a801              ADD      r0,sp,#4
0008fa  f7fffffe          BL       __aeabi_uwrite4
;;;1492   					pep0state->nState = M_EP0_TX;	
0008fe  4621              MOV      r1,r4
000900  2002              MOVS     r0,#2
000902  e000              B        |L27.2310|
                  |L27.2308|
000904  e00a              B        |L27.2332|
                  |L27.2310|
000906  f7fffffe          BL       __aeabi_uwrite4
;;;1493   					MWRITE_BYTE(M_REG_INDEX,0);	
00090a  2000              MOVS     r0,#0
00090c  490f              LDR      r1,|L27.2380|
00090e  7388              STRB     r0,[r1,#0xe]
;;;1494   					break;
000910  e002              B        |L27.2328|
                  |L27.2322|
;;;1495   					
;;;1496   					default:
;;;1497   					bError = TRUE;
000912  2001              MOVS     r0,#1
000914  9008              STR      r0,[sp,#0x20]
;;;1498   					break;
000916  bf00              NOP      
                  |L27.2328|
000918  bf00              NOP                            ;1451
;;;1499   				
;;;1500   			}
;;;1501   		break;	
00091a  e002              B        |L27.2338|
                  |L27.2332|
;;;1502   
;;;1503   			
;;;1504   		/***不可识别的请求***/
;;;1505   		default:
;;;1506   			/* Stall the command if an unrecognized request is received */
;;;1507   			bError = TRUE;
00091c  2001              MOVS     r0,#1
00091e  9008              STR      r0,[sp,#0x20]
;;;1508   		break;
000920  bf00              NOP      
                  |L27.2338|
000922  bf00              NOP                            ;964
;;;1509    }
;;;1510   
;;;1511   	/* Stall command if an error occurred */
;;;1512   	if (bError)
000924  9808              LDR      r0,[sp,#0x20]
000926  2800              CMP      r0,#0
000928  d002              BEQ      |L27.2352|
;;;1513   	{
;;;1514   		/***清零 OUTPKTRDY 位,终止当前传输***/
;;;1515   		by = M_CSR0_SVDOUTPKTRDY | M_CSR0_SENDSTALL;
00092a  2060              MOVS     r0,#0x60
00092c  9006              STR      r0,[sp,#0x18]
00092e  e007              B        |L27.2368|
                  |L27.2352|
;;;1516   	}
;;;1517   	else if(bNoData)
000930  9807              LDR      r0,[sp,#0x1c]
000932  2800              CMP      r0,#0
000934  d002              BEQ      |L27.2364|
;;;1518   	{
;;;1519   //		FIFOWrite(0, 0, pep0state->pData);
;;;1520   //		by = M_CSR0_INPKTRDY | M_CSR0_DATAEND;
;;;1521   //		MWRITE_BYTE(M_REG_CSR0, by);
;;;1522   		/***清零 OUTPKTRDY 位,在发送时表示，将要发送的时最后一包数据；接收时将要接收的是最后一包数据；***/
;;;1523   		by = M_CSR0_SVDOUTPKTRDY | M_CSR0_DATAEND;
000936  2048              MOVS     r0,#0x48
000938  9006              STR      r0,[sp,#0x18]
00093a  e001              B        |L27.2368|
                  |L27.2364|
;;;1524   //					pep0state->nBytesLeft = 0;
;;;1525   //					pep0state->nState = M_EP0_TX;			
;;;1526   	}
;;;1527   	else
;;;1528   	{
;;;1529   		/***清零 OUTPKTRDY 位***/
;;;1530   		by = M_CSR0_SVDOUTPKTRDY;
00093c  2040              MOVS     r0,#0x40
00093e  9006              STR      r0,[sp,#0x18]
                  |L27.2368|
;;;1531   	}
;;;1532   	
;;;1533   	MWRITE_BYTE(M_REG_CSR0, by);
000940  4902              LDR      r1,|L27.2380|
000942  9806              LDR      r0,[sp,#0x18]
000944  7448              STRB     r0,[r1,#0x11]
;;;1534   
;;;1535   	return;
;;;1536   	
;;;1537   }
000946  b009              ADD      sp,sp,#0x24
000948  bdf0              POP      {r4-r7,pc}
;;;1538   
                          ENDP

00094a  0000              DCW      0x0000
                  |L27.2380|
                          DCD      0x40005c00

                          AREA ||i.USB_Suspend||, CODE, READONLY, ALIGN=2

                  USB_Suspend PROC
;;;198    */
;;;199    void USB_Suspend(void)
000000  4809              LDR      r0,|L28.40|
;;;200    {
;;;201    	if(usb_state == USB_SUSPEND_FLAG)
000002  7800              LDRB     r0,[r0,#0]  ; usb_state
000004  2801              CMP      r0,#1
000006  d106              BNE      |L28.22|
;;;202    	{
;;;203    		USB->POWER |= 0x01;//允许挂起模块
000008  4808              LDR      r0,|L28.44|
00000a  7840              LDRB     r0,[r0,#1]
00000c  2101              MOVS     r1,#1
00000e  4308              ORRS     r0,r0,r1
000010  4906              LDR      r1,|L28.44|
000012  7048              STRB     r0,[r1,#1]
000014  e006              B        |L28.36|
                  |L28.22|
;;;204    		
;;;205    		/*关闭一些时钟省电*/
;;;206    		
;;;207    		/*结束*/
;;;208    		
;;;209    //		while(USB->POWER & 0x02)								//suspend flag
;;;210    //		{	
;;;211    //			GPIOB->ODR ^= GPIO_Pin_2;
;;;212    ////			SysTick_Delay_Ms(500);
;;;213    //			if(GPIO_ReadInputDataBit(GPIOC,GPIO_Pin_11) == RESET)//按键唤醒
;;;214    //			{
;;;215    //				/*remote wakeup*/
;;;216    //				USB_Remote_Wakeup();
;;;217    //				
;;;218    //				f_send_kb = 1;
;;;219    //				USB->POWER &= ~0x01;							//不允许挂起模块	
;;;220    //				usb_state = USB_NORMAL;
;;;221    //			}
;;;222    //		}
;;;223    		
;;;224    		
;;;225    		/*重新配置时钟*/	
;;;226    	}
;;;227    	else if(usb_state == USB_RESUME_FLAG)						//自动退出suspend
000016  4804              LDR      r0,|L28.40|
000018  7800              LDRB     r0,[r0,#0]  ; usb_state
00001a  2802              CMP      r0,#2
00001c  d102              BNE      |L28.36|
;;;228    	{
;;;229    		usb_state = USB_NORMAL;
00001e  2000              MOVS     r0,#0
000020  4901              LDR      r1,|L28.40|
000022  7008              STRB     r0,[r1,#0]
                  |L28.36|
;;;230    		/*重新配置时钟*/
;;;231    	}
;;;232    }
000024  4770              BX       lr
;;;233    /******************************************************************************
                          ENDP

000026  0000              DCW      0x0000
                  |L28.40|
                          DCD      usb_state
                  |L28.44|
                          DCD      0x40005c00

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  c_hid_data
                          %        88
                  gpCurIf
                          %        28
                  Device_Info
                          %        15
                  ep1_send_buf
                          %        64
                  ep0state
                          %        17

                          AREA ||.data||, DATA, ALIGN=2

                  INCSRDATA
000000  00                DCB      0x00
                  usb_state
000001  000000            DCB      0x00,0x00,0x00
                  gnDevState
                          DCD      0x00000000
                  gpCurCfg
                          DCD      0x00000000
                  gbyCurIfVal
                          DCD      0x00000000
000010  00000000          DCB      0x00,0x00,0x00,0x00
                  pInformation
                          DCD      Device_Info
                  flag1
                          DCD      0x00000000
                  ||cmd||
                          %        8

                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=1

                  __ARM_common_switch8 PROC
000000  b430              PUSH     {r4,r5}
000002  4674              MOV      r4,lr
000004  1e64              SUBS     r4,r4,#1
000006  7825              LDRB     r5,[r4,#0]
000008  1c64              ADDS     r4,r4,#1
00000a  42ab              CMP      r3,r5
00000c  d304              BCC      |L174.24|
                  |L174.14|
00000e  5d63              LDRB     r3,[r4,r5]
000010  005b              LSLS     r3,r3,#1
000012  18e3              ADDS     r3,r4,r3
000014  bc30              POP      {r4,r5}
000016  4718              BX       r3
                  |L174.24|
000018  461d              MOV      r5,r3
00001a  e7f8              B        |L174.14|
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\usb\\src\\usb_core.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_usb_core_c_cc00d2b3____REV16|
#line 129 "..\\FTLib\\CMSIS\\inc\\core_cmInstr.h"
|__asm___10_usb_core_c_cc00d2b3____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_usb_core_c_cc00d2b3____REVSH|
#line 144
|__asm___10_usb_core_c_cc00d2b3____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
