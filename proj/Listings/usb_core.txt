; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\usb_core.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\usb_core.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\FTLib\CMSIS\inc -I..\FTLib\Inc -I..\FTLib\Lib -I..\usb\inc -I..\user -I..\RTT -I..\iap2 -IC:\Users\dell1\AppData\Local\Arm\Packs\FMD\FT32F0xx_DFP\1.0.6\Drivers\CMSIS\FT32F0xx\Include -D__UVISION_VERSION=534 -DFT32F072x8 -DFT32F072x8 --omf_browse=.\objects\usb_core.crf ..\usb\src\usb_core.c]
                          THUMB

                          AREA ||i.ConfigureIfs||, CODE, READONLY, ALIGN=2

                  ConfigureIfs PROC
;;;1756   */
;;;1757   static uint32_t ConfigureIfs(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1758   {
000002  b087              SUB      sp,sp,#0x1c
;;;1759   	PSTD_CFG_DSCR	pcfg;
;;;1760   	BYTE		byIf, byAltIf, byEP, byNumEPs, by;
;;;1761   	BYTE		*pby;
;;;1762   	BYTE		*pbyIfVal;
;;;1763   	PSTD_IF_DSCR	pif;
;;;1764   	PSTD_EP_DSCR	pep;
;;;1765   
;;;1766   	/* Set pointer to first interface descriptor in current configuration */
;;;1767   	pby = (BYTE *)(gpCurCfg) + sizeof(STD_CFG_DSCR);
000004  487d              LDR      r0,|L1.508|
000006  6800              LDR      r0,[r0,#0]  ; gpCurCfg
000008  4605              MOV      r5,r0
00000a  3509              ADDS     r5,r5,#9
;;;1768   	pif = (PSTD_IF_DSCR)pby;
00000c  462f              MOV      r7,r5
;;;1769   
;;;1770   	/* Loop through all interfaces in the current configuration */
;;;1771   	pcfg = (PSTD_CFG_DSCR)gpCurCfg;
00000e  487b              LDR      r0,|L1.508|
000010  6800              LDR      r0,[r0,#0]  ; gpCurCfg
000012  9006              STR      r0,[sp,#0x18]
;;;1772   	pbyIfVal = (BYTE*)&gbyCurIfVal;	//接口
000014  487a              LDR      r0,|L1.512|
000016  9001              STR      r0,[sp,#4]
;;;1773   
;;;1774   	SEGGER_RTT_printf(0,"ConfigureIfs;  pcfg->bNumInterfaces=%d\n",pcfg->bNumInterfaces);
000018  9806              LDR      r0,[sp,#0x18]
00001a  7902              LDRB     r2,[r0,#4]
00001c  a179              ADR      r1,|L1.516|
00001e  2000              MOVS     r0,#0
000020  f7fffffe          BL       SEGGER_RTT_printf
;;;1775   	for (byIf=0; byIf < pcfg->bNumInterfaces; byIf++, pbyIfVal++) 
000024  2000              MOVS     r0,#0
000026  9005              STR      r0,[sp,#0x14]
000028  e0e0              B        |L1.492|
                  |L1.42|
;;;1776   	{
;;;1777   		SEGGER_RTT_printf(0,"ConfigureIfs; byIf=%d	byAltIf=%d pbyIfVal=%d\n",byIf,byAltIf ,*pbyIfVal);
00002a  9801              LDR      r0,[sp,#4]
00002c  7800              LDRB     r0,[r0,#0]
00002e  9000              STR      r0,[sp,#0]
000030  a17e              ADR      r1,|L1.556|
000032  2000              MOVS     r0,#0
000034  9b04              LDR      r3,[sp,#0x10]
000036  9a05              LDR      r2,[sp,#0x14]
000038  f7fffffe          BL       SEGGER_RTT_printf
;;;1778   		/* Advance pointer to selected alternate interface descriptor */
;;;1779   		if (*pbyIfVal) 
00003c  9801              LDR      r0,[sp,#4]
00003e  7800              LDRB     r0,[r0,#0]
000040  2800              CMP      r0,#0
000042  d024              BEQ      |L1.142|
;;;1780   		{
;;;1781   		
;;;1782   	
;;;1783   			for (byAltIf=0; byAltIf<*pbyIfVal; byAltIf++) 
000044  2000              MOVS     r0,#0
000046  9004              STR      r0,[sp,#0x10]
000048  e01c              B        |L1.132|
                  |L1.74|
;;;1784   			{
;;;1785   				byNumEPs = pif->bNumEndpoints;
00004a  7938              LDRB     r0,[r7,#4]
00004c  9002              STR      r0,[sp,#8]
;;;1786   				
;;;1787   				SEGGER_RTT_printf(0,"ConfigureIfs; byAltIf=%d	byNumEPs=%d\n",byNumEPs,byAltIf);
00004e  a183              ADR      r1,|L1.604|
000050  2000              MOVS     r0,#0
000052  9b04              LDR      r3,[sp,#0x10]
000054  9a02              LDR      r2,[sp,#8]
000056  f7fffffe          BL       SEGGER_RTT_printf
;;;1788   				pby += sizeof(STD_IF_DSCR) + byNumEPs * sizeof(STD_EP_DSCR) /*+ sizeof(STD_HID_DSCR)*/;
00005a  9802              LDR      r0,[sp,#8]
00005c  00c1              LSLS     r1,r0,#3
00005e  1a08              SUBS     r0,r1,r0
000060  3009              ADDS     r0,r0,#9
000062  182d              ADDS     r5,r5,r0
;;;1789   				pif  = (PSTD_IF_DSCR)pby;
000064  462f              MOV      r7,r5
;;;1790   				/* Check an alternate setting > number of alternates not specified */
;;;1791   				if (!pif->bAlternateSetting)
000066  78f8              LDRB     r0,[r7,#3]
000068  2800              CMP      r0,#0
00006a  d107              BNE      |L1.124|
;;;1792   				{
;;;1793   				
;;;1794   				SEGGER_RTT_printf(0,"ConfigureIfs; byAltIf=%d	byNumEPs=%d !pif->bAlternateSetting\n",byNumEPs,byAltIf);
00006c  a185              ADR      r1,|L1.644|
00006e  9b04              LDR      r3,[sp,#0x10]
000070  9a02              LDR      r2,[sp,#8]
000072  f7fffffe          BL       SEGGER_RTT_printf
;;;1795   					return FALSE;
000076  2000              MOVS     r0,#0
                  |L1.120|
;;;1796   				}
;;;1797   			} 
;;;1798   		}
;;;1799   
;;;1800   		/* Store pointer to interface in global array */
;;;1801   		gpCurIf[byIf] = pif;
;;;1802   		SEGGER_RTT_printf(0,"aa ConfigureIfs;	pif->bNumEndpoints=%d\n",pif->bNumEndpoints);
;;;1803   
;;;1804   		/* Loop through all endpoints in interface */
;;;1805   		byNumEPs = pif->bNumEndpoints;
;;;1806   		
;;;1807   		SEGGER_RTT_printf(0,"bbb ConfigureIfs;	pif->bNumEndpoints=%d\n",pif->bNumEndpoints);
;;;1808   		pby += sizeof(STD_IF_DSCR) /*+ sizeof(STD_HID_DSCR)*/;	//endpoint
;;;1809   		
;;;1810   		SEGGER_RTT_printf(0,"ccc ConfigureIfs;	pif->bNumEndpoints=%d\n",pif->bNumEndpoints);
;;;1811   		for ( byEP = 0; byEP < byNumEPs; byEP++ )
;;;1812   		{
;;;1813   		
;;;1814   		SEGGER_RTT_printf(0,"ddd ConfigureIfs;	pep->bEndpointAddress=0x%02x\n",pep->bEndpointAddress);
;;;1815   			pep = (PSTD_EP_DSCR)pby;
;;;1816   			SEGGER_RTT_printf(0,"ee ConfigureIfs;	pep->bEndpointAddress=0x%02x\n",pep->bEndpointAddress);
;;;1817   
;;;1818   			/* Configure the endpoint */
;;;1819   			MWRITE_BYTE(M_REG_INDEX, (pep->bEndpointAddress & 0x0F));
;;;1820   			
;;;1821   			SEGGER_RTT_printf(0,"ff ConfigureIfs;	pep->bEndpointAddress=0x%02x\n",pep->bEndpointAddress);
;;;1822   			/* Round up max packet size to a multiple of 8 for writing to MaxP registers */
;;;1823   			by = (BYTE)((pep->wMaxPacketSize + 7) >> 3);
;;;1824   			
;;;1825   			SEGGER_RTT_printf(0,"33 ConfigureIfs;	pep->bEndpointAddress=0x%02x\n",pep->bEndpointAddress);
;;;1826   			if(pep->bEndpointAddress & 0x80)
;;;1827   			{
;;;1828   			
;;;1829   			SEGGER_RTT_printf(0,"444 ConfigureIfs;	pep->bEndpointAddress=0x%02x\n",pep->bEndpointAddress);
;;;1830   				MWRITE_BYTE(M_REG_INMAXP, by);
;;;1831   				by = MREAD_BYTE(M_REG_INCSR2);
;;;1832   				
;;;1833   				SEGGER_RTT_printf(0,"66 ConfigureIfs;	pep->bmAttributes=0x%02x\n",pep->bmAttributes);
;;;1834   				
;;;1835   				SEGGER_RTT_printf(0,"66 ConfigureIfs;	pep->bmAttributes=0x%02x\n",(pep->bmAttributes & M_EP_TFMASK));
;;;1836   				switch (pep->bmAttributes & M_EP_TFMASK)
;;;1837   				{
;;;1838   					case M_EP_ISO:
;;;1839   						
;;;1840   						SEGGER_RTT_printf(0,"555 ConfigureIfs;	pep->bEndpointAddress=0x%02x\n",pep->bEndpointAddress);
;;;1841   						by |= M_INCSR2_ISO;
;;;1842   					break;
;;;1843   					case M_EP_BULK:
;;;1844   					case M_EP_INTR:		
;;;1845   						
;;;1846   						SEGGER_RTT_printf(0,"777 ConfigureIfs;	pep->bmAttributes=0x%02x\n",pep->bmAttributes);
;;;1847   						by &= ~M_INCSR2_ISO;
;;;1848   					break;
;;;1849   				}
;;;1850   				
;;;1851   				/* Set mode bit high (only strictly necessary if sharing a FIFO) */
;;;1852   				by |= M_INCSR2_MODE;
;;;1853   				
;;;1854   				MWRITE_BYTE(M_REG_INCSR2, by);
;;;1855   				
;;;1856   				/* Other configuration for an IN endpoint */
;;;1857   				/* e.g. AutoClr, DMA */
;;;1858   				/* should be added here */
;;;1859   			}
;;;1860   			else
;;;1861   			{
;;;1862   				MWRITE_BYTE(M_REG_OUTMAXP, by);
;;;1863   				by = MREAD_BYTE(M_REG_OUTCSR2);
;;;1864   				
;;;1865   				SEGGER_RTT_printf(0,"999 ConfigureIfs;	pep->bmAttributes=0x%02x\n",pep->bmAttributes);
;;;1866   				switch (pep->bmAttributes & M_EP_TFMASK)
;;;1867   				{
;;;1868   					case M_EP_ISO:
;;;1869   						
;;;1870   						SEGGER_RTT_printf(0,"hhh ConfigureIfs;	pep->bmAttributes=0x%02x\n",pep->bmAttributes);
;;;1871   						by |= M_OUTCSR2_ISO;
;;;1872   					break;
;;;1873   					case M_EP_BULK:
;;;1874   					case M_EP_INTR:
;;;1875   						
;;;1876   						SEGGER_RTT_printf(0,"ffff ConfigureIfs;	pep->bmAttributes=0x%02x\n",pep->bmAttributes);
;;;1877   						by &= ~M_OUTCSR2_ISO;
;;;1878   					break;
;;;1879   				}
;;;1880   				MWRITE_BYTE(M_REG_OUTCSR2, by);
;;;1881   				/* Other configuration for an OUT endpoint */
;;;1882   				/* e.g. AutoSet, DMA */
;;;1883   				/* should be added here */
;;;1884   			}
;;;1885   			
;;;1886   			pby += sizeof(STD_EP_DSCR);	
;;;1887   		}
;;;1888   	}
;;;1889   
;;;1890   	return TRUE;
;;;1891   }
000078  b007              ADD      sp,sp,#0x1c
00007a  bdf0              POP      {r4-r7,pc}
                  |L1.124|
00007c  9804              LDR      r0,[sp,#0x10]         ;1783
00007e  1c40              ADDS     r0,r0,#1              ;1783
000080  b2c0              UXTB     r0,r0                 ;1783
000082  9004              STR      r0,[sp,#0x10]         ;1783
                  |L1.132|
000084  9801              LDR      r0,[sp,#4]            ;1783
000086  7801              LDRB     r1,[r0,#0]            ;1783
000088  9804              LDR      r0,[sp,#0x10]         ;1783
00008a  4281              CMP      r1,r0                 ;1783
00008c  dcdd              BGT      |L1.74|
                  |L1.142|
00008e  9805              LDR      r0,[sp,#0x14]         ;1801
000090  0080              LSLS     r0,r0,#2              ;1801
000092  498c              LDR      r1,|L1.708|
000094  500f              STR      r7,[r1,r0]            ;1801
000096  793a              LDRB     r2,[r7,#4]            ;1802
000098  a18b              ADR      r1,|L1.712|
00009a  2000              MOVS     r0,#0                 ;1802
00009c  f7fffffe          BL       SEGGER_RTT_printf
0000a0  7938              LDRB     r0,[r7,#4]            ;1805
0000a2  9002              STR      r0,[sp,#8]            ;1805
0000a4  793a              LDRB     r2,[r7,#4]            ;1807
0000a6  a192              ADR      r1,|L1.752|
0000a8  2000              MOVS     r0,#0                 ;1807
0000aa  f7fffffe          BL       SEGGER_RTT_printf
0000ae  3509              ADDS     r5,r5,#9              ;1808
0000b0  793a              LDRB     r2,[r7,#4]            ;1810
0000b2  a19a              ADR      r1,|L1.796|
0000b4  2000              MOVS     r0,#0                 ;1810
0000b6  f7fffffe          BL       SEGGER_RTT_printf
0000ba  2000              MOVS     r0,#0                 ;1811
0000bc  9003              STR      r0,[sp,#0xc]          ;1811
0000be  e089              B        |L1.468|
                  |L1.192|
0000c0  78a2              LDRB     r2,[r4,#2]            ;1814
0000c2  a1a1              ADR      r1,|L1.840|
0000c4  2000              MOVS     r0,#0                 ;1814
0000c6  f7fffffe          BL       SEGGER_RTT_printf
0000ca  462c              MOV      r4,r5                 ;1815
0000cc  78a2              LDRB     r2,[r4,#2]            ;1816
0000ce  a1aa              ADR      r1,|L1.888|
0000d0  2000              MOVS     r0,#0                 ;1816
0000d2  f7fffffe          BL       SEGGER_RTT_printf
0000d6  78a0              LDRB     r0,[r4,#2]            ;1819
0000d8  0700              LSLS     r0,r0,#28             ;1819
0000da  0f00              LSRS     r0,r0,#28             ;1819
0000dc  49b2              LDR      r1,|L1.936|
0000de  7388              STRB     r0,[r1,#0xe]          ;1819
0000e0  78a2              LDRB     r2,[r4,#2]            ;1821
0000e2  a1b2              ADR      r1,|L1.940|
0000e4  2000              MOVS     r0,#0                 ;1821
0000e6  f7fffffe          BL       SEGGER_RTT_printf
0000ea  7960              LDRB     r0,[r4,#5]            ;1823
0000ec  7921              LDRB     r1,[r4,#4]            ;1823
0000ee  0200              LSLS     r0,r0,#8              ;1823
0000f0  4308              ORRS     r0,r0,r1              ;1823
0000f2  1dc0              ADDS     r0,r0,#7              ;1823
0000f4  0540              LSLS     r0,r0,#21             ;1823
0000f6  0e06              LSRS     r6,r0,#24             ;1823
0000f8  78a2              LDRB     r2,[r4,#2]            ;1825
0000fa  a1b8              ADR      r1,|L1.988|
0000fc  2000              MOVS     r0,#0                 ;1825
0000fe  f7fffffe          BL       SEGGER_RTT_printf
000102  78a0              LDRB     r0,[r4,#2]            ;1826
000104  2180              MOVS     r1,#0x80              ;1826
000106  4008              ANDS     r0,r0,r1              ;1826
000108  2800              CMP      r0,#0                 ;1826
00010a  d036              BEQ      |L1.378|
00010c  78a2              LDRB     r2,[r4,#2]            ;1829
00010e  a1bf              ADR      r1,|L1.1036|
000110  2000              MOVS     r0,#0                 ;1829
000112  f7fffffe          BL       SEGGER_RTT_printf
000116  48a4              LDR      r0,|L1.936|
000118  7406              STRB     r6,[r0,#0x10]         ;1830
00011a  7c86              LDRB     r6,[r0,#0x12]         ;1831
00011c  78e2              LDRB     r2,[r4,#3]            ;1833
00011e  a1c7              ADR      r1,|L1.1084|
000120  2000              MOVS     r0,#0                 ;1833
000122  f7fffffe          BL       SEGGER_RTT_printf
000126  78e0              LDRB     r0,[r4,#3]            ;1835
000128  0782              LSLS     r2,r0,#30             ;1835
00012a  0f92              LSRS     r2,r2,#30             ;1835
00012c  a1c3              ADR      r1,|L1.1084|
00012e  2000              MOVS     r0,#0                 ;1835
000130  f7fffffe          BL       SEGGER_RTT_printf
000134  78e0              LDRB     r0,[r4,#3]            ;1836
000136  0780              LSLS     r0,r0,#30             ;1836
000138  0f80              LSRS     r0,r0,#30             ;1836
00013a  2801              CMP      r0,#1                 ;1836
00013c  d004              BEQ      |L1.328|
00013e  2802              CMP      r0,#2                 ;1836
000140  d00a              BEQ      |L1.344|
000142  2803              CMP      r0,#3                 ;1836
000144  d113              BNE      |L1.366|
000146  e008              B        |L1.346|
                  |L1.328|
000148  78a2              LDRB     r2,[r4,#2]            ;1840
00014a  a1c7              ADR      r1,|L1.1128|
00014c  2000              MOVS     r0,#0                 ;1840
00014e  f7fffffe          BL       SEGGER_RTT_printf
000152  2040              MOVS     r0,#0x40              ;1841
000154  4306              ORRS     r6,r6,r0              ;1841
000156  e00a              B        |L1.366|
                  |L1.344|
000158  bf00              NOP                            ;1844
                  |L1.346|
00015a  78e2              LDRB     r2,[r4,#3]            ;1846
00015c  a1ce              ADR      r1,|L1.1176|
00015e  2000              MOVS     r0,#0                 ;1846
000160  f7fffffe          BL       SEGGER_RTT_printf
000164  2140              MOVS     r1,#0x40              ;1847
000166  4630              MOV      r0,r6                 ;1847
000168  4388              BICS     r0,r0,r1              ;1847
00016a  4606              MOV      r6,r0                 ;1847
00016c  bf00              NOP                            ;1848
                  |L1.366|
00016e  bf00              NOP                            ;1842
000170  2020              MOVS     r0,#0x20              ;1852
000172  4306              ORRS     r6,r6,r0              ;1852
000174  488c              LDR      r0,|L1.936|
000176  7486              STRB     r6,[r0,#0x12]         ;1854
000178  e027              B        |L1.458|
                  |L1.378|
00017a  488b              LDR      r0,|L1.936|
00017c  74c6              STRB     r6,[r0,#0x13]         ;1862
00017e  7d46              LDRB     r6,[r0,#0x15]         ;1863
000180  78e2              LDRB     r2,[r4,#3]            ;1865
000182  a1d0              ADR      r1,|L1.1220|
000184  2000              MOVS     r0,#0                 ;1865
000186  f7fffffe          BL       SEGGER_RTT_printf
00018a  78e0              LDRB     r0,[r4,#3]            ;1866
00018c  0780              LSLS     r0,r0,#30             ;1866
00018e  0f80              LSRS     r0,r0,#30             ;1866
000190  2801              CMP      r0,#1                 ;1866
000192  d004              BEQ      |L1.414|
000194  2802              CMP      r0,#2                 ;1866
000196  d00a              BEQ      |L1.430|
000198  2803              CMP      r0,#3                 ;1866
00019a  d113              BNE      |L1.452|
00019c  e008              B        |L1.432|
                  |L1.414|
00019e  78e2              LDRB     r2,[r4,#3]            ;1870
0001a0  a1d3              ADR      r1,|L1.1264|
0001a2  2000              MOVS     r0,#0                 ;1870
0001a4  f7fffffe          BL       SEGGER_RTT_printf
0001a8  2040              MOVS     r0,#0x40              ;1871
0001aa  4306              ORRS     r6,r6,r0              ;1871
0001ac  e00a              B        |L1.452|
                  |L1.430|
0001ae  bf00              NOP                            ;1874
                  |L1.432|
0001b0  78e2              LDRB     r2,[r4,#3]            ;1876
0001b2  a1da              ADR      r1,|L1.1308|
0001b4  2000              MOVS     r0,#0                 ;1876
0001b6  f7fffffe          BL       SEGGER_RTT_printf
0001ba  2140              MOVS     r1,#0x40              ;1877
0001bc  4630              MOV      r0,r6                 ;1877
0001be  4388              BICS     r0,r0,r1              ;1877
0001c0  4606              MOV      r6,r0                 ;1877
0001c2  bf00              NOP                            ;1878
                  |L1.452|
0001c4  bf00              NOP                            ;1872
0001c6  4878              LDR      r0,|L1.936|
0001c8  7546              STRB     r6,[r0,#0x15]         ;1880
                  |L1.458|
0001ca  1ded              ADDS     r5,r5,#7              ;1886
0001cc  9803              LDR      r0,[sp,#0xc]          ;1811
0001ce  1c40              ADDS     r0,r0,#1              ;1811
0001d0  b2c0              UXTB     r0,r0                 ;1811
0001d2  9003              STR      r0,[sp,#0xc]          ;1811
                  |L1.468|
0001d4  9902              LDR      r1,[sp,#8]            ;1811
0001d6  9803              LDR      r0,[sp,#0xc]          ;1811
0001d8  4288              CMP      r0,r1                 ;1811
0001da  da00              BGE      |L1.478|
0001dc  e770              B        |L1.192|
                  |L1.478|
0001de  9805              LDR      r0,[sp,#0x14]         ;1775
0001e0  1c40              ADDS     r0,r0,#1              ;1775
0001e2  b2c0              UXTB     r0,r0                 ;1775
0001e4  9005              STR      r0,[sp,#0x14]         ;1775
0001e6  9801              LDR      r0,[sp,#4]            ;1775
0001e8  1c40              ADDS     r0,r0,#1              ;1775
0001ea  9001              STR      r0,[sp,#4]            ;1775
                  |L1.492|
0001ec  9806              LDR      r0,[sp,#0x18]         ;1775
0001ee  7901              LDRB     r1,[r0,#4]            ;1775
0001f0  9805              LDR      r0,[sp,#0x14]         ;1775
0001f2  4281              CMP      r1,r0                 ;1775
0001f4  dd00              BLE      |L1.504|
0001f6  e718              B        |L1.42|
                  |L1.504|
0001f8  2001              MOVS     r0,#1                 ;1890
0001fa  e73d              B        |L1.120|
;;;1892   
                          ENDP

                  |L1.508|
                          DCD      gpCurCfg
                  |L1.512|
                          DCD      gbyCurIfVal
                  |L1.516|
000204  436f6e66          DCB      "ConfigureIfs;  pcfg->bNumInterfaces=%d\n",0
000208  69677572
00020c  65496673
000210  3b202070
000214  6366672d
000218  3e624e75
00021c  6d496e74
000220  65726661
000224  6365733d
000228  25640a00
                  |L1.556|
00022c  436f6e66          DCB      "ConfigureIfs; byIf=%d\tbyAltIf=%d pbyIfVal=%d\n",0
000230  69677572
000234  65496673
000238  3b206279
00023c  49663d25
000240  64096279
000244  416c7449
000248  663d2564
00024c  20706279
000250  49665661
000254  6c3d2564
000258  0a00    
00025a  00                DCB      0
00025b  00                DCB      0
                  |L1.604|
00025c  436f6e66          DCB      "ConfigureIfs; byAltIf=%d\tbyNumEPs=%d\n",0
000260  69677572
000264  65496673
000268  3b206279
00026c  416c7449
000270  663d2564
000274  0962794e
000278  756d4550
00027c  733d2564
000280  0a00    
000282  00                DCB      0
000283  00                DCB      0
                  |L1.644|
000284  436f6e66          DCB      "ConfigureIfs; byAltIf=%d\tbyNumEPs=%d !pif->bAlternateS"
000288  69677572
00028c  65496673
000290  3b206279
000294  416c7449
000298  663d2564
00029c  0962794e
0002a0  756d4550
0002a4  733d2564
0002a8  20217069
0002ac  662d3e62
0002b0  416c7465
0002b4  726e6174
0002b8  6553    
0002ba  65747469          DCB      "etting\n",0
0002be  6e670a00
0002c2  00                DCB      0
0002c3  00                DCB      0
                  |L1.708|
                          DCD      gpCurIf
                  |L1.712|
0002c8  61612043          DCB      "aa ConfigureIfs;\tpif->bNumEndpoints=%d\n",0
0002cc  6f6e6669
0002d0  67757265
0002d4  4966733b
0002d8  09706966
0002dc  2d3e624e
0002e0  756d456e
0002e4  64706f69
0002e8  6e74733d
0002ec  25640a00
                  |L1.752|
0002f0  62626220          DCB      "bbb ConfigureIfs;\tpif->bNumEndpoints=%d\n",0
0002f4  436f6e66
0002f8  69677572
0002fc  65496673
000300  3b097069
000304  662d3e62
000308  4e756d45
00030c  6e64706f
000310  696e7473
000314  3d25640a
000318  00      
000319  00                DCB      0
00031a  00                DCB      0
00031b  00                DCB      0
                  |L1.796|
00031c  63636320          DCB      "ccc ConfigureIfs;\tpif->bNumEndpoints=%d\n",0
000320  436f6e66
000324  69677572
000328  65496673
00032c  3b097069
000330  662d3e62
000334  4e756d45
000338  6e64706f
00033c  696e7473
000340  3d25640a
000344  00      
000345  00                DCB      0
000346  00                DCB      0
000347  00                DCB      0
                  |L1.840|
000348  64646420          DCB      "ddd ConfigureIfs;\tpep->bEndpointAddress=0x%02x\n",0
00034c  436f6e66
000350  69677572
000354  65496673
000358  3b097065
00035c  702d3e62
000360  456e6470
000364  6f696e74
000368  41646472
00036c  6573733d
000370  30782530
000374  32780a00
                  |L1.888|
000378  65652043          DCB      "ee ConfigureIfs;\tpep->bEndpointAddress=0x%02x\n",0
00037c  6f6e6669
000380  67757265
000384  4966733b
000388  09706570
00038c  2d3e6245
000390  6e64706f
000394  696e7441
000398  64647265
00039c  73733d30
0003a0  78253032
0003a4  780a00  
0003a7  00                DCB      0
                  |L1.936|
                          DCD      0x40005c00
                  |L1.940|
0003ac  66662043          DCB      "ff ConfigureIfs;\tpep->bEndpointAddress=0x%02x\n",0
0003b0  6f6e6669
0003b4  67757265
0003b8  4966733b
0003bc  09706570
0003c0  2d3e6245
0003c4  6e64706f
0003c8  696e7441
0003cc  64647265
0003d0  73733d30
0003d4  78253032
0003d8  780a00  
0003db  00                DCB      0
                  |L1.988|
0003dc  33332043          DCB      "33 ConfigureIfs;\tpep->bEndpointAddress=0x%02x\n",0
0003e0  6f6e6669
0003e4  67757265
0003e8  4966733b
0003ec  09706570
0003f0  2d3e6245
0003f4  6e64706f
0003f8  696e7441
0003fc  64647265
000400  73733d30
000404  78253032
000408  780a00  
00040b  00                DCB      0
                  |L1.1036|
00040c  34343420          DCB      "444 ConfigureIfs;\tpep->bEndpointAddress=0x%02x\n",0
000410  436f6e66
000414  69677572
000418  65496673
00041c  3b097065
000420  702d3e62
000424  456e6470
000428  6f696e74
00042c  41646472
000430  6573733d
000434  30782530
000438  32780a00
                  |L1.1084|
00043c  36362043          DCB      "66 ConfigureIfs;\tpep->bmAttributes=0x%02x\n",0
000440  6f6e6669
000444  67757265
000448  4966733b
00044c  09706570
000450  2d3e626d
000454  41747472
000458  69627574
00045c  65733d30
000460  78253032
000464  780a00  
000467  00                DCB      0
                  |L1.1128|
000468  35353520          DCB      "555 ConfigureIfs;\tpep->bEndpointAddress=0x%02x\n",0
00046c  436f6e66
000470  69677572
000474  65496673
000478  3b097065
00047c  702d3e62
000480  456e6470
000484  6f696e74
000488  41646472
00048c  6573733d
000490  30782530
000494  32780a00
                  |L1.1176|
000498  37373720          DCB      "777 ConfigureIfs;\tpep->bmAttributes=0x%02x\n",0
00049c  436f6e66
0004a0  69677572
0004a4  65496673
0004a8  3b097065
0004ac  702d3e62
0004b0  6d417474
0004b4  72696275
0004b8  7465733d
0004bc  30782530
0004c0  32780a00
                  |L1.1220|
0004c4  39393920          DCB      "999 ConfigureIfs;\tpep->bmAttributes=0x%02x\n",0
0004c8  436f6e66
0004cc  69677572
0004d0  65496673
0004d4  3b097065
0004d8  702d3e62
0004dc  6d417474
0004e0  72696275
0004e4  7465733d
0004e8  30782530
0004ec  32780a00
                  |L1.1264|
0004f0  68686820          DCB      "hhh ConfigureIfs;\tpep->bmAttributes=0x%02x\n",0
0004f4  436f6e66
0004f8  69677572
0004fc  65496673
000500  3b097065
000504  702d3e62
000508  6d417474
00050c  72696275
000510  7465733d
000514  30782530
000518  32780a00
                  |L1.1308|
00051c  66666666          DCB      "ffff ConfigureIfs;\tpep->bmAttributes=0x%02x\n",0
000520  20436f6e
000524  66696775
000528  72654966
00052c  733b0970
000530  65702d3e
000534  626d4174
000538  74726962
00053c  75746573
000540  3d307825
000544  3032780a
000548  00      
000549  00                DCB      0
00054a  00                DCB      0
00054b  00                DCB      0

                          AREA ||i.EndpointBulkIn||, CODE, READONLY, ALIGN=2

                  EndpointBulkIn PROC
;;;381    */
;;;382    void EndpointBulkIn(M_EPBIN_STATUS pbistate, int nCallState)
000000  b57f              PUSH     {r0-r6,lr}
;;;383    {
000002  461e              MOV      r6,r3
;;;384    	int     nBytes;
;;;385    	BYTE    byInCSR;
;;;386    
;;;387    	/* Reset endpoint */
;;;388    	if(nCallState == M_EP_RESET)
000004  2e01              CMP      r6,#1
000006  d107              BNE      |L2.24|
;;;389    	{
;;;390    		/*切换端点号*/
;;;391    		MWRITE_BYTE(M_REG_INDEX, pbistate.byEP);
000008  4668              MOV      r0,sp
00000a  7a00              LDRB     r0,[r0,#8]
00000c  491a              LDR      r1,|L2.120|
00000e  7388              STRB     r0,[r1,#0xe]
;;;392    		/*清除相应端点的数据翻转状态和清空FIFO中要发送的数据*/
;;;393    		byInCSR = M_INCSR_CDT | M_INCSR_FF;
000010  2548              MOVS     r5,#0x48
;;;394    		MWRITE_BYTE(M_REG_INCSR1, byInCSR);
000012  4608              MOV      r0,r1
000014  7445              STRB     r5,[r0,#0x11]
000016  e02e              B        |L2.118|
                  |L2.24|
;;;395    	}
;;;396    	else
;;;397    	{
;;;398    	
;;;399    	SEGGER_RTT_printf(0,"EndpointBulkIn pbistate.nBytesLeft=%d\n",pbistate.nBytesLeft);
000018  a118              ADR      r1,|L2.124|
00001a  2000              MOVS     r0,#0
00001c  9a01              LDR      r2,[sp,#4]
00001e  f7fffffe          BL       SEGGER_RTT_printf
;;;400    		/* Check whether there is any data to send */ 
;;;401    		if(pbistate.nBytesLeft != M_EP_NODATA)
000022  9801              LDR      r0,[sp,#4]
000024  1c40              ADDS     r0,r0,#1
000026  2800              CMP      r0,#0
000028  d025              BEQ      |L2.118|
;;;402    		{
;;;403    			/* Determine number of bytes to send */
;;;404    			if(pbistate.nBytesLeft < M_EP_MAXP)
00002a  9801              LDR      r0,[sp,#4]
00002c  2840              CMP      r0,#0x40
00002e  da04              BGE      |L2.58|
;;;405    			{
;;;406    				nBytes = pbistate.nBytesLeft;
000030  9c01              LDR      r4,[sp,#4]
;;;407    				pbistate.nBytesLeft = M_EP_NODATA;
000032  2000              MOVS     r0,#0
000034  43c0              MVNS     r0,r0
000036  9001              STR      r0,[sp,#4]
000038  e003              B        |L2.66|
                  |L2.58|
;;;408    			}
;;;409    			else 
;;;410    			{
;;;411    				nBytes = M_EP_MAXP;
00003a  2440              MOVS     r4,#0x40
;;;412    				pbistate.nBytesLeft -= M_EP_MAXP;
00003c  9801              LDR      r0,[sp,#4]
00003e  3840              SUBS     r0,r0,#0x40
000040  9001              STR      r0,[sp,#4]
                  |L2.66|
;;;413    			}
;;;414    			SEGGER_RTT_printf(0,"222 EndpointBulkIn pbistate.nBytesLeft=%d\n",pbistate.nBytesLeft);
000042  a118              ADR      r1,|L2.164|
000044  2000              MOVS     r0,#0
000046  9a01              LDR      r2,[sp,#4]
000048  f7fffffe          BL       SEGGER_RTT_printf
;;;415    
;;;416    			/* Load FIFO */
;;;417    			FIFOWrite((int)pbistate.byEP, nBytes, pbistate.pData);
00004c  4669              MOV      r1,sp
00004e  7a08              LDRB     r0,[r1,#8]
000050  4621              MOV      r1,r4
000052  9a00              LDR      r2,[sp,#0]
000054  f7fffffe          BL       FIFOWrite
;;;418    			
;;;419    			SEGGER_RTT_printf(0,"333 EndpointBulkIn nBytes=%d\n",nBytes);
000058  4622              MOV      r2,r4
00005a  a11d              ADR      r1,|L2.208|
00005c  2000              MOVS     r0,#0
00005e  f7fffffe          BL       SEGGER_RTT_printf
;;;420    			pbistate.pData = (BYTE *)pbistate.pData + nBytes;
000062  9800              LDR      r0,[sp,#0]
000064  1900              ADDS     r0,r0,r4
000066  9000              STR      r0,[sp,#0]
;;;421    
;;;422    			MWRITE_BYTE(M_REG_INDEX, pbistate.byEP);
000068  4669              MOV      r1,sp
00006a  7a08              LDRB     r0,[r1,#8]
00006c  4902              LDR      r1,|L2.120|
00006e  7388              STRB     r0,[r1,#0xe]
;;;423    			/*表示要发送的数据已经装入相应端点的FIFO中*/
;;;424    			byInCSR = M_INCSR_IPR;
000070  2501              MOVS     r5,#1
;;;425    			MWRITE_BYTE(M_REG_INCSR1, byInCSR);
000072  4608              MOV      r0,r1
000074  7445              STRB     r5,[r0,#0x11]
                  |L2.118|
;;;426    		}
;;;427    	}
;;;428    }
000076  bd7f              POP      {r0-r6,pc}
;;;429    
                          ENDP

                  |L2.120|
                          DCD      0x40005c00
                  |L2.124|
00007c  456e6470          DCB      "EndpointBulkIn pbistate.nBytesLeft=%d\n",0
000080  6f696e74
000084  42756c6b
000088  496e2070
00008c  62697374
000090  6174652e
000094  6e427974
000098  65734c65
00009c  66743d25
0000a0  640a00  
0000a3  00                DCB      0
                  |L2.164|
0000a4  32323220          DCB      "222 EndpointBulkIn pbistate.nBytesLeft=%d\n",0
0000a8  456e6470
0000ac  6f696e74
0000b0  42756c6b
0000b4  496e2070
0000b8  62697374
0000bc  6174652e
0000c0  6e427974
0000c4  65734c65
0000c8  66743d25
0000cc  640a00  
0000cf  00                DCB      0
                  |L2.208|
0000d0  33333320          DCB      "333 EndpointBulkIn nBytes=%d\n",0
0000d4  456e6470
0000d8  6f696e74
0000dc  42756c6b
0000e0  496e206e
0000e4  42797465
0000e8  733d2564
0000ec  0a00    
0000ee  00                DCB      0
0000ef  00                DCB      0

                          AREA ||i.EndpointBulkOut||, CODE, READONLY, ALIGN=2

                  EndpointBulkOut PROC
;;;441    */
;;;442    int EndpointBulkOut(M_EPBOUT_STATUS pbostate, int nCallState)
000000  b57f              PUSH     {r0-r6,lr}
;;;443    {
000002  9e08              LDR      r6,[sp,#0x20]
;;;444    	int     nBytes;
;;;445    	BYTE    byOutCSR;
;;;446    
;;;447    	/* Reset endpoint */
;;;448    	if(nCallState == M_EP_RESET)
000004  2e01              CMP      r6,#1
000006  d107              BNE      |L3.24|
;;;449    	{
;;;450    		/***配置端点号***/
;;;451    		MWRITE_BYTE(M_REG_INDEX, pbostate.byEP);
000008  4668              MOV      r0,sp
00000a  7b00              LDRB     r0,[r0,#0xc]
00000c  4919              LDR      r1,|L3.116|
00000e  7388              STRB     r0,[r1,#0xe]
;;;452    		byOutCSR = M_OUTCSR_CDT | M_OUTCSR_FF;
000010  2590              MOVS     r5,#0x90
;;;453    		/***复位端点的数据反转状态,清空接收 FIFO 中的数据***/
;;;454    		MWRITE_BYTE(M_REG_OUTCSR1, byOutCSR);
000012  4608              MOV      r0,r1
000014  7505              STRB     r5,[r0,#0x14]
000016  e02b              B        |L3.112|
                  |L3.24|
;;;455    	}
;;;456    	else
;;;457    	{
;;;458    		/* Set index register */
;;;459    		MWRITE_BYTE(M_REG_INDEX, pbostate.byEP);
000018  4668              MOV      r0,sp
00001a  7b00              LDRB     r0,[r0,#0xc]
00001c  4915              LDR      r1,|L3.116|
00001e  7388              STRB     r0,[r1,#0xe]
;;;460    
;;;461    		/* Read OUT CSR register */
;;;462    		byOutCSR = MREAD_BYTE(M_REG_OUTCSR1);
000020  4608              MOV      r0,r1
000022  7d05              LDRB     r5,[r0,#0x14]
;;;463    
;;;464    		/* Get packet, */
;;;465    		/* may need to unload more than one packet if double buffering enabled */
;;;466    		/*端点FIFO 中有数据*/
;;;467    		while(byOutCSR & M_OUTCSR_OPR)
000024  e020              B        |L3.104|
                  |L3.38|
;;;468    		{
;;;469    			/* Get packet size */
;;;470    			nBytes = (int)MREAD_BYTE(M_REG_OUTCOUNT2);
000026  4813              LDR      r0,|L3.116|
000028  7dc4              LDRB     r4,[r0,#0x17]
;;;471    			nBytes <<= 8;
00002a  0224              LSLS     r4,r4,#8
;;;472    			nBytes |= (int)MREAD_BYTE(M_REG_OUTCOUNT1);
00002c  7d80              LDRB     r0,[r0,#0x16]
00002e  4304              ORRS     r4,r4,r0
;;;473    
;;;474    			/* Check there is room in the buffer */
;;;475    			if(pbostate.nBytesRecv + nBytes > pbostate.nBuffLen)
000030  9802              LDR      r0,[sp,#8]
000032  1900              ADDS     r0,r0,r4
000034  9901              LDR      r1,[sp,#4]
000036  4288              CMP      r0,r1
000038  dd05              BLE      |L3.70|
;;;476    			{
;;;477    				/* Call to function to handle buffer over run */
;;;478    				MWRITE_BYTE(M_REG_OUTCSR1, 0);
00003a  2000              MOVS     r0,#0
00003c  490d              LDR      r1,|L3.116|
00003e  7508              STRB     r0,[r1,#0x14]
;;;479    				return nBytes;
000040  4620              MOV      r0,r4
                  |L3.66|
;;;480    			}
;;;481    
;;;482    			/* Unload FIFO */
;;;483    			FIFORead((int)pbostate.byEP, nBytes, pbostate.pData);
;;;484    
;;;485    			/* Update status */
;;;486    			pbostate.nBytesRecv += nBytes;
;;;487    			pbostate.pData = (BYTE *)pbostate.pData + nBytes;
;;;488    
;;;489    			/* Check for end of transfer */
;;;490    			if (nBytes <= M_EP_MAXP) 
;;;491    			{
;;;492    				/* Call function to handle received data */	
;;;493    			}
;;;494    
;;;495    			/* Clear OutPktRdy */
;;;496    			MWRITE_BYTE(M_REG_OUTCSR1, 0);
;;;497    
;;;498    			/* Check for another packet */
;;;499    			byOutCSR = MREAD_BYTE(M_REG_OUTCSR1);
;;;500    		}
;;;501    	}
;;;502    	return nBytes;
;;;503    }
000042  b004              ADD      sp,sp,#0x10
000044  bd70              POP      {r4-r6,pc}
                  |L3.70|
000046  4669              MOV      r1,sp                 ;483
000048  7b08              LDRB     r0,[r1,#0xc]          ;483
00004a  4621              MOV      r1,r4                 ;483
00004c  9a00              LDR      r2,[sp,#0]            ;483
00004e  f7fffffe          BL       FIFORead
000052  9802              LDR      r0,[sp,#8]            ;486
000054  1900              ADDS     r0,r0,r4              ;486
000056  9002              STR      r0,[sp,#8]            ;486
000058  9800              LDR      r0,[sp,#0]            ;487
00005a  1900              ADDS     r0,r0,r4              ;487
00005c  9000              STR      r0,[sp,#0]            ;487
00005e  2000              MOVS     r0,#0                 ;496
000060  4904              LDR      r1,|L3.116|
000062  7508              STRB     r0,[r1,#0x14]         ;496
000064  4608              MOV      r0,r1                 ;499
000066  7d05              LDRB     r5,[r0,#0x14]         ;499
                  |L3.104|
000068  07e8              LSLS     r0,r5,#31             ;467
00006a  0fc0              LSRS     r0,r0,#31             ;467
00006c  2800              CMP      r0,#0                 ;467
00006e  d1da              BNE      |L3.38|
                  |L3.112|
000070  4620              MOV      r0,r4                 ;502
000072  e7e6              B        |L3.66|
;;;504    
                          ENDP

                  |L3.116|
                          DCD      0x40005c00

                          AREA ||i.FIFORead||, CODE, READONLY, ALIGN=2

                  FIFORead PROC
;;;551    */
;;;552    void FIFORead(int nEP, int nBytes, void * pDst)		
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;553    {
000002  b082              SUB      sp,sp,#8
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
;;;554    	int     nCount;
;;;555    	BYTE *  pby;
;;;556    	int     nAddr;
;;;557    	int i;
;;;558    	SEGGER_RTT_printf(0,"start FIFORead nBytes = %d nEP=%d\n",nBytes,nEP);
000008  4633              MOV      r3,r6
00000a  4622              MOV      r2,r4
00000c  a115              ADR      r1,|L4.100|
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       SEGGER_RTT_printf
;;;559    
;;;560    	if(nBytes) 
000014  2c00              CMP      r4,#0
000016  d01c              BEQ      |L4.82|
;;;561    	{
;;;562    		nAddr = M_FIFO_EP0+(nEP<<2);
000018  00b0              LSLS     r0,r6,#2
00001a  491b              LDR      r1,|L4.136|
00001c  1840              ADDS     r0,r0,r1
00001e  9001              STR      r0,[sp,#4]
;;;563    		nCount = nBytes;
000020  4627              MOV      r7,r4
;;;564    		pby = (BYTE *)pDst;
000022  9d04              LDR      r5,[sp,#0x10]
;;;565    		while(nCount) 
000024  e013              B        |L4.78|
                  |L4.38|
;;;566    		{
;;;567    
;;;568    		 SEGGER_RTT_printf(0," 0x%02x ",*pby);
000026  782a              LDRB     r2,[r5,#0]
000028  a118              ADR      r1,|L4.140|
00002a  2000              MOVS     r0,#0
00002c  f7fffffe          BL       SEGGER_RTT_printf
;;;569    		 i++;
000030  9800              LDR      r0,[sp,#0]
000032  1c40              ADDS     r0,r0,#1
000034  9000              STR      r0,[sp,#0]
;;;570    		if(i==10)
000036  9800              LDR      r0,[sp,#0]
000038  280a              CMP      r0,#0xa
00003a  d103              BNE      |L4.68|
;;;571    			SEGGER_RTT_printf(0,"\n");
00003c  a116              ADR      r1,|L4.152|
00003e  2000              MOVS     r0,#0
000040  f7fffffe          BL       SEGGER_RTT_printf
                  |L4.68|
;;;572    			*pby++ = *((BYTE *)nAddr);
000044  9801              LDR      r0,[sp,#4]
000046  7800              LDRB     r0,[r0,#0]
000048  7028              STRB     r0,[r5,#0]
00004a  1c6d              ADDS     r5,r5,#1
;;;573    			
;;;574    			nCount--;
00004c  1e7f              SUBS     r7,r7,#1
                  |L4.78|
00004e  2f00              CMP      r7,#0                 ;565
000050  d1e9              BNE      |L4.38|
                  |L4.82|
;;;575    			
;;;576    		}
;;;577    	}
;;;578    	
;;;579    	SEGGER_RTT_printf(0,"\n  end FIFORead nBytes = %d nEP=%d\n",nBytes,nEP);
000052  4633              MOV      r3,r6
000054  4622              MOV      r2,r4
000056  a111              ADR      r1,|L4.156|
000058  2000              MOVS     r0,#0
00005a  f7fffffe          BL       SEGGER_RTT_printf
;;;580    }
00005e  b005              ADD      sp,sp,#0x14
000060  bdf0              POP      {r4-r7,pc}
;;;581    
                          ENDP

000062  0000              DCW      0x0000
                  |L4.100|
000064  73746172          DCB      "start FIFORead nBytes = %d nEP=%d\n",0
000068  74204649
00006c  464f5265
000070  6164206e
000074  42797465
000078  73203d20
00007c  2564206e
000080  45503d25
000084  640a00  
000087  00                DCB      0
                  |L4.136|
                          DCD      0x40005c20
                  |L4.140|
00008c  20307825          DCB      " 0x%02x ",0
000090  30327820
000094  00      
000095  00                DCB      0
000096  00                DCB      0
000097  00                DCB      0
                  |L4.152|
000098  0a00              DCB      "\n",0
00009a  00                DCB      0
00009b  00                DCB      0
                  |L4.156|
00009c  0a202065          DCB      "\n  end FIFORead nBytes = %d nEP=%d\n",0
0000a0  6e642046
0000a4  49464f52
0000a8  65616420
0000ac  6e427974
0000b0  6573203d
0000b4  20256420
0000b8  6e45503d
0000bc  25640a00

                          AREA ||i.FIFOWrite||, CODE, READONLY, ALIGN=2

                  FIFOWrite PROC
;;;590    */
;;;591    void FIFOWrite(int nEP, int nBytes, void * pSrc)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;592    {
000002  b082              SUB      sp,sp,#8
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
;;;593    	int     nCount;
;;;594    	BYTE *  pby;
;;;595    	int     nAddr;
;;;596    	int i = 0;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;597    	SEGGER_RTT_printf(0,"start FIFOWrite nBytes = %d nEP=%d\n",nBytes,nEP);
00000c  4633              MOV      r3,r6
00000e  4622              MOV      r2,r4
000010  a114              ADR      r1,|L5.100|
000012  f7fffffe          BL       SEGGER_RTT_printf
;;;598    	
;;;599    	if(nBytes)
000016  2c00              CMP      r4,#0
000018  d01c              BEQ      |L5.84|
;;;600    	{
;;;601    		nAddr = M_FIFO_EP0+(nEP<<2);
00001a  00b0              LSLS     r0,r6,#2
00001c  491a              LDR      r1,|L5.136|
00001e  1840              ADDS     r0,r0,r1
000020  9001              STR      r0,[sp,#4]
;;;602    		nCount = nBytes;
000022  4627              MOV      r7,r4
;;;603    		pby = (BYTE *)pSrc;
000024  9d04              LDR      r5,[sp,#0x10]
;;;604    		while (nCount)
000026  e013              B        |L5.80|
                  |L5.40|
;;;605    		{
;;;606    		 SEGGER_RTT_printf(0," 0x%02x ",*pby);
000028  782a              LDRB     r2,[r5,#0]
00002a  a118              ADR      r1,|L5.140|
00002c  2000              MOVS     r0,#0
00002e  f7fffffe          BL       SEGGER_RTT_printf
;;;607    		 *((BYTE *)nAddr) = *pby++;
000032  7829              LDRB     r1,[r5,#0]
000034  9801              LDR      r0,[sp,#4]
000036  7001              STRB     r1,[r0,#0]
000038  1c6d              ADDS     r5,r5,#1
;;;608    		 i++;
00003a  9800              LDR      r0,[sp,#0]
00003c  1c40              ADDS     r0,r0,#1
00003e  9000              STR      r0,[sp,#0]
;;;609    		if(i==10)
000040  9800              LDR      r0,[sp,#0]
000042  280a              CMP      r0,#0xa
000044  d103              BNE      |L5.78|
;;;610    			SEGGER_RTT_printf(0,"\n");
000046  a114              ADR      r1,|L5.152|
000048  2000              MOVS     r0,#0
00004a  f7fffffe          BL       SEGGER_RTT_printf
                  |L5.78|
;;;611    			nCount--;
00004e  1e7f              SUBS     r7,r7,#1
                  |L5.80|
000050  2f00              CMP      r7,#0                 ;604
000052  d1e9              BNE      |L5.40|
                  |L5.84|
;;;612    		}
;;;613    	}
;;;614    	
;;;615    	SEGGER_RTT_printf(0,"\n end FIFOWrite nBytes = %d nEP=%d\n",nBytes,nEP);
000054  4633              MOV      r3,r6
000056  4622              MOV      r2,r4
000058  a110              ADR      r1,|L5.156|
00005a  2000              MOVS     r0,#0
00005c  f7fffffe          BL       SEGGER_RTT_printf
;;;616    	
;;;617    }
000060  b005              ADD      sp,sp,#0x14
000062  bdf0              POP      {r4-r7,pc}
;;;618    
                          ENDP

                  |L5.100|
000064  73746172          DCB      "start FIFOWrite nBytes = %d nEP=%d\n",0
000068  74204649
00006c  464f5772
000070  69746520
000074  6e427974
000078  6573203d
00007c  20256420
000080  6e45503d
000084  25640a00
                  |L5.136|
                          DCD      0x40005c20
                  |L5.140|
00008c  20307825          DCB      " 0x%02x ",0
000090  30327820
000094  00      
000095  00                DCB      0
000096  00                DCB      0
000097  00                DCB      0
                  |L5.152|
000098  0a00              DCB      "\n",0
00009a  00                DCB      0
00009b  00                DCB      0
                  |L5.156|
00009c  0a20656e          DCB      "\n end FIFOWrite nBytes = %d nEP=%d\n",0
0000a0  64204649
0000a4  464f5772
0000a8  69746520
0000ac  6e427974
0000b0  6573203d
0000b4  20256420
0000b8  6e45503d
0000bc  25640a00

                          AREA ||i.HID_GetIdleEvent||, CODE, READONLY, ALIGN=2

                  HID_GetIdleEvent PROC
;;;870    */
;;;871    void HID_GetIdleEvent(PM_EP0_STATUS pep0state,PCOMMAND pcmd)
000000  b570              PUSH     {r4-r6,lr}
;;;872    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;873    	/*保存请求类型*/
;;;874    	c_hid_data.wHID_Status = HID_REQUEST_GET_IDLE;
000006  490b              LDR      r1,|L6.52|
000008  2002              MOVS     r0,#2
00000a  f7fffffe          BL       __aeabi_uwrite4
;;;875    	
;;;876    	pep0state->nBytesLeft = 0x01;
00000e  1d21              ADDS     r1,r4,#4
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       __aeabi_uwrite4
;;;877    	pep0state->pData = (void*)&c_hid_data.wHID_IdleTimeIf0ID;
000016  4621              MOV      r1,r4
000018  3108              ADDS     r1,r1,#8
00001a  4806              LDR      r0,|L6.52|
00001c  3843              SUBS     r0,r0,#0x43
00001e  f7fffffe          BL       __aeabi_uwrite4
;;;878    	pep0state->nState = M_EP0_TX;
000022  4621              MOV      r1,r4
000024  2002              MOVS     r0,#2
000026  f7fffffe          BL       __aeabi_uwrite4
;;;879    	MWRITE_BYTE(M_REG_CSR0,M_CSR0_SVDOUTPKTRDY);	
00002a  2040              MOVS     r0,#0x40
00002c  4902              LDR      r1,|L6.56|
00002e  7448              STRB     r0,[r1,#0x11]
;;;880    }
000030  bd70              POP      {r4-r6,pc}
;;;881    /******************************************************************************
                          ENDP

000032  0000              DCW      0x0000
                  |L6.52|
                          DCD      c_hid_data+0x53
                  |L6.56|
                          DCD      0x40005c00

                          AREA ||i.HID_GetProtocolEvent||, CODE, READONLY, ALIGN=2

                  HID_GetProtocolEvent PROC
;;;906    */
;;;907    void HID_GetProtocolEvent(PM_EP0_STATUS pep0state,PCOMMAND pcmd)
000000  b570              PUSH     {r4-r6,lr}
;;;908    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;909    	/*保存请求类型*/
;;;910    	c_hid_data.wHID_Status = HID_REQUEST_GET_PROTOCOL;
000006  490b              LDR      r1,|L7.52|
000008  2003              MOVS     r0,#3
00000a  f7fffffe          BL       __aeabi_uwrite4
;;;911    	
;;;912    	pep0state->nBytesLeft = 0x01;
00000e  1d21              ADDS     r1,r4,#4
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       __aeabi_uwrite4
;;;913    	pep0state->pData = (void*)&c_hid_data.wHID_Protocol;
000016  4621              MOV      r1,r4
000018  3108              ADDS     r1,r1,#8
00001a  4806              LDR      r0,|L7.52|
00001c  3842              SUBS     r0,r0,#0x42
00001e  f7fffffe          BL       __aeabi_uwrite4
;;;914    	pep0state->nState = M_EP0_TX;
000022  4621              MOV      r1,r4
000024  2002              MOVS     r0,#2
000026  f7fffffe          BL       __aeabi_uwrite4
;;;915    	MWRITE_BYTE(M_REG_CSR0,M_CSR0_SVDOUTPKTRDY);		
00002a  2040              MOVS     r0,#0x40
00002c  4902              LDR      r1,|L7.56|
00002e  7448              STRB     r0,[r1,#0x11]
;;;916    }
000030  bd70              POP      {r4-r6,pc}
;;;917    /******************************************************************************
                          ENDP

000032  0000              DCW      0x0000
                  |L7.52|
                          DCD      c_hid_data+0x53
                  |L7.56|
                          DCD      0x40005c00

                          AREA ||i.HID_GetReportEvent||, CODE, READONLY, ALIGN=2

                  HID_GetReportEvent PROC
;;;842    */
;;;843    void HID_GetReportEvent(PM_EP0_STATUS pep0state,PCOMMAND pcmd)
000000  b570              PUSH     {r4-r6,lr}
;;;844    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;845    	if(gnDevState > DEVSTATE_ADDRESS)
000006  4815              LDR      r0,|L8.92|
000008  6800              LDR      r0,[r0,#0]  ; gnDevState
00000a  2801              CMP      r0,#1
00000c  d924              BLS      |L8.88|
;;;846    	{
;;;847    		switch(pcmd->USBwValue >>8)
00000e  78e8              LDRB     r0,[r5,#3]
000010  78a9              LDRB     r1,[r5,#2]
000012  0200              LSLS     r0,r0,#8
000014  4308              ORRS     r0,r0,r1
000016  1200              ASRS     r0,r0,#8
000018  2801              CMP      r0,#1
00001a  d004              BEQ      |L8.38|
00001c  2802              CMP      r0,#2
00001e  d004              BEQ      |L8.42|
000020  2803              CMP      r0,#3
000022  d118              BNE      |L8.86|
000024  e000              B        |L8.40|
                  |L8.38|
;;;848    		{
;;;849    			case	HID_REPORT_INPUT:
;;;850    			case	HID_REPORT_FEATURE:
000026  bf00              NOP      
                  |L8.40|
;;;851    			case	HID_REPORT_OUTPUT:
000028  bf00              NOP      
                  |L8.42|
;;;852    				/*保存请求类型*/
;;;853    				c_hid_data.wHID_Status = HID_REQUEST_GET_REPORT;
00002a  490d              LDR      r1,|L8.96|
00002c  2001              MOVS     r0,#1
00002e  f7fffffe          BL       __aeabi_uwrite4
;;;854    			
;;;855    				pep0state->nBytesLeft = 0x01;
000032  1d21              ADDS     r1,r4,#4
000034  2001              MOVS     r0,#1
000036  f7fffffe          BL       __aeabi_uwrite4
;;;856    				pep0state->pData = (void*)&c_hid_data.wHID_SetRptByte[0];
00003a  4621              MOV      r1,r4
00003c  3108              ADDS     r1,r1,#8
00003e  4808              LDR      r0,|L8.96|
000040  3853              SUBS     r0,r0,#0x53
000042  f7fffffe          BL       __aeabi_uwrite4
;;;857    				pep0state->nState = M_EP0_TX;
000046  4621              MOV      r1,r4
000048  2002              MOVS     r0,#2
00004a  f7fffffe          BL       __aeabi_uwrite4
;;;858    				MWRITE_BYTE(M_REG_CSR0,M_CSR0_SVDOUTPKTRDY);
00004e  2040              MOVS     r0,#0x40
000050  4904              LDR      r1,|L8.100|
000052  7448              STRB     r0,[r1,#0x11]
;;;859    				break;
000054  bf00              NOP      
                  |L8.86|
000056  bf00              NOP      
                  |L8.88|
;;;860    		}
;;;861    	}	
;;;862    }
000058  bd70              POP      {r4-r6,pc}
;;;863    /******************************************************************************
                          ENDP

00005a  0000              DCW      0x0000
                  |L8.92|
                          DCD      gnDevState
                  |L8.96|
                          DCD      c_hid_data+0x53
                  |L8.100|
                          DCD      0x40005c00

                          AREA ||i.HID_SetIdleEvent||, CODE, READONLY, ALIGN=2

                  HID_SetIdleEvent PROC
;;;888    */
;;;889    void HID_SetIdleEvent(PM_EP0_STATUS pep0state,PCOMMAND pcmd)
000000  b570              PUSH     {r4-r6,lr}
;;;890    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;891    	/*保存请求类型*/
;;;892    	c_hid_data.wHID_Status = HID_REQUEST_SET_IDLE;
000006  490a              LDR      r1,|L9.48|
000008  200a              MOVS     r0,#0xa
00000a  f7fffffe          BL       __aeabi_uwrite4
;;;893    
;;;894    	pep0state->nState = M_EP0_IDLE;
00000e  4621              MOV      r1,r4
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       __aeabi_uwrite4
;;;895    	c_hid_data.wHID_IdleTimeIf0ID = (pcmd->USBwValue>>8);
000016  78e8              LDRB     r0,[r5,#3]
000018  78a9              LDRB     r1,[r5,#2]
00001a  0200              LSLS     r0,r0,#8
00001c  4308              ORRS     r0,r0,r1
00001e  1200              ASRS     r0,r0,#8
000020  4903              LDR      r1,|L9.48|
000022  3953              SUBS     r1,r1,#0x53
000024  7408              STRB     r0,[r1,#0x10]
;;;896    	MWRITE_BYTE(M_REG_CSR0,M_CSR0_SVDOUTPKTRDY);		
000026  2040              MOVS     r0,#0x40
000028  4902              LDR      r1,|L9.52|
00002a  7448              STRB     r0,[r1,#0x11]
;;;897    }
00002c  bd70              POP      {r4-r6,pc}
;;;898    
                          ENDP

00002e  0000              DCW      0x0000
                  |L9.48|
                          DCD      c_hid_data+0x53
                  |L9.52|
                          DCD      0x40005c00

                          AREA ||i.HID_SetProtocolEvent||, CODE, READONLY, ALIGN=2

                  HID_SetProtocolEvent PROC
;;;924    */
;;;925    void HID_SetProtocolEvent(PM_EP0_STATUS pep0state,PCOMMAND pcmd)
000000  b570              PUSH     {r4-r6,lr}
;;;926    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;927    	/*保存请求类型*/
;;;928    	c_hid_data.wHID_Status = HID_REQUEST_SET_PROTOCOL;
000006  4909              LDR      r1,|L10.44|
000008  200b              MOVS     r0,#0xb
00000a  f7fffffe          BL       __aeabi_uwrite4
;;;929    
;;;930    	pep0state->nState = M_EP0_IDLE;
00000e  4621              MOV      r1,r4
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       __aeabi_uwrite4
;;;931    	c_hid_data.wHID_Protocol = (pcmd->USBwValue & 0x00ff);
000016  78e8              LDRB     r0,[r5,#3]
000018  78a9              LDRB     r1,[r5,#2]
00001a  0200              LSLS     r0,r0,#8
00001c  4308              ORRS     r0,r0,r1
00001e  4903              LDR      r1,|L10.44|
000020  3953              SUBS     r1,r1,#0x53
000022  7448              STRB     r0,[r1,#0x11]
;;;932    	MWRITE_BYTE(M_REG_CSR0,M_CSR0_SVDOUTPKTRDY);		
000024  2040              MOVS     r0,#0x40
000026  4902              LDR      r1,|L10.48|
000028  7448              STRB     r0,[r1,#0x11]
;;;933    }
00002a  bd70              POP      {r4-r6,pc}
;;;934    /******************************************************************************
                          ENDP

                  |L10.44|
                          DCD      c_hid_data+0x53
                  |L10.48|
                          DCD      0x40005c00

                          AREA ||i.HID_SetReportEvent||, CODE, READONLY, ALIGN=2

                  HID_SetReportEvent PROC
;;;814    */
;;;815    void HID_SetReportEvent(PM_EP0_STATUS pep0state,PCOMMAND pcmd)
000000  b570              PUSH     {r4-r6,lr}
;;;816    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;817    	//if ((pcmd->bmRequestType == HID_REQUEST_SET) && (pcmd->USBwIndex == 1))// Interface 1
;;;818    	{
;;;819    		switch(pcmd->USBwValue >>8)
000006  78e8              LDRB     r0,[r5,#3]
000008  78a9              LDRB     r1,[r5,#2]
00000a  0200              LSLS     r0,r0,#8
00000c  4308              ORRS     r0,r0,r1
00000e  1200              ASRS     r0,r0,#8
000010  2801              CMP      r0,#1
000012  d004              BEQ      |L11.30|
000014  2802              CMP      r0,#2
000016  d003              BEQ      |L11.32|
000018  2803              CMP      r0,#3
00001a  d11c              BNE      |L11.86|
00001c  e01a              B        |L11.84|
                  |L11.30|
;;;820    		{
;;;821    			case	HID_REPORT_INPUT:break;
00001e  e01a              B        |L11.86|
                  |L11.32|
;;;822    			case	HID_REPORT_OUTPUT:
;;;823    				/*保存请求类型*/
;;;824    				c_hid_data.wHID_Status = HID_REQUEST_SET_REPORT;
000020  490e              LDR      r1,|L11.92|
000022  2009              MOVS     r0,#9
000024  f7fffffe          BL       __aeabi_uwrite4
;;;825    			
;;;826    				pep0state->nBytesLeft = pcmd->USBwLength;
000028  79e9              LDRB     r1,[r5,#7]
00002a  79aa              LDRB     r2,[r5,#6]
00002c  0209              LSLS     r1,r1,#8
00002e  4311              ORRS     r1,r1,r2
000030  4608              MOV      r0,r1
000032  1d21              ADDS     r1,r4,#4
000034  f7fffffe          BL       __aeabi_uwrite4
;;;827    				pep0state->nState = M_EP0_RX;
000038  4621              MOV      r1,r4
00003a  2001              MOVS     r0,#1
00003c  f7fffffe          BL       __aeabi_uwrite4
;;;828    				pep0state->pData = (void*)&c_hid_data.wHID_SetRptByte[0];
000040  4621              MOV      r1,r4
000042  3108              ADDS     r1,r1,#8
000044  4805              LDR      r0,|L11.92|
000046  3853              SUBS     r0,r0,#0x53
000048  f7fffffe          BL       __aeabi_uwrite4
;;;829    				MWRITE_BYTE(M_REG_CSR0,M_CSR0_SVDOUTPKTRDY);				
00004c  2040              MOVS     r0,#0x40
00004e  4904              LDR      r1,|L11.96|
000050  7448              STRB     r0,[r1,#0x11]
;;;830    				break;
000052  e000              B        |L11.86|
                  |L11.84|
;;;831    			case	HID_REPORT_FEATURE:break;
000054  bf00              NOP      
                  |L11.86|
000056  bf00              NOP                            ;821
;;;832    		}
;;;833    	}	
;;;834    }
000058  bd70              POP      {r4-r6,pc}
;;;835    /******************************************************************************
                          ENDP

00005a  0000              DCW      0x0000
                  |L11.92|
                          DCD      c_hid_data+0x53
                  |L11.96|
                          DCD      0x40005c00

                          AREA ||i.USB_EP_Rx||, CODE, READONLY, ALIGN=1

                  USB_EP_Rx PROC
;;;1948   */
;;;1949   int USB_EP_Rx(uint8_t Ep,uint8_t *ptr,uint8_t data_len)
000000  b570              PUSH     {r4-r6,lr}
;;;1950   {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;1951   	M_EPBOUT_STATUS    tEp1out;
;;;1952   	
;;;1953   	tEp1out.byEP = Ep;
00000a  4668              MOV      r0,sp
00000c  7504              STRB     r4,[r0,#0x14]
;;;1954   	tEp1out.nBuffLen = data_len; 	//M_EP_MAXP
00000e  9603              STR      r6,[sp,#0xc]
;;;1955   	tEp1out.pData = ptr;
000010  9502              STR      r5,[sp,#8]
;;;1956   	tEp1out.nBytesRecv = 0;
000012  2000              MOVS     r0,#0
000014  9004              STR      r0,[sp,#0x10]
;;;1957   
;;;1958   	return EndpointBulkOut(tEp1out, M_EP_NORMAL);
000016  9000              STR      r0,[sp,#0]
000018  a802              ADD      r0,sp,#8
00001a  c80f              LDM      r0,{r0-r3}
00001c  f7fffffe          BL       EndpointBulkOut
;;;1959   	//return tEp1out.nBytesRecv;
;;;1960   }
000020  b006              ADD      sp,sp,#0x18
000022  bd70              POP      {r4-r6,pc}
;;;1961   
                          ENDP


                          AREA ||i.USB_EP_Tx||, CODE, READONLY, ALIGN=2

                  USB_EP_Tx PROC
;;;1901   */
;;;1902   ErrorStatus USB_EP_Tx(uint8_t Ep,uint8_t *ptr,uint8_t data_len)
000000  b5fe              PUSH     {r1-r7,lr}
;;;1903   {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
;;;1904   	M_EPBIN_STATUS tEp0in;
;;;1905   	uint32_t timeout = 0;
000008  2400              MOVS     r4,#0
;;;1906   	
;;;1907   	SEGGER_RTT_printf(0,"USB_EP_Tx gnDevState=%d\n",gnDevState);
00000a  4822              LDR      r0,|L13.148|
00000c  a122              ADR      r1,|L13.152|
00000e  6802              LDR      r2,[r0,#0]  ; gnDevState
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       SEGGER_RTT_printf
;;;1908   	if(gnDevState > DEVSTATE_ADDRESS)
000016  481f              LDR      r0,|L13.148|
000018  6800              LDR      r0,[r0,#0]  ; gnDevState
00001a  2801              CMP      r0,#1
00001c  d932              BLS      |L13.132|
;;;1909   	{
;;;1910   	
;;;1911   	SEGGER_RTT_printf(0,"2 USB_EP_Tx gnDevState=%d\n",gnDevState);
00001e  481d              LDR      r0,|L13.148|
000020  a124              ADR      r1,|L13.180|
000022  6802              LDR      r2,[r0,#0]  ; gnDevState
000024  2000              MOVS     r0,#0
000026  f7fffffe          BL       SEGGER_RTT_printf
;;;1912   		tEp0in.byEP = Ep;
00002a  4668              MOV      r0,sp
00002c  7205              STRB     r5,[r0,#8]
;;;1913   		tEp0in.nBytesLeft = data_len;
00002e  9701              STR      r7,[sp,#4]
;;;1914   		tEp0in.pData = ptr;
000030  9600              STR      r6,[sp,#0]
;;;1915   		EndpointBulkIn(tEp0in, M_EP_NORMAL);
000032  2300              MOVS     r3,#0
000034  4668              MOV      r0,sp
000036  c807              LDM      r0,{r0-r2}
000038  f7fffffe          BL       EndpointBulkIn
;;;1916   
;;;1917   		
;;;1918   		SEGGER_RTT_printf(0,"3 USB_EP_Tx MREAD_BYTE(M_REG_INCSR1)=0x%02x\n",MREAD_BYTE(M_REG_INCSR1));
00003c  4824              LDR      r0,|L13.208|
00003e  7c42              LDRB     r2,[r0,#0x11]
000040  a124              ADR      r1,|L13.212|
000042  2000              MOVS     r0,#0
000044  f7fffffe          BL       SEGGER_RTT_printf
;;;1919   		while(MREAD_BYTE(M_REG_INCSR1) & 0x01)
000048  e00e              B        |L13.104|
                  |L13.74|
;;;1920   		{
;;;1921   		
;;;1922   		SEGGER_RTT_printf(0,"4 USB_EP_Tx timeout=%d\n",timeout);
00004a  4622              MOV      r2,r4
00004c  a12d              ADR      r1,|L13.260|
00004e  2000              MOVS     r0,#0
000050  f7fffffe          BL       SEGGER_RTT_printf
;;;1923   			timeout++;
000054  1c64              ADDS     r4,r4,#1
;;;1924   			if(timeout>=0xffffffff)
000056  1c60              ADDS     r0,r4,#1
000058  2800              CMP      r0,#0
00005a  d105              BNE      |L13.104|
;;;1925   			{
;;;1926   			
;;;1927   			SEGGER_RTT_printf(0,"5 USB_EP_Tx timeout=%d\n",timeout);
00005c  4622              MOV      r2,r4
00005e  a12f              ADR      r1,|L13.284|
000060  f7fffffe          BL       SEGGER_RTT_printf
;;;1928   				return ERROR;
000064  2000              MOVS     r0,#0
                  |L13.102|
;;;1929   			}
;;;1930   		}
;;;1931   		
;;;1932   		SEGGER_RTT_printf(0,"6 USB_EP_Tx gnDevState=%d\n",gnDevState);
;;;1933   		return SUCCESS;
;;;1934   	}
;;;1935   	
;;;1936   	SEGGER_RTT_printf(0,"7 USB_EP_Tx gnDevState=%d\n",gnDevState);
;;;1937   	return ERROR;
;;;1938   }
000066  bdfe              POP      {r1-r7,pc}
                  |L13.104|
000068  4819              LDR      r0,|L13.208|
00006a  7c40              LDRB     r0,[r0,#0x11]         ;1919
00006c  07c0              LSLS     r0,r0,#31             ;1919
00006e  0fc0              LSRS     r0,r0,#31             ;1919
000070  2800              CMP      r0,#0                 ;1919
000072  d1ea              BNE      |L13.74|
000074  4807              LDR      r0,|L13.148|
000076  a12f              ADR      r1,|L13.308|
000078  6802              LDR      r2,[r0,#0]            ;1932  ; gnDevState
00007a  2000              MOVS     r0,#0                 ;1932
00007c  f7fffffe          BL       SEGGER_RTT_printf
000080  2001              MOVS     r0,#1                 ;1933
000082  e7f0              B        |L13.102|
                  |L13.132|
000084  4803              LDR      r0,|L13.148|
000086  a132              ADR      r1,|L13.336|
000088  6802              LDR      r2,[r0,#0]            ;1936  ; gnDevState
00008a  2000              MOVS     r0,#0                 ;1936
00008c  f7fffffe          BL       SEGGER_RTT_printf
000090  2000              MOVS     r0,#0                 ;1937
000092  e7e8              B        |L13.102|
;;;1939   
                          ENDP

                  |L13.148|
                          DCD      gnDevState
                  |L13.152|
000098  5553425f          DCB      "USB_EP_Tx gnDevState=%d\n",0
00009c  45505f54
0000a0  7820676e
0000a4  44657653
0000a8  74617465
0000ac  3d25640a
0000b0  00      
0000b1  00                DCB      0
0000b2  00                DCB      0
0000b3  00                DCB      0
                  |L13.180|
0000b4  32205553          DCB      "2 USB_EP_Tx gnDevState=%d\n",0
0000b8  425f4550
0000bc  5f547820
0000c0  676e4465
0000c4  76537461
0000c8  74653d25
0000cc  640a00  
0000cf  00                DCB      0
                  |L13.208|
                          DCD      0x40005c00
                  |L13.212|
0000d4  33205553          DCB      "3 USB_EP_Tx MREAD_BYTE(M_REG_INCSR1)=0x%02x\n",0
0000d8  425f4550
0000dc  5f547820
0000e0  4d524541
0000e4  445f4259
0000e8  5445284d
0000ec  5f524547
0000f0  5f494e43
0000f4  53523129
0000f8  3d307825
0000fc  3032780a
000100  00      
000101  00                DCB      0
000102  00                DCB      0
000103  00                DCB      0
                  |L13.260|
000104  34205553          DCB      "4 USB_EP_Tx timeout=%d\n",0
000108  425f4550
00010c  5f547820
000110  74696d65
000114  6f75743d
000118  25640a00
                  |L13.284|
00011c  35205553          DCB      "5 USB_EP_Tx timeout=%d\n",0
000120  425f4550
000124  5f547820
000128  74696d65
00012c  6f75743d
000130  25640a00
                  |L13.308|
000134  36205553          DCB      "6 USB_EP_Tx gnDevState=%d\n",0
000138  425f4550
00013c  5f547820
000140  676e4465
000144  76537461
000148  74653d25
00014c  640a00  
00014f  00                DCB      0
                  |L13.336|
000150  37205553          DCB      "7 USB_EP_Tx gnDevState=%d\n",0
000154  425f4550
000158  5f547820
00015c  676e4465
000160  76537461
000164  74653d25
000168  640a00  
00016b  00                DCB      0

                          AREA ||i.USB_Endpoint0||, CODE, READONLY, ALIGN=2

                  USB_Endpoint0 PROC
;;;711    */
;;;712    void USB_Endpoint0(int nCallState)
000000  b570              PUSH     {r4-r6,lr}
;;;713    {
000002  4605              MOV      r5,r0
;;;714    	static M_EP0_STATUS	ep0state;
;;;715    	static COMMAND	cmd;
;;;716    	BYTE	byCSR0;
;;;717    
;;;718    	
;;;719    	SEGGER_RTT_printf(0,"USB_Endpoint0  xxx nCallState =%d\n",nCallState);
000004  462a              MOV      r2,r5
000006  a146              ADR      r1,|L14.288|
000008  2000              MOVS     r0,#0
00000a  f7fffffe          BL       SEGGER_RTT_printf
;;;720    	/* Check for USB reset of endpoint 0 */
;;;721    	if (nCallState == M_EP_RESET)
00000e  2d01              CMP      r5,#1
000010  d10a              BNE      |L14.40|
;;;722    	{
;;;723    		ep0state.nState = M_EP0_IDLE;
000012  494c              LDR      r1,|L14.324|
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       __aeabi_uwrite4
;;;724    		ep0state.byFAddr = 0xFF;
00001a  20ff              MOVS     r0,#0xff
00001c  4949              LDR      r1,|L14.324|
00001e  7408              STRB     r0,[r1,#0x10]
;;;725    		/* Clear current configuration pointer */
;;;726    		gpCurCfg = NULL;
000020  2000              MOVS     r0,#0
000022  4949              LDR      r1,|L14.328|
000024  6008              STR      r0,[r1,#0]  ; gpCurCfg
                  |L14.38|
;;;727    		return;
;;;728    	}
;;;729    
;;;730    	/* Read CSR0 */
;;;731    	MWRITE_BYTE(M_REG_INDEX, 0);							//选择endpoint0
;;;732    	byCSR0 = MREAD_BYTE(M_REG_CSR0);						//读取CSR0，各种通信状态
;;;733    
;;;734    	/* Check for status stage of a request */
;;;735    	/*接收已完成状态*/
;;;736    	if(!(byCSR0 & M_CSR0_OUTPKTRDY)) 
;;;737    	{
;;;738    		/* Complete SET_ADDRESS command */
;;;739    		if(ep0state.byFAddr != 0xFF)
;;;740    		{
;;;741    			MWRITE_BYTE(M_REG_FADDR, ep0state.byFAddr);		//如果地址不为FF，reset，地址设置为byFAddr
;;;742    			if((gnDevState == DEVSTATE_DEFAULT) && ep0state.byFAddr)
;;;743    			{
;;;744    			
;;;745    			SEGGER_RTT_printf(0,"gnDevState = DEVSTATE_ADDRESS;	 xxx 111\n");
;;;746    				gnDevState = DEVSTATE_ADDRESS;				//地址不为0，且设备状态为 DEVSTATE_DEFAULT
;;;747    			}
;;;748    			else if((gnDevState == DEVSTATE_ADDRESS) && !ep0state.byFAddr)
;;;749    			{
;;;750    			
;;;751    			SEGGER_RTT_printf(0,"gnDevState = DEVSTATE_ADDRESS;	 222\n");
;;;752    				gnDevState = DEVSTATE_DEFAULT;				//地址为0，且设备状态为 DEVSTATE_ADDRESS
;;;753    			}
;;;754    		}
;;;755    	}
;;;756    	/* Clear pending commands */
;;;757    	ep0state.byFAddr = 0xFF;	
;;;758    
;;;759    	/* Check for SentStall */
;;;760    	if(byCSR0 & M_CSR0_SENTSTALL)
;;;761    	{
;;;762    		/*清除STALL 位*/
;;;763    		MWRITE_BYTE(M_REG_CSR0, (byCSR0 & ~M_CSR0_SENDSTALL));
;;;764    		ep0state.nState = M_EP0_IDLE;
;;;765    	}
;;;766    
;;;767    	/* Check for SetupEnd */
;;;768    	if(byCSR0 & M_CSR0_SETUPEND)
;;;769    	{
;;;770    		/*清除setupend位*/
;;;771    		MWRITE_BYTE(M_REG_CSR0, (byCSR0 | M_CSR0_SVDSETUPEND));
;;;772    		ep0state.nState = M_EP0_IDLE;
;;;773    	}
;;;774    
;;;775    	/* Call relevant routines for endpoint 0 state */
;;;776    	if(ep0state.nState == M_EP0_IDLE) 
;;;777    	{
;;;778    		/* If no packet has been received, */
;;;779    		/* assume that this was a STATUS phase complete. */
;;;780    		/* Otherwise load new command */
;;;781    		if(byCSR0 & M_CSR0_OUTPKTRDY) 
;;;782    		{
;;;783    			/* Read the 8-byte command from the FIFO */
;;;784    			/* There is no need to check that OutCount is set to 8 */
;;;785    			/* as the MUSBFSFC will reject SETUP packets that are not 8 bytes long. */
;;;786    			FIFORead(0, 8, &cmd);	
;;;787    			SEGGER_RTT_printf(0,"USB_Endpoint0  aaa\n");
;;;788    			//传入cmd地址存放数据到结构体中
;;;789    			USB_Endpoint0_Command(&ep0state, &cmd);			//数据解析
;;;790    		}
;;;791    	}
;;;792    	
;;;793    	if(ep0state.nState == M_EP0_TX)
;;;794    	{
;;;795    	
;;;796    	SEGGER_RTT_printf(0,"USB_Endpoint0_Tx 1111\n");
;;;797    		USB_Endpoint0_Tx(&ep0state);
;;;798    	}
;;;799    	else if(ep0state.nState == M_EP0_RX)
;;;800    	{
;;;801    	
;;;802    	SEGGER_RTT_printf(0,"USB_Endpoint0_Tx 2222\n");
;;;803    		USB_Endpoint0_Rx(&ep0state);
;;;804    	}
;;;805    }
000026  bd70              POP      {r4-r6,pc}
                  |L14.40|
000028  2000              MOVS     r0,#0                 ;731
00002a  4948              LDR      r1,|L14.332|
00002c  7388              STRB     r0,[r1,#0xe]          ;731
00002e  4608              MOV      r0,r1                 ;732
000030  7c44              LDRB     r4,[r0,#0x11]         ;732
000032  07e0              LSLS     r0,r4,#31             ;736
000034  0fc0              LSRS     r0,r0,#31             ;736
000036  2800              CMP      r0,#0                 ;736
000038  d124              BNE      |L14.132|
00003a  4842              LDR      r0,|L14.324|
00003c  7c00              LDRB     r0,[r0,#0x10]         ;739  ; ep0state
00003e  28ff              CMP      r0,#0xff              ;739
000040  d020              BEQ      |L14.132|
000042  4840              LDR      r0,|L14.324|
000044  7c00              LDRB     r0,[r0,#0x10]         ;741  ; ep0state
000046  7008              STRB     r0,[r1,#0]            ;741
000048  4841              LDR      r0,|L14.336|
00004a  6800              LDR      r0,[r0,#0]            ;742  ; gnDevState
00004c  2800              CMP      r0,#0                 ;742
00004e  d10b              BNE      |L14.104|
000050  483c              LDR      r0,|L14.324|
000052  7c00              LDRB     r0,[r0,#0x10]         ;742  ; ep0state
000054  2800              CMP      r0,#0                 ;742
000056  d007              BEQ      |L14.104|
000058  a13e              ADR      r1,|L14.340|
00005a  2000              MOVS     r0,#0                 ;745
00005c  f7fffffe          BL       SEGGER_RTT_printf
000060  2001              MOVS     r0,#1                 ;746
000062  493b              LDR      r1,|L14.336|
000064  6008              STR      r0,[r1,#0]            ;746  ; gnDevState
000066  e00d              B        |L14.132|
                  |L14.104|
000068  4839              LDR      r0,|L14.336|
00006a  6800              LDR      r0,[r0,#0]            ;748  ; gnDevState
00006c  2801              CMP      r0,#1                 ;748
00006e  d109              BNE      |L14.132|
000070  4834              LDR      r0,|L14.324|
000072  7c00              LDRB     r0,[r0,#0x10]         ;748  ; ep0state
000074  2800              CMP      r0,#0                 ;748
000076  d105              BNE      |L14.132|
000078  a141              ADR      r1,|L14.384|
00007a  f7fffffe          BL       SEGGER_RTT_printf
00007e  2000              MOVS     r0,#0                 ;752
000080  4933              LDR      r1,|L14.336|
000082  6008              STR      r0,[r1,#0]            ;752  ; gnDevState
                  |L14.132|
000084  20ff              MOVS     r0,#0xff              ;757
000086  492f              LDR      r1,|L14.324|
000088  7408              STRB     r0,[r1,#0x10]         ;757
00008a  2004              MOVS     r0,#4                 ;760
00008c  4020              ANDS     r0,r0,r4              ;760
00008e  2800              CMP      r0,#0                 ;760
000090  d008              BEQ      |L14.164|
000092  2120              MOVS     r1,#0x20              ;763
000094  4620              MOV      r0,r4                 ;763
000096  4388              BICS     r0,r0,r1              ;763
000098  492c              LDR      r1,|L14.332|
00009a  7448              STRB     r0,[r1,#0x11]         ;763
00009c  4929              LDR      r1,|L14.324|
00009e  2000              MOVS     r0,#0                 ;764
0000a0  f7fffffe          BL       __aeabi_uwrite4
                  |L14.164|
0000a4  2010              MOVS     r0,#0x10              ;768
0000a6  4020              ANDS     r0,r0,r4              ;768
0000a8  2800              CMP      r0,#0                 ;768
0000aa  d007              BEQ      |L14.188|
0000ac  2080              MOVS     r0,#0x80              ;771
0000ae  4320              ORRS     r0,r0,r4              ;771
0000b0  4926              LDR      r1,|L14.332|
0000b2  7448              STRB     r0,[r1,#0x11]         ;771
0000b4  4923              LDR      r1,|L14.324|
0000b6  2000              MOVS     r0,#0                 ;772
0000b8  f7fffffe          BL       __aeabi_uwrite4
                  |L14.188|
0000bc  4821              LDR      r0,|L14.324|
0000be  f7fffffe          BL       __aeabi_uread4
0000c2  2800              CMP      r0,#0                 ;776
0000c4  d110              BNE      |L14.232|
0000c6  07e0              LSLS     r0,r4,#31             ;781
0000c8  0fc0              LSRS     r0,r0,#31             ;781
0000ca  2800              CMP      r0,#0                 ;781
0000cc  d00c              BEQ      |L14.232|
0000ce  4a36              LDR      r2,|L14.424|
0000d0  2108              MOVS     r1,#8                 ;786
0000d2  2000              MOVS     r0,#0                 ;786
0000d4  f7fffffe          BL       FIFORead
0000d8  a134              ADR      r1,|L14.428|
0000da  2000              MOVS     r0,#0                 ;787
0000dc  f7fffffe          BL       SEGGER_RTT_printf
0000e0  4931              LDR      r1,|L14.424|
0000e2  4818              LDR      r0,|L14.324|
0000e4  f7fffffe          BL       USB_Endpoint0_Command
                  |L14.232|
0000e8  4816              LDR      r0,|L14.324|
0000ea  f7fffffe          BL       __aeabi_uread4
0000ee  2802              CMP      r0,#2                 ;793
0000f0  d107              BNE      |L14.258|
0000f2  a133              ADR      r1,|L14.448|
0000f4  2000              MOVS     r0,#0                 ;796
0000f6  f7fffffe          BL       SEGGER_RTT_printf
0000fa  4812              LDR      r0,|L14.324|
0000fc  f7fffffe          BL       USB_Endpoint0_Tx
000100  e00b              B        |L14.282|
                  |L14.258|
000102  4810              LDR      r0,|L14.324|
000104  f7fffffe          BL       __aeabi_uread4
000108  2801              CMP      r0,#1                 ;799
00010a  d106              BNE      |L14.282|
00010c  a132              ADR      r1,|L14.472|
00010e  2000              MOVS     r0,#0                 ;802
000110  f7fffffe          BL       SEGGER_RTT_printf
000114  480b              LDR      r0,|L14.324|
000116  f7fffffe          BL       USB_Endpoint0_Rx
                  |L14.282|
00011a  bf00              NOP      
00011c  e783              B        |L14.38|
;;;806    
                          ENDP

00011e  0000              DCW      0x0000
                  |L14.288|
000120  5553425f          DCB      "USB_Endpoint0  xxx nCallState =%d\n",0
000124  456e6470
000128  6f696e74
00012c  30202078
000130  7878206e
000134  43616c6c
000138  53746174
00013c  65203d25
000140  640a00  
000143  00                DCB      0
                  |L14.324|
                          DCD      ep0state
                  |L14.328|
                          DCD      gpCurCfg
                  |L14.332|
                          DCD      0x40005c00
                  |L14.336|
                          DCD      gnDevState
                  |L14.340|
000154  676e4465          DCB      "gnDevState = DEVSTATE_ADDRESS;\t xxx 111\n",0
000158  76537461
00015c  7465203d
000160  20444556
000164  53544154
000168  455f4144
00016c  44524553
000170  533b0920
000174  78787820
000178  3131310a
00017c  00      
00017d  00                DCB      0
00017e  00                DCB      0
00017f  00                DCB      0
                  |L14.384|
000180  676e4465          DCB      "gnDevState = DEVSTATE_ADDRESS;\t 222\n",0
000184  76537461
000188  7465203d
00018c  20444556
000190  53544154
000194  455f4144
000198  44524553
00019c  533b0920
0001a0  3232320a
0001a4  00      
0001a5  00                DCB      0
0001a6  00                DCB      0
0001a7  00                DCB      0
                  |L14.424|
                          DCD      ||cmd||
                  |L14.428|
0001ac  5553425f          DCB      "USB_Endpoint0  aaa\n",0
0001b0  456e6470
0001b4  6f696e74
0001b8  30202061
0001bc  61610a00
                  |L14.448|
0001c0  5553425f          DCB      "USB_Endpoint0_Tx 1111\n",0
0001c4  456e6470
0001c8  6f696e74
0001cc  305f5478
0001d0  20313131
0001d4  310a00  
0001d7  00                DCB      0
                  |L14.472|
0001d8  5553425f          DCB      "USB_Endpoint0_Tx 2222\n",0
0001dc  456e6470
0001e0  6f696e74
0001e4  305f5478
0001e8  20323232
0001ec  320a00  
0001ef  00                DCB      0

                          AREA ||i.USB_Endpoint0_Command||, CODE, READONLY, ALIGN=2

                  USB_Endpoint0_Command PROC
;;;990    */
;;;991    static void USB_Endpoint0_Command(PM_EP0_STATUS pep0state, PCOMMAND pcmd)
000000  b570              PUSH     {r4-r6,lr}
;;;992    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;993    
;;;994    
;;;995    	/* Check request type */
;;;996    	switch(pcmd->bmRequestType & M_CMD_TYPEMASK)	//判断数据中为何种命令
000006  7820              LDRB     r0,[r4,#0]
000008  2160              MOVS     r1,#0x60
00000a  4008              ANDS     r0,r0,r1
00000c  2800              CMP      r0,#0
00000e  d004              BEQ      |L15.26|
000010  2820              CMP      r0,#0x20
000012  d007              BEQ      |L15.36|
000014  2840              CMP      r0,#0x40
000016  d10a              BNE      |L15.46|
000018  e00a              B        |L15.48|
                  |L15.26|
;;;997    	{
;;;998    		/***主机到设备，标准请求命令，接收者为设备***/
;;;999    		case M_CMD_STDREQ:
;;;1000   			USB_StdDev_Req(pep0state, pcmd);
00001a  4621              MOV      r1,r4
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       USB_StdDev_Req
;;;1001   			break;
000022  e009              B        |L15.56|
                  |L15.36|
;;;1002   
;;;1003   		/***主机到设备，类请求命令，接收者为设备***/
;;;1004   		case M_CMD_CLASSREQ:
;;;1005   			/* Add call to external routine for handling class requests */
;;;1006   			USB_HID_Class_Req(pep0state,pcmd);
000024  4621              MOV      r1,r4
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       USB_HID_Class_Req
;;;1007   			break;
00002c  e004              B        |L15.56|
                  |L15.46|
;;;1008   		/***主机到设备，用户定义的命令，接收者为设备***/
;;;1009   		case M_CMD_VENDREQ:
00002e  bf00              NOP      
                  |L15.48|
;;;1010   		/* Add call to external routine for handling vendor requests */
;;;1011   			
;;;1012   		/***保留***/
;;;1013   		default:
;;;1014   			/* Stall the command if a reserved request is received */
;;;1015   			MWRITE_BYTE(M_REG_CSR0, M_CSR0_SVDOUTPKTRDY | M_CSR0_SENDSTALL);
000030  2060              MOVS     r0,#0x60
000032  4902              LDR      r1,|L15.60|
000034  7448              STRB     r0,[r1,#0x11]
;;;1016   		break;
000036  bf00              NOP      
                  |L15.56|
000038  bf00              NOP                            ;1001
;;;1017     }
;;;1018   
;;;1019   	return;
;;;1020   }
00003a  bd70              POP      {r4-r6,pc}
;;;1021   
                          ENDP

                  |L15.60|
                          DCD      0x40005c00

                          AREA ||i.USB_Endpoint0_Rx||, CODE, READONLY, ALIGN=2

                  USB_Endpoint0_Rx PROC
;;;1716   */
;;;1717   static void USB_Endpoint0_Rx(PM_EP0_STATUS pep0state)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1718   {
000002  4604              MOV      r4,r0
;;;1719   	BYTE    byOutCSR;
;;;1720   	
;;;1721   	/* Set index register */
;;;1722   	MWRITE_BYTE(M_REG_INDEX, 0);
000004  2000              MOVS     r0,#0
000006  4910              LDR      r1,|L16.72|
000008  7388              STRB     r0,[r1,#0xe]
;;;1723   	/* Read OUT CSR register */
;;;1724   	byOutCSR = MREAD_BYTE(M_REG_CSR0);
00000a  4608              MOV      r0,r1
00000c  7c45              LDRB     r5,[r0,#0x11]
;;;1725   
;;;1726   	/* Get packet, */
;;;1727   	/* may need to unload more than one packet if double buffering enabled */
;;;1728   	/*端点FIFO 中有数据*/
;;;1729   	while(byOutCSR & M_CSR0_OUTPKTRDY)
00000e  e016              B        |L16.62|
                  |L16.16|
;;;1730   	{
;;;1731   		pep0state->nState = M_EP0_IDLE;
000010  4621              MOV      r1,r4
000012  2000              MOVS     r0,#0
000014  f7fffffe          BL       __aeabi_uwrite4
;;;1732   
;;;1733   		/* Unload FIFO */
;;;1734   		//FIFORead(0, 1, pep0state->pData);//NUM CAP SCR指示灯信息
;;;1735   		FIFORead(0, pep0state->nBytesLeft, pep0state->pData);//NUM CAP SCR指示灯信息
000018  4620              MOV      r0,r4
00001a  3008              ADDS     r0,r0,#8
00001c  f7fffffe          BL       __aeabi_uread4
000020  4606              MOV      r6,r0
000022  1d20              ADDS     r0,r4,#4
000024  f7fffffe          BL       __aeabi_uread4
000028  4607              MOV      r7,r0
00002a  4632              MOV      r2,r6
00002c  4639              MOV      r1,r7
00002e  2000              MOVS     r0,#0
000030  f7fffffe          BL       FIFORead
;;;1736   		
;;;1737   		/*Cear flag*/
;;;1738   		MWRITE_BYTE(M_REG_CSR0,M_CSR0_SVDOUTPKTRDY);
000034  2040              MOVS     r0,#0x40
000036  4904              LDR      r1,|L16.72|
000038  7448              STRB     r0,[r1,#0x11]
;;;1739   		/* Check for another packet */
;;;1740   		byOutCSR = MREAD_BYTE(M_REG_CSR0);
00003a  4608              MOV      r0,r1
00003c  7c45              LDRB     r5,[r0,#0x11]
                  |L16.62|
00003e  07e8              LSLS     r0,r5,#31             ;1729
000040  0fc0              LSRS     r0,r0,#31             ;1729
000042  2800              CMP      r0,#0                 ;1729
000044  d1e4              BNE      |L16.16|
;;;1741   	}
;;;1742   		
;;;1743   }
000046  bdf8              POP      {r3-r7,pc}
;;;1744   
                          ENDP

                  |L16.72|
                          DCD      0x40005c00

                          AREA ||i.USB_Endpoint0_Tx||, CODE, READONLY, ALIGN=2

                  USB_Endpoint0_Tx PROC
;;;1674   */
;;;1675   static void USB_Endpoint0_Tx(PM_EP0_STATUS pep0state)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1676   {
000002  4604              MOV      r4,r0
;;;1677   	int	nBytes;
;;;1678   	BYTE	by;
;;;1679   
;;;1680   	/* Determine number of bytes to send */
;;;1681   	if(pep0state->nBytesLeft <= M_EP0_MAXP)
000004  1d20              ADDS     r0,r4,#4
000006  f7fffffe          BL       __aeabi_uread4
00000a  2840              CMP      r0,#0x40
00000c  dc08              BGT      |L17.32|
;;;1682   	{
;;;1683   		nBytes = pep0state->nBytesLeft;
00000e  1d20              ADDS     r0,r4,#4
000010  f7fffffe          BL       __aeabi_uread4
000014  4605              MOV      r5,r0
;;;1684   		pep0state->nBytesLeft = 0;
000016  1d21              ADDS     r1,r4,#4
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       __aeabi_uwrite4
00001e  e008              B        |L17.50|
                  |L17.32|
;;;1685   	}
;;;1686   	else
;;;1687   	{
;;;1688   		nBytes = M_EP0_MAXP;
000020  2540              MOVS     r5,#0x40
;;;1689   		pep0state->nBytesLeft -= M_EP0_MAXP;
000022  1d20              ADDS     r0,r4,#4
000024  f7fffffe          BL       __aeabi_uread4
000028  1b47              SUBS     r7,r0,r5
00002a  1d21              ADDS     r1,r4,#4
00002c  4638              MOV      r0,r7
00002e  f7fffffe          BL       __aeabi_uwrite4
                  |L17.50|
;;;1690   	}
;;;1691   
;;;1692   	FIFOWrite(0, nBytes, pep0state->pData);
000032  4620              MOV      r0,r4
000034  3008              ADDS     r0,r0,#8
000036  f7fffffe          BL       __aeabi_uread4
00003a  4607              MOV      r7,r0
00003c  463a              MOV      r2,r7
00003e  4629              MOV      r1,r5
000040  2000              MOVS     r0,#0
000042  f7fffffe          BL       FIFOWrite
;;;1693   	pep0state->pData = (BYTE *)pep0state->pData + nBytes;
000046  4620              MOV      r0,r4
000048  3008              ADDS     r0,r0,#8
00004a  f7fffffe          BL       __aeabi_uread4
00004e  1947              ADDS     r7,r0,r5
000050  4621              MOV      r1,r4
000052  3108              ADDS     r1,r1,#8
000054  4638              MOV      r0,r7
000056  f7fffffe          BL       __aeabi_uwrite4
;;;1694   	if(nBytes < M_EP0_MAXP)
00005a  2d40              CMP      r5,#0x40
00005c  da05              BGE      |L17.106|
;;;1695   	{
;;;1696   		/***数据已经写入 FIFO 中,将要发送的时最后一包数据***/
;;;1697   		by = M_CSR0_INPKTRDY | M_CSR0_DATAEND;
00005e  260a              MOVS     r6,#0xa
;;;1698   		pep0state->nState = M_EP0_IDLE;
000060  4621              MOV      r1,r4
000062  2000              MOVS     r0,#0
000064  f7fffffe          BL       __aeabi_uwrite4
000068  e000              B        |L17.108|
                  |L17.106|
;;;1699   	}
;;;1700   	else
;;;1701   	{
;;;1702   		/***数据已经写入 FIFO 中***/
;;;1703   		by = M_CSR0_INPKTRDY;
00006a  2602              MOVS     r6,#2
                  |L17.108|
;;;1704   	}
;;;1705   	
;;;1706   	MWRITE_BYTE(M_REG_CSR0, by);
00006c  4801              LDR      r0,|L17.116|
00006e  7446              STRB     r6,[r0,#0x11]
;;;1707   }
000070  bdf8              POP      {r3-r7,pc}
;;;1708   
                          ENDP

000072  0000              DCW      0x0000
                  |L17.116|
                          DCD      0x40005c00

                          AREA ||i.USB_GetITStatus||, CODE, READONLY, ALIGN=2

                  USB_GetITStatus PROC
;;;666    */
;;;667    ITStatus USB_GetITStatus(uint32_t USB_IT)
000000  b570              PUSH     {r4-r6,lr}
;;;668    {
000002  4601              MOV      r1,r0
;;;669        __IO uint8_t *tmp = (__IO uint8_t *)USB_BASE;
000004  4a16              LDR      r2,|L18.96|
;;;670        uint8_t tmp_flag = 0;
000006  2300              MOVS     r3,#0
;;;671    		uint32_t IT_FLAG = 0;
000008  2400              MOVS     r4,#0
;;;672        ITStatus bitstatus = RESET;
00000a  2000              MOVS     r0,#0
;;;673    
;;;674        assert_param(IS_USB_CONFIG_IT(USB_IT));
;;;675    
;;;676        if(USB_IT & 0x00000100)
00000c  1595              ASRS     r5,r2,#22
00000e  400d              ANDS     r5,r5,r1
000010  2d00              CMP      r5,#0
000012  d005              BEQ      |L18.32|
;;;677        {
;;;678          tmp = &USB->INTRIN;
000014  1c92              ADDS     r2,r2,#2
;;;679          IT_FLAG = USB_IT & 0xfffffeff;
000016  1596              ASRS     r6,r2,#22
000018  460d              MOV      r5,r1
00001a  43b5              BICS     r5,r5,r6
00001c  462c              MOV      r4,r5
00001e  e016              B        |L18.78|
                  |L18.32|
;;;680        }
;;;681        else if(USB_IT & 0x00000200)
000020  2501              MOVS     r5,#1
000022  026d              LSLS     r5,r5,#9
000024  400d              ANDS     r5,r5,r1
000026  2d00              CMP      r5,#0
000028  d006              BEQ      |L18.56|
;;;682        {
;;;683          tmp = &USB->INTROUT;
00002a  4a0d              LDR      r2,|L18.96|
00002c  1d12              ADDS     r2,r2,#4
;;;684          IT_FLAG = USB_IT & 0xfffffdff;
00002e  1556              ASRS     r6,r2,#21
000030  460d              MOV      r5,r1
000032  43b5              BICS     r5,r5,r6
000034  462c              MOV      r4,r5
000036  e00a              B        |L18.78|
                  |L18.56|
;;;685        }
;;;686        else if(USB_IT & 0x00000400)
000038  2501              MOVS     r5,#1
00003a  02ad              LSLS     r5,r5,#10
00003c  400d              ANDS     r5,r5,r1
00003e  2d00              CMP      r5,#0
000040  d005              BEQ      |L18.78|
;;;687        {
;;;688          tmp = &USB->INTRUSB;
000042  4a07              LDR      r2,|L18.96|
000044  1d92              ADDS     r2,r2,#6
;;;689          IT_FLAG = USB_IT & 0xfffffbff;
000046  1516              ASRS     r6,r2,#20
000048  460d              MOV      r5,r1
00004a  43b5              BICS     r5,r5,r6
00004c  462c              MOV      r4,r5
                  |L18.78|
;;;690        }
;;;691    
;;;692        tmp_flag = *(__IO uint8_t *)tmp;
00004e  7813              LDRB     r3,[r2,#0]
;;;693        if( (tmp_flag & ((uint8_t)IT_FLAG)) != ((uint8_t)RESET))
000050  461d              MOV      r5,r3
000052  4025              ANDS     r5,r5,r4
000054  2d00              CMP      r5,#0
000056  d001              BEQ      |L18.92|
;;;694        {
;;;695          bitstatus = SET;
000058  2001              MOVS     r0,#1
00005a  e000              B        |L18.94|
                  |L18.92|
;;;696        }
;;;697        else
;;;698        {
;;;699          bitstatus = RESET;
00005c  2000              MOVS     r0,#0
                  |L18.94|
;;;700        }
;;;701    
;;;702        return bitstatus;
;;;703    }
00005e  bd70              POP      {r4-r6,pc}
;;;704    
                          ENDP

                  |L18.96|
                          DCD      0x40005c00

                          AREA ||i.USB_HID_Class_Req||, CODE, READONLY, ALIGN=2

                  USB_HID_Class_Req PROC
;;;941    */
;;;942    void USB_HID_Class_Req(PM_EP0_STATUS pep0state,PCOMMAND pcmd)
000000  b570              PUSH     {r4-r6,lr}
;;;943    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;944    	switch(pcmd->bRequest)
000006  7860              LDRB     r0,[r4,#1]
000008  0003              MOVS     r3,r0
00000a  f7fffffe          BL       __ARM_common_switch8
00000e  0c25              DCB      0x0c,0x25
000010  070c1125          DCB      0x07,0x0c,0x11,0x25
000014  25252525          DCB      0x25,0x25,0x25,0x25
000018  161b2025          DCB      0x16,0x1b,0x20,0x25
;;;945    	{
;;;946    		case	HID_REQUEST_GET_REPORT:
;;;947    		{
;;;948    			HID_GetReportEvent(pep0state,pcmd);
00001c  4621              MOV      r1,r4
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       HID_GetReportEvent
                  |L19.36|
;;;949    			return;
;;;950    		}
;;;951    		case	HID_REQUEST_GET_IDLE:
;;;952    		{
;;;953    			HID_GetIdleEvent(pep0state,pcmd);
;;;954    			return;
;;;955    		}
;;;956    		case	HID_REQUEST_GET_PROTOCOL:
;;;957    		{
;;;958    			HID_GetProtocolEvent(pep0state,pcmd);
;;;959    			return;
;;;960    		}
;;;961    		case	HID_REQUEST_SET_REPORT:
;;;962    		{
;;;963    			HID_SetReportEvent(pep0state,pcmd);
;;;964    			return;
;;;965    		}
;;;966    		case	HID_REQUEST_SET_IDLE:
;;;967    		{
;;;968    			HID_SetIdleEvent(pep0state,pcmd);
;;;969    			return;
;;;970    		}
;;;971    		case	HID_REQUEST_SET_PROTOCOL:
;;;972    		{
;;;973    			HID_SetProtocolEvent(pep0state,pcmd);
;;;974    			return;
;;;975    		}
;;;976    		default:
;;;977    		{
;;;978    			break;
;;;979    		}
;;;980    	}
;;;981    	MWRITE_BYTE(M_REG_CSR0, M_CSR0_SVDOUTPKTRDY | M_CSR0_SENDSTALL);
;;;982    }
000024  bd70              POP      {r4-r6,pc}
000026  4621              MOV      r1,r4                 ;953
000028  4628              MOV      r0,r5                 ;953
00002a  f7fffffe          BL       HID_GetIdleEvent
00002e  e7f9              B        |L19.36|
000030  4621              MOV      r1,r4                 ;958
000032  4628              MOV      r0,r5                 ;958
000034  f7fffffe          BL       HID_GetProtocolEvent
000038  e7f4              B        |L19.36|
00003a  4621              MOV      r1,r4                 ;963
00003c  4628              MOV      r0,r5                 ;963
00003e  f7fffffe          BL       HID_SetReportEvent
000042  e7ef              B        |L19.36|
000044  4621              MOV      r1,r4                 ;968
000046  4628              MOV      r0,r5                 ;968
000048  f7fffffe          BL       HID_SetIdleEvent
00004c  e7ea              B        |L19.36|
00004e  4621              MOV      r1,r4                 ;973
000050  4628              MOV      r0,r5                 ;973
000052  f7fffffe          BL       HID_SetProtocolEvent
000056  e7e5              B        |L19.36|
000058  bf00              NOP                            ;978
00005a  bf00              NOP                            ;978
00005c  2060              MOVS     r0,#0x60              ;981
00005e  4902              LDR      r1,|L19.104|
000060  7448              STRB     r0,[r1,#0x11]         ;981
000062  bf00              NOP      
000064  e7de              B        |L19.36|
;;;983    /******************************************************************************
                          ENDP

000066  0000              DCW      0x0000
                  |L19.104|
                          DCD      0x40005c00

                          AREA ||i.USB_IRQHandler||, CODE, READONLY, ALIGN=2

                  USB_IRQHandler PROC
;;;123    */
;;;124    void USB_IRQHandler(void)
000000  b5fe              PUSH     {r1-r7,lr}
;;;125    {
;;;126    	uint8_t usb_intrin = 0,usb_intrusb = 0,usb_introut = 0;
000002  2000              MOVS     r0,#0
000004  9001              STR      r0,[sp,#4]
000006  2700              MOVS     r7,#0
000008  2600              MOVS     r6,#0
;;;127    			ListUsbData  *pUsbData;
;;;128    			uint16 recv_data_len;
;;;129    	usb_intrin  = USB->INTRIN;									//端点中断标志
00000a  4882              LDR      r0,|L20.532|
00000c  7880              LDRB     r0,[r0,#2]
00000e  9001              STR      r0,[sp,#4]
;;;130    	usb_intrusb = USB->INTRUSB;									//USB中断标志RESET、RESUME、SUSPEND、SOF
000010  4880              LDR      r0,|L20.532|
000012  7987              LDRB     r7,[r0,#6]
;;;131    	usb_introut = USB->INTROUT;
000014  7906              LDRB     r6,[r0,#4]
;;;132    	
;;;133    	//SEGGER_RTT_printf(0,"USB_IRQHandler ###usb_intrin =0x%02x usb_intrusb =0x%02x ###usb_introut =0x%02x\n",usb_intrin,usb_intrusb,usb_introut);
;;;134    	if(usb_introut!=0 || usb_intrin!=0)
000016  2e00              CMP      r6,#0
000018  d102              BNE      |L20.32|
00001a  9801              LDR      r0,[sp,#4]
00001c  2800              CMP      r0,#0
00001e  d006              BEQ      |L20.46|
                  |L20.32|
;;;135    		{
;;;136    		SEGGER_RTT_printf(0,"USB_IRQHandler ###usb_intrin =0x%02x usb_intrusb =0x%02x ###usb_introut =0x%02x\n",usb_intrin,usb_intrusb,usb_introut);
000020  463b              MOV      r3,r7
000022  9600              STR      r6,[sp,#0]
000024  497c              LDR      r1,|L20.536|
000026  2000              MOVS     r0,#0
000028  9a01              LDR      r2,[sp,#4]
00002a  f7fffffe          BL       SEGGER_RTT_printf
                  |L20.46|
;;;137    		}
;;;138    	if(usb_introut!=0)
00002e  2e00              CMP      r6,#0
000030  d004              BEQ      |L20.60|
;;;139    		{
;;;140    		   
;;;141    		   SEGGER_RTT_printf(0,"USB_IRQHandler ############################################# usb_introut =0x%02x \n",usb_introut);
000032  4632              MOV      r2,r6
000034  4979              LDR      r1,|L20.540|
000036  2000              MOVS     r0,#0
000038  f7fffffe          BL       SEGGER_RTT_printf
                  |L20.60|
;;;142    		}
;;;143    	/*Check for resume from suspend mode, Add call to resume routine here */
;;;144    	if((usb_intrusb & 0x02) != RESET)							//RESUME
00003c  2002              MOVS     r0,#2
00003e  4038              ANDS     r0,r0,r7
000040  2800              CMP      r0,#0
000042  d002              BEQ      |L20.74|
;;;145    	{
;;;146    		usb_state = USB_RESUME_FLAG;
000044  2002              MOVS     r0,#2
000046  4976              LDR      r1,|L20.544|
000048  7008              STRB     r0,[r1,#0]
                  |L20.74|
;;;147    	}
;;;148    
;;;149    	if(usb_intrusb & USB_IT_USB_SOF_FLAG)						//SOF
00004a  2081              MOVS     r0,#0x81
00004c  00c0              LSLS     r0,r0,#3
00004e  4038              ANDS     r0,r0,r7
000050  2800              CMP      r0,#0
000052  d00c              BEQ      |L20.110|
;;;150    	{
;;;151    		USB->INTRUSB &= ~0x08;									//sof
000054  486f              LDR      r0,|L20.532|
000056  7980              LDRB     r0,[r0,#6]
000058  2108              MOVS     r1,#8
00005a  4388              BICS     r0,r0,r1
00005c  496d              LDR      r1,|L20.532|
00005e  7188              STRB     r0,[r1,#6]
;;;152    		f_sof_flag = 1;
000060  4870              LDR      r0,|L20.548|
000062  7800              LDRB     r0,[r0,#0]  ; flag1
000064  2110              MOVS     r1,#0x10
000066  4388              BICS     r0,r0,r1
000068  3010              ADDS     r0,r0,#0x10
00006a  496e              LDR      r1,|L20.548|
00006c  7008              STRB     r0,[r1,#0]
                  |L20.110|
;;;153    	}
;;;154    	/* Check for system interrupts */
;;;155    	if((usb_intrusb &USB_IT_USB_RESET_FLAG) != RESET)
00006e  486e              LDR      r0,|L20.552|
000070  4038              ANDS     r0,r0,r7
000072  2800              CMP      r0,#0
000074  d001              BEQ      |L20.122|
;;;156    	{
;;;157    		USB_Reset();
000076  f7fffffe          BL       USB_Reset
                  |L20.122|
;;;158    	}
;;;159    
;;;160    	/* Check for endpoint 0 interrupt */
;;;161    	if((usb_intrin & USB_IT_IN_EP0_FLAG) != RESET)
00007a  21ff              MOVS     r1,#0xff
00007c  3102              ADDS     r1,#2
00007e  9801              LDR      r0,[sp,#4]
000080  4008              ANDS     r0,r0,r1
000082  2800              CMP      r0,#0
000084  d006              BEQ      |L20.148|
;;;162    	{
;;;163    	SEGGER_RTT_printf(0,"USB_Endpoint0(M_EP_NORMAL); 111");
000086  a169              ADR      r1,|L20.556|
000088  2000              MOVS     r0,#0
00008a  f7fffffe          BL       SEGGER_RTT_printf
;;;164    		USB_Endpoint0(M_EP_NORMAL);
00008e  2000              MOVS     r0,#0
000090  f7fffffe          BL       USB_Endpoint0
                  |L20.148|
;;;165    	}
;;;166    
;;;167    
;;;168    	
;;;169    		
;;;170    
;;;171    		/* Check for endpoint 5 interrupt */
;;;172    	if((usb_introut & USB_IT_OUT_EP1_FLAG) != RESET) //huanghanjing
000094  486d              LDR      r0,|L20.588|
000096  4030              ANDS     r0,r0,r6
000098  2800              CMP      r0,#0
00009a  d029              BEQ      |L20.240|
;;;173    	{
;;;174    		//USB_EP_Rx(ep_hid_vendor_rx, Vendor_data_Buffer, M_EP_MAXP);
;;;175    				SEGGER_RTT_printf(0,"US B_IT_OUT_EP1_FLAG ##   # function=%s line=%d\n",__FUNCTION__,__LINE__);
00009c  23af              MOVS     r3,#0xaf
00009e  4a6c              LDR      r2,|L20.592|
0000a0  a16c              ADR      r1,|L20.596|
0000a2  2000              MOVS     r0,#0
0000a4  f7fffffe          BL       SEGGER_RTT_printf
;;;176    			recv_data_len = 	USB_EP_Rx(ep_iap2_vendor_rx, Vendor_data_Buffer, M_EP_MAXP);
0000a8  2240              MOVS     r2,#0x40
0000aa  4977              LDR      r1,|L20.648|
0000ac  2000              MOVS     r0,#0
0000ae  f7fffffe          BL       USB_EP_Rx
0000b2  b285              UXTH     r5,r0
;;;177    		pUsbData = (ListUsbData *)malloc(sizeof(ListUsbData));
0000b4  200f              MOVS     r0,#0xf
0000b6  f7fffffe          BL       malloc
0000ba  4604              MOV      r4,r0
;;;178    		pUsbData->pdata = malloc(recv_data_len);
0000bc  4628              MOV      r0,r5
0000be  f7fffffe          BL       malloc
0000c2  4621              MOV      r1,r4
0000c4  310a              ADDS     r1,r1,#0xa
0000c6  9000              STR      r0,[sp,#0]
0000c8  f7fffffe          BL       __aeabi_uwrite4
;;;179    		pUsbData->m_isUsed = 0;
0000cc  2000              MOVS     r0,#0
0000ce  73a0              STRB     r0,[r4,#0xe]
;;;180    		pUsbData->m_pNext = NULL;
0000d0  4621              MOV      r1,r4
0000d2  f7fffffe          BL       __aeabi_uwrite4
;;;181    		pUsbData->m_pPre = NULL;
0000d6  1d21              ADDS     r1,r4,#4
0000d8  2000              MOVS     r0,#0
0000da  f7fffffe          BL       __aeabi_uwrite4
;;;182    		pUsbData->data_size = recv_data_len;
0000de  b228              SXTH     r0,r5
0000e0  7220              STRB     r0,[r4,#8]
0000e2  0a00              LSRS     r0,r0,#8
0000e4  7260              STRB     r0,[r4,#9]
;;;183    		
;;;184    
;;;185    			ListUsbData_AddTail(g_usbdata_list,pUsbData);
0000e6  4621              MOV      r1,r4
0000e8  4868              LDR      r0,|L20.652|
0000ea  6800              LDR      r0,[r0,#0]  ; g_usbdata_list
0000ec  f7fffffe          BL       ListUsbData_AddTail
                  |L20.240|
;;;186    		#ifdef _debug_
;;;187    		//Vendor_data_Buffer[0]++;
;;;188    		//USB_Transmit_VendorData((uint8_t*)&send, M_EP_MAXP);
;;;189    		#endif
;;;190    	}
;;;191    	
;;;192    	if((usb_introut & USB_IT_OUT_EP2_FLAG) != RESET) //huanghanjing
0000f0  2081              MOVS     r0,#0x81
0000f2  0080              LSLS     r0,r0,#2
0000f4  4030              ANDS     r0,r0,r6
0000f6  2800              CMP      r0,#0
0000f8  d05c              BEQ      |L20.436|
;;;193    	{
;;;194    	
;;;195    	SEGGER_RTT_printf(0,"USB_IT_OUT_EP2_FLAG ### function=%s line=%d\n",__FUNCTION__,__LINE__);
0000fa  23c3              MOVS     r3,#0xc3
0000fc  4a54              LDR      r2,|L20.592|
0000fe  a164              ADR      r1,|L20.656|
000100  2000              MOVS     r0,#0
000102  f7fffffe          BL       SEGGER_RTT_printf
;;;196    	recv_data_len = 	USB_EP_Rx(2, Vendor_data_Buffer, M_EP_MAXP);
000106  2240              MOVS     r2,#0x40
000108  495f              LDR      r1,|L20.648|
00010a  2002              MOVS     r0,#2
00010c  f7fffffe          BL       USB_EP_Rx
000110  b285              UXTH     r5,r0
;;;197    	SEGGER_RTT_printf(0,"USB_IT_OUT_EP2_FLAG rr ### function=%s line=%d recv_data_len=%d\n",__FUNCTION__,__LINE__,recv_data_len);
000112  23c5              MOVS     r3,#0xc5
000114  4a4e              LDR      r2,|L20.592|
000116  496a              LDR      r1,|L20.704|
000118  2000              MOVS     r0,#0
00011a  9500              STR      r5,[sp,#0]
00011c  f7fffffe          BL       SEGGER_RTT_printf
;;;198    	for(int i=0;i<recv_data_len;i++)
000120  2000              MOVS     r0,#0
000122  9000              STR      r0,[sp,#0]
000124  e009              B        |L20.314|
                  |L20.294|
;;;199    		SEGGER_RTT_printf(0,"22 0x%02x ",Vendor_data_Buffer[i]);
000126  4958              LDR      r1,|L20.648|
000128  9800              LDR      r0,[sp,#0]
00012a  5c0a              LDRB     r2,[r1,r0]
00012c  a165              ADR      r1,|L20.708|
00012e  2000              MOVS     r0,#0
000130  f7fffffe          BL       SEGGER_RTT_printf
000134  9800              LDR      r0,[sp,#0]            ;198
000136  1c40              ADDS     r0,r0,#1              ;198
000138  9000              STR      r0,[sp,#0]            ;198
                  |L20.314|
00013a  9800              LDR      r0,[sp,#0]            ;198
00013c  42a8              CMP      r0,r5                 ;198
00013e  dbf2              BLT      |L20.294|
;;;200    		pUsbData = (ListUsbData *)malloc(sizeof(ListUsbData));
000140  200f              MOVS     r0,#0xf
000142  f7fffffe          BL       malloc
000146  4604              MOV      r4,r0
;;;201    		
;;;202    		SEGGER_RTT_printf(0,"\n ### function=%s line=%d recv_data_len=%d\n",__FUNCTION__,__LINE__,recv_data_len);
000148  23ca              MOVS     r3,#0xca
00014a  4a41              LDR      r2,|L20.592|
00014c  a160              ADR      r1,|L20.720|
00014e  2000              MOVS     r0,#0
000150  9500              STR      r5,[sp,#0]
000152  f7fffffe          BL       SEGGER_RTT_printf
;;;203    		pUsbData->pdata = malloc(recv_data_len);
000156  4628              MOV      r0,r5
000158  f7fffffe          BL       malloc
00015c  4621              MOV      r1,r4
00015e  310a              ADDS     r1,r1,#0xa
000160  9000              STR      r0,[sp,#0]
000162  f7fffffe          BL       __aeabi_uwrite4
;;;204    		
;;;205    		SEGGER_RTT_printf(0,"\n ### function=%s line=%d recv_data_len=%d\n",__FUNCTION__,__LINE__,recv_data_len);
000166  23cd              MOVS     r3,#0xcd
000168  4a39              LDR      r2,|L20.592|
00016a  a159              ADR      r1,|L20.720|
00016c  2000              MOVS     r0,#0
00016e  9500              STR      r5,[sp,#0]
000170  f7fffffe          BL       SEGGER_RTT_printf
;;;206    		pUsbData->m_isUsed = 0;
000174  2000              MOVS     r0,#0
000176  73a0              STRB     r0,[r4,#0xe]
;;;207    		pUsbData->m_pNext = NULL;
000178  4621              MOV      r1,r4
00017a  f7fffffe          BL       __aeabi_uwrite4
;;;208    		pUsbData->m_pPre = NULL;
00017e  1d21              ADDS     r1,r4,#4
000180  2000              MOVS     r0,#0
000182  f7fffffe          BL       __aeabi_uwrite4
;;;209    		pUsbData->data_size = recv_data_len;
000186  b228              SXTH     r0,r5
000188  7220              STRB     r0,[r4,#8]
00018a  0a00              LSRS     r0,r0,#8
00018c  7260              STRB     r0,[r4,#9]
;;;210    		
;;;211    		SEGGER_RTT_printf(0,"\n USB_IT_OUT_EP2_FLAG 111 ### function=%s line=%d recv_data_len=%d\n",__FUNCTION__,__LINE__,recv_data_len);
00018e  23d3              MOVS     r3,#0xd3
000190  4a2f              LDR      r2,|L20.592|
000192  495a              LDR      r1,|L20.764|
000194  2000              MOVS     r0,#0
000196  9500              STR      r5,[sp,#0]
000198  f7fffffe          BL       SEGGER_RTT_printf
;;;212    
;;;213    			ListUsbData_AddTail(g_usbdata_list,pUsbData);
00019c  4621              MOV      r1,r4
00019e  483b              LDR      r0,|L20.652|
0001a0  6800              LDR      r0,[r0,#0]  ; g_usbdata_list
0001a2  f7fffffe          BL       ListUsbData_AddTail
;;;214    	SEGGER_RTT_printf(0,"\n USB_IT_OUT_EP2_FLAG 222 ### function=%s line=%d recv_data_len=%d\n",__FUNCTION__,__LINE__,recv_data_len);
0001a6  23d6              MOVS     r3,#0xd6
0001a8  4a29              LDR      r2,|L20.592|
0001aa  4955              LDR      r1,|L20.768|
0001ac  2000              MOVS     r0,#0
0001ae  9500              STR      r5,[sp,#0]
0001b0  f7fffffe          BL       SEGGER_RTT_printf
                  |L20.436|
;;;215    
;;;216    		#ifdef _debug_
;;;217    		//Vendor_data_Buffer[0]++;
;;;218    		//USB_Transmit_VendorData((uint8_t*)&send, M_EP_MAXP);
;;;219    		#endif
;;;220    	}
;;;221    	
;;;222    
;;;223    	
;;;224    	/* Check for endpoint 5 interrupt */
;;;225    	if((usb_introut & USB_IT_OUT_EP5_FLAG) != RESET)
0001b4  2011              MOVS     r0,#0x11
0001b6  0140              LSLS     r0,r0,#5
0001b8  4030              ANDS     r0,r0,r6
0001ba  2800              CMP      r0,#0
0001bc  d00a              BEQ      |L20.468|
;;;226    	{
;;;227    	
;;;228    	SEGGER_RTT_printf(0,"USB_IT_OUT_EP2_FLAG ### function=%s line=%d\n",__FUNCTION__,__LINE__);
0001be  23e4              MOVS     r3,#0xe4
0001c0  4a23              LDR      r2,|L20.592|
0001c2  a133              ADR      r1,|L20.656|
0001c4  2000              MOVS     r0,#0
0001c6  f7fffffe          BL       SEGGER_RTT_printf
;;;229    		USB_EP_Rx(ep_hid_vendor_rx, Vendor_data_Buffer, M_EP_MAXP);
0001ca  2240              MOVS     r2,#0x40
0001cc  492e              LDR      r1,|L20.648|
0001ce  2005              MOVS     r0,#5
0001d0  f7fffffe          BL       USB_EP_Rx
                  |L20.468|
;;;230    		
;;;231    		#ifdef _debug_
;;;232    		//Vendor_data_Buffer[0]++;
;;;233    		//USB_Transmit_VendorData((uint8_t*)&send, M_EP_MAXP);
;;;234    		#endif
;;;235    	}
;;;236    	
;;;237    	/* Check for endpoint 7 interrupt */
;;;238    	if((usb_introut & USB_IT_OUT_EP7_FLAG) != RESET)
0001d4  2005              MOVS     r0,#5
0001d6  01c0              LSLS     r0,r0,#7
0001d8  4030              ANDS     r0,r0,r6
0001da  2800              CMP      r0,#0
0001dc  d00d              BEQ      |L20.506|
;;;239    	{	
;;;240    		USB_EP_Rx(7, Vendor_data_Buffer, M_EP_MAXP);
0001de  2240              MOVS     r2,#0x40
0001e0  4929              LDR      r1,|L20.648|
0001e2  2007              MOVS     r0,#7
0001e4  f7fffffe          BL       USB_EP_Rx
;;;241    		
;;;242    		#ifdef _debug_
;;;243    		Vendor_data_Buffer[0]++;
0001e8  4827              LDR      r0,|L20.648|
0001ea  7800              LDRB     r0,[r0,#0]  ; Vendor_data_Buffer
0001ec  1c40              ADDS     r0,r0,#1
0001ee  4926              LDR      r1,|L20.648|
0001f0  7008              STRB     r0,[r1,#0]
;;;244    		USB_EP_Tx(6, Vendor_data_Buffer, M_EP_MAXP);
0001f2  2240              MOVS     r2,#0x40
0001f4  2006              MOVS     r0,#6
0001f6  f7fffffe          BL       USB_EP_Tx
                  |L20.506|
;;;245    		#endif
;;;246    	}
;;;247    
;;;248    	/* Check for suspend mode */
;;;249    	/* Add call to suspend routine here*/
;;;250    	if((usb_intrusb & 0x01) != RESET)
0001fa  07f8              LSLS     r0,r7,#31
0001fc  0fc0              LSRS     r0,r0,#31
0001fe  2800              CMP      r0,#0
000200  d006              BEQ      |L20.528|
;;;251    	{
;;;252    		if(gnDevState > DEVSTATE_ADDRESS)
000202  4840              LDR      r0,|L20.772|
000204  6800              LDR      r0,[r0,#0]  ; gnDevState
000206  2801              CMP      r0,#1
000208  d902              BLS      |L20.528|
;;;253    		{
;;;254    			usb_state = USB_SUSPEND_FLAG;						//usb suspend
00020a  2001              MOVS     r0,#1
00020c  4904              LDR      r1,|L20.544|
00020e  7008              STRB     r0,[r1,#0]
                  |L20.528|
;;;255    		}
;;;256    	}
;;;257    }
000210  bdfe              POP      {r1-r7,pc}
;;;258    /******************************************************************************
                          ENDP

000212  0000              DCW      0x0000
                  |L20.532|
                          DCD      0x40005c00
                  |L20.536|
                          DCD      ||.conststring||
                  |L20.540|
                          DCD      ||.conststring||+0x54
                  |L20.544|
                          DCD      usb_state
                  |L20.548|
                          DCD      flag1
                  |L20.552|
                          DCD      0x00000404
                  |L20.556|
00022c  5553425f          DCB      "USB_Endpoint0(M_EP_NORMAL); 111",0
000230  456e6470
000234  6f696e74
000238  30284d5f
00023c  45505f4e
000240  4f524d41
000244  4c293b20
000248  31313100
                  |L20.588|
                          DCD      0x00000202
                  |L20.592|
                          DCD      __FUNCTION__
                  |L20.596|
000254  55532042          DCB      "US B_IT_OUT_EP1_FLAG ##   # function=%s line=%d\n",0
000258  5f49545f
00025c  4f55545f
000260  4550315f
000264  464c4147
000268  20232320
00026c  20202320
000270  66756e63
000274  74696f6e
000278  3d257320
00027c  6c696e65
000280  3d25640a
000284  00      
000285  00                DCB      0
000286  00                DCB      0
000287  00                DCB      0
                  |L20.648|
                          DCD      Vendor_data_Buffer
                  |L20.652|
                          DCD      g_usbdata_list
                  |L20.656|
000290  5553425f          DCB      "USB_IT_OUT_EP2_FLAG ### function=%s line=%d\n",0
000294  49545f4f
000298  55545f45
00029c  50325f46
0002a0  4c414720
0002a4  23232320
0002a8  66756e63
0002ac  74696f6e
0002b0  3d257320
0002b4  6c696e65
0002b8  3d25640a
0002bc  00      
0002bd  00                DCB      0
0002be  00                DCB      0
0002bf  00                DCB      0
                  |L20.704|
                          DCD      ||.conststring||+0xa8
                  |L20.708|
0002c4  32322030          DCB      "22 0x%02x ",0
0002c8  78253032
0002cc  782000  
0002cf  00                DCB      0
                  |L20.720|
0002d0  0a202323          DCB      "\n ### function=%s line=%d recv_data_len=%d\n",0
0002d4  23206675
0002d8  6e637469
0002dc  6f6e3d25
0002e0  73206c69
0002e4  6e653d25
0002e8  64207265
0002ec  63765f64
0002f0  6174615f
0002f4  6c656e3d
0002f8  25640a00
                  |L20.764|
                          DCD      ||.conststring||+0xec
                  |L20.768|
                          DCD      ||.conststring||+0x130
                  |L20.772|
                          DCD      gnDevState

                          AREA ||i.USB_ITConfig||, CODE, READONLY, ALIGN=2

                  USB_ITConfig PROC
;;;626    */
;;;627    void USB_ITConfig(uint32_t USB_IT, FunctionalState NewState)
000000  b530              PUSH     {r4,r5,lr}
;;;628    {
000002  460a              MOV      r2,r1
;;;629        __IO uint8_t *tmp = (__IO uint8_t *)USB_BASE;
000004  4916              LDR      r1,|L21.96|
;;;630        uint32_t IT_FLAG = 0;
000006  2300              MOVS     r3,#0
;;;631    
;;;632        assert_param(IS_USB_CONFIG_IT(USB_IT));
;;;633        assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;634    
;;;635        if(USB_IT & 0x00000100)
000008  158c              ASRS     r4,r1,#22
00000a  4004              ANDS     r4,r4,r0
00000c  2c00              CMP      r4,#0
00000e  d005              BEQ      |L21.28|
;;;636        {
;;;637          tmp = &USB->INTRINE;
000010  1dc9              ADDS     r1,r1,#7
;;;638          IT_FLAG = USB_IT & 0xfffffeff;
000012  158d              ASRS     r5,r1,#22
000014  4604              MOV      r4,r0
000016  43ac              BICS     r4,r4,r5
000018  4623              MOV      r3,r4
00001a  e016              B        |L21.74|
                  |L21.28|
;;;639        }
;;;640        else if(USB_IT & 0x00000200)
00001c  2401              MOVS     r4,#1
00001e  0264              LSLS     r4,r4,#9
000020  4004              ANDS     r4,r4,r0
000022  2c00              CMP      r4,#0
000024  d006              BEQ      |L21.52|
;;;641        {
;;;642          tmp = &USB->INTROUTE;
000026  490e              LDR      r1,|L21.96|
000028  3109              ADDS     r1,r1,#9
;;;643          IT_FLAG = USB_IT & 0xfffffdff;
00002a  154d              ASRS     r5,r1,#21
00002c  4604              MOV      r4,r0
00002e  43ac              BICS     r4,r4,r5
000030  4623              MOV      r3,r4
000032  e00a              B        |L21.74|
                  |L21.52|
;;;644        }
;;;645        else if(USB_IT & 0x00000400)
000034  2401              MOVS     r4,#1
000036  02a4              LSLS     r4,r4,#10
000038  4004              ANDS     r4,r4,r0
00003a  2c00              CMP      r4,#0
00003c  d005              BEQ      |L21.74|
;;;646        {
;;;647          tmp = &USB->INTRUSBE;
00003e  4908              LDR      r1,|L21.96|
000040  310b              ADDS     r1,r1,#0xb
;;;648          IT_FLAG = USB_IT & 0xfffffbff;
000042  150d              ASRS     r5,r1,#20
000044  4604              MOV      r4,r0
000046  43ac              BICS     r4,r4,r5
000048  4623              MOV      r3,r4
                  |L21.74|
;;;649        }
;;;650    
;;;651        if(NewState != DISABLE)
00004a  2a00              CMP      r2,#0
00004c  d004              BEQ      |L21.88|
;;;652        {
;;;653          *((__IO uint8_t *)tmp) |= (uint8_t)IT_FLAG;
00004e  780c              LDRB     r4,[r1,#0]
000050  b2dd              UXTB     r5,r3
000052  432c              ORRS     r4,r4,r5
000054  700c              STRB     r4,[r1,#0]
000056  e002              B        |L21.94|
                  |L21.88|
;;;654        }
;;;655        else
;;;656        {
;;;657          *((__IO uint8_t *)tmp) &= ~((uint8_t)IT_FLAG);
000058  780c              LDRB     r4,[r1,#0]
00005a  439c              BICS     r4,r4,r3
00005c  700c              STRB     r4,[r1,#0]
                  |L21.94|
;;;658        }
;;;659    }
00005e  bd30              POP      {r4,r5,pc}
;;;660    /******************************************************************************
                          ENDP

                  |L21.96|
                          DCD      0x40005c00

                          AREA ||i.USB_Init||, CODE, READONLY, ALIGN=2

                  USB_Init PROC
;;;86     */
;;;87     void USB_Init(void)
000000  b508              PUSH     {r3,lr}
;;;88     {
;;;89       NVIC_InitTypeDef NVIC_InitStructure;
;;;90     
;;;91     	if(RCC_GetFlagStatus(RCC_FLAG_HSI48RDY) != SET)
000002  2071              MOVS     r0,#0x71
000004  f7fffffe          BL       RCC_GetFlagStatus
000008  2801              CMP      r0,#1
00000a  d008              BEQ      |L22.30|
;;;92     	{
;;;93     		RCC_HSI48Cmd(ENABLE);
00000c  2001              MOVS     r0,#1
00000e  f7fffffe          BL       RCC_HSI48Cmd
;;;94     		while(RCC_GetFlagStatus(RCC_FLAG_HSI48RDY) != SET);
000012  bf00              NOP      
                  |L22.20|
000014  2071              MOVS     r0,#0x71
000016  f7fffffe          BL       RCC_GetFlagStatus
00001a  2801              CMP      r0,#1
00001c  d1fa              BNE      |L22.20|
                  |L22.30|
;;;95     	}
;;;96       RCC_USBCLKConfig(RCC_USBCLK_HSI48);
00001e  2000              MOVS     r0,#0
000020  f7fffffe          BL       RCC_USBCLKConfig
;;;97     	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USB,ENABLE);
000024  2101              MOVS     r1,#1
000026  05c8              LSLS     r0,r1,#23
000028  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;98     
;;;99     		
;;;100    	USB_ITConfig(USB_IT_USB_RESUME_FLAG,ENABLE);
00002c  2101              MOVS     r1,#1
00002e  4814              LDR      r0,|L22.128|
000030  f7fffffe          BL       USB_ITConfig
;;;101    	USB_ITConfig(USB_IT_USB_SUSPEND_FLAG,ENABLE);
000034  2101              MOVS     r1,#1
000036  4812              LDR      r0,|L22.128|
000038  1e40              SUBS     r0,r0,#1
00003a  f7fffffe          BL       USB_ITConfig
;;;102    	USB_ITConfig(USB_IT_USB_SOF_FLAG,ENABLE);
00003e  2101              MOVS     r1,#1
000040  2081              MOVS     r0,#0x81
000042  00c0              LSLS     r0,r0,#3
000044  f7fffffe          BL       USB_ITConfig
;;;103    	USB_ITConfig(USB_IT_USB_RESET_FLAG,ENABLE);
000048  2101              MOVS     r1,#1
00004a  480d              LDR      r0,|L22.128|
00004c  1c80              ADDS     r0,r0,#2
00004e  f7fffffe          BL       USB_ITConfig
;;;104    		
;;;105      USB_PDCTRLConfig(USB_PDCTRL_PU_ENABLE);
000052  2001              MOVS     r0,#1
000054  f7fffffe          BL       USB_PDCTRLConfig
;;;106    	
;;;107      NVIC_InitStructure.NVIC_IRQChannel = USB_IRQn;
000058  211f              MOVS     r1,#0x1f
00005a  4668              MOV      r0,sp
00005c  7001              STRB     r1,[r0,#0]
;;;108      NVIC_InitStructure.NVIC_IRQChannelPriority = 0;
00005e  2100              MOVS     r1,#0
000060  7041              STRB     r1,[r0,#1]
;;;109      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000062  2101              MOVS     r1,#1
000064  7081              STRB     r1,[r0,#2]
;;;110      NVIC_Init(&NVIC_InitStructure);
000066  f7fffffe          BL       NVIC_Init
;;;111    	
;;;112    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_CRS,ENABLE);
00006a  2101              MOVS     r1,#1
00006c  06c8              LSLS     r0,r1,#27
00006e  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;113    	CRS_FrequencyErrorCounterCmd(ENABLE);
000072  2001              MOVS     r0,#1
000074  f7fffffe          BL       CRS_FrequencyErrorCounterCmd
;;;114    	CRS_AutomaticCalibrationCmd(ENABLE);
000078  2001              MOVS     r0,#1
00007a  f7fffffe          BL       CRS_AutomaticCalibrationCmd
;;;115    }
00007e  bd08              POP      {r3,pc}
;;;116    
                          ENDP

                  |L22.128|
                          DCD      0x00000402

                          AREA ||i.USB_PDCTRLConfig||, CODE, READONLY, ALIGN=2

                  USB_PDCTRLConfig PROC
;;;531    */
;;;532    void USB_PDCTRLConfig(uint8_t PDCT)
000000  4601              MOV      r1,r0
;;;533    {
;;;534        uint8_t temp = 0;
000002  2000              MOVS     r0,#0
;;;535    
;;;536        assert_param(IS_USB_PDCTRL(PDCT));
;;;537    
;;;538        temp = USB->PDCTRL;
000004  4a04              LDR      r2,|L23.24|
000006  7bd0              LDRB     r0,[r2,#0xf]
;;;539        temp &= ~USB_PDCTRL_FLAG;
000008  0880              LSRS     r0,r0,#2
00000a  0080              LSLS     r0,r0,#2
;;;540        temp |= PDCT;
00000c  4602              MOV      r2,r0
00000e  430a              ORRS     r2,r2,r1
000010  4610              MOV      r0,r2
;;;541        USB->PDCTRL = temp;
000012  4a01              LDR      r2,|L23.24|
000014  73d0              STRB     r0,[r2,#0xf]
;;;542    
;;;543    }
000016  4770              BX       lr
;;;544    /******************************************************************************
                          ENDP

                  |L23.24|
                          DCD      0x40005c00

                          AREA ||i.USB_ReadRegister||, CODE, READONLY, ALIGN=2

                  USB_ReadRegister PROC
;;;511    */
;;;512    uint8_t USB_ReadRegister(uint8_t USB_Refister)
000000  b508              PUSH     {r3,lr}
;;;513    {
000002  4601              MOV      r1,r0
;;;514        __IO uint32_t tmp = 0;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;515    
;;;516        /* Check the parameters */
;;;517        assert_param(IS_USB_REGISTER(USB_Refister));
;;;518    
;;;519        tmp = (uint32_t)USB;
000008  4803              LDR      r0,|L24.24|
00000a  9000              STR      r0,[sp,#0]
;;;520        tmp += USB_Refister;
00000c  9800              LDR      r0,[sp,#0]
00000e  1840              ADDS     r0,r0,r1
000010  9000              STR      r0,[sp,#0]
;;;521    
;;;522        /* Return the selected register value */
;;;523        return (*(__IO uint8_t *) tmp);	
000012  9800              LDR      r0,[sp,#0]
000014  7800              LDRB     r0,[r0,#0]
;;;524    }
000016  bd08              POP      {r3,pc}
;;;525    /******************************************************************************
                          ENDP

                  |L24.24|
                          DCD      0x40005c00

                          AREA ||i.USB_Remote_Wakeup||, CODE, READONLY, ALIGN=2

                  USB_Remote_Wakeup PROC
;;;360    */
;;;361    void USB_Remote_Wakeup(void)
000000  4806              LDR      r0,|L25.28|
;;;362    {
;;;363    	USB->POWER |= 0x04;
000002  7840              LDRB     r0,[r0,#1]
000004  2104              MOVS     r1,#4
000006  4308              ORRS     r0,r0,r1
000008  4904              LDR      r1,|L25.28|
00000a  7048              STRB     r0,[r1,#1]
;;;364    //	SysTick_Delay_Ms(12);
;;;365    	USB->POWER &= ~0x04;			
00000c  4608              MOV      r0,r1
00000e  7840              LDRB     r0,[r0,#1]
000010  2104              MOVS     r1,#4
000012  4388              BICS     r0,r0,r1
000014  4901              LDR      r1,|L25.28|
000016  7048              STRB     r0,[r1,#1]
;;;366    }
000018  4770              BX       lr
;;;367    
                          ENDP

00001a  0000              DCW      0x0000
                  |L25.28|
                          DCD      0x40005c00

                          AREA ||i.USB_Reset||, CODE, READONLY, ALIGN=2

                  USB_Reset PROC
;;;304    */
;;;305    void USB_Reset(void)
000000  b500              PUSH     {lr}
;;;306    {
000002  b089              SUB      sp,sp,#0x24
;;;307    	M_EPBIN_STATUS  tEpin;
;;;308    	M_EPBOUT_STATUS tEpout;
;;;309    	
;;;310    	/* Set device into default state */
;;;311    	gnDevState = DEVSTATE_DEFAULT;
000004  2000              MOVS     r0,#0
000006  492c              LDR      r1,|L26.184|
000008  6008              STR      r0,[r1,#0]  ; gnDevState
;;;312    //    pInformation->Current_Feature = USB_FSConfigDescriptor[7];
;;;313    	/* Reset any state machines for each endpoint */
;;;314    	/* This example assumes 2 bulk IN endpoints with endpoint numbers 1,2, */
;;;315    	/* and 2 bulk out endpoints with endpoint numbers 1,2 */
;;;316    	USB_Endpoint0(M_EP_RESET);
00000a  2001              MOVS     r0,#1
00000c  f7fffffe          BL       USB_Endpoint0
;;;317    
;;;318    	/* Initialise endpoint status structures with endpoint numbers */
;;;319    
;;;320    	tEpin.byEP = 1;
000010  2101              MOVS     r1,#1
000012  a808              ADD      r0,sp,#0x20
000014  7001              STRB     r1,[r0,#0]
;;;321    	tEpin.nBytesLeft = M_EP_NODATA;
000016  1e88              SUBS     r0,r1,#2
000018  9007              STR      r0,[sp,#0x1c]
;;;322    	EndpointBulkIn(tEpin, M_EP_RESET);
00001a  2301              MOVS     r3,#1
00001c  a806              ADD      r0,sp,#0x18
00001e  c807              LDM      r0,{r0-r2}
000020  f7fffffe          BL       EndpointBulkIn
;;;323    	
;;;324    	tEpin.byEP = 2;
000024  2102              MOVS     r1,#2
000026  a808              ADD      r0,sp,#0x20
000028  7001              STRB     r1,[r0,#0]
;;;325    	tEpin.nBytesLeft = M_EP_NODATA;
00002a  1ec8              SUBS     r0,r1,#3
00002c  9007              STR      r0,[sp,#0x1c]
;;;326    	EndpointBulkIn(tEpin, M_EP_RESET);
00002e  2301              MOVS     r3,#1
000030  a806              ADD      r0,sp,#0x18
000032  c807              LDM      r0,{r0-r2}
000034  f7fffffe          BL       EndpointBulkIn
;;;327    	
;;;328    	tEpin.byEP = 3;
000038  2103              MOVS     r1,#3
00003a  a808              ADD      r0,sp,#0x20
00003c  7001              STRB     r1,[r0,#0]
;;;329    	tEpin.nBytesLeft = M_EP_NODATA;
00003e  1f08              SUBS     r0,r1,#4
000040  9007              STR      r0,[sp,#0x1c]
;;;330    	EndpointBulkIn(tEpin, M_EP_RESET);
000042  2301              MOVS     r3,#1
000044  a806              ADD      r0,sp,#0x18
000046  c807              LDM      r0,{r0-r2}
000048  f7fffffe          BL       EndpointBulkIn
;;;331    	
;;;332    	tEpin.byEP = 4;
00004c  2104              MOVS     r1,#4
00004e  a808              ADD      r0,sp,#0x20
000050  7001              STRB     r1,[r0,#0]
;;;333    	tEpin.nBytesLeft = M_EP_NODATA;
000052  1f48              SUBS     r0,r1,#5
000054  9007              STR      r0,[sp,#0x1c]
;;;334    	EndpointBulkIn(tEpin, M_EP_RESET);
000056  2301              MOVS     r3,#1
000058  a806              ADD      r0,sp,#0x18
00005a  c807              LDM      r0,{r0-r2}
00005c  f7fffffe          BL       EndpointBulkIn
;;;335    	
;;;336    	tEpin.byEP = 6;
000060  2106              MOVS     r1,#6
000062  a808              ADD      r0,sp,#0x20
000064  7001              STRB     r1,[r0,#0]
;;;337    	tEpin.nBytesLeft = M_EP_NODATA;
000066  1fc8              SUBS     r0,r1,#7
000068  9007              STR      r0,[sp,#0x1c]
;;;338    	EndpointBulkIn(tEpin, M_EP_RESET);
00006a  2301              MOVS     r3,#1
00006c  a806              ADD      r0,sp,#0x18
00006e  c807              LDM      r0,{r0-r2}
000070  f7fffffe          BL       EndpointBulkIn
;;;339    	
;;;340    	//--------------------------------------//
;;;341    	
;;;342    	tEpout.byEP = 5;
000074  2105              MOVS     r1,#5
000076  4668              MOV      r0,sp
000078  7501              STRB     r1,[r0,#0x14]
;;;343    	tEpout.nBuffLen = M_EP_MAXP;
00007a  2040              MOVS     r0,#0x40
00007c  9003              STR      r0,[sp,#0xc]
;;;344    	tEpout.nBytesRecv = 0;
00007e  2000              MOVS     r0,#0
000080  9004              STR      r0,[sp,#0x10]
;;;345    	EndpointBulkOut(tEpout, M_EP_RESET);
000082  2001              MOVS     r0,#1
000084  9000              STR      r0,[sp,#0]
000086  a802              ADD      r0,sp,#8
000088  c80f              LDM      r0,{r0-r3}
00008a  f7fffffe          BL       EndpointBulkOut
;;;346    	
;;;347    	tEpout.byEP = 7;
00008e  2107              MOVS     r1,#7
000090  4668              MOV      r0,sp
000092  7501              STRB     r1,[r0,#0x14]
;;;348    	tEpout.nBuffLen = M_EP_MAXP;
000094  2040              MOVS     r0,#0x40
000096  9003              STR      r0,[sp,#0xc]
;;;349    	tEpout.nBytesRecv = 0;
000098  2000              MOVS     r0,#0
00009a  9004              STR      r0,[sp,#0x10]
;;;350    	EndpointBulkOut(tEpout, M_EP_RESET);
00009c  2001              MOVS     r0,#1
00009e  9000              STR      r0,[sp,#0]
0000a0  a802              ADD      r0,sp,#8
0000a2  c80f              LDM      r0,{r0-r3}
0000a4  f7fffffe          BL       EndpointBulkOut
;;;351    	
;;;352    	USB->POWER |= 0x01;												//允许挂起模块
0000a8  4804              LDR      r0,|L26.188|
0000aa  7840              LDRB     r0,[r0,#1]
0000ac  2101              MOVS     r1,#1
0000ae  4308              ORRS     r0,r0,r1
0000b0  4902              LDR      r1,|L26.188|
0000b2  7048              STRB     r0,[r1,#1]
;;;353    }
0000b4  b009              ADD      sp,sp,#0x24
0000b6  bd00              POP      {pc}
;;;354    /******************************************************************************
                          ENDP

                  |L26.184|
                          DCD      gnDevState
                  |L26.188|
                          DCD      0x40005c00

                          AREA ||i.USB_StdDev_Req||, CODE, READONLY, ALIGN=2

                  USB_StdDev_Req PROC
;;;1031   */
;;;1032   static void USB_StdDev_Req(PM_EP0_STATUS pep0state, PCOMMAND pcmd)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1033   {
000002  b089              SUB      sp,sp,#0x24
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;1034   	int	bError = FALSE, bNoData = FALSE, n;
000008  2000              MOVS     r0,#0
00000a  9008              STR      r0,[sp,#0x20]
00000c  9007              STR      r0,[sp,#0x1c]
;;;1035   	BYTE	by;
;;;1036   	BYTE	byConfig;
;;;1037   	PSTD_CFG_DSCR	pcfg;	
;;;1038   	
;;;1039   	uint8_t Related_Endpoint;
;;;1040   	uint8_t wIndex0 = pcmd->USBwIndex0;
00000e  7928              LDRB     r0,[r5,#4]
000010  9002              STR      r0,[sp,#8]
;;;1041   	Related_Endpoint = (wIndex0 & 0x0f);		
000012  9802              LDR      r0,[sp,#8]
000014  0700              LSLS     r0,r0,#28
000016  0f00              LSRS     r0,r0,#28
000018  9003              STR      r0,[sp,#0xc]
;;;1042   	uint8_t srbuff;
;;;1043   	uint8_t txdat[2] = {0};
00001a  2000              MOVS     r0,#0
00001c  9001              STR      r0,[sp,#4]
;;;1044   	
;;;1045   	SEGGER_RTT_printf(0,"USB_StdDev_Req;  333 pcmd->bRequest=%d\n",pcmd->bRequest);
00001e  786a              LDRB     r2,[r5,#1]
000020  a1fa              ADR      r1,|L27.1036|
000022  f7fffffe          BL       SEGGER_RTT_printf
;;;1046   	switch(pcmd->bRequest) 
000026  7868              LDRB     r0,[r5,#1]
000028  280c              CMP      r0,#0xc
00002a  d270              BCS      |L27.270|
00002c  0043              LSLS     r3,r0,#1
00002e  447b              ADD      r3,r3,pc
000030  889b              LDRH     r3,[r3,#4]
000032  005b              LSLS     r3,r3,#1
000034  449f              ADD      pc,pc,r3
000036  04f8              DCW      0x04f8
000038  03b6006b          DCW      0x03b6,0x006b
00003c  0351006b          DCW      0x0351,0x006b
000040  000b0020          DCW      0x000b,0x0020
000044  006b02f9          DCW      0x006b,0x02f9
000048  0280032a          DCW      0x0280,0x032a
00004c  02d1              DCW      0x02d1
;;;1047   	{
;;;1048   		/***用来给设备分配地址***/
;;;1049   		case SET_ADDRESS:
;;;1050   			/* Store device function address until status stage of request */
;;;1051   			if (pcmd->bmRequestType != M_CMD_STDDEVOUT)
00004e  7828              LDRB     r0,[r5,#0]
000050  2800              CMP      r0,#0
000052  d002              BEQ      |L27.90|
;;;1052   			{
;;;1053   				bError = TRUE;
000054  2001              MOVS     r0,#1
000056  9008              STR      r0,[sp,#0x20]
000058  e00d              B        |L27.118|
                  |L27.90|
;;;1054   			}
;;;1055   			else if (gnDevState <= DEVSTATE_ADDRESS) 
00005a  48f6              LDR      r0,|L27.1076|
00005c  6800              LDR      r0,[r0,#0]  ; gnDevState
00005e  2801              CMP      r0,#1
000060  d807              BHI      |L27.114|
;;;1056   			{
;;;1057   				pep0state->byFAddr = (BYTE)pcmd->USBwValue;
000062  78e8              LDRB     r0,[r5,#3]
000064  78a9              LDRB     r1,[r5,#2]
000066  0200              LSLS     r0,r0,#8
000068  4308              ORRS     r0,r0,r1
00006a  7420              STRB     r0,[r4,#0x10]
;;;1058   				bNoData = TRUE;
00006c  2001              MOVS     r0,#1
00006e  9007              STR      r0,[sp,#0x1c]
000070  e001              B        |L27.118|
                  |L27.114|
;;;1059   			}
;;;1060   			else
;;;1061   			{
;;;1062   				bError = TRUE;
000072  2001              MOVS     r0,#1
000074  9008              STR      r0,[sp,#0x20]
                  |L27.118|
;;;1063   			}
;;;1064   			break;
000076  e25e              B        |L27.1334|
;;;1065   			
;;;1066   		/***用于主机获取设备的特定描述符***/		
;;;1067   		case GET_DESCRIPTOR:
;;;1068   			/* Decode the required descriptor from the command */
;;;1069   			/***报告描述符的接受者是接口，pcmd->bmRequestType = 0x81时传输HID报告描述符***/
;;;1070   			if(!(pcmd->bmRequestType & M_CMD_STDDEVIN))
000078  7828              LDRB     r0,[r5,#0]
00007a  2180              MOVS     r1,#0x80
00007c  4008              ANDS     r0,r0,r1
00007e  2800              CMP      r0,#0
000080  d102              BNE      |L27.136|
;;;1071   			{
;;;1072   				bError = TRUE;
000082  2001              MOVS     r0,#1
000084  9008              STR      r0,[sp,#0x20]
000086  e256              B        |L27.1334|
                  |L27.136|
;;;1073   			}
;;;1074   			else 
;;;1075   			{
;;;1076   				switch(pcmd->USBwValue & M_CMD_DESCMASK) 
000088  78e8              LDRB     r0,[r5,#3]
00008a  78a9              LDRB     r1,[r5,#2]
00008c  0200              LSLS     r0,r0,#8
00008e  4308              ORRS     r0,r0,r1
000090  21ff              MOVS     r1,#0xff
000092  0209              LSLS     r1,r1,#8
000094  4008              ANDS     r0,r0,r1
000096  2203              MOVS     r2,#3
000098  0252              LSLS     r2,r2,#9
00009a  1a81              SUBS     r1,r0,r2
00009c  4290              CMP      r0,r2
00009e  d037              BEQ      |L27.272|
0000a0  dc0c              BGT      |L27.188|
0000a2  38ff              SUBS     r0,r0,#0xff
0000a4  3801              SUBS     r0,#1
0000a6  2800              CMP      r0,#0
0000a8  d011              BEQ      |L27.206|
0000aa  38ff              SUBS     r0,r0,#0xff
0000ac  3801              SUBS     r0,#1
0000ae  2800              CMP      r0,#0
0000b0  d031              BEQ      |L27.278|
0000b2  38ff              SUBS     r0,r0,#0xff
0000b4  3801              SUBS     r0,#1
0000b6  2800              CMP      r0,#0
                  |L27.184|
0000b8  d17e              BNE      |L27.440|
0000ba  e112              B        |L27.738|
                  |L27.188|
0000bc  39ff              SUBS     r1,r1,#0xff
0000be  3901              SUBS     r1,#1
0000c0  2900              CMP      r1,#0
0000c2  d059              BEQ      |L27.376|
0000c4  201b              MOVS     r0,#0x1b
0000c6  0200              LSLS     r0,r0,#8
0000c8  1a08              SUBS     r0,r1,r0
0000ca  d1f5              BNE      |L27.184|
0000cc  e057              B        |L27.382|
                  |L27.206|
;;;1077   				{
;;;1078   					/***设备描述符***/
;;;1079   					case M_CMD_DEVICE:
;;;1080   						/* Prepare to return Standard Device Descriptor */
;;;1081   						pep0state->nBytesLeft = USB_FSDeviceDescriptorSize;
0000ce  1d21              ADDS     r1,r4,#4
0000d0  48d9              LDR      r0,|L27.1080|
0000d2  8800              LDRH     r0,[r0,#0]  ; USB_FSDeviceDescriptorSize
0000d4  f7fffffe          BL       __aeabi_uwrite4
;;;1082   						/* Check host is allowing a descriptor this long */
;;;1083   						if(pcmd->USBwLength < pep0state->nBytesLeft)
0000d8  1d20              ADDS     r0,r4,#4
0000da  f7fffffe          BL       __aeabi_uread4
0000de  79e9              LDRB     r1,[r5,#7]
0000e0  79aa              LDRB     r2,[r5,#6]
0000e2  0209              LSLS     r1,r1,#8
0000e4  4311              ORRS     r1,r1,r2
0000e6  4288              CMP      r0,r1
0000e8  dd07              BLE      |L27.250|
;;;1084   						{
;;;1085   							pep0state->nBytesLeft = pcmd->USBwLength;
0000ea  79e9              LDRB     r1,[r5,#7]
0000ec  79aa              LDRB     r2,[r5,#6]
0000ee  0209              LSLS     r1,r1,#8
0000f0  4311              ORRS     r1,r1,r2
0000f2  4608              MOV      r0,r1
0000f4  1d21              ADDS     r1,r4,#4
0000f6  f7fffffe          BL       __aeabi_uwrite4
                  |L27.250|
;;;1086   						}
;;;1087   						
;;;1088   						pep0state->pData = (void*)USB_FSDeviceDescriptor;
0000fa  4621              MOV      r1,r4
0000fc  3108              ADDS     r1,r1,#8
0000fe  48cf              LDR      r0,|L27.1084|
000100  f7fffffe          BL       __aeabi_uwrite4
;;;1089   						pep0state->nState = M_EP0_TX;
000104  4621              MOV      r1,r4
000106  2002              MOVS     r0,#2
000108  f7fffffe          BL       __aeabi_uwrite4
;;;1090   						break;
00010c  e212              B        |L27.1332|
                  |L27.270|
00010e  e398              B        |L27.2114|
                  |L27.272|
;;;1091   					/***设备限定描述符***/	
;;;1092   					case M_CMD_DEVQUAL:
;;;1093   						/* No alternate speed supported */
;;;1094   						bError = TRUE;
000110  2001              MOVS     r0,#1
000112  9008              STR      r0,[sp,#0x20]
;;;1095   						break;
000114  e20e              B        |L27.1332|
                  |L27.278|
;;;1096   					/***配置描述符***/					
;;;1097   					case M_CMD_CONFIG:
;;;1098   						byConfig = (BYTE)(pcmd->USBwValue & 0x00FF);
000116  78e8              LDRB     r0,[r5,#3]
000118  78a9              LDRB     r1,[r5,#2]
00011a  0200              LSLS     r0,r0,#8
00011c  4308              ORRS     r0,r0,r1
00011e  b2c0              UXTB     r0,r0
000120  9005              STR      r0,[sp,#0x14]
;;;1099   						if(byConfig>USB_FSDeviceDescriptor[USB_FSDeviceDescriptorSize-1])
000122  48c5              LDR      r0,|L27.1080|
000124  8800              LDRH     r0,[r0,#0]  ; USB_FSDeviceDescriptorSize
000126  1e40              SUBS     r0,r0,#1
000128  49c4              LDR      r1,|L27.1084|
00012a  5c09              LDRB     r1,[r1,r0]
00012c  9805              LDR      r0,[sp,#0x14]
00012e  4281              CMP      r1,r0
000130  da02              BGE      |L27.312|
;;;1100   						{
;;;1101   							bError = TRUE;
000132  2001              MOVS     r0,#1
000134  9008              STR      r0,[sp,#0x20]
000136  e01e              B        |L27.374|
                  |L27.312|
;;;1102   						}
;;;1103   						else
;;;1104   						{
;;;1105   							/* Get pointer to requested configuration descriptor */
;;;1106   							/* Prepare to return Configuration Descriptors */
;;;1107   							pep0state->nBytesLeft = USB_FSConfigDescriptorSize;
000138  1d21              ADDS     r1,r4,#4
00013a  48c1              LDR      r0,|L27.1088|
00013c  8800              LDRH     r0,[r0,#0]  ; USB_FSConfigDescriptorSize
00013e  f7fffffe          BL       __aeabi_uwrite4
;;;1108   							pep0state->pData = (void*)USB_FSConfigDescriptor;
000142  4621              MOV      r1,r4
000144  3108              ADDS     r1,r1,#8
000146  48bf              LDR      r0,|L27.1092|
000148  f7fffffe          BL       __aeabi_uwrite4
;;;1109   							pep0state->nState = M_EP0_TX;
00014c  4621              MOV      r1,r4
00014e  2002              MOVS     r0,#2
000150  f7fffffe          BL       __aeabi_uwrite4
;;;1110   							/* Check host is allowing a descriptor this long */
;;;1111   							if (pcmd->USBwLength < pep0state->nBytesLeft)
000154  1d20              ADDS     r0,r4,#4
000156  f7fffffe          BL       __aeabi_uread4
00015a  79e9              LDRB     r1,[r5,#7]
00015c  79aa              LDRB     r2,[r5,#6]
00015e  0209              LSLS     r1,r1,#8
000160  4311              ORRS     r1,r1,r2
000162  4288              CMP      r0,r1
000164  dd07              BLE      |L27.374|
;;;1112   							{
;;;1113   								pep0state->nBytesLeft = pcmd->USBwLength;
000166  79e9              LDRB     r1,[r5,#7]
000168  79aa              LDRB     r2,[r5,#6]
00016a  0209              LSLS     r1,r1,#8
00016c  4311              ORRS     r1,r1,r2
00016e  4608              MOV      r0,r1
000170  1d21              ADDS     r1,r4,#4
000172  f7fffffe          BL       __aeabi_uwrite4
                  |L27.374|
;;;1114   							}
;;;1115   						}
;;;1116   						break;
000176  e1dd              B        |L27.1332|
                  |L27.376|
;;;1117   					/***其它速度配置描述符***/						
;;;1118   					case M_CMD_OTHERSPEED:
;;;1119   						/* No alternate speed supported */
;;;1120   						bError = TRUE;
000178  2001              MOVS     r0,#1
00017a  9008              STR      r0,[sp,#0x20]
;;;1121   						break;
00017c  e1da              B        |L27.1332|
                  |L27.382|
;;;1122   					/***HID报告描述符***/
;;;1123   					case	M_CMD_HID_REPORT_DESC:		//报告描述符		0x2200
;;;1124   						/* Prepare to return Standard Device Descriptor */
;;;1125   						switch(pcmd->USBwIndex)
00017e  7968              LDRB     r0,[r5,#5]
000180  7929              LDRB     r1,[r5,#4]
000182  0200              LSLS     r0,r0,#8
000184  4308              ORRS     r0,r0,r1
000186  0003              MOVS     r3,r0
000188  f7fffffe          BL       __ARM_common_switch8
00018c  05042646          DCB      0x05,0x04,0x26,0x46
000190  6686a600          DCB      0x66,0x86,0xa6,0x00
;;;1126   						{
;;;1127   							case	0:
;;;1128   								//接口0
;;;1129   								pep0state->nBytesLeft = USB_HID_FSReportDescriptor_1Size;		//报告描述符的长度
000194  1d21              ADDS     r1,r4,#4
000196  48ac              LDR      r0,|L27.1096|
000198  8800              LDRH     r0,[r0,#0]  ; USB_HID_FSReportDescriptor_1Size
00019a  f7fffffe          BL       __aeabi_uwrite4
;;;1130   								/* Check host is allowing a descriptor this long */
;;;1131   								if (pcmd->USBwLength < pep0state->nBytesLeft)
00019e  1d20              ADDS     r0,r4,#4
0001a0  f7fffffe          BL       __aeabi_uread4
0001a4  79e9              LDRB     r1,[r5,#7]
0001a6  79aa              LDRB     r2,[r5,#6]
0001a8  0209              LSLS     r1,r1,#8
0001aa  4311              ORRS     r1,r1,r2
0001ac  4288              CMP      r0,r1
0001ae  dd09              BLE      |L27.452|
;;;1132   								{
;;;1133   									pep0state->nBytesLeft = pcmd->USBwLength;
0001b0  79e9              LDRB     r1,[r5,#7]
0001b2  79aa              LDRB     r2,[r5,#6]
0001b4  0209              LSLS     r1,r1,#8
0001b6  e000              B        |L27.442|
                  |L27.440|
0001b8  e1b9              B        |L27.1326|
                  |L27.442|
0001ba  4311              ORRS     r1,r1,r2
0001bc  4608              MOV      r0,r1
0001be  1d21              ADDS     r1,r4,#4
0001c0  f7fffffe          BL       __aeabi_uwrite4
                  |L27.452|
;;;1134   								}
;;;1135   								pep0state->pData = (void*)USB_HID_FSReportDescriptor_1;
0001c4  4621              MOV      r1,r4
0001c6  3108              ADDS     r1,r1,#8
0001c8  48a0              LDR      r0,|L27.1100|
0001ca  f7fffffe          BL       __aeabi_uwrite4
;;;1136   								pep0state->nState = M_EP0_TX;
0001ce  4621              MOV      r1,r4
0001d0  2002              MOVS     r0,#2
0001d2  f7fffffe          BL       __aeabi_uwrite4
;;;1137   								break;
0001d6  e082              B        |L27.734|
;;;1138   							case	1:
;;;1139   								//接口1
;;;1140   								pep0state->nBytesLeft = USB_HID_FSReportDescriptor_2Size;		//报告描述符的长度
0001d8  1d21              ADDS     r1,r4,#4
0001da  489d              LDR      r0,|L27.1104|
0001dc  8800              LDRH     r0,[r0,#0]  ; USB_HID_FSReportDescriptor_2Size
0001de  f7fffffe          BL       __aeabi_uwrite4
;;;1141   								/* Check host is allowing a descriptor this long */
;;;1142   								if (pcmd->USBwLength < pep0state->nBytesLeft)
0001e2  1d20              ADDS     r0,r4,#4
0001e4  f7fffffe          BL       __aeabi_uread4
0001e8  79e9              LDRB     r1,[r5,#7]
0001ea  79aa              LDRB     r2,[r5,#6]
0001ec  0209              LSLS     r1,r1,#8
0001ee  4311              ORRS     r1,r1,r2
0001f0  4288              CMP      r0,r1
0001f2  dd07              BLE      |L27.516|
;;;1143   								{
;;;1144   									pep0state->nBytesLeft = pcmd->USBwLength;
0001f4  79e9              LDRB     r1,[r5,#7]
0001f6  79aa              LDRB     r2,[r5,#6]
0001f8  0209              LSLS     r1,r1,#8
0001fa  4311              ORRS     r1,r1,r2
0001fc  4608              MOV      r0,r1
0001fe  1d21              ADDS     r1,r4,#4
000200  f7fffffe          BL       __aeabi_uwrite4
                  |L27.516|
;;;1145   								}
;;;1146   								pep0state->pData = (void*)USB_HID_FSReportDescriptor_2;
000204  4621              MOV      r1,r4
000206  3108              ADDS     r1,r1,#8
000208  4892              LDR      r0,|L27.1108|
00020a  f7fffffe          BL       __aeabi_uwrite4
;;;1147   								pep0state->nState = M_EP0_TX;
00020e  4621              MOV      r1,r4
000210  2002              MOVS     r0,#2
000212  f7fffffe          BL       __aeabi_uwrite4
;;;1148   								break;
000216  e062              B        |L27.734|
;;;1149   							case	2:
;;;1150   								//接口2
;;;1151   								pep0state->nBytesLeft = USB_HID_FSReportDescriptor_3Size;		//报告描述符的长度
000218  1d21              ADDS     r1,r4,#4
00021a  488f              LDR      r0,|L27.1112|
00021c  8800              LDRH     r0,[r0,#0]  ; USB_HID_FSReportDescriptor_3Size
00021e  f7fffffe          BL       __aeabi_uwrite4
;;;1152   								/* Check host is allowing a descriptor this long */
;;;1153   								if (pcmd->USBwLength < pep0state->nBytesLeft)
000222  1d20              ADDS     r0,r4,#4
000224  f7fffffe          BL       __aeabi_uread4
000228  79e9              LDRB     r1,[r5,#7]
00022a  79aa              LDRB     r2,[r5,#6]
00022c  0209              LSLS     r1,r1,#8
00022e  4311              ORRS     r1,r1,r2
000230  4288              CMP      r0,r1
000232  dd07              BLE      |L27.580|
;;;1154   								{
;;;1155   									pep0state->nBytesLeft = pcmd->USBwLength;
000234  79e9              LDRB     r1,[r5,#7]
000236  79aa              LDRB     r2,[r5,#6]
000238  0209              LSLS     r1,r1,#8
00023a  4311              ORRS     r1,r1,r2
00023c  4608              MOV      r0,r1
00023e  1d21              ADDS     r1,r4,#4
000240  f7fffffe          BL       __aeabi_uwrite4
                  |L27.580|
;;;1156   								}
;;;1157   								pep0state->pData = (void*)USB_HID_FSReportDescriptor_3;
000244  4621              MOV      r1,r4
000246  3108              ADDS     r1,r1,#8
000248  4884              LDR      r0,|L27.1116|
00024a  f7fffffe          BL       __aeabi_uwrite4
;;;1158   								pep0state->nState = M_EP0_TX;
00024e  4621              MOV      r1,r4
000250  2002              MOVS     r0,#2
000252  f7fffffe          BL       __aeabi_uwrite4
;;;1159   								break;
000256  e042              B        |L27.734|
;;;1160   								case	3:
;;;1161   								//接口3
;;;1162   								pep0state->nBytesLeft = USB_HID_FSReportDescriptor_4Size;		//报告描述符的长度
000258  1d21              ADDS     r1,r4,#4
00025a  4881              LDR      r0,|L27.1120|
00025c  8800              LDRH     r0,[r0,#0]  ; USB_HID_FSReportDescriptor_4Size
00025e  f7fffffe          BL       __aeabi_uwrite4
;;;1163   								/* Check host is allowing a descriptor this long */
;;;1164   								if (pcmd->USBwLength < pep0state->nBytesLeft)
000262  1d20              ADDS     r0,r4,#4
000264  f7fffffe          BL       __aeabi_uread4
000268  79e9              LDRB     r1,[r5,#7]
00026a  79aa              LDRB     r2,[r5,#6]
00026c  0209              LSLS     r1,r1,#8
00026e  4311              ORRS     r1,r1,r2
000270  4288              CMP      r0,r1
000272  dd07              BLE      |L27.644|
;;;1165   								{
;;;1166   									pep0state->nBytesLeft = pcmd->USBwLength;
000274  79e9              LDRB     r1,[r5,#7]
000276  79aa              LDRB     r2,[r5,#6]
000278  0209              LSLS     r1,r1,#8
00027a  4311              ORRS     r1,r1,r2
00027c  4608              MOV      r0,r1
00027e  1d21              ADDS     r1,r4,#4
000280  f7fffffe          BL       __aeabi_uwrite4
                  |L27.644|
;;;1167   								}
;;;1168   								pep0state->pData = (void*)USB_HID_FSReportDescriptor_4;
000284  4621              MOV      r1,r4
000286  3108              ADDS     r1,r1,#8
000288  4876              LDR      r0,|L27.1124|
00028a  f7fffffe          BL       __aeabi_uwrite4
;;;1169   								pep0state->nState = M_EP0_TX;
00028e  4621              MOV      r1,r4
000290  2002              MOVS     r0,#2
000292  f7fffffe          BL       __aeabi_uwrite4
;;;1170   								break;
000296  e022              B        |L27.734|
;;;1171   								case	4:
;;;1172   								//接口4
;;;1173   								pep0state->nBytesLeft = USB_HID_FSReportDescriptor_5Size;		//报告描述符的长度
000298  1d21              ADDS     r1,r4,#4
00029a  4873              LDR      r0,|L27.1128|
00029c  8800              LDRH     r0,[r0,#0]  ; USB_HID_FSReportDescriptor_5Size
00029e  f7fffffe          BL       __aeabi_uwrite4
;;;1174   								/* Check host is allowing a descriptor this long */
;;;1175   								if (pcmd->USBwLength < pep0state->nBytesLeft)
0002a2  1d20              ADDS     r0,r4,#4
0002a4  f7fffffe          BL       __aeabi_uread4
0002a8  79e9              LDRB     r1,[r5,#7]
0002aa  79aa              LDRB     r2,[r5,#6]
0002ac  0209              LSLS     r1,r1,#8
0002ae  4311              ORRS     r1,r1,r2
0002b0  4288              CMP      r0,r1
0002b2  dd07              BLE      |L27.708|
;;;1176   								{
;;;1177   									pep0state->nBytesLeft = pcmd->USBwLength;
0002b4  79e9              LDRB     r1,[r5,#7]
0002b6  79aa              LDRB     r2,[r5,#6]
0002b8  0209              LSLS     r1,r1,#8
0002ba  4311              ORRS     r1,r1,r2
0002bc  4608              MOV      r0,r1
0002be  1d21              ADDS     r1,r4,#4
0002c0  f7fffffe          BL       __aeabi_uwrite4
                  |L27.708|
;;;1178   								}
;;;1179   								pep0state->pData = (void*)USB_HID_FSReportDescriptor_5;
0002c4  4621              MOV      r1,r4
0002c6  3108              ADDS     r1,r1,#8
0002c8  4868              LDR      r0,|L27.1132|
0002ca  f7fffffe          BL       __aeabi_uwrite4
;;;1180   								pep0state->nState = M_EP0_TX;
0002ce  4621              MOV      r1,r4
0002d0  2002              MOVS     r0,#2
0002d2  f7fffffe          BL       __aeabi_uwrite4
;;;1181   								break;
0002d6  e002              B        |L27.734|
;;;1182   							default:
;;;1183   								//接口
;;;1184   								bError = TRUE;
0002d8  2001              MOVS     r0,#1
0002da  9008              STR      r0,[sp,#0x20]
;;;1185   								break;							
0002dc  bf00              NOP      
                  |L27.734|
0002de  bf00              NOP                            ;1137
;;;1186   						}
;;;1187   						break;
0002e0  e128              B        |L27.1332|
                  |L27.738|
;;;1188   					case	M_CMD_STRING:	//字符串描述符
;;;1189   
;;;1190   						SEGGER_RTT_printf(0,"USB_StdDev_Req;  333 pcmd->USBwValue=%d\n",pcmd->USBwValue);
0002e2  78e8              LDRB     r0,[r5,#3]
0002e4  78a9              LDRB     r1,[r5,#2]
0002e6  0200              LSLS     r0,r0,#8
0002e8  4308              ORRS     r0,r0,r1
0002ea  4602              MOV      r2,r0
0002ec  a160              ADR      r1,|L27.1136|
0002ee  2000              MOVS     r0,#0
0002f0  f7fffffe          BL       SEGGER_RTT_printf
;;;1191   						switch(pcmd->USBwValue & 0xff)
0002f4  78e8              LDRB     r0,[r5,#3]
0002f6  78a9              LDRB     r1,[r5,#2]
0002f8  0200              LSLS     r0,r0,#8
0002fa  4308              ORRS     r0,r0,r1
0002fc  b2c0              UXTB     r0,r0
0002fe  0003              MOVS     r3,r0
000300  f7fffffe          BL       __ARM_common_switch8
000304  05042444          DCB      0x05,0x04,0x24,0x44
000308  64dcef00          DCB      0x64,0xdc,0xef,0x00
;;;1192   						{
;;;1193   							case	0:	//获取语言ID
;;;1194   								pep0state->nBytesLeft = LanguageIdSize;		
00030c  1d21              ADDS     r1,r4,#4
00030e  4863              LDR      r0,|L27.1180|
000310  8800              LDRH     r0,[r0,#0]  ; LanguageIdSize
000312  f7fffffe          BL       __aeabi_uwrite4
;;;1195   								/* Check host is allowing a descriptor this long */
;;;1196   								if (pcmd->USBwLength < pep0state->nBytesLeft)
000316  1d20              ADDS     r0,r4,#4
000318  f7fffffe          BL       __aeabi_uread4
00031c  79e9              LDRB     r1,[r5,#7]
00031e  79aa              LDRB     r2,[r5,#6]
000320  0209              LSLS     r1,r1,#8
000322  4311              ORRS     r1,r1,r2
000324  4288              CMP      r0,r1
000326  dd07              BLE      |L27.824|
;;;1197   								{
;;;1198   									pep0state->nBytesLeft = pcmd->USBwLength;
000328  79e9              LDRB     r1,[r5,#7]
00032a  79aa              LDRB     r2,[r5,#6]
00032c  0209              LSLS     r1,r1,#8
00032e  4311              ORRS     r1,r1,r2
000330  4608              MOV      r0,r1
000332  1d21              ADDS     r1,r4,#4
000334  f7fffffe          BL       __aeabi_uwrite4
                  |L27.824|
;;;1199   								}
;;;1200   								pep0state->pData = (void*)LanguageId;
000338  4621              MOV      r1,r4
00033a  3108              ADDS     r1,r1,#8
00033c  4858              LDR      r0,|L27.1184|
00033e  f7fffffe          BL       __aeabi_uwrite4
;;;1201   								pep0state->nState = M_EP0_TX;
000342  4621              MOV      r1,r4
000344  2002              MOVS     r0,#2
000346  f7fffffe          BL       __aeabi_uwrite4
;;;1202   							break;
00034a  e0ee              B        |L27.1322|
;;;1203   							case	1:	//因厂商字符串索引值为1，所以这里写1
;;;1204   								pep0state->nBytesLeft = ManufacturerStringDescriptorSize;		
00034c  1d21              ADDS     r1,r4,#4
00034e  4855              LDR      r0,|L27.1188|
000350  8800              LDRH     r0,[r0,#0]  ; ManufacturerStringDescriptorSize
000352  f7fffffe          BL       __aeabi_uwrite4
;;;1205   								/* Check host is allowing a descriptor this long */
;;;1206   								if (pcmd->USBwLength < pep0state->nBytesLeft)
000356  1d20              ADDS     r0,r4,#4
000358  f7fffffe          BL       __aeabi_uread4
00035c  79e9              LDRB     r1,[r5,#7]
00035e  79aa              LDRB     r2,[r5,#6]
000360  0209              LSLS     r1,r1,#8
000362  4311              ORRS     r1,r1,r2
000364  4288              CMP      r0,r1
000366  dd07              BLE      |L27.888|
;;;1207   								{
;;;1208   									pep0state->nBytesLeft = pcmd->USBwLength;
000368  79e9              LDRB     r1,[r5,#7]
00036a  79aa              LDRB     r2,[r5,#6]
00036c  0209              LSLS     r1,r1,#8
00036e  4311              ORRS     r1,r1,r2
000370  4608              MOV      r0,r1
000372  1d21              ADDS     r1,r4,#4
000374  f7fffffe          BL       __aeabi_uwrite4
                  |L27.888|
;;;1209   								}
;;;1210   								pep0state->pData = (void*)ManufacturerStringDescriptor;
000378  4621              MOV      r1,r4
00037a  3108              ADDS     r1,r1,#8
00037c  484a              LDR      r0,|L27.1192|
00037e  f7fffffe          BL       __aeabi_uwrite4
;;;1211   								pep0state->nState = M_EP0_TX;
000382  4621              MOV      r1,r4
000384  2002              MOVS     r0,#2
000386  f7fffffe          BL       __aeabi_uwrite4
;;;1212   							break;	
00038a  e0ce              B        |L27.1322|
;;;1213   							case	2:	//因产品字符串索引值为2，所以这里写2
;;;1214   								pep0state->nBytesLeft = ProductStringDescriptorSize;		
00038c  1d21              ADDS     r1,r4,#4
00038e  4847              LDR      r0,|L27.1196|
000390  8800              LDRH     r0,[r0,#0]  ; ProductStringDescriptorSize
000392  f7fffffe          BL       __aeabi_uwrite4
;;;1215   								/* Check host is allowing a descriptor this long */
;;;1216   								if (pcmd->USBwLength < pep0state->nBytesLeft)
000396  1d20              ADDS     r0,r4,#4
000398  f7fffffe          BL       __aeabi_uread4
00039c  79e9              LDRB     r1,[r5,#7]
00039e  79aa              LDRB     r2,[r5,#6]
0003a0  0209              LSLS     r1,r1,#8
0003a2  4311              ORRS     r1,r1,r2
0003a4  4288              CMP      r0,r1
0003a6  dd07              BLE      |L27.952|
;;;1217   								{
;;;1218   									pep0state->nBytesLeft = pcmd->USBwLength;
0003a8  79e9              LDRB     r1,[r5,#7]
0003aa  79aa              LDRB     r2,[r5,#6]
0003ac  0209              LSLS     r1,r1,#8
0003ae  4311              ORRS     r1,r1,r2
0003b0  4608              MOV      r0,r1
0003b2  1d21              ADDS     r1,r4,#4
0003b4  f7fffffe          BL       __aeabi_uwrite4
                  |L27.952|
;;;1219   								}
;;;1220   								pep0state->pData = (void*)ProductStringDescriptor;
0003b8  4621              MOV      r1,r4
0003ba  3108              ADDS     r1,r1,#8
0003bc  483c              LDR      r0,|L27.1200|
0003be  f7fffffe          BL       __aeabi_uwrite4
;;;1221   								pep0state->nState = M_EP0_TX;
0003c2  4621              MOV      r1,r4
0003c4  2002              MOVS     r0,#2
0003c6  f7fffffe          BL       __aeabi_uwrite4
;;;1222   							break;			
0003ca  e0ae              B        |L27.1322|
;;;1223   							case	3:	//因产品序列号索引值为3，所以这里写3
;;;1224   								pep0state->nBytesLeft = SerialNumberSringDescriptorSize;		
0003cc  1d21              ADDS     r1,r4,#4
0003ce  4839              LDR      r0,|L27.1204|
0003d0  8800              LDRH     r0,[r0,#0]  ; SerialNumberSringDescriptorSize
0003d2  f7fffffe          BL       __aeabi_uwrite4
;;;1225   								/* Check host is allowing a descriptor this long */
;;;1226   								if (pcmd->USBwLength < pep0state->nBytesLeft)
0003d6  1d20              ADDS     r0,r4,#4
0003d8  f7fffffe          BL       __aeabi_uread4
0003dc  79e9              LDRB     r1,[r5,#7]
0003de  79aa              LDRB     r2,[r5,#6]
0003e0  0209              LSLS     r1,r1,#8
0003e2  4311              ORRS     r1,r1,r2
0003e4  4288              CMP      r0,r1
0003e6  dd07              BLE      |L27.1016|
;;;1227   								{
;;;1228   									pep0state->nBytesLeft = pcmd->USBwLength;
0003e8  79e9              LDRB     r1,[r5,#7]
0003ea  79aa              LDRB     r2,[r5,#6]
0003ec  0209              LSLS     r1,r1,#8
0003ee  4311              ORRS     r1,r1,r2
0003f0  4608              MOV      r0,r1
0003f2  1d21              ADDS     r1,r4,#4
0003f4  f7fffffe          BL       __aeabi_uwrite4
                  |L27.1016|
;;;1229   								}
;;;1230   								pep0state->pData = (void*)SerialNumberSringDescriptor;
0003f8  4621              MOV      r1,r4
0003fa  3108              ADDS     r1,r1,#8
0003fc  482e              LDR      r0,|L27.1208|
0003fe  f7fffffe          BL       __aeabi_uwrite4
;;;1231   								pep0state->nState = M_EP0_TX;
000402  4621              MOV      r1,r4
000404  2002              MOVS     r0,#2
000406  f7fffffe          BL       __aeabi_uwrite4
;;;1232   							break;
00040a  e08e              B        |L27.1322|
                  |L27.1036|
00040c  5553425f          DCB      "USB_StdDev_Req;  333 pcmd->bRequest=%d\n",0
000410  53746444
000414  65765f52
000418  65713b20
00041c  20333333
000420  2070636d
000424  642d3e62
000428  52657175
00042c  6573743d
000430  25640a00
                  |L27.1076|
                          DCD      gnDevState
                  |L27.1080|
                          DCD      USB_FSDeviceDescriptorSize
                  |L27.1084|
                          DCD      USB_FSDeviceDescriptor
                  |L27.1088|
                          DCD      USB_FSConfigDescriptorSize
                  |L27.1092|
                          DCD      USB_FSConfigDescriptor
                  |L27.1096|
                          DCD      USB_HID_FSReportDescriptor_1Size
                  |L27.1100|
                          DCD      USB_HID_FSReportDescriptor_1
                  |L27.1104|
                          DCD      USB_HID_FSReportDescriptor_2Size
                  |L27.1108|
                          DCD      USB_HID_FSReportDescriptor_2
                  |L27.1112|
                          DCD      USB_HID_FSReportDescriptor_3Size
                  |L27.1116|
                          DCD      USB_HID_FSReportDescriptor_3
                  |L27.1120|
                          DCD      USB_HID_FSReportDescriptor_4Size
                  |L27.1124|
                          DCD      USB_HID_FSReportDescriptor_4
                  |L27.1128|
                          DCD      USB_HID_FSReportDescriptor_5Size
                  |L27.1132|
                          DCD      USB_HID_FSReportDescriptor_5
                  |L27.1136|
000470  5553425f          DCB      "USB_StdDev_Req;  333 pcmd->USBwValue=%d\n",0
000474  53746444
000478  65765f52
00047c  65713b20
000480  20333333
000484  2070636d
000488  642d3e55
00048c  53427756
000490  616c7565
000494  3d25640a
000498  00      
000499  00                DCB      0
00049a  00                DCB      0
00049b  00                DCB      0
                  |L27.1180|
                          DCD      LanguageIdSize
                  |L27.1184|
                          DCD      LanguageId
                  |L27.1188|
                          DCD      ManufacturerStringDescriptorSize
                  |L27.1192|
                          DCD      ManufacturerStringDescriptor
                  |L27.1196|
                          DCD      ProductStringDescriptorSize
                  |L27.1200|
                          DCD      ProductStringDescriptor
                  |L27.1204|
                          DCD      SerialNumberSringDescriptorSize
                  |L27.1208|
                          DCD      SerialNumberSringDescriptor
;;;1233   
;;;1234   							case	4:	//因产品字符串索引值为2，所以这里写4
;;;1235   								pep0state->nBytesLeft = iapStringDescriptorSize;		
0004bc  1d21              ADDS     r1,r4,#4
0004be  48e1              LDR      r0,|L27.2116|
0004c0  8800              LDRH     r0,[r0,#0]  ; iapStringDescriptorSize
0004c2  f7fffffe          BL       __aeabi_uwrite4
;;;1236   								/* Check host is allowing a descriptor this long */
;;;1237   								
;;;1238   								SEGGER_RTT_printf(0,"USB_StdDev_Req;  444 pcmd->USBwLength=%d\n",pcmd->USBwLength);
0004c6  79e8              LDRB     r0,[r5,#7]
0004c8  79a9              LDRB     r1,[r5,#6]
0004ca  0200              LSLS     r0,r0,#8
0004cc  4308              ORRS     r0,r0,r1
0004ce  4602              MOV      r2,r0
0004d0  a1dd              ADR      r1,|L27.2120|
0004d2  2000              MOVS     r0,#0
0004d4  f7fffffe          BL       SEGGER_RTT_printf
;;;1239   								
;;;1240   								SEGGER_RTT_printf(0,"USB_StdDev_Req;  444 pcmd->nBytesLeft=%d\n",pep0state->nBytesLeft);
0004d8  1d20              ADDS     r0,r4,#4
0004da  f7fffffe          BL       __aeabi_uread4
0004de  4602              MOV      r2,r0
0004e0  e000              B        |L27.1252|
0004e2  e01f              B        |L27.1316|
                  |L27.1252|
0004e4  a1e3              ADR      r1,|L27.2164|
0004e6  9000              STR      r0,[sp,#0]
0004e8  2000              MOVS     r0,#0
0004ea  f7fffffe          BL       SEGGER_RTT_printf
;;;1241   								if (pcmd->USBwLength < pep0state->nBytesLeft)
0004ee  1d20              ADDS     r0,r4,#4
0004f0  f7fffffe          BL       __aeabi_uread4
0004f4  79e9              LDRB     r1,[r5,#7]
0004f6  79aa              LDRB     r2,[r5,#6]
0004f8  0209              LSLS     r1,r1,#8
0004fa  4311              ORRS     r1,r1,r2
0004fc  4288              CMP      r0,r1
0004fe  dd07              BLE      |L27.1296|
;;;1242   								{
;;;1243   									pep0state->nBytesLeft = pcmd->USBwLength;
000500  79e9              LDRB     r1,[r5,#7]
000502  79aa              LDRB     r2,[r5,#6]
000504  0209              LSLS     r1,r1,#8
000506  4311              ORRS     r1,r1,r2
000508  4608              MOV      r0,r1
00050a  1d21              ADDS     r1,r4,#4
00050c  f7fffffe          BL       __aeabi_uwrite4
                  |L27.1296|
;;;1244   								}
;;;1245   								pep0state->pData = (void*)iapStringDescriptor;
000510  4621              MOV      r1,r4
000512  3108              ADDS     r1,r1,#8
000514  48e2              LDR      r0,|L27.2208|
000516  f7fffffe          BL       __aeabi_uwrite4
;;;1246   								pep0state->nState = M_EP0_TX;
00051a  4621              MOV      r1,r4
00051c  2002              MOVS     r0,#2
00051e  f7fffffe          BL       __aeabi_uwrite4
;;;1247   							break;		
000522  e002              B        |L27.1322|
                  |L27.1316|
;;;1248   							default:
;;;1249   								bError = TRUE;								
000524  2001              MOVS     r0,#1
000526  9008              STR      r0,[sp,#0x20]
;;;1250   							break;
000528  bf00              NOP      
                  |L27.1322|
00052a  bf00              NOP                            ;1202
;;;1251   						}
;;;1252   					break;
00052c  e002              B        |L27.1332|
                  |L27.1326|
;;;1253   					/***保留***/
;;;1254   					default: bError = TRUE;
00052e  2001              MOVS     r0,#1
000530  9008              STR      r0,[sp,#0x20]
000532  bf00              NOP                            ;1076
                  |L27.1332|
000534  bf00              NOP                            ;1090
                  |L27.1334|
;;;1255   				}
;;;1256   			}
;;;1257   			break;
000536  e32c              B        |L27.2962|
;;;1258   
;;;1259   		/***用于主机指示设备采用的要求的配置***/
;;;1260   		case SET_CONFIGURATION:
;;;1261   			byConfig = (BYTE)(pcmd->USBwValue & 0x00FF);
000538  78e8              LDRB     r0,[r5,#3]
00053a  78a9              LDRB     r1,[r5,#2]
00053c  0200              LSLS     r0,r0,#8
00053e  4308              ORRS     r0,r0,r1
000540  b2c0              UXTB     r0,r0
000542  9005              STR      r0,[sp,#0x14]
;;;1262   			if(gnDevState == DEVSTATE_DEFAULT)
000544  48d7              LDR      r0,|L27.2212|
000546  6800              LDR      r0,[r0,#0]  ; gnDevState
000548  2800              CMP      r0,#0
00054a  d106              BNE      |L27.1370|
;;;1263   			{
;;;1264   			SEGGER_RTT_printf(0,"gnDevState = DEVSTATE_ADDRESS;	 777 byConfig=%d\n",byConfig);
00054c  a1d6              ADR      r1,|L27.2216|
00054e  9a05              LDR      r2,[sp,#0x14]
000550  f7fffffe          BL       SEGGER_RTT_printf
;;;1265   				bError = TRUE;
000554  2001              MOVS     r0,#1
000556  9008              STR      r0,[sp,#0x20]
000558  e037              B        |L27.1482|
                  |L27.1370|
;;;1266   			}
;;;1267   			/* Assumes configurations are numbered 1 to NumConfigurations */
;;;1268   			else if(byConfig >USB_FSDeviceDescriptor[USB_FSDeviceDescriptorSize-1])
00055a  48e0              LDR      r0,|L27.2268|
00055c  8800              LDRH     r0,[r0,#0]  ; USB_FSDeviceDescriptorSize
00055e  1e40              SUBS     r0,r0,#1
000560  49df              LDR      r1,|L27.2272|
000562  5c09              LDRB     r1,[r1,r0]
000564  9805              LDR      r0,[sp,#0x14]
000566  4281              CMP      r1,r0
000568  da07              BGE      |L27.1402|
;;;1269   			{
;;;1270   			SEGGER_RTT_printf(0,"gnDevState = DEVSTATE_ADDRESS;	 666 byConfig=%d\n",byConfig);
00056a  a1de              ADR      r1,|L27.2276|
00056c  2000              MOVS     r0,#0
00056e  9a05              LDR      r2,[sp,#0x14]
000570  f7fffffe          BL       SEGGER_RTT_printf
;;;1271   				bError = TRUE;
000574  2001              MOVS     r0,#1
000576  9008              STR      r0,[sp,#0x20]
000578  e027              B        |L27.1482|
                  |L27.1402|
;;;1272   			}
;;;1273   			else if(!byConfig)
00057a  9805              LDR      r0,[sp,#0x14]
00057c  2800              CMP      r0,#0
00057e  d106              BNE      |L27.1422|
;;;1274   			{
;;;1275   			
;;;1276   			SEGGER_RTT_printf(0,"gnDevState = DEVSTATE_ADDRESS;	 333\n");
000580  a1e5              ADR      r1,|L27.2328|
000582  f7fffffe          BL       SEGGER_RTT_printf
;;;1277   				gnDevState = DEVSTATE_ADDRESS;
000586  2001              MOVS     r0,#1
000588  49c6              LDR      r1,|L27.2212|
00058a  6008              STR      r0,[r1,#0]  ; gnDevState
00058c  e01d              B        |L27.1482|
                  |L27.1422|
;;;1278   			}
;;;1279   			else
;;;1280   			{
;;;1281   			
;;;1282   			SEGGER_RTT_printf(0,"gnDevState = DEVSTATE_ADDRESS;	 555 byConfig=%d\n",byConfig);
00058e  a1ec              ADR      r1,|L27.2368|
000590  2000              MOVS     r0,#0
000592  9a05              LDR      r2,[sp,#0x14]
000594  f7fffffe          BL       SEGGER_RTT_printf
;;;1283   				/* Get pointer to requested configuration descriptor */
;;;1284   				gpCurCfg = (void *)USB_FSConfigDescriptor;
000598  48f6              LDR      r0,|L27.2420|
00059a  49f7              LDR      r1,|L27.2424|
00059c  6008              STR      r0,[r1,#0]  ; gpCurCfg
;;;1285   				/* Set all alternate settings to zero */
;;;1286   				for (n=0; n<M_MAXIFS; n++)
00059e  2700              MOVS     r7,#0
0005a0  e003              B        |L27.1450|
                  |L27.1442|
;;;1287   					gbyCurIfVal[n] = 0;
0005a2  2000              MOVS     r0,#0
0005a4  49f5              LDR      r1,|L27.2428|
0005a6  55c8              STRB     r0,[r1,r7]
0005a8  1c7f              ADDS     r7,r7,#1              ;1286
                  |L27.1450|
0005aa  2f07              CMP      r7,#7                 ;1286
0005ac  dbf9              BLT      |L27.1442|
;;;1288   				/* Configure endpoints */
;;;1289   				ConfigureIfs();
0005ae  f7fffffe          BL       ConfigureIfs
;;;1290   				
;;;1291   				SEGGER_RTT_printf(0,"gnDevState = DEVSTATE_ADDRESS;  444\n");
0005b2  a1f3              ADR      r1,|L27.2432|
0005b4  2000              MOVS     r0,#0
0005b6  f7fffffe          BL       SEGGER_RTT_printf
;;;1292   				gnDevState = DEVSTATE_CONFIG;
0005ba  2002              MOVS     r0,#2
0005bc  49b9              LDR      r1,|L27.2212|
0005be  6008              STR      r0,[r1,#0]  ; gnDevState
;;;1293   				MWRITE_BYTE(M_REG_INDEX, 0);
0005c0  2000              MOVS     r0,#0
0005c2  49f9              LDR      r1,|L27.2472|
0005c4  7388              STRB     r0,[r1,#0xe]
;;;1294   				bNoData = TRUE;
0005c6  2001              MOVS     r0,#1
0005c8  9007              STR      r0,[sp,#0x1c]
                  |L27.1482|
;;;1295   			}
;;;1296   			
;;;1297   			SEGGER_RTT_printf(0,"b_config == 1\n");
0005ca  a1f8              ADR      r1,|L27.2476|
0005cc  2000              MOVS     r0,#0
0005ce  f7fffffe          BL       SEGGER_RTT_printf
;;;1298   			b_config = 1;
0005d2  2001              MOVS     r0,#1
0005d4  49f9              LDR      r1,|L27.2492|
0005d6  6008              STR      r0,[r1,#0]  ; b_config
;;;1299   			break;
0005d8  e2db              B        |L27.2962|
;;;1300   
;;;1301   		/***用于主机要求设备用某个描述符来描述接口***/		
;;;1302   		case SET_INTERFACE:
;;;1303   			if(gnDevState > DEVSTATE_ADDRESS)
0005da  48b2              LDR      r0,|L27.2212|
0005dc  6800              LDR      r0,[r0,#0]  ; gnDevState
0005de  2801              CMP      r0,#1
0005e0  d920              BLS      |L27.1572|
;;;1304   			{
;;;1305   				n = (int)pcmd->USBwIndex;
0005e2  7968              LDRB     r0,[r5,#5]
0005e4  7929              LDRB     r1,[r5,#4]
0005e6  0207              LSLS     r7,r0,#8
0005e8  430f              ORRS     r7,r7,r1
;;;1306   				pcfg = (PSTD_CFG_DSCR)gpCurCfg;
0005ea  48e3              LDR      r0,|L27.2424|
0005ec  6800              LDR      r0,[r0,#0]  ; gpCurCfg
0005ee  9004              STR      r0,[sp,#0x10]
;;;1307   				if((BYTE)n >= pcfg->bNumInterfaces)
0005f0  b2f9              UXTB     r1,r7
0005f2  9804              LDR      r0,[sp,#0x10]
0005f4  7900              LDRB     r0,[r0,#4]
0005f6  4281              CMP      r1,r0
0005f8  db02              BLT      |L27.1536|
;;;1308   				{
;;;1309   					bError = TRUE;
0005fa  2001              MOVS     r0,#1
0005fc  9008              STR      r0,[sp,#0x20]
0005fe  e013              B        |L27.1576|
                  |L27.1536|
;;;1310   				}
;;;1311   				else 
;;;1312   				{
;;;1313   					gbyCurIfVal[n] = (BYTE)pcmd->USBwValue;
000600  78e8              LDRB     r0,[r5,#3]
000602  78a9              LDRB     r1,[r5,#2]
000604  0200              LSLS     r0,r0,#8
000606  4308              ORRS     r0,r0,r1
000608  49dc              LDR      r1,|L27.2428|
00060a  55c8              STRB     r0,[r1,r7]
;;;1314   					if (ConfigureIfs() == FALSE)
00060c  f7fffffe          BL       ConfigureIfs
000610  2800              CMP      r0,#0
000612  d101              BNE      |L27.1560|
;;;1315   					{
;;;1316   						bError = TRUE;
000614  2001              MOVS     r0,#1
000616  9008              STR      r0,[sp,#0x20]
                  |L27.1560|
;;;1317   					}
;;;1318   					
;;;1319   					MWRITE_BYTE(M_REG_INDEX, 0);
000618  2000              MOVS     r0,#0
00061a  49e3              LDR      r1,|L27.2472|
00061c  7388              STRB     r0,[r1,#0xe]
;;;1320   					bNoData = TRUE;
00061e  2001              MOVS     r0,#1
000620  9007              STR      r0,[sp,#0x1c]
000622  e001              B        |L27.1576|
                  |L27.1572|
;;;1321   				}
;;;1322   			}
;;;1323   			else
;;;1324   			{
;;;1325   				bError = TRUE;
000624  2001              MOVS     r0,#1
000626  9008              STR      r0,[sp,#0x20]
                  |L27.1576|
;;;1326   			}
;;;1327   			break;
000628  e2b3              B        |L27.2962|
;;;1328   
;;;1329   		/***用于主机获取设备当前设备的配置值***/		
;;;1330   		case GET_CONFIGURATION:
;;;1331   			if ((gnDevState == DEVSTATE_ADDRESS) && (!pcmd->USBwValue))
00062a  489e              LDR      r0,|L27.2212|
00062c  6800              LDR      r0,[r0,#0]  ; gnDevState
00062e  2801              CMP      r0,#1
000630  d113              BNE      |L27.1626|
000632  78e8              LDRB     r0,[r5,#3]
000634  78a9              LDRB     r1,[r5,#2]
000636  0200              LSLS     r0,r0,#8
000638  4308              ORRS     r0,r0,r1
00063a  2800              CMP      r0,#0
00063c  d10d              BNE      |L27.1626|
;;;1332   			{
;;;1333   				/* Prepare to return zero */
;;;1334   				pep0state->nBytesLeft = 1;
00063e  1d21              ADDS     r1,r4,#4
000640  2001              MOVS     r0,#1
000642  f7fffffe          BL       __aeabi_uwrite4
;;;1335   				pep0state->pData = (void*)&pcmd->USBwValue;
000646  4621              MOV      r1,r4
000648  3108              ADDS     r1,r1,#8
00064a  1ca8              ADDS     r0,r5,#2
00064c  f7fffffe          BL       __aeabi_uwrite4
;;;1336   				pep0state->nState = M_EP0_TX;
000650  4621              MOV      r1,r4
000652  2002              MOVS     r0,#2
000654  f7fffffe          BL       __aeabi_uwrite4
000658  e017              B        |L27.1674|
                  |L27.1626|
;;;1337   			}
;;;1338   			else if(gnDevState > DEVSTATE_ADDRESS)
00065a  4892              LDR      r0,|L27.2212|
00065c  6800              LDR      r0,[r0,#0]  ; gnDevState
00065e  2801              CMP      r0,#1
000660  d911              BLS      |L27.1670|
;;;1339   			{
;;;1340   				/* Prepare to return configuration value */
;;;1341   				pcfg = (PSTD_CFG_DSCR)gpCurCfg;
000662  48c5              LDR      r0,|L27.2424|
000664  6800              LDR      r0,[r0,#0]  ; gpCurCfg
000666  9004              STR      r0,[sp,#0x10]
;;;1342   				pep0state->nBytesLeft = 1;
000668  1d21              ADDS     r1,r4,#4
00066a  2001              MOVS     r0,#1
00066c  f7fffffe          BL       __aeabi_uwrite4
;;;1343   				pep0state->pData = (void*)&pcfg->bConfigurationValue;
000670  4621              MOV      r1,r4
000672  3108              ADDS     r1,r1,#8
000674  9804              LDR      r0,[sp,#0x10]
000676  1d40              ADDS     r0,r0,#5
000678  f7fffffe          BL       __aeabi_uwrite4
;;;1344   				pep0state->nState = M_EP0_TX;
00067c  4621              MOV      r1,r4
00067e  2002              MOVS     r0,#2
000680  f7fffffe          BL       __aeabi_uwrite4
000684  e001              B        |L27.1674|
                  |L27.1670|
;;;1345   			}
;;;1346   			else
;;;1347   			{
;;;1348   				bError = TRUE;
000686  2001              MOVS     r0,#1
000688  9008              STR      r0,[sp,#0x20]
                  |L27.1674|
;;;1349   			}
;;;1350   			break;
00068a  e282              B        |L27.2962|
;;;1351   
;;;1352   		/***用于获取当前某个接口描述符编号***/	
;;;1353   		case GET_INTERFACE:
;;;1354   			if(gnDevState > DEVSTATE_ADDRESS)
00068c  4885              LDR      r0,|L27.2212|
00068e  6800              LDR      r0,[r0,#0]  ; gnDevState
000690  2801              CMP      r0,#1
000692  d91f              BLS      |L27.1748|
;;;1355   			{
;;;1356   				n = (int)pcmd->USBwIndex;
000694  7968              LDRB     r0,[r5,#5]
000696  7929              LDRB     r1,[r5,#4]
000698  0207              LSLS     r7,r0,#8
00069a  430f              ORRS     r7,r7,r1
;;;1357   				pcfg = (PSTD_CFG_DSCR)gpCurCfg;
00069c  48b6              LDR      r0,|L27.2424|
00069e  6800              LDR      r0,[r0,#0]  ; gpCurCfg
0006a0  9004              STR      r0,[sp,#0x10]
;;;1358   				if((BYTE)n >= pcfg->bNumInterfaces)
0006a2  b2f9              UXTB     r1,r7
0006a4  9804              LDR      r0,[sp,#0x10]
0006a6  7900              LDRB     r0,[r0,#4]
0006a8  4281              CMP      r1,r0
0006aa  db02              BLT      |L27.1714|
;;;1359   				{
;;;1360   					bError = TRUE;
0006ac  2001              MOVS     r0,#1
0006ae  9008              STR      r0,[sp,#0x20]
0006b0  e012              B        |L27.1752|
                  |L27.1714|
;;;1361   				}
;;;1362   				else 
;;;1363   				{
;;;1364   					/* Prepare to return interface value */
;;;1365   					pep0state->nBytesLeft = 1;
0006b2  1d21              ADDS     r1,r4,#4
0006b4  2001              MOVS     r0,#1
0006b6  f7fffffe          BL       __aeabi_uwrite4
;;;1366   					pep0state->pData = (void*)&gpCurIf[n]->bInterfaceNumber;
0006ba  00b9              LSLS     r1,r7,#2
0006bc  4ac0              LDR      r2,|L27.2496|
0006be  5851              LDR      r1,[r2,r1]
0006c0  1c88              ADDS     r0,r1,#2
0006c2  4621              MOV      r1,r4
0006c4  3108              ADDS     r1,r1,#8
0006c6  f7fffffe          BL       __aeabi_uwrite4
;;;1367   					pep0state->nState = M_EP0_TX;
0006ca  4621              MOV      r1,r4
0006cc  2002              MOVS     r0,#2
0006ce  f7fffffe          BL       __aeabi_uwrite4
0006d2  e001              B        |L27.1752|
                  |L27.1748|
;;;1368   				}
;;;1369   			}
;;;1370   			else
;;;1371   				bError = TRUE;
0006d4  2001              MOVS     r0,#1
0006d6  9008              STR      r0,[sp,#0x20]
                  |L27.1752|
;;;1372   			break;
0006d8  e25b              B        |L27.2962|
;;;1373   
;;;1374   		/***用来启用或激活命令接收者的某些特性***/
;;;1375   		case SET_FEATURE:
;;;1376   			switch (pcmd->bmRequestType) 
0006da  7828              LDRB     r0,[r5,#0]
0006dc  2800              CMP      r0,#0
0006de  d004              BEQ      |L27.1770|
0006e0  2801              CMP      r0,#1
0006e2  d018              BEQ      |L27.1814|
0006e4  2802              CMP      r0,#2
0006e6  d158              BNE      |L27.1946|
0006e8  e016              B        |L27.1816|
                  |L27.1770|
;;;1377   			{
;;;1378   					case M_CMD_STDDEVOUT:
;;;1379   						switch (pcmd->USBwValue) 
0006ea  78e8              LDRB     r0,[r5,#3]
0006ec  78a9              LDRB     r1,[r5,#2]
0006ee  0200              LSLS     r0,r0,#8
0006f0  4308              ORRS     r0,r0,r1
0006f2  2801              CMP      r0,#1
0006f4  d10a              BNE      |L27.1804|
;;;1380   						{
;;;1381   							case M_FTR_DEVREMWAKE:
;;;1382   							pInformation->Current_Feature = pInformation->Current_Feature | (0x1<<5);	
0006f6  48b3              LDR      r0,|L27.2500|
0006f8  6800              LDR      r0,[r0,#0]  ; pInformation
0006fa  7840              LDRB     r0,[r0,#1]
0006fc  2120              MOVS     r1,#0x20
0006fe  4308              ORRS     r0,r0,r1
000700  49b0              LDR      r1,|L27.2500|
000702  6809              LDR      r1,[r1,#0]  ; pInformation
000704  7048              STRB     r0,[r1,#1]
;;;1383   							bNoData = TRUE;	
000706  2001              MOVS     r0,#1
000708  9007              STR      r0,[sp,#0x1c]
;;;1384   							break;	
00070a  e002              B        |L27.1810|
                  |L27.1804|
;;;1385   							default:
;;;1386   							bError = TRUE;
00070c  2001              MOVS     r0,#1
00070e  9008              STR      r0,[sp,#0x20]
;;;1387   							break;
000710  bf00              NOP      
                  |L27.1810|
000712  bf00              NOP                            ;1384
;;;1388   						}
;;;1389   					break;
000714  e044              B        |L27.1952|
                  |L27.1814|
;;;1390   						
;;;1391   					case M_CMD_STDIFOUT:
;;;1392   
;;;1393   					/* SET FEATURE for EndPoint*/
;;;1394   					case M_CMD_STDEPOUT:
000716  bf00              NOP      
                  |L27.1816|
;;;1395   
;;;1396   						switch (pcmd->USBwValue0) 
000718  78a8              LDRB     r0,[r5,#2]
00071a  2800              CMP      r0,#0
00071c  d138              BNE      |L27.1936|
;;;1397   						{						
;;;1398   							case M_FTR_EPHALT:
;;;1399   	
;;;1400   							MWRITE_BYTE(M_REG_INDEX,Related_Endpoint);	
00071e  49a2              LDR      r1,|L27.2472|
000720  9803              LDR      r0,[sp,#0xc]
000722  7388              STRB     r0,[r1,#0xe]
;;;1401   							if (pcmd->USBwIndex0 & 0x80)
000724  7928              LDRB     r0,[r5,#4]
000726  2180              MOVS     r1,#0x80
000728  4008              ANDS     r0,r0,r1
00072a  2800              CMP      r0,#0
00072c  d016              BEQ      |L27.1884|
;;;1402   							{
;;;1403   								if(Related_Endpoint)/* IN endpoint */
00072e  9803              LDR      r0,[sp,#0xc]
000730  2800              CMP      r0,#0
000732  d00a              BEQ      |L27.1866|
;;;1404   								{
;;;1405   									srbuff = *((uint8_t*)M_REG_INCSR1);	
000734  489c              LDR      r0,|L27.2472|
000736  7c46              LDRB     r6,[r0,#0x11]
;;;1406   									srbuff = srbuff |(0x1<<4);
000738  2010              MOVS     r0,#0x10
00073a  4306              ORRS     r6,r6,r0
;;;1407   									MWRITE_BYTE(M_REG_INCSR1,srbuff);
00073c  489a              LDR      r0,|L27.2472|
00073e  7446              STRB     r6,[r0,#0x11]
;;;1408   									INCSRDATA = MREAD_BYTE(M_REG_INCSR1);	
000740  7c40              LDRB     r0,[r0,#0x11]
000742  49a1              LDR      r1,|L27.2504|
000744  7008              STRB     r0,[r1,#0]
;;;1409   									__ASM("NOP");
000746  bf00              NOP      
000748  e01c              B        |L27.1924|
                  |L27.1866|
;;;1410   								}
;;;1411   								
;;;1412   								else
;;;1413   								{
;;;1414   									srbuff = *((uint8_t*)M_REG_CSR0);	
00074a  4897              LDR      r0,|L27.2472|
00074c  7c46              LDRB     r6,[r0,#0x11]
;;;1415   									*((uint8_t*)M_REG_CSR0) = srbuff |(0x1<<5);
00074e  2020              MOVS     r0,#0x20
000750  4330              ORRS     r0,r0,r6
000752  4995              LDR      r1,|L27.2472|
000754  7448              STRB     r0,[r1,#0x11]
;;;1416   									srbuff = *((uint8_t*)M_REG_CSR0);	
000756  4608              MOV      r0,r1
000758  7c46              LDRB     r6,[r0,#0x11]
00075a  e013              B        |L27.1924|
                  |L27.1884|
;;;1417   								}
;;;1418   							
;;;1419   							}
;;;1420   
;;;1421   							else
;;;1422   							{
;;;1423   						/* OUT endpoint */
;;;1424   								if(Related_Endpoint)
00075c  9803              LDR      r0,[sp,#0xc]
00075e  2800              CMP      r0,#0
000760  d008              BEQ      |L27.1908|
;;;1425   								{
;;;1426   									srbuff = *((uint8_t*)M_REG_OUTCSR1);	
000762  4891              LDR      r0,|L27.2472|
000764  7d06              LDRB     r6,[r0,#0x14]
;;;1427   									*((uint8_t*)M_REG_OUTCSR1) = srbuff |(0x1<<5);
000766  2020              MOVS     r0,#0x20
000768  4330              ORRS     r0,r0,r6
00076a  498f              LDR      r1,|L27.2472|
00076c  7508              STRB     r0,[r1,#0x14]
;;;1428   									srbuff = *((uint8_t*)M_REG_OUTCSR1);								
00076e  4608              MOV      r0,r1
000770  7d06              LDRB     r6,[r0,#0x14]
000772  e007              B        |L27.1924|
                  |L27.1908|
;;;1429   								}
;;;1430   								
;;;1431   								else
;;;1432   								{
;;;1433   									srbuff = *((uint8_t*)M_REG_CSR0);	
000774  488c              LDR      r0,|L27.2472|
000776  7c46              LDRB     r6,[r0,#0x11]
;;;1434   									*((uint8_t*)M_REG_CSR0) = srbuff |(0x1<<5);
000778  2020              MOVS     r0,#0x20
00077a  4330              ORRS     r0,r0,r6
00077c  498a              LDR      r1,|L27.2472|
00077e  7448              STRB     r0,[r1,#0x11]
;;;1435   									srbuff = *((uint8_t*)M_REG_CSR0);								
000780  4608              MOV      r0,r1
000782  7c46              LDRB     r6,[r0,#0x11]
                  |L27.1924|
;;;1436   								}
;;;1437   													
;;;1438   							}
;;;1439   							bNoData = TRUE;	
000784  2001              MOVS     r0,#1
000786  9007              STR      r0,[sp,#0x1c]
;;;1440   							MWRITE_BYTE(M_REG_INDEX,0);	
000788  2000              MOVS     r0,#0
00078a  4987              LDR      r1,|L27.2472|
00078c  7388              STRB     r0,[r1,#0xe]
;;;1441   							break;
00078e  e002              B        |L27.1942|
                  |L27.1936|
;;;1442   							default:
;;;1443   							bError = TRUE;
000790  2001              MOVS     r0,#1
000792  9008              STR      r0,[sp,#0x20]
;;;1444   							break;
000794  bf00              NOP      
                  |L27.1942|
000796  bf00              NOP                            ;1441
;;;1445   						}
;;;1446   					break;
000798  e002              B        |L27.1952|
                  |L27.1946|
;;;1447   						
;;;1448   					default:
;;;1449   					bError = TRUE;
00079a  2001              MOVS     r0,#1
00079c  9008              STR      r0,[sp,#0x20]
;;;1450   					break;
00079e  bf00              NOP      
                  |L27.1952|
0007a0  bf00              NOP                            ;1389
;;;1451   			}
;;;1452   		break;
0007a2  e1f6              B        |L27.2962|
;;;1453   			
;;;1454   		/***用来CLEAR接收者的某些特性***/			
;;;1455   		case CLEAR_FEATURE:
;;;1456   			switch (pcmd->bmRequestType) 
0007a4  7828              LDRB     r0,[r5,#0]
0007a6  2800              CMP      r0,#0
0007a8  d004              BEQ      |L27.1972|
0007aa  2801              CMP      r0,#1
0007ac  d018              BEQ      |L27.2016|
0007ae  2802              CMP      r0,#2
0007b0  d144              BNE      |L27.2108|
0007b2  e016              B        |L27.2018|
                  |L27.1972|
;;;1457   			{
;;;1458   					case M_CMD_STDDEVOUT:
;;;1459   						switch (pcmd->USBwValue) 
0007b4  78e8              LDRB     r0,[r5,#3]
0007b6  78a9              LDRB     r1,[r5,#2]
0007b8  0200              LSLS     r0,r0,#8
0007ba  4308              ORRS     r0,r0,r1
0007bc  2801              CMP      r0,#1
0007be  d10a              BNE      |L27.2006|
;;;1460   						{
;;;1461   							case M_FTR_DEVREMWAKE:
;;;1462   							pInformation->Current_Feature = pInformation->Current_Feature & (~(0x1<<5));
0007c0  4880              LDR      r0,|L27.2500|
0007c2  6800              LDR      r0,[r0,#0]  ; pInformation
0007c4  7840              LDRB     r0,[r0,#1]
0007c6  2120              MOVS     r1,#0x20
0007c8  4388              BICS     r0,r0,r1
0007ca  497e              LDR      r1,|L27.2500|
0007cc  6809              LDR      r1,[r1,#0]  ; pInformation
0007ce  7048              STRB     r0,[r1,#1]
;;;1463   							bNoData = TRUE;	
0007d0  2001              MOVS     r0,#1
0007d2  9007              STR      r0,[sp,#0x1c]
;;;1464   							break;
0007d4  e002              B        |L27.2012|
                  |L27.2006|
;;;1465   							default:
;;;1466   							bError = TRUE;
0007d6  2001              MOVS     r0,#1
0007d8  9008              STR      r0,[sp,#0x20]
;;;1467   							break;
0007da  bf00              NOP      
                  |L27.2012|
0007dc  bf00              NOP                            ;1464
;;;1468   						}
;;;1469   					break;
0007de  e121              B        |L27.2596|
                  |L27.2016|
;;;1470   						
;;;1471   					case M_CMD_STDIFOUT:
;;;1472   
;;;1473   					/* CLEAR FEATURE for EndPoint*/
;;;1474   					case M_CMD_STDEPOUT:
0007e0  bf00              NOP      
                  |L27.2018|
;;;1475   						switch (pcmd->USBwValue0) 
0007e2  78a8              LDRB     r0,[r5,#2]
0007e4  2800              CMP      r0,#0
0007e6  d12a              BNE      |L27.2110|
;;;1476   						{
;;;1477   							case M_FTR_EPHALT:						
;;;1478   							MWRITE_BYTE(M_REG_INDEX,Related_Endpoint);	
0007e8  496f              LDR      r1,|L27.2472|
0007ea  9803              LDR      r0,[sp,#0xc]
0007ec  7388              STRB     r0,[r1,#0xe]
;;;1479   							if (pcmd->USBwIndex0 & 0x80)
0007ee  7928              LDRB     r0,[r5,#4]
0007f0  2180              MOVS     r1,#0x80
0007f2  4008              ANDS     r0,r0,r1
0007f4  2800              CMP      r0,#0
0007f6  d023              BEQ      |L27.2112|
;;;1480   							{/* IN endpoint */
;;;1481   								if(Related_Endpoint)
0007f8  9803              LDR      r0,[sp,#0xc]
0007fa  2800              CMP      r0,#0
0007fc  d014              BEQ      |L27.2088|
;;;1482   								{
;;;1483   //									*((uint8_t*)M_REG_INCSR1) = *((uint8_t*)M_REG_INCSR1) & (~(0x01<<6));
;;;1484   									srbuff = *((uint8_t*)M_REG_INCSR1);	
0007fe  486a              LDR      r0,|L27.2472|
000800  7c46              LDRB     r6,[r0,#0x11]
;;;1485   									*((uint8_t*)M_REG_INCSR1) = srbuff & (~(0x01<<6));
000802  2140              MOVS     r1,#0x40
000804  4630              MOV      r0,r6
000806  4388              BICS     r0,r0,r1
000808  4967              LDR      r1,|L27.2472|
00080a  7448              STRB     r0,[r1,#0x11]
;;;1486   									srbuff = *((uint8_t*)M_REG_INCSR1);											
00080c  4608              MOV      r0,r1
00080e  7c46              LDRB     r6,[r0,#0x11]
;;;1487   									
;;;1488   //									*((uint8_t*)M_REG_INCSR1) = *((uint8_t*)M_REG_INCSR1) & (~(0x01<<4));
;;;1489   									srbuff = *((uint8_t*)M_REG_INCSR1);	
000810  7c46              LDRB     r6,[r0,#0x11]
;;;1490   									*((uint8_t*)M_REG_INCSR1) = srbuff & (~(0x01<<4));	
000812  2110              MOVS     r1,#0x10
000814  4630              MOV      r0,r6
000816  4388              BICS     r0,r0,r1
000818  4963              LDR      r1,|L27.2472|
00081a  7448              STRB     r0,[r1,#0x11]
;;;1491   									INCSRDATA = *((uint8_t*)M_REG_INCSR1);	
00081c  4608              MOV      r0,r1
00081e  7c40              LDRB     r0,[r0,#0x11]
000820  4969              LDR      r1,|L27.2504|
000822  7008              STRB     r0,[r1,#0]
;;;1492   									__ASM("NOP");
000824  bf00              NOP      
000826  e0ef              B        |L27.2568|
                  |L27.2088|
;;;1493   								}
;;;1494   								
;;;1495   								else
;;;1496   								{
;;;1497   //									*((uint8_t*)M_REG_CSR0) = *((uint8_t*)M_REG_CSR0) & (~(0x01<<5));
;;;1498   									srbuff = *((uint8_t*)M_REG_CSR0);	
000828  485f              LDR      r0,|L27.2472|
00082a  7c46              LDRB     r6,[r0,#0x11]
;;;1499   									*((uint8_t*)M_REG_CSR0) = srbuff & (~(0x01<<5));
00082c  2120              MOVS     r1,#0x20
00082e  4630              MOV      r0,r6
000830  4388              BICS     r0,r0,r1
000832  495d              LDR      r1,|L27.2472|
000834  7448              STRB     r0,[r1,#0x11]
;;;1500   									srbuff = *((uint8_t*)M_REG_CSR0);										
000836  4608              MOV      r0,r1
000838  7c46              LDRB     r6,[r0,#0x11]
00083a  e0e5              B        |L27.2568|
                  |L27.2108|
00083c  e0ef              B        |L27.2590|
                  |L27.2110|
00083e  e0e9              B        |L27.2580|
                  |L27.2112|
000840  e0c4              B        |L27.2508|
                  |L27.2114|
000842  e1a3              B        |L27.2956|
                  |L27.2116|
                          DCD      iapStringDescriptorSize
                  |L27.2120|
000848  5553425f          DCB      "USB_StdDev_Req;  444 pcmd->USBwLength=%d\n",0
00084c  53746444
000850  65765f52
000854  65713b20
000858  20343434
00085c  2070636d
000860  642d3e55
000864  5342774c
000868  656e6774
00086c  683d2564
000870  0a00    
000872  00                DCB      0
000873  00                DCB      0
                  |L27.2164|
000874  5553425f          DCB      "USB_StdDev_Req;  444 pcmd->nBytesLeft=%d\n",0
000878  53746444
00087c  65765f52
000880  65713b20
000884  20343434
000888  2070636d
00088c  642d3e6e
000890  42797465
000894  734c6566
000898  743d2564
00089c  0a00    
00089e  00                DCB      0
00089f  00                DCB      0
                  |L27.2208|
                          DCD      iapStringDescriptor
                  |L27.2212|
                          DCD      gnDevState
                  |L27.2216|
0008a8  676e4465          DCB      "gnDevState = DEVSTATE_ADDRESS;\t 777 byConfig=%d\n",0
0008ac  76537461
0008b0  7465203d
0008b4  20444556
0008b8  53544154
0008bc  455f4144
0008c0  44524553
0008c4  533b0920
0008c8  37373720
0008cc  6279436f
0008d0  6e666967
0008d4  3d25640a
0008d8  00      
0008d9  00                DCB      0
0008da  00                DCB      0
0008db  00                DCB      0
                  |L27.2268|
                          DCD      USB_FSDeviceDescriptorSize
                  |L27.2272|
                          DCD      USB_FSDeviceDescriptor
                  |L27.2276|
0008e4  676e4465          DCB      "gnDevState = DEVSTATE_ADDRESS;\t 666 byConfig=%d\n",0
0008e8  76537461
0008ec  7465203d
0008f0  20444556
0008f4  53544154
0008f8  455f4144
0008fc  44524553
000900  533b0920
000904  36363620
000908  6279436f
00090c  6e666967
000910  3d25640a
000914  00      
000915  00                DCB      0
000916  00                DCB      0
000917  00                DCB      0
                  |L27.2328|
000918  676e4465          DCB      "gnDevState = DEVSTATE_ADDRESS;\t 333\n",0
00091c  76537461
000920  7465203d
000924  20444556
000928  53544154
00092c  455f4144
000930  44524553
000934  533b0920
000938  3333330a
00093c  00      
00093d  00                DCB      0
00093e  00                DCB      0
00093f  00                DCB      0
                  |L27.2368|
000940  676e4465          DCB      "gnDevState = DEVSTATE_ADDRESS;\t 555 byConfig=%d\n",0
000944  76537461
000948  7465203d
00094c  20444556
000950  53544154
000954  455f4144
000958  44524553
00095c  533b0920
000960  35353520
000964  6279436f
000968  6e666967
00096c  3d25640a
000970  00      
000971  00                DCB      0
000972  00                DCB      0
000973  00                DCB      0
                  |L27.2420|
                          DCD      USB_FSConfigDescriptor
                  |L27.2424|
                          DCD      gpCurCfg
                  |L27.2428|
                          DCD      gbyCurIfVal
                  |L27.2432|
000980  676e4465          DCB      "gnDevState = DEVSTATE_ADDRESS;  444\n",0
000984  76537461
000988  7465203d
00098c  20444556
000990  53544154
000994  455f4144
000998  44524553
00099c  533b2020
0009a0  3434340a
0009a4  00      
0009a5  00                DCB      0
0009a6  00                DCB      0
0009a7  00                DCB      0
                  |L27.2472|
                          DCD      0x40005c00
                  |L27.2476|
0009ac  625f636f          DCB      "b_config == 1\n",0
0009b0  6e666967
0009b4  203d3d20
0009b8  310a00  
0009bb  00                DCB      0
                  |L27.2492|
                          DCD      b_config
                  |L27.2496|
                          DCD      gpCurIf
                  |L27.2500|
                          DCD      pInformation
                  |L27.2504|
                          DCD      INCSRDATA
                  |L27.2508|
;;;1501   									
;;;1502   								}
;;;1503   									
;;;1504   							}
;;;1505   
;;;1506   							else
;;;1507   							{
;;;1508   								/* OUT endpoint */
;;;1509   								if(Related_Endpoint)
0009cc  9803              LDR      r0,[sp,#0xc]
0009ce  2800              CMP      r0,#0
0009d0  d011              BEQ      |L27.2550|
;;;1510   								{
;;;1511   //									*((uint8_t*)M_REG_OUTCSR1) = *((uint8_t*)M_REG_OUTCSR1) & (~(0x01<<7));
;;;1512   //									*((uint8_t*)M_REG_OUTCSR1) = *((uint8_t*)M_REG_OUTCSR1) & (~(0x01<<5));
;;;1513   									srbuff = *((uint8_t*)M_REG_OUTCSR1);	
0009d2  487a              LDR      r0,|L27.3004|
0009d4  7d06              LDRB     r6,[r0,#0x14]
;;;1514   									*((uint8_t*)M_REG_OUTCSR1) = srbuff & (~(0x01<<7));
0009d6  2180              MOVS     r1,#0x80
0009d8  4630              MOV      r0,r6
0009da  4388              BICS     r0,r0,r1
0009dc  4977              LDR      r1,|L27.3004|
0009de  7508              STRB     r0,[r1,#0x14]
;;;1515   									srbuff = *((uint8_t*)M_REG_OUTCSR1);											
0009e0  4608              MOV      r0,r1
0009e2  7d06              LDRB     r6,[r0,#0x14]
;;;1516   									
;;;1517   									srbuff = *((uint8_t*)M_REG_OUTCSR1);	
0009e4  7d06              LDRB     r6,[r0,#0x14]
;;;1518   									*((uint8_t*)M_REG_OUTCSR1) = srbuff & (~(0x01<<5));
0009e6  2120              MOVS     r1,#0x20
0009e8  4630              MOV      r0,r6
0009ea  4388              BICS     r0,r0,r1
0009ec  4973              LDR      r1,|L27.3004|
0009ee  7508              STRB     r0,[r1,#0x14]
;;;1519   									srbuff = *((uint8_t*)M_REG_OUTCSR1);				
0009f0  4608              MOV      r0,r1
0009f2  7d06              LDRB     r6,[r0,#0x14]
0009f4  e008              B        |L27.2568|
                  |L27.2550|
;;;1520   									
;;;1521   								}
;;;1522   								
;;;1523   								else
;;;1524   								{
;;;1525   //									*((uint8_t*)M_REG_CSR0) = *((uint8_t*)M_REG_CSR0)  & (~(0x01<<5));
;;;1526   									srbuff = *((uint8_t*)M_REG_CSR0);	
0009f6  4871              LDR      r0,|L27.3004|
0009f8  7c46              LDRB     r6,[r0,#0x11]
;;;1527   									*((uint8_t*)M_REG_CSR0) = srbuff & (~(0x01<<5));
0009fa  2120              MOVS     r1,#0x20
0009fc  4630              MOV      r0,r6
0009fe  4388              BICS     r0,r0,r1
000a00  496e              LDR      r1,|L27.3004|
000a02  7448              STRB     r0,[r1,#0x11]
;;;1528   									srbuff = *((uint8_t*)M_REG_CSR0);											
000a04  4608              MOV      r0,r1
000a06  7c46              LDRB     r6,[r0,#0x11]
                  |L27.2568|
;;;1529   								}
;;;1530   													
;;;1531   							}
;;;1532   								bNoData = TRUE;	
000a08  2001              MOVS     r0,#1
000a0a  9007              STR      r0,[sp,#0x1c]
;;;1533   								MWRITE_BYTE(M_REG_INDEX,0);
000a0c  2000              MOVS     r0,#0
000a0e  496b              LDR      r1,|L27.3004|
000a10  7388              STRB     r0,[r1,#0xe]
;;;1534   								break;
000a12  e002              B        |L27.2586|
                  |L27.2580|
;;;1535   						
;;;1536   							default:
;;;1537   							bError = TRUE;
000a14  2001              MOVS     r0,#1
000a16  9008              STR      r0,[sp,#0x20]
;;;1538   							break;
000a18  bf00              NOP      
                  |L27.2586|
000a1a  bf00              NOP                            ;1534
;;;1539   						}
;;;1540   				break;
000a1c  e002              B        |L27.2596|
                  |L27.2590|
;;;1541   						
;;;1542   				default:
;;;1543   				bError = TRUE;
000a1e  2001              MOVS     r0,#1
000a20  9008              STR      r0,[sp,#0x20]
;;;1544   				break;		
000a22  bf00              NOP      
                  |L27.2596|
000a24  bf00              NOP                            ;1469
;;;1545   			}
;;;1546   		break;	
000a26  e0b4              B        |L27.2962|
;;;1547   			
;;;1548   			
;;;1549   		/***用于主机获取设备 STATUS***/					
;;;1550   		case GET_STATUS:	
;;;1551   		
;;;1552   			switch (pcmd->bmRequestType) 
000a28  7828              LDRB     r0,[r5,#0]
000a2a  2880              CMP      r0,#0x80
000a2c  d004              BEQ      |L27.2616|
000a2e  2881              CMP      r0,#0x81
000a30  d03b              BEQ      |L27.2730|
000a32  2882              CMP      r0,#0x82
000a34  d172              BNE      |L27.2844|
000a36  e046              B        |L27.2758|
                  |L27.2616|
;;;1553   			{
;;;1554   
;;;1555   				 /* GET STATUS for Device*/
;;;1556   					case M_CMD_STDDEVIN:
;;;1557   						
;;;1558   					if (pInformation->Current_Feature & (0x1<<5))
000a38  4861              LDR      r0,|L27.3008|
000a3a  6800              LDR      r0,[r0,#0]  ; pInformation
000a3c  7840              LDRB     r0,[r0,#1]
000a3e  2120              MOVS     r1,#0x20
000a40  4008              ANDS     r0,r0,r1
000a42  2800              CMP      r0,#0
000a44  d006              BEQ      |L27.2644|
;;;1559   					{
;;;1560   						txdat[0] |=(0x1<<1);						
000a46  4669              MOV      r1,sp
000a48  7908              LDRB     r0,[r1,#4]
000a4a  2102              MOVS     r1,#2
000a4c  4308              ORRS     r0,r0,r1
000a4e  4669              MOV      r1,sp
000a50  7108              STRB     r0,[r1,#4]
000a52  e005              B        |L27.2656|
                  |L27.2644|
;;;1561   					}
;;;1562   					else
;;;1563   					{
;;;1564   						txdat[0] &= ~(0x1<<1);	
000a54  4669              MOV      r1,sp
000a56  7908              LDRB     r0,[r1,#4]
000a58  2102              MOVS     r1,#2
000a5a  4388              BICS     r0,r0,r1
000a5c  4669              MOV      r1,sp
000a5e  7108              STRB     r0,[r1,#4]
                  |L27.2656|
;;;1565   					} 
;;;1566   					if (pInformation->Current_Feature & (0x1<<6))
000a60  4857              LDR      r0,|L27.3008|
000a62  6800              LDR      r0,[r0,#0]  ; pInformation
000a64  7840              LDRB     r0,[r0,#1]
000a66  2140              MOVS     r1,#0x40
000a68  4008              ANDS     r0,r0,r1
000a6a  2800              CMP      r0,#0
000a6c  d006              BEQ      |L27.2684|
;;;1567   					{
;;;1568   						txdat[0] |=(0x1<<0);						
000a6e  4669              MOV      r1,sp
000a70  7908              LDRB     r0,[r1,#4]
000a72  2101              MOVS     r1,#1
000a74  4308              ORRS     r0,r0,r1
000a76  4669              MOV      r1,sp
000a78  7108              STRB     r0,[r1,#4]
000a7a  e005              B        |L27.2696|
                  |L27.2684|
;;;1569   					}
;;;1570   					else
;;;1571   					{
;;;1572   						txdat[0] &= ~(0x1<<0);	
000a7c  4668              MOV      r0,sp
000a7e  7900              LDRB     r0,[r0,#4]
000a80  0841              LSRS     r1,r0,#1
000a82  0049              LSLS     r1,r1,#1
000a84  4668              MOV      r0,sp
000a86  7101              STRB     r1,[r0,#4]
                  |L27.2696|
;;;1573   					} 					
;;;1574   					
;;;1575   					txdat[1]=0;
000a88  2000              MOVS     r0,#0
000a8a  4669              MOV      r1,sp
000a8c  7148              STRB     r0,[r1,#5]
;;;1576   					pep0state->nBytesLeft = 2;
000a8e  1d21              ADDS     r1,r4,#4
000a90  2002              MOVS     r0,#2
000a92  f7fffffe          BL       __aeabi_uwrite4
;;;1577   					pep0state->pData = txdat;
000a96  4621              MOV      r1,r4
000a98  3108              ADDS     r1,r1,#8
000a9a  a801              ADD      r0,sp,#4
000a9c  f7fffffe          BL       __aeabi_uwrite4
;;;1578   					pep0state->nState = M_EP0_TX;	
000aa0  4621              MOV      r1,r4
000aa2  2002              MOVS     r0,#2
000aa4  f7fffffe          BL       __aeabi_uwrite4
;;;1579   					break;
000aa8  e06e              B        |L27.2952|
                  |L27.2730|
;;;1580   					
;;;1581   				/* GET STATUS for Interface*/		
;;;1582   					case M_CMD_STDIFIN:
;;;1583   					pep0state->nBytesLeft = 2;
000aaa  1d21              ADDS     r1,r4,#4
000aac  2002              MOVS     r0,#2
000aae  f7fffffe          BL       __aeabi_uwrite4
;;;1584   					pep0state->pData = txdat;
000ab2  4621              MOV      r1,r4
000ab4  3108              ADDS     r1,r1,#8
000ab6  a801              ADD      r0,sp,#4
000ab8  f7fffffe          BL       __aeabi_uwrite4
;;;1585   					pep0state->nState = M_EP0_TX;	
000abc  4621              MOV      r1,r4
000abe  2002              MOVS     r0,#2
000ac0  f7fffffe          BL       __aeabi_uwrite4
;;;1586   					break;
000ac4  e060              B        |L27.2952|
                  |L27.2758|
;;;1587   				/* GET STATUS for EndPoint*/
;;;1588   					case M_CMD_STDEPIN:									
;;;1589   					
;;;1590   					if (pcmd->USBwIndex0 & 0x80)
000ac6  7928              LDRB     r0,[r5,#4]
000ac8  2180              MOVS     r1,#0x80
000aca  4008              ANDS     r0,r0,r1
000acc  2800              CMP      r0,#0
000ace  d026              BEQ      |L27.2846|
;;;1591   					{	
;;;1592   						if(Related_Endpoint){
000ad0  9803              LDR      r0,[sp,#0xc]
000ad2  2800              CMP      r0,#0
000ad4  d014              BEQ      |L27.2816|
;;;1593   							MWRITE_BYTE(M_REG_INDEX,Related_Endpoint);
000ad6  4939              LDR      r1,|L27.3004|
000ad8  9803              LDR      r0,[sp,#0xc]
000ada  7388              STRB     r0,[r1,#0xe]
;;;1594   							INCSRDATA = MREAD_BYTE(M_REG_INCSR1);
000adc  4608              MOV      r0,r1
000ade  7c40              LDRB     r0,[r0,#0x11]
000ae0  4938              LDR      r1,|L27.3012|
000ae2  7008              STRB     r0,[r1,#0]
;;;1595   							if(INCSRDATA & (0x1<<4))
000ae4  4608              MOV      r0,r1
000ae6  7800              LDRB     r0,[r0,#0]  ; INCSRDATA
000ae8  2110              MOVS     r1,#0x10
000aea  4008              ANDS     r0,r0,r1
000aec  2800              CMP      r0,#0
000aee  d003              BEQ      |L27.2808|
;;;1596   								txdat[0] = 1;	
000af0  2001              MOVS     r0,#1
000af2  4669              MOV      r1,sp
000af4  7108              STRB     r0,[r1,#4]
000af6  e030              B        |L27.2906|
                  |L27.2808|
;;;1597   							else txdat[0] = 0;	
000af8  2000              MOVS     r0,#0
000afa  4669              MOV      r1,sp
000afc  7108              STRB     r0,[r1,#4]
000afe  e02c              B        |L27.2906|
                  |L27.2816|
;;;1598   						}
;;;1599   						else
;;;1600   							if(*((uint8_t*)M_REG_CSR0) & (0x1<<2))
000b00  482e              LDR      r0,|L27.3004|
000b02  7c40              LDRB     r0,[r0,#0x11]
000b04  2104              MOVS     r1,#4
000b06  4008              ANDS     r0,r0,r1
000b08  2800              CMP      r0,#0
000b0a  d003              BEQ      |L27.2836|
;;;1601   							txdat[0] = 1;	
000b0c  2001              MOVS     r0,#1
000b0e  4669              MOV      r1,sp
000b10  7108              STRB     r0,[r1,#4]
000b12  e022              B        |L27.2906|
                  |L27.2836|
;;;1602   							else txdat[0] = 0;								
000b14  2000              MOVS     r0,#0
000b16  4669              MOV      r1,sp
000b18  7108              STRB     r0,[r1,#4]
000b1a  e01e              B        |L27.2906|
                  |L27.2844|
000b1c  e031              B        |L27.2946|
                  |L27.2846|
;;;1603   					}
;;;1604   
;;;1605   					else
;;;1606   					{
;;;1607   						if(Related_Endpoint){
000b1e  9803              LDR      r0,[sp,#0xc]
000b20  2800              CMP      r0,#0
000b22  d00d              BEQ      |L27.2880|
;;;1608   							if(*((uint8_t*)M_REG_OUTCSR1) & (0x1<<5))
000b24  4825              LDR      r0,|L27.3004|
000b26  7d00              LDRB     r0,[r0,#0x14]
000b28  2120              MOVS     r1,#0x20
000b2a  4008              ANDS     r0,r0,r1
000b2c  2800              CMP      r0,#0
000b2e  d003              BEQ      |L27.2872|
;;;1609   								txdat[0] = 1;	
000b30  2001              MOVS     r0,#1
000b32  4669              MOV      r1,sp
000b34  7108              STRB     r0,[r1,#4]
000b36  e010              B        |L27.2906|
                  |L27.2872|
;;;1610   							else txdat[0] = 0;	
000b38  2000              MOVS     r0,#0
000b3a  4669              MOV      r1,sp
000b3c  7108              STRB     r0,[r1,#4]
000b3e  e00c              B        |L27.2906|
                  |L27.2880|
;;;1611   						}
;;;1612   						else
;;;1613   							if(*((uint8_t*)M_REG_CSR0) & (0x1<<2))
000b40  481e              LDR      r0,|L27.3004|
000b42  7c40              LDRB     r0,[r0,#0x11]
000b44  2104              MOVS     r1,#4
000b46  4008              ANDS     r0,r0,r1
000b48  2800              CMP      r0,#0
000b4a  d003              BEQ      |L27.2900|
;;;1614   							txdat[0] = 1;	
000b4c  2001              MOVS     r0,#1
000b4e  4669              MOV      r1,sp
000b50  7108              STRB     r0,[r1,#4]
000b52  e002              B        |L27.2906|
                  |L27.2900|
;;;1615   							else txdat[0] = 0;								
000b54  2000              MOVS     r0,#0
000b56  4669              MOV      r1,sp
000b58  7108              STRB     r0,[r1,#4]
                  |L27.2906|
;;;1616   					}		
;;;1617   					txdat[1]=0;
000b5a  2000              MOVS     r0,#0
000b5c  4669              MOV      r1,sp
000b5e  7148              STRB     r0,[r1,#5]
;;;1618   					pep0state->nBytesLeft = 2;
000b60  1d21              ADDS     r1,r4,#4
000b62  2002              MOVS     r0,#2
000b64  f7fffffe          BL       __aeabi_uwrite4
;;;1619   					pep0state->pData = txdat;
000b68  4621              MOV      r1,r4
000b6a  3108              ADDS     r1,r1,#8
000b6c  a801              ADD      r0,sp,#4
000b6e  f7fffffe          BL       __aeabi_uwrite4
;;;1620   					pep0state->nState = M_EP0_TX;	
000b72  4621              MOV      r1,r4
000b74  2002              MOVS     r0,#2
000b76  f7fffffe          BL       __aeabi_uwrite4
;;;1621   					MWRITE_BYTE(M_REG_INDEX,0);	
000b7a  2000              MOVS     r0,#0
000b7c  490f              LDR      r1,|L27.3004|
000b7e  7388              STRB     r0,[r1,#0xe]
;;;1622   					break;
000b80  e002              B        |L27.2952|
                  |L27.2946|
;;;1623   					
;;;1624   					default:
;;;1625   					bError = TRUE;
000b82  2001              MOVS     r0,#1
000b84  9008              STR      r0,[sp,#0x20]
;;;1626   					break;
000b86  bf00              NOP      
                  |L27.2952|
000b88  bf00              NOP                            ;1579
;;;1627   				
;;;1628   			}
;;;1629   		break;	
000b8a  e002              B        |L27.2962|
                  |L27.2956|
;;;1630   
;;;1631   			
;;;1632   		/***不可识别的请求***/
;;;1633   		default:
;;;1634   			/* Stall the command if an unrecognized request is received */
;;;1635   			bError = TRUE;
000b8c  2001              MOVS     r0,#1
000b8e  9008              STR      r0,[sp,#0x20]
;;;1636   		break;
000b90  bf00              NOP      
                  |L27.2962|
000b92  bf00              NOP                            ;1064
;;;1637    }
;;;1638   
;;;1639   	/* Stall command if an error occurred */
;;;1640   	if (bError)
000b94  9808              LDR      r0,[sp,#0x20]
000b96  2800              CMP      r0,#0
000b98  d002              BEQ      |L27.2976|
;;;1641   	{
;;;1642   		/***清零 OUTPKTRDY 位,终止当前传输***/
;;;1643   		by = M_CSR0_SVDOUTPKTRDY | M_CSR0_SENDSTALL;
000b9a  2060              MOVS     r0,#0x60
000b9c  9006              STR      r0,[sp,#0x18]
000b9e  e007              B        |L27.2992|
                  |L27.2976|
;;;1644   	}
;;;1645   	else if(bNoData)
000ba0  9807              LDR      r0,[sp,#0x1c]
000ba2  2800              CMP      r0,#0
000ba4  d002              BEQ      |L27.2988|
;;;1646   	{
;;;1647   //		FIFOWrite(0, 0, pep0state->pData);
;;;1648   //		by = M_CSR0_INPKTRDY | M_CSR0_DATAEND;
;;;1649   //		MWRITE_BYTE(M_REG_CSR0, by);
;;;1650   		/***清零 OUTPKTRDY 位,在发送时表示，将要发送的时最后一包数据；接收时将要接收的是最后一包数据；***/
;;;1651   		by = M_CSR0_SVDOUTPKTRDY | M_CSR0_DATAEND;
000ba6  2048              MOVS     r0,#0x48
000ba8  9006              STR      r0,[sp,#0x18]
000baa  e001              B        |L27.2992|
                  |L27.2988|
;;;1652   //					pep0state->nBytesLeft = 0;
;;;1653   //					pep0state->nState = M_EP0_TX;			
;;;1654   	}
;;;1655   	else
;;;1656   	{
;;;1657   		/***清零 OUTPKTRDY 位***/
;;;1658   		by = M_CSR0_SVDOUTPKTRDY;
000bac  2040              MOVS     r0,#0x40
000bae  9006              STR      r0,[sp,#0x18]
                  |L27.2992|
;;;1659   	}
;;;1660   	
;;;1661   	MWRITE_BYTE(M_REG_CSR0, by);
000bb0  4902              LDR      r1,|L27.3004|
000bb2  9806              LDR      r0,[sp,#0x18]
000bb4  7448              STRB     r0,[r1,#0x11]
;;;1662   
;;;1663   	return;
;;;1664   	
;;;1665   }
000bb6  b009              ADD      sp,sp,#0x24
000bb8  bdf0              POP      {r4-r7,pc}
;;;1666   
                          ENDP

000bba  0000              DCW      0x0000
                  |L27.3004|
                          DCD      0x40005c00
                  |L27.3008|
                          DCD      pInformation
                  |L27.3012|
                          DCD      INCSRDATA

                          AREA ||i.USB_Suspend||, CODE, READONLY, ALIGN=2

                  USB_Suspend PROC
;;;264    */
;;;265    void USB_Suspend(void)
000000  4809              LDR      r0,|L28.40|
;;;266    {
;;;267    	if(usb_state == USB_SUSPEND_FLAG)
000002  7800              LDRB     r0,[r0,#0]  ; usb_state
000004  2801              CMP      r0,#1
000006  d106              BNE      |L28.22|
;;;268    	{
;;;269    		USB->POWER |= 0x01;//允许挂起模块
000008  4808              LDR      r0,|L28.44|
00000a  7840              LDRB     r0,[r0,#1]
00000c  2101              MOVS     r1,#1
00000e  4308              ORRS     r0,r0,r1
000010  4906              LDR      r1,|L28.44|
000012  7048              STRB     r0,[r1,#1]
000014  e006              B        |L28.36|
                  |L28.22|
;;;270    		
;;;271    		/*关闭一些时钟省电*/
;;;272    		
;;;273    		/*结束*/
;;;274    		
;;;275    //		while(USB->POWER & 0x02)								//suspend flag
;;;276    //		{	
;;;277    //			GPIOB->ODR ^= GPIO_Pin_2;
;;;278    ////			SysTick_Delay_Ms(500);
;;;279    //			if(GPIO_ReadInputDataBit(GPIOC,GPIO_Pin_11) == RESET)//按键唤醒
;;;280    //			{
;;;281    //				/*remote wakeup*/
;;;282    //				USB_Remote_Wakeup();
;;;283    //				
;;;284    //				f_send_kb = 1;
;;;285    //				USB->POWER &= ~0x01;							//不允许挂起模块	
;;;286    //				usb_state = USB_NORMAL;
;;;287    //			}
;;;288    //		}
;;;289    		
;;;290    		/*重新配置时钟*/	
;;;291    	}
;;;292    	else if(usb_state == USB_RESUME_FLAG)						//自动退出suspend
000016  4804              LDR      r0,|L28.40|
000018  7800              LDRB     r0,[r0,#0]  ; usb_state
00001a  2802              CMP      r0,#2
00001c  d102              BNE      |L28.36|
;;;293    	{
;;;294    		usb_state = USB_NORMAL;
00001e  2000              MOVS     r0,#0
000020  4901              LDR      r1,|L28.40|
000022  7008              STRB     r0,[r1,#0]
                  |L28.36|
;;;295    		/*重新配置时钟*/
;;;296    	}
;;;297    }
000024  4770              BX       lr
;;;298    /******************************************************************************
                          ENDP

000026  0000              DCW      0x0000
                  |L28.40|
                          DCD      usb_state
                  |L28.44|
                          DCD      0x40005c00

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  c_hid_data
                          %        88
                  gpCurIf
                          %        28
                  Device_Info
                          %        15
                  ep1_send_buf
                          %        64
                  ep0state
                          %        17

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  5553425f          DCB      0x55,0x53,0x42,0x5f
000004  49525148          DCB      0x49,0x52,0x51,0x48
000008  616e646c          DCB      0x61,0x6e,0x64,0x6c
00000c  657200            DCB      0x65,0x72,0x00

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  5553425f          DCB      "USB_IRQHandler ###usb_intrin =0x%02x usb_intrusb =0x%02"
000004  49525148
000008  616e646c
00000c  65722023
000010  23237573
000014  625f696e
000018  7472696e
00001c  203d3078
000020  25303278
000024  20757362
000028  5f696e74
00002c  72757362
000030  203d3078
000034  253032  
000037  78202323          DCB      "x ###usb_introut =0x%02x\n",0
00003b  23757362
00003f  5f696e74
000043  726f7574
000047  203d3078
00004b  25303278
00004f  0a00    
000051  00                DCB      0
000052  00                DCB      0
000053  00                DCB      0
000054  5553425f          DCB      "USB_IRQHandler ########################################"
000058  49525148
00005c  616e646c
000060  65722023
000064  23232323
000068  23232323
00006c  23232323
000070  23232323
000074  23232323
000078  23232323
00007c  23232323
000080  23232323
000084  23232323
000088  232323  
00008b  23232323          DCB      "##### usb_introut =0x%02x \n",0
00008f  23207573
000093  625f696e
000097  74726f75
00009b  74203d30
00009f  78253032
0000a3  78200a00
0000a7  00                DCB      0
0000a8  5553425f          DCB      "USB_IT_OUT_EP2_FLAG rr ### function=%s line=%d recv_dat"
0000ac  49545f4f
0000b0  55545f45
0000b4  50325f46
0000b8  4c414720
0000bc  72722023
0000c0  23232066
0000c4  756e6374
0000c8  696f6e3d
0000cc  2573206c
0000d0  696e653d
0000d4  25642072
0000d8  6563765f
0000dc  646174  
0000df  615f6c65          DCB      "a_len=%d\n",0
0000e3  6e3d2564
0000e7  0a00    
0000e9  00                DCB      0
0000ea  00                DCB      0
0000eb  00                DCB      0
0000ec  0a205553          DCB      "\n USB_IT_OUT_EP2_FLAG 111 ### function=%s line=%d recv"
0000f0  425f4954
0000f4  5f4f5554
0000f8  5f455032
0000fc  5f464c41
000100  47203131
000104  31202323
000108  23206675
00010c  6e637469
000110  6f6e3d25
000114  73206c69
000118  6e653d25
00011c  64207265
000120  6376    
000122  5f646174          DCB      "_data_len=%d\n",0
000126  615f6c65
00012a  6e3d2564
00012e  0a00    
000130  0a205553          DCB      "\n USB_IT_OUT_EP2_FLAG 222 ### function=%s line=%d recv"
000134  425f4954
000138  5f4f5554
00013c  5f455032
000140  5f464c41
000144  47203232
000148  32202323
00014c  23206675
000150  6e637469
000154  6f6e3d25
000158  73206c69
00015c  6e653d25
000160  64207265
000164  6376    
000166  5f646174          DCB      "_data_len=%d\n",0
00016a  615f6c65
00016e  6e3d2564
000172  0a00    

                          AREA ||.data||, DATA, ALIGN=2

                  INCSRDATA
000000  00                DCB      0x00
                  usb_state
000001  000000            DCB      0x00,0x00,0x00
                  gnDevState
                          DCD      0x00000000
                  gpCurCfg
                          DCD      0x00000000
                  gbyCurIfVal
                          DCD      0x00000000
000010  00000000          DCB      0x00,0x00,0x00,0x00
                  pInformation
                          DCD      Device_Info
                  flag1
                          DCD      0x00000000
                  ||cmd||
                          %        8

                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=1

                  __ARM_common_switch8 PROC
000000  b430              PUSH     {r4,r5}
000002  4674              MOV      r4,lr
000004  1e64              SUBS     r4,r4,#1
000006  7825              LDRB     r5,[r4,#0]
000008  1c64              ADDS     r4,r4,#1
00000a  42ab              CMP      r3,r5
00000c  d304              BCC      |L176.24|
                  |L176.14|
00000e  5d63              LDRB     r3,[r4,r5]
000010  005b              LSLS     r3,r3,#1
000012  18e3              ADDS     r3,r4,r3
000014  bc30              POP      {r4,r5}
000016  4718              BX       r3
                  |L176.24|
000018  461d              MOV      r5,r3
00001a  e7f8              B        |L176.14|
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\usb\\src\\usb_core.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_usb_core_c_cc00d2b3____REV16|
#line 129 "..\\FTLib\\CMSIS\\inc\\core_cmInstr.h"
|__asm___10_usb_core_c_cc00d2b3____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_usb_core_c_cc00d2b3____REVSH|
#line 144
|__asm___10_usb_core_c_cc00d2b3____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
