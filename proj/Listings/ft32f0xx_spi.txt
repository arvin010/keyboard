; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\ft32f0xx_spi.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\ft32f0xx_spi.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\FTLib\CMSIS\inc -I..\FTLib\Inc -I..\FTLib\Lib -I..\usb\inc -I..\user -I..\RTT -I..\iap2 -IC:\Users\dell1\AppData\Local\Arm\Packs\FMD\FT32F0xx_DFP\1.0.6\Drivers\CMSIS\FT32F0xx\Include -D__UVISION_VERSION=534 -DFT32F072x8 -DFT32F072x8 --omf_browse=.\objects\ft32f0xx_spi.crf ..\FTLib\Src\ft32f0xx_spi.c]
                          THUMB

                          AREA ||i.SPI_BiDirectionalLineConfig||, CODE, READONLY, ALIGN=2

                  SPI_BiDirectionalLineConfig PROC
;;;282      */
;;;283    void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction)
000000  2201              MOVS     r2,#1
;;;284    {
;;;285      /* Check the parameters */
;;;286      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;287      assert_param(IS_SPI_DIRECTION(SPI_Direction));
;;;288      if (SPI_Direction == SPI_Direction_Tx)
000002  0392              LSLS     r2,r2,#14
000004  4291              CMP      r1,r2
000006  d104              BNE      |L1.18|
;;;289      {
;;;290        /* Set the Tx only mode */
;;;291        SPIx->CR1 |= SPI_Direction_Tx;
000008  8802              LDRH     r2,[r0,#0]
00000a  460b              MOV      r3,r1
00000c  431a              ORRS     r2,r2,r3
00000e  8002              STRH     r2,[r0,#0]
000010  e003              B        |L1.26|
                  |L1.18|
;;;292      }
;;;293      else
;;;294      {
;;;295        /* Set the Rx only mode */
;;;296        SPIx->CR1 &= SPI_Direction_Rx;
000012  8802              LDRH     r2,[r0,#0]
000014  4b01              LDR      r3,|L1.28|
000016  401a              ANDS     r2,r2,r3
000018  8002              STRH     r2,[r0,#0]
                  |L1.26|
;;;297      }
;;;298    }
00001a  4770              BX       lr
;;;299    
                          ENDP

                  |L1.28|
                          DCD      0x0000bfff

                          AREA ||i.SPI_CRCLengthConfig||, CODE, READONLY, ALIGN=2

                  SPI_CRCLengthConfig PROC
;;;460      */
;;;461    void SPI_CRCLengthConfig(SPI_TypeDef* SPIx, uint16_t SPI_CRCLength)
000000  8802              LDRH     r2,[r0,#0]
;;;462    {
;;;463      /* Check the parameters */
;;;464      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;465      assert_param(IS_SPI_CRC_LENGTH(SPI_CRCLength));
;;;466    
;;;467      /* Clear CRCL bit */
;;;468      SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_CRCL);
000002  4b03              LDR      r3,|L2.16|
000004  401a              ANDS     r2,r2,r3
000006  8002              STRH     r2,[r0,#0]
;;;469    
;;;470      /* Set new CRCL bit value */
;;;471      SPIx->CR1 |= SPI_CRCLength;
000008  8802              LDRH     r2,[r0,#0]
00000a  430a              ORRS     r2,r2,r1
00000c  8002              STRH     r2,[r0,#0]
;;;472    }
00000e  4770              BX       lr
;;;473    
                          ENDP

                  |L2.16|
                          DCD      0x0000f7ff

                          AREA ||i.SPI_CalculateCRC||, CODE, READONLY, ALIGN=2

                  SPI_CalculateCRC PROC
;;;482      */
;;;483    void SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;484    {
;;;485      /* Check the parameters */
;;;486      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;487      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;488    
;;;489      if (NewState != DISABLE)
000002  d005              BEQ      |L3.16|
;;;490      {
;;;491        /* Enable the selected SPI CRC calculation */
;;;492        SPIx->CR1 |= SPI_CR1_CRCEN;
000004  8802              LDRH     r2,[r0,#0]
000006  2301              MOVS     r3,#1
000008  035b              LSLS     r3,r3,#13
00000a  431a              ORRS     r2,r2,r3
00000c  8002              STRH     r2,[r0,#0]
00000e  e003              B        |L3.24|
                  |L3.16|
;;;493      }
;;;494      else
;;;495      {
;;;496        /* Disable the selected SPI CRC calculation */
;;;497        SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_CRCEN);
000010  8802              LDRH     r2,[r0,#0]
000012  4b02              LDR      r3,|L3.28|
000014  401a              ANDS     r2,r2,r3
000016  8002              STRH     r2,[r0,#0]
                  |L3.24|
;;;498      }
;;;499    }
000018  4770              BX       lr
;;;500    
                          ENDP

00001a  0000              DCW      0x0000
                  |L3.28|
                          DCD      0x0000dfff

                          AREA ||i.SPI_Cmd||, CODE, READONLY, ALIGN=2

                  SPI_Cmd PROC
;;;164      */
;;;165    void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;166    {
;;;167      /* Check the parameters */
;;;168      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;169      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;170    
;;;171      if (NewState != DISABLE)
000002  d004              BEQ      |L4.14|
;;;172      {
;;;173        /* Enable the selected SPI peripheral */
;;;174        SPIx->CR1 |= SPI_CR1_SPE;
000004  8802              LDRH     r2,[r0,#0]
000006  2340              MOVS     r3,#0x40
000008  431a              ORRS     r2,r2,r3
00000a  8002              STRH     r2,[r0,#0]
00000c  e003              B        |L4.22|
                  |L4.14|
;;;175      }
;;;176      else
;;;177      {
;;;178        /* Disable the selected SPI peripheral */
;;;179        SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_SPE);
00000e  8802              LDRH     r2,[r0,#0]
000010  4b01              LDR      r3,|L4.24|
000012  401a              ANDS     r2,r2,r3
000014  8002              STRH     r2,[r0,#0]
                  |L4.22|
;;;180      }
;;;181    }
000016  4770              BX       lr
;;;182    
                          ENDP

                  |L4.24|
                          DCD      0x0000ffbf

                          AREA ||i.SPI_DataSizeConfig||, CODE, READONLY, ALIGN=2

                  SPI_DataSizeConfig PROC
;;;233      */
;;;234    void SPI_DataSizeConfig(SPI_TypeDef* SPIx, uint16_t SPI_DataSize)
000000  460a              MOV      r2,r1
;;;235    {
;;;236      uint16_t tmpreg = 0;
000002  2100              MOVS     r1,#0
;;;237      
;;;238      /* Check the parameters */
;;;239      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;240      assert_param(IS_SPI_DATA_SIZE(SPI_DataSize));
;;;241      /* Read the CR2 register */
;;;242      tmpreg = SPIx->CR2;
000004  8881              LDRH     r1,[r0,#4]
;;;243      /* Clear DS[3:0] bits */
;;;244      tmpreg &= (uint16_t)~SPI_CR2_DS;
000006  4b03              LDR      r3,|L5.20|
000008  4019              ANDS     r1,r1,r3
;;;245      /* Set new DS[3:0] bits value */
;;;246      tmpreg |= SPI_DataSize;
00000a  460b              MOV      r3,r1
00000c  4313              ORRS     r3,r3,r2
00000e  4619              MOV      r1,r3
;;;247      SPIx->CR2 = tmpreg;
000010  8081              STRH     r1,[r0,#4]
;;;248    }
000012  4770              BX       lr
;;;249    
                          ENDP

                  |L5.20|
                          DCD      0x0000f0ff

                          AREA ||i.SPI_GetCRC||, CODE, READONLY, ALIGN=1

                  SPI_GetCRC PROC
;;;523      */
;;;524    uint16_t SPI_GetCRC(SPI_TypeDef* SPIx, uint8_t SPI_CRC)
000000  4602              MOV      r2,r0
;;;525    {
;;;526      uint16_t crcreg = 0;
000002  2000              MOVS     r0,#0
;;;527      /* Check the parameters */
;;;528      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;529      assert_param(IS_SPI_CRC(SPI_CRC));
;;;530    
;;;531      if (SPI_CRC != SPI_CRC_Rx)
000004  2901              CMP      r1,#1
000006  d001              BEQ      |L6.12|
;;;532      {
;;;533        /* Get the Tx CRC register */
;;;534        crcreg = SPIx->TXCRCR;
000008  8b10              LDRH     r0,[r2,#0x18]
00000a  e000              B        |L6.14|
                  |L6.12|
;;;535      }
;;;536      else
;;;537      {
;;;538        /* Get the Rx CRC register */
;;;539        crcreg = SPIx->RXCRCR;
00000c  8a90              LDRH     r0,[r2,#0x14]
                  |L6.14|
;;;540      }
;;;541      /* Return the selected CRC register */
;;;542      return crcreg;
;;;543    }
00000e  4770              BX       lr
;;;544    
                          ENDP


                          AREA ||i.SPI_GetCRCPolynomial||, CODE, READONLY, ALIGN=1

                  SPI_GetCRCPolynomial PROC
;;;549      */
;;;550    uint16_t SPI_GetCRCPolynomial(SPI_TypeDef* SPIx)
000000  4601              MOV      r1,r0
;;;551    {
;;;552      /* Check the parameters */
;;;553      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;554    
;;;555      /* Return the CRC polynomial register */
;;;556      return SPIx->CRCPR;
000002  8a08              LDRH     r0,[r1,#0x10]
;;;557    }
000004  4770              BX       lr
;;;558    
                          ENDP


                          AREA ||i.SPI_GetReceptionFIFOStatus||, CODE, READONLY, ALIGN=1

                  SPI_GetReceptionFIFOStatus PROC
;;;690      */
;;;691    uint16_t SPI_GetReceptionFIFOStatus(SPI_TypeDef* SPIx)
000000  4601              MOV      r1,r0
;;;692    {
;;;693      /* Get the SPIx Reception FIFO level bits */
;;;694      return (uint16_t)((SPIx->SR & SPI_SR_FRLVL));
000002  8908              LDRH     r0,[r1,#8]
000004  2203              MOVS     r2,#3
000006  0252              LSLS     r2,r2,#9
000008  4010              ANDS     r0,r0,r2
;;;695    }
00000a  4770              BX       lr
;;;696    
                          ENDP


                          AREA ||i.SPI_GetTransmissionFIFOStatus||, CODE, READONLY, ALIGN=1

                  SPI_GetTransmissionFIFOStatus PROC
;;;675      */
;;;676    uint16_t SPI_GetTransmissionFIFOStatus(SPI_TypeDef* SPIx)
000000  4601              MOV      r1,r0
;;;677    {
;;;678      /* Get the SPIx Transmission FIFO level bits */
;;;679      return (uint16_t)((SPIx->SR & SPI_SR_FTLVL));
000002  8908              LDRH     r0,[r1,#8]
000004  2203              MOVS     r2,#3
000006  02d2              LSLS     r2,r2,#11
000008  4010              ANDS     r0,r0,r2
;;;680    }
00000a  4770              BX       lr
;;;681    
                          ENDP


                          AREA ||i.SPI_I2S_ClearFlag||, CODE, READONLY, ALIGN=1

                  SPI_I2S_ClearFlag PROC
;;;748      */
;;;749    void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
000000  43ca              MVNS     r2,r1
;;;750    {
;;;751      /* Check the parameters */
;;;752      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;753      assert_param(IS_SPI_CLEAR_FLAG(SPI_I2S_FLAG));
;;;754    
;;;755      /* Clear the selected SPI CRC Error (CRCERR) flag */
;;;756      SPIx->SR = (uint16_t)~SPI_I2S_FLAG;
000002  8102              STRH     r2,[r0,#8]
;;;757    }
000004  4770              BX       lr
;;;758    
                          ENDP


                          AREA ||i.SPI_I2S_DMACmd||, CODE, READONLY, ALIGN=1

                  SPI_I2S_DMACmd PROC
;;;573      */
;;;574    void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;575    {
;;;576      /* Check the parameters */
;;;577      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;578      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;579      assert_param(IS_SPI_I2S_DMA_REQ(SPI_I2S_DMAReq));
;;;580    
;;;581      if (NewState != DISABLE)
000002  d003              BEQ      |L11.12|
;;;582      {
;;;583        /* Enable the selected SPI DMA requests */
;;;584        SPIx->CR2 |= SPI_I2S_DMAReq;
000004  8883              LDRH     r3,[r0,#4]
000006  430b              ORRS     r3,r3,r1
000008  8083              STRH     r3,[r0,#4]
00000a  e002              B        |L11.18|
                  |L11.12|
;;;585      }
;;;586      else
;;;587      {
;;;588        /* Disable the selected SPI DMA requests */
;;;589        SPIx->CR2 &= (uint16_t)~SPI_I2S_DMAReq;
00000c  8883              LDRH     r3,[r0,#4]
00000e  438b              BICS     r3,r3,r1
000010  8083              STRH     r3,[r0,#4]
                  |L11.18|
;;;590      }
;;;591    }
000012  4770              BX       lr
;;;592    
                          ENDP


                          AREA ||i.SPI_I2S_DeInit||, CODE, READONLY, ALIGN=2

                  SPI_I2S_DeInit PROC
;;;33       */
;;;34     void SPI_I2S_DeInit(SPI_TypeDef* SPIx)
000000  b510              PUSH     {r4,lr}
;;;35     {
000002  4604              MOV      r4,r0
;;;36       /* Check the parameters */
;;;37       assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;38     
;;;39       if (SPIx == SPI1)
000004  480b              LDR      r0,|L12.52|
000006  4284              CMP      r4,r0
000008  d108              BNE      |L12.28|
;;;40       {
;;;41         /* Enable SPI1 reset state */
;;;42         RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  1480              ASRS     r0,r0,#18
00000e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;43         /* Release SPI1 from reset state */
;;;44         RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
000012  2100              MOVS     r1,#0
000014  14a0              ASRS     r0,r4,#18
000016  f7fffffe          BL       RCC_APB2PeriphResetCmd
00001a  e00a              B        |L12.50|
                  |L12.28|
;;;45       }
;;;46       else
;;;47       {
;;;48         if (SPIx == SPI2)
00001c  4806              LDR      r0,|L12.56|
00001e  4284              CMP      r4,r0
000020  d107              BNE      |L12.50|
;;;49         {
;;;50           /* Enable SPI2 reset state */
;;;51           RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
000022  2101              MOVS     r1,#1
000024  1400              ASRS     r0,r0,#16
000026  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;52           /* Release SPI2 from reset state */
;;;53           RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
00002a  2100              MOVS     r1,#0
00002c  1420              ASRS     r0,r4,#16
00002e  f7fffffe          BL       RCC_APB1PeriphResetCmd
                  |L12.50|
;;;54         }
;;;55       }
;;;56     }
000032  bd10              POP      {r4,pc}
;;;57     
                          ENDP

                  |L12.52|
                          DCD      0x40013000
                  |L12.56|
                          DCD      0x40003800

                          AREA ||i.SPI_I2S_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  SPI_I2S_GetFlagStatus PROC
;;;713      */
;;;714    FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
000000  4602              MOV      r2,r0
;;;715    {
;;;716      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;717      /* Check the parameters */
;;;718      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;719      assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));
;;;720    
;;;721      /* Check the status of the specified SPI flag */
;;;722      if ((SPIx->SR & SPI_I2S_FLAG) != (uint16_t)RESET)
000004  8913              LDRH     r3,[r2,#8]
000006  400b              ANDS     r3,r3,r1
000008  2b00              CMP      r3,#0
00000a  d001              BEQ      |L13.16|
;;;723      {
;;;724        /* SPI_I2S_FLAG is set */
;;;725        bitstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L13.18|
                  |L13.16|
;;;726      }
;;;727      else
;;;728      {
;;;729        /* SPI_I2S_FLAG is reset */
;;;730        bitstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L13.18|
;;;731      }
;;;732      /* Return the SPI_I2S_FLAG status */
;;;733      return  bitstatus;
;;;734    }
000012  4770              BX       lr
;;;735    
                          ENDP


                          AREA ||i.SPI_I2S_GetITStatus||, CODE, READONLY, ALIGN=1

                  SPI_I2S_GetITStatus PROC
;;;772      */
;;;773    ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
000000  b5f0              PUSH     {r4-r7,lr}
;;;774    {
000002  4602              MOV      r2,r0
;;;775      ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;776      uint16_t itpos = 0, itmask = 0, enablestatus = 0;
000006  2400              MOVS     r4,#0
000008  2300              MOVS     r3,#0
00000a  2500              MOVS     r5,#0
;;;777    
;;;778      /* Check the parameters */
;;;779      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;780      assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));
;;;781    
;;;782      /* Get the SPI_I2S_IT index */
;;;783      itpos = 0x01 << (SPI_I2S_IT & 0x0F);
00000c  070f              LSLS     r7,r1,#28
00000e  0f3f              LSRS     r7,r7,#28
000010  2601              MOVS     r6,#1
000012  40be              LSLS     r6,r6,r7
000014  b2b4              UXTH     r4,r6
;;;784    
;;;785      /* Get the SPI_I2S_IT IT mask */
;;;786      itmask = SPI_I2S_IT >> 4;
000016  110b              ASRS     r3,r1,#4
;;;787    
;;;788      /* Set the IT mask */
;;;789      itmask = 0x01 << itmask;
000018  2601              MOVS     r6,#1
00001a  409e              LSLS     r6,r6,r3
00001c  b2b3              UXTH     r3,r6
;;;790    
;;;791      /* Get the SPI_I2S_IT enable bit status */
;;;792      enablestatus = (SPIx->CR2 & itmask) ;
00001e  8896              LDRH     r6,[r2,#4]
000020  401e              ANDS     r6,r6,r3
000022  4635              MOV      r5,r6
;;;793    
;;;794      /* Check the status of the specified SPI interrupt */
;;;795      if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
000024  8916              LDRH     r6,[r2,#8]
000026  4026              ANDS     r6,r6,r4
000028  2e00              CMP      r6,#0
00002a  d003              BEQ      |L14.52|
00002c  2d00              CMP      r5,#0
00002e  d001              BEQ      |L14.52|
;;;796      {
;;;797        /* SPI_I2S_IT is set */
;;;798        bitstatus = SET;
000030  2001              MOVS     r0,#1
000032  e000              B        |L14.54|
                  |L14.52|
;;;799      }
;;;800      else
;;;801      {
;;;802        /* SPI_I2S_IT is reset */
;;;803        bitstatus = RESET;
000034  2000              MOVS     r0,#0
                  |L14.54|
;;;804      }
;;;805      /* Return the SPI_I2S_IT status */
;;;806      return bitstatus;
;;;807    }
000036  bdf0              POP      {r4-r7,pc}
;;;808    
                          ENDP


                          AREA ||i.SPI_I2S_ITConfig||, CODE, READONLY, ALIGN=1

                  SPI_I2S_ITConfig PROC
;;;639      */
;;;640    void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState)
000000  b530              PUSH     {r4,r5,lr}
;;;641    {
;;;642      uint16_t itpos = 0, itmask = 0 ;
000002  2400              MOVS     r4,#0
000004  2300              MOVS     r3,#0
;;;643    
;;;644      /* Check the parameters */
;;;645      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;646      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;647      assert_param(IS_SPI_I2S_CONFIG_IT(SPI_I2S_IT));
;;;648    
;;;649      /* Get the SPI IT index */
;;;650      itpos = SPI_I2S_IT >> 4;
000006  110c              ASRS     r4,r1,#4
;;;651    
;;;652      /* Set the IT mask */
;;;653      itmask = (uint16_t)1 << (uint16_t)itpos;
000008  2501              MOVS     r5,#1
00000a  40a5              LSLS     r5,r5,r4
00000c  b2ab              UXTH     r3,r5
;;;654    
;;;655      if (NewState != DISABLE)
00000e  2a00              CMP      r2,#0
000010  d003              BEQ      |L15.26|
;;;656      {
;;;657        /* Enable the selected SPI interrupt */
;;;658        SPIx->CR2 |= itmask;
000012  8885              LDRH     r5,[r0,#4]
000014  431d              ORRS     r5,r5,r3
000016  8085              STRH     r5,[r0,#4]
000018  e002              B        |L15.32|
                  |L15.26|
;;;659      }
;;;660      else
;;;661      {
;;;662        /* Disable the selected SPI interrupt */
;;;663        SPIx->CR2 &= (uint16_t)~itmask;
00001a  8885              LDRH     r5,[r0,#4]
00001c  439d              BICS     r5,r5,r3
00001e  8085              STRH     r5,[r0,#4]
                  |L15.32|
;;;664      }
;;;665    }
000020  bd30              POP      {r4,r5,pc}
;;;666    
                          ENDP


                          AREA ||i.SPI_I2S_ReceiveData16||, CODE, READONLY, ALIGN=1

                  SPI_I2S_ReceiveData16 PROC
;;;442      */
;;;443    uint16_t SPI_I2S_ReceiveData16(SPI_TypeDef* SPIx)
000000  4601              MOV      r1,r0
;;;444    {
;;;445      return SPIx->DR;
000002  8988              LDRH     r0,[r1,#0xc]
;;;446    }
000004  4770              BX       lr
;;;447    /**
                          ENDP


                          AREA ||i.SPI_I2S_SendData16||, CODE, READONLY, ALIGN=1

                  SPI_I2S_SendData16 PROC
;;;413      */
;;;414    void SPI_I2S_SendData16(SPI_TypeDef* SPIx, uint16_t Data)
000000  8181              STRH     r1,[r0,#0xc]
;;;415    {
;;;416      /* Check the parameters */
;;;417      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;418      
;;;419      SPIx->DR = (uint16_t)Data;
;;;420    }
000002  4770              BX       lr
;;;421    
                          ENDP


                          AREA ||i.SPI_Init||, CODE, READONLY, ALIGN=2

                  SPI_Init PROC
;;;93       */
;;;94     void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
000000  b510              PUSH     {r4,lr}
;;;95     {
000002  4602              MOV      r2,r0
;;;96       uint16_t tmpreg = 0;
000004  2000              MOVS     r0,#0
;;;97     
;;;98       /* check the parameters */
;;;99       assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;100    
;;;101      /* Check the SPI parameters */
;;;102      assert_param(IS_SPI_DIRECTION_MODE(SPI_InitStruct->SPI_Direction));
;;;103      assert_param(IS_SPI_MODE(SPI_InitStruct->SPI_Mode));
;;;104      assert_param(IS_SPI_DATA_SIZE(SPI_InitStruct->SPI_DataSize));
;;;105      assert_param(IS_SPI_CPOL(SPI_InitStruct->SPI_CPOL));
;;;106      assert_param(IS_SPI_CPHA(SPI_InitStruct->SPI_CPHA));
;;;107      assert_param(IS_SPI_NSS(SPI_InitStruct->SPI_NSS));
;;;108      assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_InitStruct->SPI_BaudRatePrescaler));
;;;109      assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
;;;110      assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));
;;;111    
;;;112      /*---------------------------- SPIx CR1 Configuration ------------------------*/
;;;113      /* Get the SPIx CR1 value */
;;;114      tmpreg = SPIx->CR1;
000006  8810              LDRH     r0,[r2,#0]
;;;115      /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, CPOL and CPHA bits */
;;;116      tmpreg &= CR1_CLEAR_MASK;
000008  23c1              MOVS     r3,#0xc1
00000a  019b              LSLS     r3,r3,#6
00000c  4018              ANDS     r0,r0,r3
;;;117      /* Configure SPIx: direction, NSS management, first transmitted bit, BaudRate prescaler
;;;118      master/slave mode, CPOL and CPHA */
;;;119      /* Set BIDImode, BIDIOE and RxONLY bits according to SPI_Direction value */
;;;120      /* Set SSM, SSI bit according to SPI_NSS values */
;;;121      /* Set LSBFirst bit according to SPI_FirstBit value */
;;;122      /* Set BR bits according to SPI_BaudRatePrescaler value */
;;;123      /* Set CPOL bit according to SPI_CPOL value */
;;;124      /* Set CPHA bit according to SPI_CPHA value */
;;;125      tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_FirstBit |
00000e  880b              LDRH     r3,[r1,#0]
000010  89cc              LDRH     r4,[r1,#0xe]
000012  4323              ORRS     r3,r3,r4
000014  88cc              LDRH     r4,[r1,#6]
000016  4323              ORRS     r3,r3,r4
000018  890c              LDRH     r4,[r1,#8]
00001a  4323              ORRS     r3,r3,r4
00001c  894c              LDRH     r4,[r1,#0xa]
00001e  4323              ORRS     r3,r3,r4
000020  898c              LDRH     r4,[r1,#0xc]
000022  4323              ORRS     r3,r3,r4
000024  4318              ORRS     r0,r0,r3
;;;126                          SPI_InitStruct->SPI_CPOL | SPI_InitStruct->SPI_CPHA |
;;;127                          SPI_InitStruct->SPI_NSS | SPI_InitStruct->SPI_BaudRatePrescaler);  
;;;128      /* Write to SPIx CR1 */
;;;129      SPIx->CR1 = tmpreg;
000026  8010              STRH     r0,[r2,#0]
;;;130      /*-------------------------Data Size Configuration -----------------------*/
;;;131      /* Get the SPIx CR2 value */
;;;132      tmpreg = SPIx->CR2;
000028  8890              LDRH     r0,[r2,#4]
;;;133      /* Clear DS[3:0] bits */
;;;134      tmpreg &=(uint16_t)~SPI_CR2_DS;
00002a  4b07              LDR      r3,|L18.72|
00002c  4018              ANDS     r0,r0,r3
;;;135      /* Configure SPIx: Data Size */
;;;136      tmpreg |= (uint16_t)(SPI_InitStruct->SPI_DataSize);
00002e  888b              LDRH     r3,[r1,#4]
000030  4318              ORRS     r0,r0,r3
;;;137      /* Write to SPIx CR2 */
;;;138      SPIx->CR2 = tmpreg;
000032  8090              STRH     r0,[r2,#4]
;;;139      
;;;140      /*---------------------------- SPIx CRCPOLY Configuration --------------------*/
;;;141      /* Write to SPIx CRCPOLY */
;;;142      SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
000034  8a0b              LDRH     r3,[r1,#0x10]
000036  8213              STRH     r3,[r2,#0x10]
;;;143      
;;;144      /*---------------------------- SPIx CR1 Configuration ------------------------*/
;;;145      /* Get the SPIx CR1 value */
;;;146      tmpreg = SPIx->CR1;
000038  8810              LDRH     r0,[r2,#0]
;;;147      /* Clear MSTR bit */
;;;148      tmpreg &= CR1_CLEAR_MASK2;
00003a  4b04              LDR      r3,|L18.76|
00003c  4018              ANDS     r0,r0,r3
;;;149      /* Configure SPIx: master/slave mode */  
;;;150      /* Set MSTR bit according to SPI_Mode */
;;;151      tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Mode);  
00003e  884b              LDRH     r3,[r1,#2]
000040  4318              ORRS     r0,r0,r3
;;;152      /* Write to SPIx CR1 */
;;;153      SPIx->CR1 = tmpreg;  
000042  8010              STRH     r0,[r2,#0]
;;;154      
;;;155    //  /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
;;;156    //  SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SMOD);
;;;157    }
000044  bd10              POP      {r4,pc}
;;;158    /**
                          ENDP

000046  0000              DCW      0x0000
                  |L18.72|
                          DCD      0x0000f0ff
                  |L18.76|
                          DCD      0x0000fffb

                          AREA ||i.SPI_LastDMATransferCmd||, CODE, READONLY, ALIGN=2

                  SPI_LastDMATransferCmd PROC
;;;610      */
;;;611    void SPI_LastDMATransferCmd(SPI_TypeDef* SPIx, uint16_t SPI_LastDMATransfer)
000000  8882              LDRH     r2,[r0,#4]
;;;612    {
;;;613      /* Check the parameters */
;;;614      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;615      assert_param(IS_SPI_LAST_DMA_TRANSFER(SPI_LastDMATransfer));
;;;616    
;;;617      /* Clear LDMA_TX and LDMA_RX bits */
;;;618      SPIx->CR2 &= CR2_LDMA_MASK;
000002  4b03              LDR      r3,|L19.16|
000004  401a              ANDS     r2,r2,r3
000006  8082              STRH     r2,[r0,#4]
;;;619    
;;;620      /* Set new LDMA_TX and LDMA_RX bits value */
;;;621      SPIx->CR2 |= SPI_LastDMATransfer; 
000008  8882              LDRH     r2,[r0,#4]
00000a  430a              ORRS     r2,r2,r1
00000c  8082              STRH     r2,[r0,#4]
;;;622    }
00000e  4770              BX       lr
;;;623    
                          ENDP

                  |L19.16|
                          DCD      0x00009fff

                          AREA ||i.SPI_NSSInternalSoftwareConfig||, CODE, READONLY, ALIGN=2

                  SPI_NSSInternalSoftwareConfig PROC
;;;310      */
;;;311    void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft)
000000  4a06              LDR      r2,|L20.28|
;;;312    {
;;;313      /* Check the parameters */
;;;314      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;315      assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));
;;;316    
;;;317      if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
000002  4291              CMP      r1,r2
000004  d005              BEQ      |L20.18|
;;;318      {
;;;319        /* Set NSS pin internally by software */
;;;320        SPIx->CR1 |= SPI_NSSInternalSoft_Set;
000006  8802              LDRH     r2,[r0,#0]
000008  23ff              MOVS     r3,#0xff
00000a  3301              ADDS     r3,#1
00000c  431a              ORRS     r2,r2,r3
00000e  8002              STRH     r2,[r0,#0]
000010  e003              B        |L20.26|
                  |L20.18|
;;;321      }
;;;322      else
;;;323      {
;;;324        /* Reset NSS pin internally by software */
;;;325        SPIx->CR1 &= SPI_NSSInternalSoft_Reset;
000012  8802              LDRH     r2,[r0,#0]
000014  4b01              LDR      r3,|L20.28|
000016  401a              ANDS     r2,r2,r3
000018  8002              STRH     r2,[r0,#0]
                  |L20.26|
;;;326      }
;;;327    }
00001a  4770              BX       lr
;;;328    
                          ENDP

                  |L20.28|
                          DCD      0x0000feff

                          AREA ||i.SPI_NSSPulseModeCmd||, CODE, READONLY, ALIGN=2

                  SPI_NSSPulseModeCmd PROC
;;;366      */
;;;367    void SPI_NSSPulseModeCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;368    {
;;;369      /* Check the parameters */
;;;370      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;371      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;372    
;;;373      if (NewState != DISABLE)
000002  d004              BEQ      |L21.14|
;;;374      {
;;;375        /* Enable the NSS pulse management mode */
;;;376        SPIx->CR2 |= SPI_CR2_NSSP;
000004  8882              LDRH     r2,[r0,#4]
000006  2308              MOVS     r3,#8
000008  431a              ORRS     r2,r2,r3
00000a  8082              STRH     r2,[r0,#4]
00000c  e003              B        |L21.22|
                  |L21.14|
;;;377      }
;;;378      else
;;;379      {
;;;380        /* Disable the NSS pulse management mode */
;;;381        SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_NSSP);    
00000e  8882              LDRH     r2,[r0,#4]
000010  4b01              LDR      r3,|L21.24|
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L21.22|
;;;382      }
;;;383    }
000016  4770              BX       lr
;;;384    
                          ENDP

                  |L21.24|
                          DCD      0x0000fff7

                          AREA ||i.SPI_ReceiveData8||, CODE, READONLY, ALIGN=1

                  SPI_ReceiveData8 PROC
;;;426      */
;;;427    uint8_t SPI_ReceiveData8(SPI_TypeDef* SPIx)
000000  4601              MOV      r1,r0
;;;428    {
;;;429      uint32_t spixbase = 0x00;
000002  2200              MOVS     r2,#0
;;;430      
;;;431      spixbase = (uint32_t)SPIx; 
000004  460a              MOV      r2,r1
;;;432      spixbase += 0x0C;
000006  320c              ADDS     r2,r2,#0xc
;;;433      
;;;434      return *(__IO uint8_t *) spixbase;
000008  7810              LDRB     r0,[r2,#0]
;;;435    }
00000a  4770              BX       lr
;;;436    
                          ENDP


                          AREA ||i.SPI_RxFIFOThresholdConfig||, CODE, READONLY, ALIGN=2

                  SPI_RxFIFOThresholdConfig PROC
;;;260      */
;;;261    void SPI_RxFIFOThresholdConfig(SPI_TypeDef* SPIx, uint16_t SPI_RxFIFOThreshold)
000000  8882              LDRH     r2,[r0,#4]
;;;262    {
;;;263      /* Check the parameters */
;;;264      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;265      assert_param(IS_SPI_RX_FIFO_THRESHOLD(SPI_RxFIFOThreshold));
;;;266    
;;;267      /* Clear FRXTH bit */
;;;268      SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_FRXTH);
000002  4b03              LDR      r3,|L23.16|
000004  401a              ANDS     r2,r2,r3
000006  8082              STRH     r2,[r0,#4]
;;;269    
;;;270      /* Set new FRXTH bit value */
;;;271      SPIx->CR2 |= SPI_RxFIFOThreshold;
000008  8882              LDRH     r2,[r0,#4]
00000a  430a              ORRS     r2,r2,r1
00000c  8082              STRH     r2,[r0,#4]
;;;272    }
00000e  4770              BX       lr
;;;273    
                          ENDP

                  |L23.16|
                          DCD      0x0000efff

                          AREA ||i.SPI_SSOutputCmd||, CODE, READONLY, ALIGN=2

                  SPI_SSOutputCmd PROC
;;;337      */
;;;338    void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;339    {
;;;340      /* Check the parameters */
;;;341      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;342      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;343      if (NewState != DISABLE)
000002  d004              BEQ      |L24.14|
;;;344      {
;;;345        /* Enable the selected SPI SS output */
;;;346        SPIx->CR2 |= SPI_CR2_SSOE;
000004  8882              LDRH     r2,[r0,#4]
000006  2304              MOVS     r3,#4
000008  431a              ORRS     r2,r2,r3
00000a  8082              STRH     r2,[r0,#4]
00000c  e003              B        |L24.22|
                  |L24.14|
;;;347      }
;;;348      else
;;;349      {
;;;350        /* Disable the selected SPI SS output */
;;;351        SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_SSOE);
00000e  8882              LDRH     r2,[r0,#4]
000010  4b01              LDR      r3,|L24.24|
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L24.22|
;;;352      }
;;;353    }
000016  4770              BX       lr
;;;354    
                          ENDP

                  |L24.24|
                          DCD      0x0000fffb

                          AREA ||i.SPI_SendData8||, CODE, READONLY, ALIGN=1

                  SPI_SendData8 PROC
;;;393      */
;;;394    void SPI_SendData8(SPI_TypeDef* SPIx, uint8_t Data)
000000  2200              MOVS     r2,#0
;;;395    {
;;;396      uint32_t spixbase = 0x00;
;;;397    
;;;398      /* Check the parameters */
;;;399      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;400    
;;;401      spixbase = (uint32_t)SPIx; 
000002  4602              MOV      r2,r0
;;;402      spixbase += 0x0C;
000004  320c              ADDS     r2,r2,#0xc
;;;403      
;;;404      *(__IO uint8_t *) spixbase = Data;
000006  7011              STRB     r1,[r2,#0]
;;;405    }
000008  4770              BX       lr
;;;406    
                          ENDP


                          AREA ||i.SPI_StructInit||, CODE, READONLY, ALIGN=1

                  SPI_StructInit PROC
;;;62       */
;;;63     void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)
000000  2100              MOVS     r1,#0
;;;64     {
;;;65     /*--------------- Reset SPI init structure parameters values -----------------*/
;;;66       /* Initialize the SPI_Direction member */
;;;67       SPI_InitStruct->SPI_Direction = SPI_Direction_2Lines_FullDuplex;
000002  8001              STRH     r1,[r0,#0]
;;;68       /* Initialize the SPI_Mode member */
;;;69       SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;
000004  8041              STRH     r1,[r0,#2]
;;;70       /* Initialize the SPI_DataSize member */
;;;71       SPI_InitStruct->SPI_DataSize = SPI_DataSize_8b;
000006  2107              MOVS     r1,#7
000008  0209              LSLS     r1,r1,#8
00000a  8081              STRH     r1,[r0,#4]
;;;72       /* Initialize the SPI_CPOL member */
;;;73       SPI_InitStruct->SPI_CPOL = SPI_CPOL_Low;
00000c  2100              MOVS     r1,#0
00000e  80c1              STRH     r1,[r0,#6]
;;;74       /* Initialize the SPI_CPHA member */
;;;75       SPI_InitStruct->SPI_CPHA = SPI_CPHA_1Edge;
000010  8101              STRH     r1,[r0,#8]
;;;76       /* Initialize the SPI_NSS member */
;;;77       SPI_InitStruct->SPI_NSS = SPI_NSS_Hard;
000012  8141              STRH     r1,[r0,#0xa]
;;;78       /* Initialize the SPI_BaudRatePrescaler member */
;;;79       SPI_InitStruct->SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
000014  8181              STRH     r1,[r0,#0xc]
;;;80       /* Initialize the SPI_FirstBit member */
;;;81       SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_MSB;
000016  81c1              STRH     r1,[r0,#0xe]
;;;82       /* Initialize the SPI_CRCPolynomial member */
;;;83       SPI_InitStruct->SPI_CRCPolynomial = 7;
000018  2107              MOVS     r1,#7
00001a  8201              STRH     r1,[r0,#0x10]
;;;84     }
00001c  4770              BX       lr
;;;85     
                          ENDP


                          AREA ||i.SPI_TIModeCmd||, CODE, READONLY, ALIGN=2

                  SPI_TIModeCmd PROC
;;;196      */
;;;197    void SPI_TIModeCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;198    {
;;;199      /* Check the parameters */
;;;200      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;201      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;202    
;;;203      if (NewState != DISABLE)
000002  d004              BEQ      |L27.14|
;;;204      {
;;;205        /* Enable the TI mode for the selected SPI peripheral */
;;;206        SPIx->CR2 |= SPI_CR2_FRF;
000004  8882              LDRH     r2,[r0,#4]
000006  2310              MOVS     r3,#0x10
000008  431a              ORRS     r2,r2,r3
00000a  8082              STRH     r2,[r0,#4]
00000c  e003              B        |L27.22|
                  |L27.14|
;;;207      }
;;;208      else
;;;209      {
;;;210        /* Disable the TI mode for the selected SPI peripheral */
;;;211        SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_FRF);
00000e  8882              LDRH     r2,[r0,#4]
000010  4b01              LDR      r3,|L27.24|
000012  401a              ANDS     r2,r2,r3
000014  8082              STRH     r2,[r0,#4]
                  |L27.22|
;;;212      }
;;;213    }
000016  4770              BX       lr
;;;214    /**
                          ENDP

                  |L27.24|
                          DCD      0x0000ffef

                          AREA ||i.SPI_TransmitCRC||, CODE, READONLY, ALIGN=1

                  SPI_TransmitCRC PROC
;;;505      */
;;;506    void SPI_TransmitCRC(SPI_TypeDef* SPIx)
000000  8801              LDRH     r1,[r0,#0]
;;;507    {
;;;508      /* Check the parameters */
;;;509      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;510    
;;;511      /* Enable the selected SPI CRC transmission */
;;;512      SPIx->CR1 |= SPI_CR1_CRCNEXT;
000002  2201              MOVS     r2,#1
000004  0312              LSLS     r2,r2,#12
000006  4311              ORRS     r1,r1,r2
000008  8001              STRH     r1,[r0,#0]
;;;513    }
00000a  4770              BX       lr
;;;514    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\FTLib\\Src\\ft32f0xx_spi.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_ft32f0xx_spi_c_2b928927____REV16|
#line 129 "..\\FTLib\\CMSIS\\inc\\core_cmInstr.h"
|__asm___14_ft32f0xx_spi_c_2b928927____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_ft32f0xx_spi_c_2b928927____REVSH|
#line 144
|__asm___14_ft32f0xx_spi_c_2b928927____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
