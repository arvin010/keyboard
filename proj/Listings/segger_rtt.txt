; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\segger_rtt.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\segger_rtt.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\FTLib\CMSIS\inc -I..\FTLib\Inc -I..\FTLib\Lib -I..\usb\inc -I..\user -I..\RTT -I..\iap2 -IC:\Users\dell1\AppData\Local\Arm\Packs\FMD\FT32F0xx_DFP\1.0.6\Drivers\CMSIS\FT32F0xx\Include -D__UVISION_VERSION=534 -DFT32F072x8 -DFT32F072x8 --omf_browse=.\objects\segger_rtt.crf ..\RTT\SEGGER_RTT.c]
                          THUMB

                          AREA ||i.SEGGER_RTT_AllocDownBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_AllocDownBuffer PROC
;;;1519   */
;;;1520   int SEGGER_RTT_AllocDownBuffer(const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
000000  b5ff              PUSH     {r0-r7,lr}
000002  b081              SUB      sp,sp,#4
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;1521     int BufferIndex;
;;;1522   
;;;1523     INIT();
00000a  bf00              NOP      
00000c  4825              LDR      r0,|L1.164|
00000e  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
000010  2800              CMP      r0,#0
000012  d101              BNE      |L1.24|
000014  f7fffffe          BL       _DoInit
                  |L1.24|
000018  bf00              NOP      
;;;1524     SEGGER_RTT_LOCK();
00001a  f3ef8110          MRS      r1,PRIMASK
00001e  4608              MOV      r0,r1
000020  2101              MOVS     r1,#1
000022  f3818810          MSR      PRIMASK,r1
000026  bf00              NOP      
000028  bf00              NOP      
;;;1525     BufferIndex = 0;
00002a  2400              MOVS     r4,#0
;;;1526     do {
00002c  bf00              NOP      
                  |L1.46|
;;;1527       if (_SEGGER_RTT.aDown[BufferIndex].pBuffer == NULL) {
00002e  2118              MOVS     r1,#0x18
000030  4361              MULS     r1,r4,r1
000032  4a1c              LDR      r2,|L1.164|
000034  3260              ADDS     r2,r2,#0x60
000036  1889              ADDS     r1,r1,r2
000038  6849              LDR      r1,[r1,#4]
00003a  2900              CMP      r1,#0
00003c  d100              BNE      |L1.64|
;;;1528         break;
00003e  e004              B        |L1.74|
                  |L1.64|
;;;1529       }
;;;1530       BufferIndex++;
000040  1c64              ADDS     r4,r4,#1
;;;1531     } while (BufferIndex < _SEGGER_RTT.MaxNumDownBuffers);
000042  4918              LDR      r1,|L1.164|
000044  6949              LDR      r1,[r1,#0x14]  ; _SEGGER_RTT
000046  42a1              CMP      r1,r4
000048  dcf1              BGT      |L1.46|
                  |L1.74|
00004a  bf00              NOP                            ;1528
;;;1532     if (BufferIndex < _SEGGER_RTT.MaxNumDownBuffers) {
00004c  4915              LDR      r1,|L1.164|
00004e  6949              LDR      r1,[r1,#0x14]  ; _SEGGER_RTT
000050  42a1              CMP      r1,r4
000052  dd1d              BLE      |L1.144|
;;;1533       _SEGGER_RTT.aDown[BufferIndex].sName        = sName;
000054  2118              MOVS     r1,#0x18
000056  4361              MULS     r1,r4,r1
000058  4a12              LDR      r2,|L1.164|
00005a  3260              ADDS     r2,r2,#0x60
00005c  5055              STR      r5,[r2,r1]
;;;1534       _SEGGER_RTT.aDown[BufferIndex].pBuffer      = (char*)pBuffer;
00005e  2118              MOVS     r1,#0x18
000060  4361              MULS     r1,r4,r1
000062  1889              ADDS     r1,r1,r2
000064  604e              STR      r6,[r1,#4]
;;;1535       _SEGGER_RTT.aDown[BufferIndex].SizeOfBuffer = BufferSize;
000066  2118              MOVS     r1,#0x18
000068  4361              MULS     r1,r4,r1
00006a  1889              ADDS     r1,r1,r2
00006c  608f              STR      r7,[r1,#8]
;;;1536       _SEGGER_RTT.aDown[BufferIndex].RdOff        = 0u;
00006e  2200              MOVS     r2,#0
000070  2118              MOVS     r1,#0x18
000072  4361              MULS     r1,r4,r1
000074  4b0b              LDR      r3,|L1.164|
000076  3360              ADDS     r3,r3,#0x60
000078  18c9              ADDS     r1,r1,r3
00007a  610a              STR      r2,[r1,#0x10]
;;;1537       _SEGGER_RTT.aDown[BufferIndex].WrOff        = 0u;
00007c  2118              MOVS     r1,#0x18
00007e  4361              MULS     r1,r4,r1
000080  18c9              ADDS     r1,r1,r3
000082  60ca              STR      r2,[r1,#0xc]
;;;1538       _SEGGER_RTT.aDown[BufferIndex].Flags        = Flags;
000084  2218              MOVS     r2,#0x18
000086  4362              MULS     r2,r4,r2
000088  18d2              ADDS     r2,r2,r3
00008a  9904              LDR      r1,[sp,#0x10]
00008c  6151              STR      r1,[r2,#0x14]
00008e  e001              B        |L1.148|
                  |L1.144|
;;;1539     } else {
;;;1540       BufferIndex = -1;
000090  2400              MOVS     r4,#0
000092  43e4              MVNS     r4,r4
                  |L1.148|
;;;1541     }
;;;1542     SEGGER_RTT_UNLOCK();
000094  b2c1              UXTB     r1,r0
000096  f3818810          MSR      PRIMASK,r1
00009a  bf00              NOP      
00009c  bf00              NOP      
;;;1543     return BufferIndex;
00009e  4620              MOV      r0,r4
;;;1544   }
0000a0  b005              ADD      sp,sp,#0x14
0000a2  bdf0              POP      {r4-r7,pc}
;;;1545   
                          ENDP

                  |L1.164|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_AllocUpBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_AllocUpBuffer PROC
;;;1564   */
;;;1565   int SEGGER_RTT_AllocUpBuffer(const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
000000  b5ff              PUSH     {r0-r7,lr}
000002  b081              SUB      sp,sp,#4
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;1566     int BufferIndex;
;;;1567   
;;;1568     INIT();
00000a  bf00              NOP      
00000c  4825              LDR      r0,|L2.164|
00000e  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
000010  2800              CMP      r0,#0
000012  d101              BNE      |L2.24|
000014  f7fffffe          BL       _DoInit
                  |L2.24|
000018  bf00              NOP      
;;;1569     SEGGER_RTT_LOCK();
00001a  f3ef8110          MRS      r1,PRIMASK
00001e  4608              MOV      r0,r1
000020  2101              MOVS     r1,#1
000022  f3818810          MSR      PRIMASK,r1
000026  bf00              NOP      
000028  bf00              NOP      
;;;1570     BufferIndex = 0;
00002a  2400              MOVS     r4,#0
;;;1571     do {
00002c  bf00              NOP      
                  |L2.46|
;;;1572       if (_SEGGER_RTT.aUp[BufferIndex].pBuffer == NULL) {
00002e  2118              MOVS     r1,#0x18
000030  4361              MULS     r1,r4,r1
000032  4a1c              LDR      r2,|L2.164|
000034  3218              ADDS     r2,r2,#0x18
000036  1889              ADDS     r1,r1,r2
000038  6849              LDR      r1,[r1,#4]
00003a  2900              CMP      r1,#0
00003c  d100              BNE      |L2.64|
;;;1573         break;
00003e  e004              B        |L2.74|
                  |L2.64|
;;;1574       }
;;;1575       BufferIndex++;
000040  1c64              ADDS     r4,r4,#1
;;;1576     } while (BufferIndex < _SEGGER_RTT.MaxNumUpBuffers);
000042  4918              LDR      r1,|L2.164|
000044  6909              LDR      r1,[r1,#0x10]  ; _SEGGER_RTT
000046  42a1              CMP      r1,r4
000048  dcf1              BGT      |L2.46|
                  |L2.74|
00004a  bf00              NOP                            ;1573
;;;1577     if (BufferIndex < _SEGGER_RTT.MaxNumUpBuffers) {
00004c  4915              LDR      r1,|L2.164|
00004e  6909              LDR      r1,[r1,#0x10]  ; _SEGGER_RTT
000050  42a1              CMP      r1,r4
000052  dd1d              BLE      |L2.144|
;;;1578       _SEGGER_RTT.aUp[BufferIndex].sName        = sName;
000054  2118              MOVS     r1,#0x18
000056  4361              MULS     r1,r4,r1
000058  4a12              LDR      r2,|L2.164|
00005a  3218              ADDS     r2,r2,#0x18
00005c  5055              STR      r5,[r2,r1]
;;;1579       _SEGGER_RTT.aUp[BufferIndex].pBuffer      = (char*)pBuffer;
00005e  2118              MOVS     r1,#0x18
000060  4361              MULS     r1,r4,r1
000062  1889              ADDS     r1,r1,r2
000064  604e              STR      r6,[r1,#4]
;;;1580       _SEGGER_RTT.aUp[BufferIndex].SizeOfBuffer = BufferSize;
000066  2118              MOVS     r1,#0x18
000068  4361              MULS     r1,r4,r1
00006a  1889              ADDS     r1,r1,r2
00006c  608f              STR      r7,[r1,#8]
;;;1581       _SEGGER_RTT.aUp[BufferIndex].RdOff        = 0u;
00006e  2200              MOVS     r2,#0
000070  2118              MOVS     r1,#0x18
000072  4361              MULS     r1,r4,r1
000074  4b0b              LDR      r3,|L2.164|
000076  3318              ADDS     r3,r3,#0x18
000078  18c9              ADDS     r1,r1,r3
00007a  610a              STR      r2,[r1,#0x10]
;;;1582       _SEGGER_RTT.aUp[BufferIndex].WrOff        = 0u;
00007c  2118              MOVS     r1,#0x18
00007e  4361              MULS     r1,r4,r1
000080  18c9              ADDS     r1,r1,r3
000082  60ca              STR      r2,[r1,#0xc]
;;;1583       _SEGGER_RTT.aUp[BufferIndex].Flags        = Flags;
000084  2218              MOVS     r2,#0x18
000086  4362              MULS     r2,r4,r2
000088  18d2              ADDS     r2,r2,r3
00008a  9904              LDR      r1,[sp,#0x10]
00008c  6151              STR      r1,[r2,#0x14]
00008e  e001              B        |L2.148|
                  |L2.144|
;;;1584     } else {
;;;1585       BufferIndex = -1;
000090  2400              MOVS     r4,#0
000092  43e4              MVNS     r4,r4
                  |L2.148|
;;;1586     }
;;;1587     SEGGER_RTT_UNLOCK();
000094  b2c1              UXTB     r1,r0
000096  f3818810          MSR      PRIMASK,r1
00009a  bf00              NOP      
00009c  bf00              NOP      
;;;1588     return BufferIndex;
00009e  4620              MOV      r0,r4
;;;1589   }
0000a0  b005              ADD      sp,sp,#0x14
0000a2  bdf0              POP      {r4-r7,pc}
;;;1590   
                          ENDP

                  |L2.164|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_ConfigDownBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_ConfigDownBuffer PROC
;;;1662   */
;;;1663   int SEGGER_RTT_ConfigDownBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
000000  b5ff              PUSH     {r0-r7,lr}
000002  b081              SUB      sp,sp,#4
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;1664     int r;
;;;1665   
;;;1666     INIT();
00000a  bf00              NOP      
00000c  4820              LDR      r0,|L3.144|
00000e  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
000010  2800              CMP      r0,#0
000012  d101              BNE      |L3.24|
000014  f7fffffe          BL       _DoInit
                  |L3.24|
000018  bf00              NOP      
;;;1667     if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumDownBuffers) {
00001a  481d              LDR      r0,|L3.144|
00001c  6940              LDR      r0,[r0,#0x14]  ; _SEGGER_RTT
00001e  42a0              CMP      r0,r4
000020  d930              BLS      |L3.132|
;;;1668       SEGGER_RTT_LOCK();
000022  f3ef8110          MRS      r1,PRIMASK
000026  4608              MOV      r0,r1
000028  2101              MOVS     r1,#1
00002a  f3818810          MSR      PRIMASK,r1
00002e  bf00              NOP      
000030  bf00              NOP      
;;;1669       if (BufferIndex > 0u) {
000032  2c00              CMP      r4,#0
000034  d018              BEQ      |L3.104|
;;;1670         _SEGGER_RTT.aDown[BufferIndex].sName        = sName;
000036  2118              MOVS     r1,#0x18
000038  4361              MULS     r1,r4,r1
00003a  4a15              LDR      r2,|L3.144|
00003c  3260              ADDS     r2,r2,#0x60
00003e  5056              STR      r6,[r2,r1]
;;;1671         _SEGGER_RTT.aDown[BufferIndex].pBuffer      = (char*)pBuffer;
000040  2118              MOVS     r1,#0x18
000042  4361              MULS     r1,r4,r1
000044  1889              ADDS     r1,r1,r2
000046  604f              STR      r7,[r1,#4]
;;;1672         _SEGGER_RTT.aDown[BufferIndex].SizeOfBuffer = BufferSize;
000048  2218              MOVS     r2,#0x18
00004a  4362              MULS     r2,r4,r2
00004c  4b10              LDR      r3,|L3.144|
00004e  3360              ADDS     r3,r3,#0x60
000050  18d2              ADDS     r2,r2,r3
000052  9904              LDR      r1,[sp,#0x10]
000054  6091              STR      r1,[r2,#8]
;;;1673         _SEGGER_RTT.aDown[BufferIndex].RdOff        = 0u;
000056  2200              MOVS     r2,#0
000058  2118              MOVS     r1,#0x18
00005a  4361              MULS     r1,r4,r1
00005c  18c9              ADDS     r1,r1,r3
00005e  610a              STR      r2,[r1,#0x10]
;;;1674         _SEGGER_RTT.aDown[BufferIndex].WrOff        = 0u;
000060  2118              MOVS     r1,#0x18
000062  4361              MULS     r1,r4,r1
000064  18c9              ADDS     r1,r1,r3
000066  60ca              STR      r2,[r1,#0xc]
                  |L3.104|
;;;1675       }
;;;1676       _SEGGER_RTT.aDown[BufferIndex].Flags          = Flags;
000068  2218              MOVS     r2,#0x18
00006a  4362              MULS     r2,r4,r2
00006c  4b08              LDR      r3,|L3.144|
00006e  3360              ADDS     r3,r3,#0x60
000070  18d2              ADDS     r2,r2,r3
000072  990a              LDR      r1,[sp,#0x28]
000074  6151              STR      r1,[r2,#0x14]
;;;1677       SEGGER_RTT_UNLOCK();
000076  b2c1              UXTB     r1,r0
000078  f3818810          MSR      PRIMASK,r1
00007c  bf00              NOP      
00007e  bf00              NOP      
;;;1678       r =  0;
000080  2500              MOVS     r5,#0
000082  e001              B        |L3.136|
                  |L3.132|
;;;1679     } else {
;;;1680       r = -1;
000084  2500              MOVS     r5,#0
000086  43ed              MVNS     r5,r5
                  |L3.136|
;;;1681     }
;;;1682     return r;
000088  4628              MOV      r0,r5
;;;1683   }
00008a  b005              ADD      sp,sp,#0x14
00008c  bdf0              POP      {r4-r7,pc}
;;;1684   
                          ENDP

00008e  0000              DCW      0x0000
                  |L3.144|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_ConfigUpBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_ConfigUpBuffer PROC
;;;1615   */
;;;1616   int SEGGER_RTT_ConfigUpBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
000000  b5ff              PUSH     {r0-r7,lr}
000002  b081              SUB      sp,sp,#4
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;1617     int r;
;;;1618   
;;;1619     INIT();
00000a  bf00              NOP      
00000c  4820              LDR      r0,|L4.144|
00000e  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
000010  2800              CMP      r0,#0
000012  d101              BNE      |L4.24|
000014  f7fffffe          BL       _DoInit
                  |L4.24|
000018  bf00              NOP      
;;;1620     if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumUpBuffers) {
00001a  481d              LDR      r0,|L4.144|
00001c  6900              LDR      r0,[r0,#0x10]  ; _SEGGER_RTT
00001e  42a0              CMP      r0,r4
000020  d930              BLS      |L4.132|
;;;1621       SEGGER_RTT_LOCK();
000022  f3ef8110          MRS      r1,PRIMASK
000026  4608              MOV      r0,r1
000028  2101              MOVS     r1,#1
00002a  f3818810          MSR      PRIMASK,r1
00002e  bf00              NOP      
000030  bf00              NOP      
;;;1622       if (BufferIndex > 0u) {
000032  2c00              CMP      r4,#0
000034  d018              BEQ      |L4.104|
;;;1623         _SEGGER_RTT.aUp[BufferIndex].sName        = sName;
000036  2118              MOVS     r1,#0x18
000038  4361              MULS     r1,r4,r1
00003a  4a15              LDR      r2,|L4.144|
00003c  3218              ADDS     r2,r2,#0x18
00003e  5056              STR      r6,[r2,r1]
;;;1624         _SEGGER_RTT.aUp[BufferIndex].pBuffer      = (char*)pBuffer;
000040  2118              MOVS     r1,#0x18
000042  4361              MULS     r1,r4,r1
000044  1889              ADDS     r1,r1,r2
000046  604f              STR      r7,[r1,#4]
;;;1625         _SEGGER_RTT.aUp[BufferIndex].SizeOfBuffer = BufferSize;
000048  2218              MOVS     r2,#0x18
00004a  4362              MULS     r2,r4,r2
00004c  4b10              LDR      r3,|L4.144|
00004e  3318              ADDS     r3,r3,#0x18
000050  18d2              ADDS     r2,r2,r3
000052  9904              LDR      r1,[sp,#0x10]
000054  6091              STR      r1,[r2,#8]
;;;1626         _SEGGER_RTT.aUp[BufferIndex].RdOff        = 0u;
000056  2200              MOVS     r2,#0
000058  2118              MOVS     r1,#0x18
00005a  4361              MULS     r1,r4,r1
00005c  18c9              ADDS     r1,r1,r3
00005e  610a              STR      r2,[r1,#0x10]
;;;1627         _SEGGER_RTT.aUp[BufferIndex].WrOff        = 0u;
000060  2118              MOVS     r1,#0x18
000062  4361              MULS     r1,r4,r1
000064  18c9              ADDS     r1,r1,r3
000066  60ca              STR      r2,[r1,#0xc]
                  |L4.104|
;;;1628       }
;;;1629       _SEGGER_RTT.aUp[BufferIndex].Flags          = Flags;
000068  2218              MOVS     r2,#0x18
00006a  4362              MULS     r2,r4,r2
00006c  4b08              LDR      r3,|L4.144|
00006e  3318              ADDS     r3,r3,#0x18
000070  18d2              ADDS     r2,r2,r3
000072  990a              LDR      r1,[sp,#0x28]
000074  6151              STR      r1,[r2,#0x14]
;;;1630       SEGGER_RTT_UNLOCK();
000076  b2c1              UXTB     r1,r0
000078  f3818810          MSR      PRIMASK,r1
00007c  bf00              NOP      
00007e  bf00              NOP      
;;;1631       r =  0;
000080  2500              MOVS     r5,#0
000082  e001              B        |L4.136|
                  |L4.132|
;;;1632     } else {
;;;1633       r = -1;
000084  2500              MOVS     r5,#0
000086  43ed              MVNS     r5,r5
                  |L4.136|
;;;1634     }
;;;1635     return r;
000088  4628              MOV      r0,r5
;;;1636   }
00008a  b005              ADD      sp,sp,#0x14
00008c  bdf0              POP      {r4-r7,pc}
;;;1637   
                          ENDP

00008e  0000              DCW      0x0000
                  |L4.144|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_GetAvailWriteSpace||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_GetAvailWriteSpace PROC
;;;1973   */
;;;1974   unsigned SEGGER_RTT_GetAvailWriteSpace (unsigned BufferIndex){
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;1975     return _GetAvailWriteSpace(&_SEGGER_RTT.aUp[BufferIndex]);
000004  2118              MOVS     r1,#0x18
000006  4361              MULS     r1,r4,r1
000008  4a02              LDR      r2,|L5.20|
00000a  1888              ADDS     r0,r1,r2
00000c  f7fffffe          BL       _GetAvailWriteSpace
;;;1976   }
000010  bd10              POP      {r4,pc}
;;;1977   
                          ENDP

000012  0000              DCW      0x0000
                  |L5.20|
                          DCD      _SEGGER_RTT+0x18

                          AREA ||i.SEGGER_RTT_GetBytesInBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_GetBytesInBuffer PROC
;;;1991   */
;;;1992   unsigned SEGGER_RTT_GetBytesInBuffer(unsigned BufferIndex) {
000000  b530              PUSH     {r4,r5,lr}
000002  4601              MOV      r1,r0
;;;1993     unsigned RdOff;
;;;1994     unsigned WrOff;
;;;1995     unsigned r;
;;;1996     //
;;;1997     // Avoid warnings regarding volatile access order.  It's not a problem
;;;1998     // in this case, but dampen compiler enthusiasm.
;;;1999     //
;;;2000     RdOff = _SEGGER_RTT.aUp[BufferIndex].RdOff;
000004  2418              MOVS     r4,#0x18
000006  434c              MULS     r4,r1,r4
000008  4d09              LDR      r5,|L6.48|
00000a  1964              ADDS     r4,r4,r5
00000c  6922              LDR      r2,[r4,#0x10]
;;;2001     WrOff = _SEGGER_RTT.aUp[BufferIndex].WrOff;
00000e  2418              MOVS     r4,#0x18
000010  434c              MULS     r4,r1,r4
000012  1964              ADDS     r4,r4,r5
000014  68e3              LDR      r3,[r4,#0xc]
;;;2002     if (RdOff <= WrOff) {
000016  429a              CMP      r2,r3
000018  d801              BHI      |L6.30|
;;;2003       r = WrOff - RdOff;
00001a  1a98              SUBS     r0,r3,r2
00001c  e006              B        |L6.44|
                  |L6.30|
;;;2004     } else {
;;;2005       r = _SEGGER_RTT.aUp[BufferIndex].SizeOfBuffer - (WrOff - RdOff);
00001e  2418              MOVS     r4,#0x18
000020  434c              MULS     r4,r1,r4
000022  4d03              LDR      r5,|L6.48|
000024  1964              ADDS     r4,r4,r5
000026  68a4              LDR      r4,[r4,#8]
000028  1a9d              SUBS     r5,r3,r2
00002a  1b60              SUBS     r0,r4,r5
                  |L6.44|
;;;2006     }
;;;2007     return r;
;;;2008   }
00002c  bd30              POP      {r4,r5,pc}
;;;2009   
                          ENDP

00002e  0000              DCW      0x0000
                  |L6.48|
                          DCD      _SEGGER_RTT+0x18

                          AREA ||i.SEGGER_RTT_GetKey||, CODE, READONLY, ALIGN=1

                  SEGGER_RTT_GetKey PROC
;;;1393   */
;;;1394   int SEGGER_RTT_GetKey(void) {
000000  b538              PUSH     {r3-r5,lr}
;;;1395     char c;
;;;1396     int r;
;;;1397   
;;;1398     r = (int)SEGGER_RTT_Read(0u, &c, 1u);
000002  2201              MOVS     r2,#1
000004  4669              MOV      r1,sp
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       SEGGER_RTT_Read
00000c  4604              MOV      r4,r0
;;;1399     if (r == 1) {
00000e  2c01              CMP      r4,#1
000010  d102              BNE      |L7.24|
;;;1400       r = (int)(unsigned char)c;
000012  4668              MOV      r0,sp
000014  7804              LDRB     r4,[r0,#0]
000016  e001              B        |L7.28|
                  |L7.24|
;;;1401     } else {
;;;1402       r = -1;
000018  2400              MOVS     r4,#0
00001a  43e4              MVNS     r4,r4
                  |L7.28|
;;;1403     }
;;;1404     return r;
00001c  4620              MOV      r0,r4
;;;1405   }
00001e  bd38              POP      {r3-r5,pc}
;;;1406   
                          ENDP


                          AREA ||i.SEGGER_RTT_HasData||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_HasData PROC
;;;1470   */
;;;1471   unsigned SEGGER_RTT_HasData(unsigned BufferIndex) {
000000  b510              PUSH     {r4,lr}
000002  4601              MOV      r1,r0
;;;1472     SEGGER_RTT_BUFFER_DOWN* pRing;
;;;1473     unsigned                v;
;;;1474   
;;;1475     pRing = &_SEGGER_RTT.aDown[BufferIndex];
000004  2018              MOVS     r0,#0x18
000006  4348              MULS     r0,r1,r0
000008  4c02              LDR      r4,|L8.20|
00000a  1902              ADDS     r2,r0,r4
;;;1476     v = pRing->WrOff;
00000c  68d3              LDR      r3,[r2,#0xc]
;;;1477     return v - pRing->RdOff;
00000e  6910              LDR      r0,[r2,#0x10]
000010  1a18              SUBS     r0,r3,r0
;;;1478   }
000012  bd10              POP      {r4,pc}
;;;1479   
                          ENDP

                  |L8.20|
                          DCD      _SEGGER_RTT+0x60

                          AREA ||i.SEGGER_RTT_HasDataUp||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_HasDataUp PROC
;;;1491   */
;;;1492   unsigned SEGGER_RTT_HasDataUp(unsigned BufferIndex) {
000000  b510              PUSH     {r4,lr}
000002  4601              MOV      r1,r0
;;;1493     SEGGER_RTT_BUFFER_UP* pRing;
;;;1494     unsigned                v;
;;;1495   
;;;1496     pRing = &_SEGGER_RTT.aUp[BufferIndex];
000004  2018              MOVS     r0,#0x18
000006  4348              MULS     r0,r1,r0
000008  4c02              LDR      r4,|L9.20|
00000a  1902              ADDS     r2,r0,r4
;;;1497     v = pRing->RdOff;
00000c  6913              LDR      r3,[r2,#0x10]
;;;1498     return pRing->WrOff - v;
00000e  68d0              LDR      r0,[r2,#0xc]
000010  1ac0              SUBS     r0,r0,r3
;;;1499   }
000012  bd10              POP      {r4,pc}
;;;1500   
                          ENDP

                  |L9.20|
                          DCD      _SEGGER_RTT+0x18

                          AREA ||i.SEGGER_RTT_HasKey||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_HasKey PROC
;;;1444   */
;;;1445   int SEGGER_RTT_HasKey(void) {
000000  b570              PUSH     {r4-r6,lr}
;;;1446     unsigned RdOff;
;;;1447     int r;
;;;1448   
;;;1449     INIT();
000002  bf00              NOP      
000004  4808              LDR      r0,|L10.40|
000006  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
000008  2800              CMP      r0,#0
00000a  d101              BNE      |L10.16|
00000c  f7fffffe          BL       _DoInit
                  |L10.16|
000010  bf00              NOP      
;;;1450     RdOff = _SEGGER_RTT.aDown[0].RdOff;
000012  4805              LDR      r0,|L10.40|
000014  6f05              LDR      r5,[r0,#0x70]
;;;1451     if (RdOff != _SEGGER_RTT.aDown[0].WrOff) {
000016  6ec0              LDR      r0,[r0,#0x6c]
000018  42a8              CMP      r0,r5
00001a  d001              BEQ      |L10.32|
;;;1452       r = 1;
00001c  2401              MOVS     r4,#1
00001e  e000              B        |L10.34|
                  |L10.32|
;;;1453     } else {
;;;1454       r = 0;
000020  2400              MOVS     r4,#0
                  |L10.34|
;;;1455     }
;;;1456     return r;
000022  4620              MOV      r0,r4
;;;1457   }
000024  bd70              POP      {r4-r6,pc}
;;;1458   
                          ENDP

000026  0000              DCW      0x0000
                  |L10.40|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_Init||, CODE, READONLY, ALIGN=1

                  SEGGER_RTT_Init PROC
;;;1817   */
;;;1818   void SEGGER_RTT_Init (void) {
000000  b510              PUSH     {r4,lr}
;;;1819     _DoInit();
000002  f7fffffe          BL       _DoInit
;;;1820   }
000006  bd10              POP      {r4,pc}
;;;1821   
                          ENDP


                          AREA ||i.SEGGER_RTT_PutChar||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_PutChar PROC
;;;1332   
;;;1333   unsigned SEGGER_RTT_PutChar(unsigned BufferIndex, char c) {
000000  b5f3              PUSH     {r0,r1,r4-r7,lr}
000002  b081              SUB      sp,sp,#4
000004  4607              MOV      r7,r0
;;;1334     SEGGER_RTT_BUFFER_UP* pRing;
;;;1335     unsigned              WrOff;
;;;1336     unsigned              Status;
;;;1337     //
;;;1338     // Prepare
;;;1339     //
;;;1340     INIT();
000006  bf00              NOP      
000008  4818              LDR      r0,|L12.108|
00000a  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000c  2800              CMP      r0,#0
00000e  d101              BNE      |L12.20|
000010  f7fffffe          BL       _DoInit
                  |L12.20|
000014  bf00              NOP      
;;;1341     SEGGER_RTT_LOCK();
000016  f3ef8010          MRS      r0,PRIMASK
00001a  2101              MOVS     r1,#1
00001c  f3818810          MSR      PRIMASK,r1
000020  bf00              NOP      
000022  bf00              NOP      
;;;1342     //
;;;1343     // Get "to-host" ring buffer.
;;;1344     //
;;;1345     pRing = &_SEGGER_RTT.aUp[BufferIndex];
000024  2118              MOVS     r1,#0x18
000026  4379              MULS     r1,r7,r1
000028  4a10              LDR      r2,|L12.108|
00002a  3218              ADDS     r2,r2,#0x18
00002c  188c              ADDS     r4,r1,r2
;;;1346     //
;;;1347     // Get write position and handle wrap-around if necessary
;;;1348     //
;;;1349     WrOff = pRing->WrOff + 1;
00002e  68e1              LDR      r1,[r4,#0xc]
000030  1c4d              ADDS     r5,r1,#1
;;;1350     if (WrOff == pRing->SizeOfBuffer) {
000032  68a1              LDR      r1,[r4,#8]
000034  42a9              CMP      r1,r5
000036  d100              BNE      |L12.58|
;;;1351       WrOff = 0;
000038  2500              MOVS     r5,#0
                  |L12.58|
;;;1352     }
;;;1353     //
;;;1354     // Wait for free space if mode is set to blocking
;;;1355     //
;;;1356     if (pRing->Flags == SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL) {
00003a  6961              LDR      r1,[r4,#0x14]
00003c  2902              CMP      r1,#2
00003e  d103              BNE      |L12.72|
;;;1357       while (WrOff == pRing->RdOff) {
000040  bf00              NOP      
                  |L12.66|
000042  6921              LDR      r1,[r4,#0x10]
000044  42a9              CMP      r1,r5
000046  d0fc              BEQ      |L12.66|
                  |L12.72|
;;;1358         ;
;;;1359       }
;;;1360     }
;;;1361     //
;;;1362     // Output byte if free space is available
;;;1363     //
;;;1364     if (WrOff != pRing->RdOff) {
000048  6921              LDR      r1,[r4,#0x10]
00004a  42a9              CMP      r1,r5
00004c  d006              BEQ      |L12.92|
;;;1365       pRing->pBuffer[pRing->WrOff] = c;
00004e  9902              LDR      r1,[sp,#8]
000050  68e3              LDR      r3,[r4,#0xc]
000052  6862              LDR      r2,[r4,#4]
000054  54d1              STRB     r1,[r2,r3]
;;;1366       pRing->WrOff = WrOff;
000056  60e5              STR      r5,[r4,#0xc]
;;;1367       Status = 1;
000058  2601              MOVS     r6,#1
00005a  e000              B        |L12.94|
                  |L12.92|
;;;1368     } else {
;;;1369       Status = 0;
00005c  2600              MOVS     r6,#0
                  |L12.94|
;;;1370     }
;;;1371     //
;;;1372     // Finish up.
;;;1373     //
;;;1374     SEGGER_RTT_UNLOCK();
00005e  b2c1              UXTB     r1,r0
000060  f3818810          MSR      PRIMASK,r1
000064  bf00              NOP      
000066  bf00              NOP      
;;;1375     //
;;;1376     return Status;
000068  4630              MOV      r0,r6
;;;1377   }
00006a  bdfe              POP      {r1-r7,pc}
;;;1378   
                          ENDP

                  |L12.108|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_PutCharSkip||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_PutCharSkip PROC
;;;1276   
;;;1277   unsigned SEGGER_RTT_PutCharSkip(unsigned BufferIndex, char c) {
000000  b5f3              PUSH     {r0,r1,r4-r7,lr}
000002  b081              SUB      sp,sp,#4
000004  4607              MOV      r7,r0
;;;1278     SEGGER_RTT_BUFFER_UP* pRing;
;;;1279     unsigned              WrOff;
;;;1280     unsigned              Status;
;;;1281     //
;;;1282     // Prepare
;;;1283     //
;;;1284     INIT();
000006  bf00              NOP      
000008  4815              LDR      r0,|L13.96|
00000a  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000c  2800              CMP      r0,#0
00000e  d101              BNE      |L13.20|
000010  f7fffffe          BL       _DoInit
                  |L13.20|
000014  bf00              NOP      
;;;1285     SEGGER_RTT_LOCK();
000016  f3ef8010          MRS      r0,PRIMASK
00001a  2101              MOVS     r1,#1
00001c  f3818810          MSR      PRIMASK,r1
000020  bf00              NOP      
000022  bf00              NOP      
;;;1286     //
;;;1287     // Get "to-host" ring buffer.
;;;1288     //
;;;1289     pRing = &_SEGGER_RTT.aUp[BufferIndex];
000024  2118              MOVS     r1,#0x18
000026  4379              MULS     r1,r7,r1
000028  4a0d              LDR      r2,|L13.96|
00002a  3218              ADDS     r2,r2,#0x18
00002c  188c              ADDS     r4,r1,r2
;;;1290     //
;;;1291     // Get write position and handle wrap-around if necessary
;;;1292     //
;;;1293     WrOff = pRing->WrOff + 1;
00002e  68e1              LDR      r1,[r4,#0xc]
000030  1c4d              ADDS     r5,r1,#1
;;;1294     if (WrOff == pRing->SizeOfBuffer) {
000032  68a1              LDR      r1,[r4,#8]
000034  42a9              CMP      r1,r5
000036  d100              BNE      |L13.58|
;;;1295       WrOff = 0;
000038  2500              MOVS     r5,#0
                  |L13.58|
;;;1296     }
;;;1297     //
;;;1298     // Output byte if free space is available
;;;1299     //
;;;1300     if (WrOff != pRing->RdOff) {
00003a  6921              LDR      r1,[r4,#0x10]
00003c  42a9              CMP      r1,r5
00003e  d006              BEQ      |L13.78|
;;;1301       pRing->pBuffer[pRing->WrOff] = c;
000040  9902              LDR      r1,[sp,#8]
000042  68e3              LDR      r3,[r4,#0xc]
000044  6862              LDR      r2,[r4,#4]
000046  54d1              STRB     r1,[r2,r3]
;;;1302       pRing->WrOff = WrOff;
000048  60e5              STR      r5,[r4,#0xc]
;;;1303       Status = 1;
00004a  2601              MOVS     r6,#1
00004c  e000              B        |L13.80|
                  |L13.78|
;;;1304     } else {
;;;1305       Status = 0;
00004e  2600              MOVS     r6,#0
                  |L13.80|
;;;1306     }
;;;1307     //
;;;1308     // Finish up.
;;;1309     //
;;;1310     SEGGER_RTT_UNLOCK();
000050  b2c1              UXTB     r1,r0
000052  f3818810          MSR      PRIMASK,r1
000056  bf00              NOP      
000058  bf00              NOP      
;;;1311     //
;;;1312     return Status;
00005a  4630              MOV      r0,r6
;;;1313   }
00005c  bdfe              POP      {r1-r7,pc}
;;;1314   
                          ENDP

00005e  0000              DCW      0x0000
                  |L13.96|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_PutCharSkipNoLock||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_PutCharSkipNoLock PROC
;;;1229   
;;;1230   unsigned SEGGER_RTT_PutCharSkipNoLock(unsigned BufferIndex, char c) {
000000  b570              PUSH     {r4-r6,lr}
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;1231     SEGGER_RTT_BUFFER_UP* pRing;
;;;1232     unsigned              WrOff;
;;;1233     unsigned              Status;
;;;1234     //
;;;1235     // Get "to-host" ring buffer.
;;;1236     //
;;;1237     pRing = &_SEGGER_RTT.aUp[BufferIndex];
000006  2518              MOVS     r5,#0x18
000008  435d              MULS     r5,r3,r5
00000a  4e09              LDR      r6,|L14.48|
00000c  19a9              ADDS     r1,r5,r6
;;;1238     //
;;;1239     // Get write position and handle wrap-around if necessary
;;;1240     //
;;;1241     WrOff = pRing->WrOff + 1;
00000e  68cd              LDR      r5,[r1,#0xc]
000010  1c6a              ADDS     r2,r5,#1
;;;1242     if (WrOff == pRing->SizeOfBuffer) {
000012  688d              LDR      r5,[r1,#8]
000014  4295              CMP      r5,r2
000016  d100              BNE      |L14.26|
;;;1243       WrOff = 0;
000018  2200              MOVS     r2,#0
                  |L14.26|
;;;1244     }
;;;1245     //
;;;1246     // Output byte if free space is available
;;;1247     //
;;;1248     if (WrOff != pRing->RdOff) {
00001a  690d              LDR      r5,[r1,#0x10]
00001c  4295              CMP      r5,r2
00001e  d005              BEQ      |L14.44|
;;;1249       pRing->pBuffer[pRing->WrOff] = c;
000020  68ce              LDR      r6,[r1,#0xc]
000022  684d              LDR      r5,[r1,#4]
000024  55ac              STRB     r4,[r5,r6]
;;;1250       pRing->WrOff = WrOff;
000026  60ca              STR      r2,[r1,#0xc]
;;;1251       Status = 1;
000028  2001              MOVS     r0,#1
00002a  e000              B        |L14.46|
                  |L14.44|
;;;1252     } else {
;;;1253       Status = 0;
00002c  2000              MOVS     r0,#0
                  |L14.46|
;;;1254     }
;;;1255     //
;;;1256     return Status;
;;;1257   }
00002e  bd70              POP      {r4-r6,pc}
;;;1258   
                          ENDP

                  |L14.48|
                          DCD      _SEGGER_RTT+0x18

                          AREA ||i.SEGGER_RTT_Read||, CODE, READONLY, ALIGN=1

                  SEGGER_RTT_Read PROC
;;;750    */
;;;751    unsigned SEGGER_RTT_Read(unsigned BufferIndex, void* pBuffer, unsigned BufferSize) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;752      unsigned NumBytesRead;
;;;753      //
;;;754      SEGGER_RTT_LOCK();
000008  f3ef8010          MRS      r0,PRIMASK
00000c  4607              MOV      r7,r0
00000e  2001              MOVS     r0,#1
000010  f3808810          MSR      PRIMASK,r0
000014  bf00              NOP      
000016  bf00              NOP      
;;;755      //
;;;756      // Call the non-locking read function
;;;757      //
;;;758      NumBytesRead = SEGGER_RTT_ReadNoLock(BufferIndex, pBuffer, BufferSize);
000018  4632              MOV      r2,r6
00001a  4629              MOV      r1,r5
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       SEGGER_RTT_ReadNoLock
000022  9000              STR      r0,[sp,#0]
;;;759      //
;;;760      // Finish up.
;;;761      //
;;;762      SEGGER_RTT_UNLOCK();
000024  b2f8              UXTB     r0,r7
000026  f3808810          MSR      PRIMASK,r0
00002a  bf00              NOP      
00002c  bf00              NOP      
;;;763      //
;;;764      return NumBytesRead;
00002e  9800              LDR      r0,[sp,#0]
;;;765    }
000030  bdf8              POP      {r3-r7,pc}
;;;766    
                          ENDP


                          AREA ||i.SEGGER_RTT_ReadNoLock||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_ReadNoLock PROC
;;;619    */
;;;620    unsigned SEGGER_RTT_ReadNoLock(unsigned BufferIndex, void* pData, unsigned BufferSize) {
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
000002  b084              SUB      sp,sp,#0x10
000004  4617              MOV      r7,r2
;;;621      unsigned                NumBytesRem;
;;;622      unsigned                NumBytesRead;
;;;623      unsigned                RdOff;
;;;624      unsigned                WrOff;
;;;625      unsigned char*          pBuffer;
;;;626      SEGGER_RTT_BUFFER_DOWN* pRing;
;;;627    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;628      const char*             pSrc;
;;;629    #endif
;;;630      //
;;;631      INIT();
000006  bf00              NOP      
000008  4827              LDR      r0,|L16.168|
00000a  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000c  2800              CMP      r0,#0
00000e  d101              BNE      |L16.20|
000010  f7fffffe          BL       _DoInit
                  |L16.20|
000014  bf00              NOP      
;;;632      pRing = &_SEGGER_RTT.aDown[BufferIndex];
000016  2118              MOVS     r1,#0x18
000018  9804              LDR      r0,[sp,#0x10]
00001a  4348              MULS     r0,r1,r0
00001c  4922              LDR      r1,|L16.168|
00001e  3160              ADDS     r1,r1,#0x60
000020  1846              ADDS     r6,r0,r1
;;;633      pBuffer = (unsigned char*)pData;
000022  9805              LDR      r0,[sp,#0x14]
000024  9001              STR      r0,[sp,#4]
;;;634      RdOff = pRing->RdOff;
000026  6935              LDR      r5,[r6,#0x10]
;;;635      WrOff = pRing->WrOff;
000028  68f0              LDR      r0,[r6,#0xc]
00002a  9002              STR      r0,[sp,#8]
;;;636      NumBytesRead = 0u;
00002c  2000              MOVS     r0,#0
00002e  9003              STR      r0,[sp,#0xc]
;;;637      //
;;;638      // Read from current read position to wrap-around of buffer, first
;;;639      //
;;;640      if (RdOff > WrOff) {
000030  9802              LDR      r0,[sp,#8]
000032  4285              CMP      r5,r0
000034  d919              BLS      |L16.106|
;;;641        NumBytesRem = pRing->SizeOfBuffer - RdOff;
000036  68b0              LDR      r0,[r6,#8]
000038  1b44              SUBS     r4,r0,r5
;;;642        NumBytesRem = MIN(NumBytesRem, BufferSize);
00003a  42bc              CMP      r4,r7
00003c  d201              BCS      |L16.66|
00003e  4620              MOV      r0,r4
000040  e000              B        |L16.68|
                  |L16.66|
000042  4638              MOV      r0,r7
                  |L16.68|
000044  4604              MOV      r4,r0
;;;643    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;644        pSrc = pRing->pBuffer + RdOff;
;;;645        NumBytesRead += NumBytesRem;
;;;646        BufferSize   -= NumBytesRem;
;;;647        RdOff        += NumBytesRem;
;;;648        while (NumBytesRem--) {
;;;649          *pBuffer++ = *pSrc++;
;;;650        };
;;;651    #else
;;;652        SEGGER_RTT_MEMCPY(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
000046  6870              LDR      r0,[r6,#4]
000048  1941              ADDS     r1,r0,r5
00004a  4622              MOV      r2,r4
00004c  9801              LDR      r0,[sp,#4]
00004e  f7fffffe          BL       __aeabi_memcpy
;;;653        NumBytesRead += NumBytesRem;
000052  9803              LDR      r0,[sp,#0xc]
000054  1900              ADDS     r0,r0,r4
000056  9003              STR      r0,[sp,#0xc]
;;;654        pBuffer      += NumBytesRem;
000058  9801              LDR      r0,[sp,#4]
00005a  1900              ADDS     r0,r0,r4
00005c  9001              STR      r0,[sp,#4]
;;;655        BufferSize   -= NumBytesRem;
00005e  1b3f              SUBS     r7,r7,r4
;;;656        RdOff        += NumBytesRem;
000060  192d              ADDS     r5,r5,r4
;;;657    #endif
;;;658        //
;;;659        // Handle wrap-around of buffer
;;;660        //
;;;661        if (RdOff == pRing->SizeOfBuffer) {
000062  68b0              LDR      r0,[r6,#8]
000064  42a8              CMP      r0,r5
000066  d100              BNE      |L16.106|
;;;662          RdOff = 0u;
000068  2500              MOVS     r5,#0
                  |L16.106|
;;;663        }
;;;664      }
;;;665      //
;;;666      // Read remaining items of buffer
;;;667      //
;;;668      NumBytesRem = WrOff - RdOff;
00006a  9802              LDR      r0,[sp,#8]
00006c  1b44              SUBS     r4,r0,r5
;;;669      NumBytesRem = MIN(NumBytesRem, BufferSize);
00006e  42bc              CMP      r4,r7
000070  d201              BCS      |L16.118|
000072  4620              MOV      r0,r4
000074  e000              B        |L16.120|
                  |L16.118|
000076  4638              MOV      r0,r7
                  |L16.120|
000078  4604              MOV      r4,r0
;;;670      if (NumBytesRem > 0u) {
00007a  2c00              CMP      r4,#0
00007c  d00d              BEQ      |L16.154|
;;;671    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;672        pSrc = pRing->pBuffer + RdOff;
;;;673        NumBytesRead += NumBytesRem;
;;;674        BufferSize   -= NumBytesRem;
;;;675        RdOff        += NumBytesRem;
;;;676        while (NumBytesRem--) {
;;;677          *pBuffer++ = *pSrc++;
;;;678        };
;;;679    #else
;;;680        SEGGER_RTT_MEMCPY(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
00007e  6870              LDR      r0,[r6,#4]
000080  1941              ADDS     r1,r0,r5
000082  4622              MOV      r2,r4
000084  9801              LDR      r0,[sp,#4]
000086  f7fffffe          BL       __aeabi_memcpy
;;;681        NumBytesRead += NumBytesRem;
00008a  9803              LDR      r0,[sp,#0xc]
00008c  1900              ADDS     r0,r0,r4
00008e  9003              STR      r0,[sp,#0xc]
;;;682        pBuffer      += NumBytesRem;
000090  9801              LDR      r0,[sp,#4]
000092  1900              ADDS     r0,r0,r4
000094  9001              STR      r0,[sp,#4]
;;;683        BufferSize   -= NumBytesRem;
000096  1b3f              SUBS     r7,r7,r4
;;;684        RdOff        += NumBytesRem;
000098  192d              ADDS     r5,r5,r4
                  |L16.154|
;;;685    #endif
;;;686      }
;;;687      if (NumBytesRead) {
00009a  9803              LDR      r0,[sp,#0xc]
00009c  2800              CMP      r0,#0
00009e  d000              BEQ      |L16.162|
;;;688        pRing->RdOff = RdOff;
0000a0  6135              STR      r5,[r6,#0x10]
                  |L16.162|
;;;689      }
;;;690      //
;;;691      return NumBytesRead;
0000a2  9803              LDR      r0,[sp,#0xc]
;;;692    }
0000a4  b007              ADD      sp,sp,#0x1c
0000a6  bdf0              POP      {r4-r7,pc}
;;;693    
                          ENDP

                  |L16.168|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_ReadUpBuffer||, CODE, READONLY, ALIGN=1

                  SEGGER_RTT_ReadUpBuffer PROC
;;;718    */
;;;719    unsigned SEGGER_RTT_ReadUpBuffer(unsigned BufferIndex, void* pBuffer, unsigned BufferSize) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;720      unsigned NumBytesRead;
;;;721      //
;;;722      SEGGER_RTT_LOCK();
000008  f3ef8010          MRS      r0,PRIMASK
00000c  4607              MOV      r7,r0
00000e  2001              MOVS     r0,#1
000010  f3808810          MSR      PRIMASK,r0
000014  bf00              NOP      
000016  bf00              NOP      
;;;723      //
;;;724      // Call the non-locking read function
;;;725      //
;;;726      NumBytesRead = SEGGER_RTT_ReadUpBufferNoLock(BufferIndex, pBuffer, BufferSize);
000018  4632              MOV      r2,r6
00001a  4629              MOV      r1,r5
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       SEGGER_RTT_ReadUpBufferNoLock
000022  9000              STR      r0,[sp,#0]
;;;727      //
;;;728      // Finish up.
;;;729      //
;;;730      SEGGER_RTT_UNLOCK();
000024  b2f8              UXTB     r0,r7
000026  f3808810          MSR      PRIMASK,r0
00002a  bf00              NOP      
00002c  bf00              NOP      
;;;731      //
;;;732      return NumBytesRead;
00002e  9800              LDR      r0,[sp,#0]
;;;733    }
000030  bdf8              POP      {r3-r7,pc}
;;;734    
                          ENDP


                          AREA ||i.SEGGER_RTT_ReadUpBufferNoLock||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_ReadUpBufferNoLock PROC
;;;525    */
;;;526    unsigned SEGGER_RTT_ReadUpBufferNoLock(unsigned BufferIndex, void* pData, unsigned BufferSize) {
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
000002  b084              SUB      sp,sp,#0x10
000004  4617              MOV      r7,r2
;;;527      unsigned                NumBytesRem;
;;;528      unsigned                NumBytesRead;
;;;529      unsigned                RdOff;
;;;530      unsigned                WrOff;
;;;531      unsigned char*          pBuffer;
;;;532      SEGGER_RTT_BUFFER_UP*   pRing;
;;;533    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;534      const char*             pSrc;
;;;535    #endif
;;;536      //
;;;537      INIT();
000006  bf00              NOP      
000008  4827              LDR      r0,|L18.168|
00000a  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000c  2800              CMP      r0,#0
00000e  d101              BNE      |L18.20|
000010  f7fffffe          BL       _DoInit
                  |L18.20|
000014  bf00              NOP      
;;;538      pRing = &_SEGGER_RTT.aUp[BufferIndex];
000016  2118              MOVS     r1,#0x18
000018  9804              LDR      r0,[sp,#0x10]
00001a  4348              MULS     r0,r1,r0
00001c  4922              LDR      r1,|L18.168|
00001e  3118              ADDS     r1,r1,#0x18
000020  1846              ADDS     r6,r0,r1
;;;539      pBuffer = (unsigned char*)pData;
000022  9805              LDR      r0,[sp,#0x14]
000024  9001              STR      r0,[sp,#4]
;;;540      RdOff = pRing->RdOff;
000026  6935              LDR      r5,[r6,#0x10]
;;;541      WrOff = pRing->WrOff;
000028  68f0              LDR      r0,[r6,#0xc]
00002a  9002              STR      r0,[sp,#8]
;;;542      NumBytesRead = 0u;
00002c  2000              MOVS     r0,#0
00002e  9003              STR      r0,[sp,#0xc]
;;;543      //
;;;544      // Read from current read position to wrap-around of buffer, first
;;;545      //
;;;546      if (RdOff > WrOff) {
000030  9802              LDR      r0,[sp,#8]
000032  4285              CMP      r5,r0
000034  d919              BLS      |L18.106|
;;;547        NumBytesRem = pRing->SizeOfBuffer - RdOff;
000036  68b0              LDR      r0,[r6,#8]
000038  1b44              SUBS     r4,r0,r5
;;;548        NumBytesRem = MIN(NumBytesRem, BufferSize);
00003a  42bc              CMP      r4,r7
00003c  d201              BCS      |L18.66|
00003e  4620              MOV      r0,r4
000040  e000              B        |L18.68|
                  |L18.66|
000042  4638              MOV      r0,r7
                  |L18.68|
000044  4604              MOV      r4,r0
;;;549    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;550        pSrc = pRing->pBuffer + RdOff;
;;;551        NumBytesRead += NumBytesRem;
;;;552        BufferSize   -= NumBytesRem;
;;;553        RdOff        += NumBytesRem;
;;;554        while (NumBytesRem--) {
;;;555          *pBuffer++ = *pSrc++;
;;;556        };
;;;557    #else
;;;558        SEGGER_RTT_MEMCPY(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
000046  6870              LDR      r0,[r6,#4]
000048  1941              ADDS     r1,r0,r5
00004a  4622              MOV      r2,r4
00004c  9801              LDR      r0,[sp,#4]
00004e  f7fffffe          BL       __aeabi_memcpy
;;;559        NumBytesRead += NumBytesRem;
000052  9803              LDR      r0,[sp,#0xc]
000054  1900              ADDS     r0,r0,r4
000056  9003              STR      r0,[sp,#0xc]
;;;560        pBuffer      += NumBytesRem;
000058  9801              LDR      r0,[sp,#4]
00005a  1900              ADDS     r0,r0,r4
00005c  9001              STR      r0,[sp,#4]
;;;561        BufferSize   -= NumBytesRem;
00005e  1b3f              SUBS     r7,r7,r4
;;;562        RdOff        += NumBytesRem;
000060  192d              ADDS     r5,r5,r4
;;;563    #endif
;;;564        //
;;;565        // Handle wrap-around of buffer
;;;566        //
;;;567        if (RdOff == pRing->SizeOfBuffer) {
000062  68b0              LDR      r0,[r6,#8]
000064  42a8              CMP      r0,r5
000066  d100              BNE      |L18.106|
;;;568          RdOff = 0u;
000068  2500              MOVS     r5,#0
                  |L18.106|
;;;569        }
;;;570      }
;;;571      //
;;;572      // Read remaining items of buffer
;;;573      //
;;;574      NumBytesRem = WrOff - RdOff;
00006a  9802              LDR      r0,[sp,#8]
00006c  1b44              SUBS     r4,r0,r5
;;;575      NumBytesRem = MIN(NumBytesRem, BufferSize);
00006e  42bc              CMP      r4,r7
000070  d201              BCS      |L18.118|
000072  4620              MOV      r0,r4
000074  e000              B        |L18.120|
                  |L18.118|
000076  4638              MOV      r0,r7
                  |L18.120|
000078  4604              MOV      r4,r0
;;;576      if (NumBytesRem > 0u) {
00007a  2c00              CMP      r4,#0
00007c  d00d              BEQ      |L18.154|
;;;577    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;578        pSrc = pRing->pBuffer + RdOff;
;;;579        NumBytesRead += NumBytesRem;
;;;580        BufferSize   -= NumBytesRem;
;;;581        RdOff        += NumBytesRem;
;;;582        while (NumBytesRem--) {
;;;583          *pBuffer++ = *pSrc++;
;;;584        };
;;;585    #else
;;;586        SEGGER_RTT_MEMCPY(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
00007e  6870              LDR      r0,[r6,#4]
000080  1941              ADDS     r1,r0,r5
000082  4622              MOV      r2,r4
000084  9801              LDR      r0,[sp,#4]
000086  f7fffffe          BL       __aeabi_memcpy
;;;587        NumBytesRead += NumBytesRem;
00008a  9803              LDR      r0,[sp,#0xc]
00008c  1900              ADDS     r0,r0,r4
00008e  9003              STR      r0,[sp,#0xc]
;;;588        pBuffer      += NumBytesRem;
000090  9801              LDR      r0,[sp,#4]
000092  1900              ADDS     r0,r0,r4
000094  9001              STR      r0,[sp,#4]
;;;589        BufferSize   -= NumBytesRem;
000096  1b3f              SUBS     r7,r7,r4
;;;590        RdOff        += NumBytesRem;
000098  192d              ADDS     r5,r5,r4
                  |L18.154|
;;;591    #endif
;;;592      }
;;;593      //
;;;594      // Update read offset of buffer
;;;595      //
;;;596      if (NumBytesRead) {
00009a  9803              LDR      r0,[sp,#0xc]
00009c  2800              CMP      r0,#0
00009e  d000              BEQ      |L18.162|
;;;597        pRing->RdOff = RdOff;
0000a0  6135              STR      r5,[r6,#0x10]
                  |L18.162|
;;;598      }
;;;599      //
;;;600      return NumBytesRead;
0000a2  9803              LDR      r0,[sp,#0xc]
;;;601    }
0000a4  b007              ADD      sp,sp,#0x1c
0000a6  bdf0              POP      {r4-r7,pc}
;;;602    
                          ENDP

                  |L18.168|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_SetFlagsDownBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_SetFlagsDownBuffer PROC
;;;1793   */
;;;1794   int SEGGER_RTT_SetFlagsDownBuffer(unsigned BufferIndex, unsigned Flags) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;1795     int r;
;;;1796   
;;;1797     INIT();
000006  bf00              NOP      
000008  4811              LDR      r0,|L19.80|
00000a  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000c  2800              CMP      r0,#0
00000e  d101              BNE      |L19.20|
000010  f7fffffe          BL       _DoInit
                  |L19.20|
000014  bf00              NOP      
;;;1798     if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumDownBuffers) {
000016  480e              LDR      r0,|L19.80|
000018  6940              LDR      r0,[r0,#0x14]  ; _SEGGER_RTT
00001a  42a0              CMP      r0,r4
00001c  d913              BLS      |L19.70|
;;;1799       SEGGER_RTT_LOCK();
00001e  f3ef8010          MRS      r0,PRIMASK
000022  2101              MOVS     r1,#1
000024  f3818810          MSR      PRIMASK,r1
000028  bf00              NOP      
00002a  bf00              NOP      
;;;1800       _SEGGER_RTT.aDown[BufferIndex].Flags = Flags;
00002c  2118              MOVS     r1,#0x18
00002e  4361              MULS     r1,r4,r1
000030  4a07              LDR      r2,|L19.80|
000032  3260              ADDS     r2,r2,#0x60
000034  1889              ADDS     r1,r1,r2
000036  614e              STR      r6,[r1,#0x14]
;;;1801       SEGGER_RTT_UNLOCK();
000038  b2c1              UXTB     r1,r0
00003a  f3818810          MSR      PRIMASK,r1
00003e  bf00              NOP      
000040  bf00              NOP      
;;;1802       r =  0;
000042  2500              MOVS     r5,#0
000044  e001              B        |L19.74|
                  |L19.70|
;;;1803     } else {
;;;1804       r = -1;
000046  2500              MOVS     r5,#0
000048  43ed              MVNS     r5,r5
                  |L19.74|
;;;1805     }
;;;1806     return r;
00004a  4628              MOV      r0,r5
;;;1807   }
00004c  bd70              POP      {r4-r6,pc}
;;;1808   
                          ENDP

00004e  0000              DCW      0x0000
                  |L19.80|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_SetFlagsUpBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_SetFlagsUpBuffer PROC
;;;1762   */
;;;1763   int SEGGER_RTT_SetFlagsUpBuffer(unsigned BufferIndex, unsigned Flags) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;1764     int r;
;;;1765   
;;;1766     INIT();
000006  bf00              NOP      
000008  4811              LDR      r0,|L20.80|
00000a  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000c  2800              CMP      r0,#0
00000e  d101              BNE      |L20.20|
000010  f7fffffe          BL       _DoInit
                  |L20.20|
000014  bf00              NOP      
;;;1767     if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumUpBuffers) {
000016  480e              LDR      r0,|L20.80|
000018  6900              LDR      r0,[r0,#0x10]  ; _SEGGER_RTT
00001a  42a0              CMP      r0,r4
00001c  d913              BLS      |L20.70|
;;;1768       SEGGER_RTT_LOCK();
00001e  f3ef8010          MRS      r0,PRIMASK
000022  2101              MOVS     r1,#1
000024  f3818810          MSR      PRIMASK,r1
000028  bf00              NOP      
00002a  bf00              NOP      
;;;1769       _SEGGER_RTT.aUp[BufferIndex].Flags = Flags;
00002c  2118              MOVS     r1,#0x18
00002e  4361              MULS     r1,r4,r1
000030  4a07              LDR      r2,|L20.80|
000032  3218              ADDS     r2,r2,#0x18
000034  1889              ADDS     r1,r1,r2
000036  614e              STR      r6,[r1,#0x14]
;;;1770       SEGGER_RTT_UNLOCK();
000038  b2c1              UXTB     r1,r0
00003a  f3818810          MSR      PRIMASK,r1
00003e  bf00              NOP      
000040  bf00              NOP      
;;;1771       r =  0;
000042  2500              MOVS     r5,#0
000044  e001              B        |L20.74|
                  |L20.70|
;;;1772     } else {
;;;1773       r = -1;
000046  2500              MOVS     r5,#0
000048  43ed              MVNS     r5,r5
                  |L20.74|
;;;1774     }
;;;1775     return r;
00004a  4628              MOV      r0,r5
;;;1776   }
00004c  bd70              POP      {r4-r6,pc}
;;;1777   
                          ENDP

00004e  0000              DCW      0x0000
                  |L20.80|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_SetNameDownBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_SetNameDownBuffer PROC
;;;1731   */
;;;1732   int SEGGER_RTT_SetNameDownBuffer(unsigned BufferIndex, const char* sName) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;1733     int r;
;;;1734   
;;;1735     INIT();
000006  bf00              NOP      
000008  4810              LDR      r0,|L21.76|
00000a  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000c  2800              CMP      r0,#0
00000e  d101              BNE      |L21.20|
000010  f7fffffe          BL       _DoInit
                  |L21.20|
000014  bf00              NOP      
;;;1736     if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumDownBuffers) {
000016  480d              LDR      r0,|L21.76|
000018  6940              LDR      r0,[r0,#0x14]  ; _SEGGER_RTT
00001a  42a0              CMP      r0,r4
00001c  d912              BLS      |L21.68|
;;;1737       SEGGER_RTT_LOCK();
00001e  f3ef8010          MRS      r0,PRIMASK
000022  2101              MOVS     r1,#1
000024  f3818810          MSR      PRIMASK,r1
000028  bf00              NOP      
00002a  bf00              NOP      
;;;1738       _SEGGER_RTT.aDown[BufferIndex].sName = sName;
00002c  2118              MOVS     r1,#0x18
00002e  4361              MULS     r1,r4,r1
000030  4a06              LDR      r2,|L21.76|
000032  3260              ADDS     r2,r2,#0x60
000034  5056              STR      r6,[r2,r1]
;;;1739       SEGGER_RTT_UNLOCK();
000036  b2c1              UXTB     r1,r0
000038  f3818810          MSR      PRIMASK,r1
00003c  bf00              NOP      
00003e  bf00              NOP      
;;;1740       r =  0;
000040  2500              MOVS     r5,#0
000042  e001              B        |L21.72|
                  |L21.68|
;;;1741     } else {
;;;1742       r = -1;
000044  2500              MOVS     r5,#0
000046  43ed              MVNS     r5,r5
                  |L21.72|
;;;1743     }
;;;1744     return r;
000048  4628              MOV      r0,r5
;;;1745   }
00004a  bd70              POP      {r4-r6,pc}
;;;1746   
                          ENDP

                  |L21.76|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_SetNameUpBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_SetNameUpBuffer PROC
;;;1700   */
;;;1701   int SEGGER_RTT_SetNameUpBuffer(unsigned BufferIndex, const char* sName) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;1702     int r;
;;;1703   
;;;1704     INIT();
000006  bf00              NOP      
000008  4810              LDR      r0,|L22.76|
00000a  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000c  2800              CMP      r0,#0
00000e  d101              BNE      |L22.20|
000010  f7fffffe          BL       _DoInit
                  |L22.20|
000014  bf00              NOP      
;;;1705     if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumUpBuffers) {
000016  480d              LDR      r0,|L22.76|
000018  6900              LDR      r0,[r0,#0x10]  ; _SEGGER_RTT
00001a  42a0              CMP      r0,r4
00001c  d912              BLS      |L22.68|
;;;1706       SEGGER_RTT_LOCK();
00001e  f3ef8010          MRS      r0,PRIMASK
000022  2101              MOVS     r1,#1
000024  f3818810          MSR      PRIMASK,r1
000028  bf00              NOP      
00002a  bf00              NOP      
;;;1707       _SEGGER_RTT.aUp[BufferIndex].sName = sName;
00002c  2118              MOVS     r1,#0x18
00002e  4361              MULS     r1,r4,r1
000030  4a06              LDR      r2,|L22.76|
000032  3218              ADDS     r2,r2,#0x18
000034  5056              STR      r6,[r2,r1]
;;;1708       SEGGER_RTT_UNLOCK();
000036  b2c1              UXTB     r1,r0
000038  f3818810          MSR      PRIMASK,r1
00003c  bf00              NOP      
00003e  bf00              NOP      
;;;1709       r =  0;
000040  2500              MOVS     r5,#0
000042  e001              B        |L22.72|
                  |L22.68|
;;;1710     } else {
;;;1711       r = -1;
000044  2500              MOVS     r5,#0
000046  43ed              MVNS     r5,r5
                  |L22.72|
;;;1712     }
;;;1713     return r;
000048  4628              MOV      r0,r5
;;;1714   }
00004a  bd70              POP      {r4-r6,pc}
;;;1715   
                          ENDP

                  |L22.76|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_SetTerminal||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_SetTerminal PROC
;;;1835   */
;;;1836   int SEGGER_RTT_SetTerminal (unsigned char TerminalId) {
000000  b5fe              PUSH     {r1-r7,lr}
000002  4604              MOV      r4,r0
;;;1837     unsigned char         ac[2];
;;;1838     SEGGER_RTT_BUFFER_UP* pRing;
;;;1839     unsigned Avail;
;;;1840     int r;
;;;1841     //
;;;1842     INIT();
000004  bf00              NOP      
000006  4821              LDR      r0,|L23.140|
000008  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000a  2800              CMP      r0,#0
00000c  d101              BNE      |L23.18|
00000e  f7fffffe          BL       _DoInit
                  |L23.18|
000012  bf00              NOP      
;;;1843     //
;;;1844     r = 0;
000014  2700              MOVS     r7,#0
;;;1845     ac[0] = 0xFFu;
000016  20ff              MOVS     r0,#0xff
000018  4669              MOV      r1,sp
00001a  7108              STRB     r0,[r1,#4]
;;;1846     if (TerminalId < sizeof(_aTerminalId)) { // We only support a certain number of channels
00001c  2c10              CMP      r4,#0x10
00001e  d230              BCS      |L23.130|
;;;1847       ac[1] = _aTerminalId[TerminalId];
000020  481b              LDR      r0,|L23.144|
000022  5d00              LDRB     r0,[r0,r4]
000024  7148              STRB     r0,[r1,#5]
;;;1848       pRing = &_SEGGER_RTT.aUp[0];    // Buffer 0 is always reserved for terminal I/O, so we can use index 0 here, fixed
000026  4d19              LDR      r5,|L23.140|
000028  3518              ADDS     r5,r5,#0x18
;;;1849       SEGGER_RTT_LOCK();    // Lock to make sure that no other task is writing into buffer, while we are and number of free bytes in buffer does not change downwards after checking and before writing
00002a  f3ef8010          MRS      r0,PRIMASK
00002e  9000              STR      r0,[sp,#0]
000030  2001              MOVS     r0,#1
000032  f3808810          MSR      PRIMASK,r0
000036  bf00              NOP      
000038  bf00              NOP      
;;;1850       if ((pRing->Flags & SEGGER_RTT_MODE_MASK) == SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL) {
00003a  7d28              LDRB     r0,[r5,#0x14]
00003c  0780              LSLS     r0,r0,#30
00003e  0f80              LSRS     r0,r0,#30
000040  2802              CMP      r0,#2
000042  d107              BNE      |L23.84|
;;;1851         _ActiveTerminal = TerminalId;
000044  4813              LDR      r0,|L23.148|
000046  7004              STRB     r4,[r0,#0]
;;;1852         _WriteBlocking(pRing, (const char*)ac, 2u);
000048  2202              MOVS     r2,#2
00004a  a901              ADD      r1,sp,#4
00004c  4628              MOV      r0,r5
00004e  f7fffffe          BL       _WriteBlocking
000052  e00f              B        |L23.116|
                  |L23.84|
;;;1853       } else {                                                                            // Skipping mode or trim mode? => We cannot trim this command so handling is the same for both modes
;;;1854         Avail = _GetAvailWriteSpace(pRing);
000054  4628              MOV      r0,r5
000056  f7fffffe          BL       _GetAvailWriteSpace
00005a  4606              MOV      r6,r0
;;;1855         if (Avail >= 2) {
00005c  2e02              CMP      r6,#2
00005e  d307              BCC      |L23.112|
;;;1856           _ActiveTerminal = TerminalId;    // Only change active terminal in case of success
000060  480c              LDR      r0,|L23.148|
000062  7004              STRB     r4,[r0,#0]
;;;1857           _WriteNoCheck(pRing, (const char*)ac, 2u);
000064  2202              MOVS     r2,#2
000066  a901              ADD      r1,sp,#4
000068  4628              MOV      r0,r5
00006a  f7fffffe          BL       _WriteNoCheck
00006e  e001              B        |L23.116|
                  |L23.112|
;;;1858         } else {
;;;1859           r = -1;
000070  2700              MOVS     r7,#0
000072  43ff              MVNS     r7,r7
                  |L23.116|
;;;1860         }
;;;1861       }
;;;1862       SEGGER_RTT_UNLOCK();
000074  9800              LDR      r0,[sp,#0]
000076  b2c0              UXTB     r0,r0
000078  f3808810          MSR      PRIMASK,r0
00007c  bf00              NOP      
00007e  bf00              NOP      
000080  e001              B        |L23.134|
                  |L23.130|
;;;1863     } else {
;;;1864       r = -1;
000082  2700              MOVS     r7,#0
000084  43ff              MVNS     r7,r7
                  |L23.134|
;;;1865     }
;;;1866     return r;
000086  4638              MOV      r0,r7
;;;1867   }
000088  bdfe              POP      {r1-r7,pc}
;;;1868   
                          ENDP

00008a  0000              DCW      0x0000
                  |L23.140|
                          DCD      _SEGGER_RTT
                  |L23.144|
                          DCD      _aTerminalId
                  |L23.148|
                          DCD      _ActiveTerminal

                          AREA ||i.SEGGER_RTT_TerminalOut||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_TerminalOut PROC
;;;1885   */
;;;1886   int SEGGER_RTT_TerminalOut (unsigned char TerminalId, const char* s) {
000000  b5f3              PUSH     {r0,r1,r4-r7,lr}
000002  b083              SUB      sp,sp,#0xc
000004  4607              MOV      r7,r0
;;;1887     int                   Status;
;;;1888     unsigned              FragLen;
;;;1889     unsigned              Avail;
;;;1890     SEGGER_RTT_BUFFER_UP* pRing;
;;;1891     //
;;;1892     INIT();
000006  bf00              NOP      
000008  483b              LDR      r0,|L24.248|
00000a  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000c  2800              CMP      r0,#0
00000e  d101              BNE      |L24.20|
000010  f7fffffe          BL       _DoInit
                  |L24.20|
000014  bf00              NOP      
;;;1893     //
;;;1894     // Validate terminal ID.
;;;1895     //
;;;1896     if (TerminalId < (char)sizeof(_aTerminalId)) { // We only support a certain number of channels
000016  2f10              CMP      r7,#0x10
000018  da68              BGE      |L24.236|
;;;1897       //
;;;1898       // Get "to-host" ring buffer.
;;;1899       //
;;;1900       pRing = &_SEGGER_RTT.aUp[0];
00001a  4837              LDR      r0,|L24.248|
00001c  3018              ADDS     r0,r0,#0x18
00001e  9002              STR      r0,[sp,#8]
;;;1901       //
;;;1902       // Need to be able to change terminal, write data, change back.
;;;1903       // Compute the fixed and variable sizes.
;;;1904       //
;;;1905       FragLen = STRLEN(s);
000020  9804              LDR      r0,[sp,#0x10]
000022  f7fffffe          BL       strlen
000026  4606              MOV      r6,r0
;;;1906       //
;;;1907       // How we output depends upon the mode...
;;;1908       //
;;;1909       SEGGER_RTT_LOCK();
000028  f3ef8010          MRS      r0,PRIMASK
00002c  9001              STR      r0,[sp,#4]
00002e  2001              MOVS     r0,#1
000030  f3808810          MSR      PRIMASK,r0
000034  bf00              NOP      
000036  bf00              NOP      
;;;1910       Avail = _GetAvailWriteSpace(pRing);
000038  9802              LDR      r0,[sp,#8]
00003a  f7fffffe          BL       _GetAvailWriteSpace
00003e  4605              MOV      r5,r0
;;;1911       switch (pRing->Flags & SEGGER_RTT_MODE_MASK) {
000040  9802              LDR      r0,[sp,#8]
000042  7d00              LDRB     r0,[r0,#0x14]
000044  0780              LSLS     r0,r0,#30
000046  0f80              LSRS     r0,r0,#30
000048  2800              CMP      r0,#0
00004a  d004              BEQ      |L24.86|
00004c  2801              CMP      r0,#1
00004e  d017              BEQ      |L24.128|
000050  2802              CMP      r0,#2
000052  d140              BNE      |L24.214|
000054  e02f              B        |L24.182|
                  |L24.86|
;;;1912       case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
;;;1913         //
;;;1914         // If we are in skip mode and there is no space for the whole
;;;1915         // of this output, don't bother switching terminals at all.
;;;1916         //
;;;1917         if (Avail < (FragLen + 4u)) {
000056  1d30              ADDS     r0,r6,#4
000058  4285              CMP      r5,r0
00005a  d201              BCS      |L24.96|
;;;1918           Status = 0;
00005c  2400              MOVS     r4,#0
00005e  e00e              B        |L24.126|
                  |L24.96|
;;;1919         } else {
;;;1920           _PostTerminalSwitch(pRing, TerminalId);
000060  4639              MOV      r1,r7
000062  9802              LDR      r0,[sp,#8]
000064  f7fffffe          BL       _PostTerminalSwitch
;;;1921           Status = (int)_WriteBlocking(pRing, s, FragLen);
000068  4632              MOV      r2,r6
00006a  9904              LDR      r1,[sp,#0x10]
00006c  9802              LDR      r0,[sp,#8]
00006e  f7fffffe          BL       _WriteBlocking
000072  4604              MOV      r4,r0
;;;1922           _PostTerminalSwitch(pRing, _ActiveTerminal);
000074  4821              LDR      r0,|L24.252|
000076  7801              LDRB     r1,[r0,#0]  ; _ActiveTerminal
000078  9802              LDR      r0,[sp,#8]
00007a  f7fffffe          BL       _PostTerminalSwitch
                  |L24.126|
;;;1923         }
;;;1924         break;
00007e  e02d              B        |L24.220|
                  |L24.128|
;;;1925       case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
;;;1926         //
;;;1927         // If we are in trim mode and there is not enough space for everything,
;;;1928         // trim the output but always include the terminal switch.  If no room
;;;1929         // for terminal switch, skip that totally.
;;;1930         //
;;;1931         if (Avail < 4u) {
000080  2d04              CMP      r5,#4
000082  d202              BCS      |L24.138|
;;;1932           Status = -1;
000084  2400              MOVS     r4,#0
000086  43e4              MVNS     r4,r4
000088  e014              B        |L24.180|
                  |L24.138|
;;;1933         } else {
;;;1934           _PostTerminalSwitch(pRing, TerminalId);
00008a  4639              MOV      r1,r7
00008c  9802              LDR      r0,[sp,#8]
00008e  f7fffffe          BL       _PostTerminalSwitch
;;;1935           Status = (int)_WriteBlocking(pRing, s, (FragLen < (Avail - 4u)) ? FragLen : (Avail - 4u));
000092  1f28              SUBS     r0,r5,#4
000094  42b0              CMP      r0,r6
000096  d901              BLS      |L24.156|
000098  4630              MOV      r0,r6
00009a  e000              B        |L24.158|
                  |L24.156|
00009c  1f28              SUBS     r0,r5,#4
                  |L24.158|
00009e  4602              MOV      r2,r0
0000a0  9904              LDR      r1,[sp,#0x10]
0000a2  9802              LDR      r0,[sp,#8]
0000a4  f7fffffe          BL       _WriteBlocking
0000a8  4604              MOV      r4,r0
;;;1936           _PostTerminalSwitch(pRing, _ActiveTerminal);
0000aa  4814              LDR      r0,|L24.252|
0000ac  7801              LDRB     r1,[r0,#0]  ; _ActiveTerminal
0000ae  9802              LDR      r0,[sp,#8]
0000b0  f7fffffe          BL       _PostTerminalSwitch
                  |L24.180|
;;;1937         }
;;;1938         break;
0000b4  e012              B        |L24.220|
                  |L24.182|
;;;1939       case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
;;;1940         //
;;;1941         // If we are in blocking mode, output everything.
;;;1942         //
;;;1943         _PostTerminalSwitch(pRing, TerminalId);
0000b6  4639              MOV      r1,r7
0000b8  9802              LDR      r0,[sp,#8]
0000ba  f7fffffe          BL       _PostTerminalSwitch
;;;1944         Status = (int)_WriteBlocking(pRing, s, FragLen);
0000be  4632              MOV      r2,r6
0000c0  9904              LDR      r1,[sp,#0x10]
0000c2  9802              LDR      r0,[sp,#8]
0000c4  f7fffffe          BL       _WriteBlocking
0000c8  4604              MOV      r4,r0
;;;1945         _PostTerminalSwitch(pRing, _ActiveTerminal);
0000ca  480c              LDR      r0,|L24.252|
0000cc  7801              LDRB     r1,[r0,#0]  ; _ActiveTerminal
0000ce  9802              LDR      r0,[sp,#8]
0000d0  f7fffffe          BL       _PostTerminalSwitch
;;;1946         break;
0000d4  e002              B        |L24.220|
                  |L24.214|
;;;1947       default:
;;;1948         Status = -1;
0000d6  2400              MOVS     r4,#0
0000d8  43e4              MVNS     r4,r4
;;;1949         break;
0000da  bf00              NOP      
                  |L24.220|
0000dc  bf00              NOP                            ;1924
;;;1950       }
;;;1951       //
;;;1952       // Finish up.
;;;1953       //
;;;1954       SEGGER_RTT_UNLOCK();
0000de  9801              LDR      r0,[sp,#4]
0000e0  b2c0              UXTB     r0,r0
0000e2  f3808810          MSR      PRIMASK,r0
0000e6  bf00              NOP      
0000e8  bf00              NOP      
0000ea  e001              B        |L24.240|
                  |L24.236|
;;;1955     } else {
;;;1956       Status = -1;
0000ec  2400              MOVS     r4,#0
0000ee  43e4              MVNS     r4,r4
                  |L24.240|
;;;1957     }
;;;1958     return Status;
0000f0  4620              MOV      r0,r4
;;;1959   }
0000f2  b005              ADD      sp,sp,#0x14
0000f4  bdf0              POP      {r4-r7,pc}
;;;1960   
                          ENDP

0000f6  0000              DCW      0x0000
                  |L24.248|
                          DCD      _SEGGER_RTT
                  |L24.252|
                          DCD      _ActiveTerminal

                          AREA ||i.SEGGER_RTT_WaitKey||, CODE, READONLY, ALIGN=1

                  SEGGER_RTT_WaitKey PROC
;;;1421   */
;;;1422   int SEGGER_RTT_WaitKey(void) {
000000  b510              PUSH     {r4,lr}
;;;1423     int r;
;;;1424   
;;;1425     do {
000002  bf00              NOP      
                  |L25.4|
;;;1426       r = SEGGER_RTT_GetKey();
000004  f7fffffe          BL       SEGGER_RTT_GetKey
;;;1427     } while (r < 0);
000008  2800              CMP      r0,#0
00000a  dbfb              BLT      |L25.4|
;;;1428     return r;
;;;1429   }
00000c  bd10              POP      {r4,pc}
;;;1430   
                          ENDP


                          AREA ||i.SEGGER_RTT_Write||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_Write PROC
;;;1162   */
;;;1163   unsigned SEGGER_RTT_Write(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;1164     unsigned Status;
;;;1165     //
;;;1166     INIT();
000008  bf00              NOP      
00000a  480e              LDR      r0,|L26.68|
00000c  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000e  2800              CMP      r0,#0
000010  d101              BNE      |L26.22|
000012  f7fffffe          BL       _DoInit
                  |L26.22|
000016  bf00              NOP      
;;;1167     SEGGER_RTT_LOCK();
000018  f3ef8010          MRS      r0,PRIMASK
00001c  4607              MOV      r7,r0
00001e  2001              MOVS     r0,#1
000020  f3808810          MSR      PRIMASK,r0
000024  bf00              NOP      
000026  bf00              NOP      
;;;1168     //
;;;1169     // Call the non-locking write function
;;;1170     //
;;;1171     Status = SEGGER_RTT_WriteNoLock(BufferIndex, pBuffer, NumBytes);
000028  4632              MOV      r2,r6
00002a  4629              MOV      r1,r5
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       SEGGER_RTT_WriteNoLock
000032  9000              STR      r0,[sp,#0]
;;;1172     //
;;;1173     // Finish up.
;;;1174     //
;;;1175     SEGGER_RTT_UNLOCK();
000034  b2f8              UXTB     r0,r7
000036  f3808810          MSR      PRIMASK,r0
00003a  bf00              NOP      
00003c  bf00              NOP      
;;;1176     //
;;;1177     return Status;
00003e  9800              LDR      r0,[sp,#0]
;;;1178   }
000040  bdf8              POP      {r3-r7,pc}
;;;1179   
                          ENDP

000042  0000              DCW      0x0000
                  |L26.68|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_WriteDownBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_WriteDownBuffer PROC
;;;1126   */
;;;1127   unsigned SEGGER_RTT_WriteDownBuffer(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;1128     unsigned Status;
;;;1129     //
;;;1130     INIT();
000008  bf00              NOP      
00000a  480e              LDR      r0,|L27.68|
00000c  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000e  2800              CMP      r0,#0
000010  d101              BNE      |L27.22|
000012  f7fffffe          BL       _DoInit
                  |L27.22|
000016  bf00              NOP      
;;;1131     SEGGER_RTT_LOCK();
000018  f3ef8010          MRS      r0,PRIMASK
00001c  4607              MOV      r7,r0
00001e  2001              MOVS     r0,#1
000020  f3808810          MSR      PRIMASK,r0
000024  bf00              NOP      
000026  bf00              NOP      
;;;1132     //
;;;1133     // Call the non-locking write function
;;;1134     //
;;;1135     Status = SEGGER_RTT_WriteDownBufferNoLock(BufferIndex, pBuffer, NumBytes);
000028  4632              MOV      r2,r6
00002a  4629              MOV      r1,r5
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       SEGGER_RTT_WriteDownBufferNoLock
000032  9000              STR      r0,[sp,#0]
;;;1136     //
;;;1137     // Finish up.
;;;1138     //
;;;1139     SEGGER_RTT_UNLOCK();
000034  b2f8              UXTB     r0,r7
000036  f3808810          MSR      PRIMASK,r0
00003a  bf00              NOP      
00003c  bf00              NOP      
;;;1140     //
;;;1141     return Status;
00003e  9800              LDR      r0,[sp,#0]
;;;1142   }
000040  bdf8              POP      {r3-r7,pc}
;;;1143   
                          ENDP

000042  0000              DCW      0x0000
                  |L27.68|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_WriteDownBufferNoLock||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_WriteDownBufferNoLock PROC
;;;973    */
;;;974    unsigned SEGGER_RTT_WriteDownBufferNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
000002  b082              SUB      sp,sp,#8
000004  4607              MOV      r7,r0
000006  4616              MOV      r6,r2
;;;975      unsigned                Status;
;;;976      unsigned                Avail;
;;;977      const char*             pData;
;;;978      SEGGER_RTT_BUFFER_UP*   pRing;
;;;979    
;;;980      pData = (const char *)pBuffer;
000008  9803              LDR      r0,[sp,#0xc]
00000a  9001              STR      r0,[sp,#4]
;;;981      //
;;;982      // Get "to-target" ring buffer.
;;;983      // It is save to cast that to a "to-host" buffer. Up and Down buffer differ in volatility of offsets that might be modified by J-Link.
;;;984      //
;;;985      pRing = (SEGGER_RTT_BUFFER_UP*)&_SEGGER_RTT.aDown[BufferIndex];
00000c  2018              MOVS     r0,#0x18
00000e  4378              MULS     r0,r7,r0
000010  491b              LDR      r1,|L28.128|
000012  1840              ADDS     r0,r0,r1
000014  9000              STR      r0,[sp,#0]
;;;986      //
;;;987      // How we output depends upon the mode...
;;;988      //
;;;989      switch (pRing->Flags) {
000016  9800              LDR      r0,[sp,#0]
000018  6940              LDR      r0,[r0,#0x14]
00001a  2800              CMP      r0,#0
00001c  d004              BEQ      |L28.40|
00001e  2801              CMP      r0,#1
000020  d011              BEQ      |L28.70|
000022  2802              CMP      r0,#2
000024  d126              BNE      |L28.116|
000026  e01e              B        |L28.102|
                  |L28.40|
;;;990      case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
;;;991        //
;;;992        // If we are in skip mode and there is no space for the whole
;;;993        // of this output, don't bother.
;;;994        //
;;;995        Avail = _GetAvailWriteSpace(pRing);
000028  9800              LDR      r0,[sp,#0]
00002a  f7fffffe          BL       _GetAvailWriteSpace
00002e  4605              MOV      r5,r0
;;;996        if (Avail < NumBytes) {
000030  42b5              CMP      r5,r6
000032  d201              BCS      |L28.56|
;;;997          Status = 0u;
000034  2400              MOVS     r4,#0
000036  e005              B        |L28.68|
                  |L28.56|
;;;998        } else {
;;;999          Status = NumBytes;
000038  4634              MOV      r4,r6
;;;1000         _WriteNoCheck(pRing, pData, NumBytes);
00003a  4632              MOV      r2,r6
00003c  9901              LDR      r1,[sp,#4]
00003e  9800              LDR      r0,[sp,#0]
000040  f7fffffe          BL       _WriteNoCheck
                  |L28.68|
;;;1001       }
;;;1002       break;
000044  e018              B        |L28.120|
                  |L28.70|
;;;1003     case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
;;;1004       //
;;;1005       // If we are in trim mode, trim to what we can output without blocking.
;;;1006       //
;;;1007       Avail = _GetAvailWriteSpace(pRing);
000046  9800              LDR      r0,[sp,#0]
000048  f7fffffe          BL       _GetAvailWriteSpace
00004c  4605              MOV      r5,r0
;;;1008       Status = Avail < NumBytes ? Avail : NumBytes;
00004e  42b5              CMP      r5,r6
000050  d201              BCS      |L28.86|
000052  4628              MOV      r0,r5
000054  e000              B        |L28.88|
                  |L28.86|
000056  4630              MOV      r0,r6
                  |L28.88|
000058  4604              MOV      r4,r0
;;;1009       _WriteNoCheck(pRing, pData, Status);
00005a  4622              MOV      r2,r4
00005c  9901              LDR      r1,[sp,#4]
00005e  9800              LDR      r0,[sp,#0]
000060  f7fffffe          BL       _WriteNoCheck
;;;1010       break;
000064  e008              B        |L28.120|
                  |L28.102|
;;;1011     case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
;;;1012       //
;;;1013       // If we are in blocking mode, output everything.
;;;1014       //
;;;1015       Status = _WriteBlocking(pRing, pData, NumBytes);
000066  4632              MOV      r2,r6
000068  9901              LDR      r1,[sp,#4]
00006a  9800              LDR      r0,[sp,#0]
00006c  f7fffffe          BL       _WriteBlocking
000070  4604              MOV      r4,r0
;;;1016       break;
000072  e001              B        |L28.120|
                  |L28.116|
;;;1017     default:
;;;1018       Status = 0u;
000074  2400              MOVS     r4,#0
;;;1019       break;
000076  bf00              NOP      
                  |L28.120|
000078  bf00              NOP                            ;1002
;;;1020     }
;;;1021     //
;;;1022     // Finish up.
;;;1023     //
;;;1024     return Status;
00007a  4620              MOV      r0,r4
;;;1025   }
00007c  b005              ADD      sp,sp,#0x14
00007e  bdf0              POP      {r4-r7,pc}
;;;1026   
                          ENDP

                  |L28.128|
                          DCD      _SEGGER_RTT+0x60

                          AREA ||i.SEGGER_RTT_WriteNoLock||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_WriteNoLock PROC
;;;1049   */
;;;1050   unsigned SEGGER_RTT_WriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
000002  b082              SUB      sp,sp,#8
000004  4607              MOV      r7,r0
000006  4616              MOV      r6,r2
;;;1051     unsigned              Status;
;;;1052     unsigned              Avail;
;;;1053     const char*           pData;
;;;1054     SEGGER_RTT_BUFFER_UP* pRing;
;;;1055   
;;;1056     pData = (const char *)pBuffer;
000008  9803              LDR      r0,[sp,#0xc]
00000a  9001              STR      r0,[sp,#4]
;;;1057     //
;;;1058     // Get "to-host" ring buffer.
;;;1059     //
;;;1060     pRing = &_SEGGER_RTT.aUp[BufferIndex];
00000c  2018              MOVS     r0,#0x18
00000e  4378              MULS     r0,r7,r0
000010  491b              LDR      r1,|L29.128|
000012  1840              ADDS     r0,r0,r1
000014  9000              STR      r0,[sp,#0]
;;;1061     //
;;;1062     // How we output depends upon the mode...
;;;1063     //
;;;1064     switch (pRing->Flags) {
000016  9800              LDR      r0,[sp,#0]
000018  6940              LDR      r0,[r0,#0x14]
00001a  2800              CMP      r0,#0
00001c  d004              BEQ      |L29.40|
00001e  2801              CMP      r0,#1
000020  d011              BEQ      |L29.70|
000022  2802              CMP      r0,#2
000024  d126              BNE      |L29.116|
000026  e01e              B        |L29.102|
                  |L29.40|
;;;1065     case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
;;;1066       //
;;;1067       // If we are in skip mode and there is no space for the whole
;;;1068       // of this output, don't bother.
;;;1069       //
;;;1070       Avail = _GetAvailWriteSpace(pRing);
000028  9800              LDR      r0,[sp,#0]
00002a  f7fffffe          BL       _GetAvailWriteSpace
00002e  4605              MOV      r5,r0
;;;1071       if (Avail < NumBytes) {
000030  42b5              CMP      r5,r6
000032  d201              BCS      |L29.56|
;;;1072         Status = 0u;
000034  2400              MOVS     r4,#0
000036  e005              B        |L29.68|
                  |L29.56|
;;;1073       } else {
;;;1074         Status = NumBytes;
000038  4634              MOV      r4,r6
;;;1075         _WriteNoCheck(pRing, pData, NumBytes);
00003a  4632              MOV      r2,r6
00003c  9901              LDR      r1,[sp,#4]
00003e  9800              LDR      r0,[sp,#0]
000040  f7fffffe          BL       _WriteNoCheck
                  |L29.68|
;;;1076       }
;;;1077       break;
000044  e018              B        |L29.120|
                  |L29.70|
;;;1078     case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
;;;1079       //
;;;1080       // If we are in trim mode, trim to what we can output without blocking.
;;;1081       //
;;;1082       Avail = _GetAvailWriteSpace(pRing);
000046  9800              LDR      r0,[sp,#0]
000048  f7fffffe          BL       _GetAvailWriteSpace
00004c  4605              MOV      r5,r0
;;;1083       Status = Avail < NumBytes ? Avail : NumBytes;
00004e  42b5              CMP      r5,r6
000050  d201              BCS      |L29.86|
000052  4628              MOV      r0,r5
000054  e000              B        |L29.88|
                  |L29.86|
000056  4630              MOV      r0,r6
                  |L29.88|
000058  4604              MOV      r4,r0
;;;1084       _WriteNoCheck(pRing, pData, Status);
00005a  4622              MOV      r2,r4
00005c  9901              LDR      r1,[sp,#4]
00005e  9800              LDR      r0,[sp,#0]
000060  f7fffffe          BL       _WriteNoCheck
;;;1085       break;
000064  e008              B        |L29.120|
                  |L29.102|
;;;1086     case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
;;;1087       //
;;;1088       // If we are in blocking mode, output everything.
;;;1089       //
;;;1090       Status = _WriteBlocking(pRing, pData, NumBytes);
000066  4632              MOV      r2,r6
000068  9901              LDR      r1,[sp,#4]
00006a  9800              LDR      r0,[sp,#0]
00006c  f7fffffe          BL       _WriteBlocking
000070  4604              MOV      r4,r0
;;;1091       break;
000072  e001              B        |L29.120|
                  |L29.116|
;;;1092     default:
;;;1093       Status = 0u;
000074  2400              MOVS     r4,#0
;;;1094       break;
000076  bf00              NOP      
                  |L29.120|
000078  bf00              NOP                            ;1077
;;;1095     }
;;;1096     //
;;;1097     // Finish up.
;;;1098     //
;;;1099     return Status;
00007a  4620              MOV      r0,r4
;;;1100   }
00007c  b005              ADD      sp,sp,#0x14
00007e  bdf0              POP      {r4-r7,pc}
;;;1101   
                          ENDP

                  |L29.128|
                          DCD      _SEGGER_RTT+0x18

                          AREA ||i.SEGGER_RTT_WriteSkipNoLock||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_WriteSkipNoLock PROC
;;;889    #if (RTT_USE_ASM == 0)
;;;890    unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
000002  b084              SUB      sp,sp,#0x10
000004  4615              MOV      r5,r2
;;;891      const char*           pData;
;;;892      SEGGER_RTT_BUFFER_UP* pRing;
;;;893      unsigned              Avail;
;;;894      unsigned              RdOff;
;;;895      unsigned              WrOff;
;;;896      unsigned              Rem;
;;;897      //
;;;898      // Cases:
;;;899      //   1) RdOff <= WrOff => Space until wrap-around is sufficient
;;;900      //   2) RdOff <= WrOff => Space after wrap-around needed (copy in 2 chunks)
;;;901      //   3) RdOff <  WrOff => No space in buf
;;;902      //   4) RdOff >  WrOff => Space is sufficient
;;;903      //   5) RdOff >  WrOff => No space in buf
;;;904      //
;;;905      // 1) is the most common case for large buffers and assuming that J-Link reads the data fast enough
;;;906      //
;;;907      pData = (const char *)pBuffer;
000006  9805              LDR      r0,[sp,#0x14]
000008  9003              STR      r0,[sp,#0xc]
;;;908      pRing = &_SEGGER_RTT.aUp[BufferIndex];
00000a  2118              MOVS     r1,#0x18
00000c  9804              LDR      r0,[sp,#0x10]
00000e  4348              MULS     r0,r1,r0
000010  491e              LDR      r1,|L30.140|
000012  1844              ADDS     r4,r0,r1
;;;909      RdOff = pRing->RdOff;
000014  6920              LDR      r0,[r4,#0x10]
000016  9002              STR      r0,[sp,#8]
;;;910      WrOff = pRing->WrOff;
000018  68e6              LDR      r6,[r4,#0xc]
;;;911      if (RdOff <= WrOff) {                                 // Case 1), 2) or 3)
00001a  9802              LDR      r0,[sp,#8]
00001c  42b0              CMP      r0,r6
00001e  d82c              BHI      |L30.122|
;;;912        Avail = pRing->SizeOfBuffer - WrOff - 1u;           // Space until wrap-around (assume 1 byte not usable for case that RdOff == 0)
000020  68a0              LDR      r0,[r4,#8]
000022  1b80              SUBS     r0,r0,r6
000024  1e47              SUBS     r7,r0,#1
;;;913        if (Avail >= NumBytes) {                            // Case 1)?
000026  42af              CMP      r7,r5
000028  d30b              BCC      |L30.66|
;;;914    CopyStraight:
00002a  bf00              NOP      
                  |L30.44|
;;;915          memcpy(pRing->pBuffer + WrOff, pData, NumBytes);
00002c  6861              LDR      r1,[r4,#4]
00002e  1988              ADDS     r0,r1,r6
000030  462a              MOV      r2,r5
000032  9903              LDR      r1,[sp,#0xc]
000034  f7fffffe          BL       __aeabi_memcpy
;;;916          pRing->WrOff = WrOff + NumBytes;
000038  1970              ADDS     r0,r6,r5
00003a  60e0              STR      r0,[r4,#0xc]
;;;917          return 1;
00003c  2001              MOVS     r0,#1
                  |L30.62|
;;;918        }
;;;919        Avail += RdOff;                                     // Space incl. wrap-around
;;;920        if (Avail >= NumBytes) {                            // Case 2? => If not, we have case 3) (does not fit)
;;;921          Rem = pRing->SizeOfBuffer - WrOff;                // Space until end of buffer
;;;922          memcpy(pRing->pBuffer + WrOff, pData, Rem);       // Copy 1st chunk
;;;923          NumBytes -= Rem;
;;;924          //
;;;925          // Special case: First check that assumed RdOff == 0 calculated that last element before wrap-around could not be used
;;;926          // But 2nd check (considering space until wrap-around and until RdOff) revealed that RdOff is not 0, so we can use the last element
;;;927          // In this case, we may use a copy straight until buffer end anyway without needing to copy 2 chunks
;;;928          // Therefore, check if 2nd memcpy is necessary at all
;;;929          //
;;;930          if (NumBytes) {
;;;931            memcpy(pRing->pBuffer, pData + Rem, NumBytes);
;;;932          }
;;;933          pRing->WrOff = NumBytes;
;;;934          return 1;
;;;935        }
;;;936      } else {                                             // Potential case 4)
;;;937        Avail = RdOff - WrOff - 1u;
;;;938        if (Avail >= NumBytes) {                           // Case 4)? => If not, we have case 5) (does not fit)
;;;939          goto CopyStraight;
;;;940        }
;;;941      }
;;;942      return 0;     // No space in buffer
;;;943    }
00003e  b007              ADD      sp,sp,#0x1c
000040  bdf0              POP      {r4-r7,pc}
                  |L30.66|
000042  9802              LDR      r0,[sp,#8]            ;919
000044  183f              ADDS     r7,r7,r0              ;919
000046  42af              CMP      r7,r5                 ;920
000048  d31d              BCC      |L30.134|
00004a  68a0              LDR      r0,[r4,#8]            ;921
00004c  1b80              SUBS     r0,r0,r6              ;921
00004e  9001              STR      r0,[sp,#4]            ;921
000050  6861              LDR      r1,[r4,#4]            ;922
000052  1988              ADDS     r0,r1,r6              ;922
000054  9a01              LDR      r2,[sp,#4]            ;922
000056  9903              LDR      r1,[sp,#0xc]          ;922
000058  f7fffffe          BL       __aeabi_memcpy
00005c  9801              LDR      r0,[sp,#4]            ;923
00005e  1a2d              SUBS     r5,r5,r0              ;923
000060  2d00              CMP      r5,#0                 ;930
000062  d007              BEQ      |L30.116|
000064  9a01              LDR      r2,[sp,#4]            ;931
000066  9803              LDR      r0,[sp,#0xc]          ;931
000068  1881              ADDS     r1,r0,r2              ;931
00006a  462a              MOV      r2,r5                 ;931
00006c  6863              LDR      r3,[r4,#4]            ;931
00006e  4618              MOV      r0,r3                 ;931
000070  f7fffffe          BL       __aeabi_memcpy
                  |L30.116|
000074  60e5              STR      r5,[r4,#0xc]          ;933
000076  2001              MOVS     r0,#1                 ;934
000078  e7e1              B        |L30.62|
                  |L30.122|
00007a  9802              LDR      r0,[sp,#8]            ;937
00007c  1b80              SUBS     r0,r0,r6              ;937
00007e  1e47              SUBS     r7,r0,#1              ;937
000080  42af              CMP      r7,r5                 ;938
000082  d300              BCC      |L30.134|
000084  e7d2              B        |L30.44|
                  |L30.134|
000086  2000              MOVS     r0,#0                 ;942
000088  e7d9              B        |L30.62|
;;;944    #endif
                          ENDP

00008a  0000              DCW      0x0000
                  |L30.140|
                          DCD      _SEGGER_RTT+0x18

                          AREA ||i.SEGGER_RTT_WriteString||, CODE, READONLY, ALIGN=1

                  SEGGER_RTT_WriteString PROC
;;;1199   */
;;;1200   unsigned SEGGER_RTT_WriteString(unsigned BufferIndex, const char* s) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1201     unsigned Len;
;;;1202   
;;;1203     Len = STRLEN(s);
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       strlen
00000c  4606              MOV      r6,r0
;;;1204     return SEGGER_RTT_Write(BufferIndex, s, Len);
00000e  4632              MOV      r2,r6
000010  4621              MOV      r1,r4
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       SEGGER_RTT_Write
;;;1205   }
000018  bd70              POP      {r4-r6,pc}
;;;1206   
                          ENDP


                          AREA ||i.SEGGER_RTT_WriteWithOverwriteNoLock||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_WriteWithOverwriteNoLock PROC
;;;789    */
;;;790    void SEGGER_RTT_WriteWithOverwriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
000002  b082              SUB      sp,sp,#8
000004  4607              MOV      r7,r0
000006  4616              MOV      r6,r2
;;;791      const char*           pData;
;;;792      SEGGER_RTT_BUFFER_UP* pRing;
;;;793      unsigned              Avail;
;;;794    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;795      char*                 pDst;
;;;796    #endif
;;;797    
;;;798      pData = (const char *)pBuffer;
000008  9803              LDR      r0,[sp,#0xc]
00000a  9001              STR      r0,[sp,#4]
;;;799      //
;;;800      // Get "to-host" ring buffer and copy some elements into local variables.
;;;801      //
;;;802      pRing = &_SEGGER_RTT.aUp[BufferIndex];
00000c  2018              MOVS     r0,#0x18
00000e  4378              MULS     r0,r7,r0
000010  4925              LDR      r1,|L32.168|
000012  1844              ADDS     r4,r0,r1
;;;803      //
;;;804      // Check if we will overwrite data and need to adjust the RdOff.
;;;805      //
;;;806      if (pRing->WrOff == pRing->RdOff) {
000014  6921              LDR      r1,[r4,#0x10]
000016  68e0              LDR      r0,[r4,#0xc]
000018  4288              CMP      r0,r1
00001a  d102              BNE      |L32.34|
;;;807        Avail = pRing->SizeOfBuffer - 1u;
00001c  68a0              LDR      r0,[r4,#8]
00001e  1e45              SUBS     r5,r0,#1
000020  e00e              B        |L32.64|
                  |L32.34|
;;;808      } else if ( pRing->WrOff < pRing->RdOff) {
000022  6921              LDR      r1,[r4,#0x10]
000024  68e0              LDR      r0,[r4,#0xc]
000026  4288              CMP      r0,r1
000028  d204              BCS      |L32.52|
;;;809        Avail = pRing->RdOff - pRing->WrOff - 1u;
00002a  6920              LDR      r0,[r4,#0x10]
00002c  68e1              LDR      r1,[r4,#0xc]
00002e  1a40              SUBS     r0,r0,r1
000030  1e45              SUBS     r5,r0,#1
000032  e005              B        |L32.64|
                  |L32.52|
;;;810      } else {
;;;811        Avail = pRing->RdOff - pRing->WrOff - 1u + pRing->SizeOfBuffer;
000034  6920              LDR      r0,[r4,#0x10]
000036  68e1              LDR      r1,[r4,#0xc]
000038  1a40              SUBS     r0,r0,r1
00003a  1e40              SUBS     r0,r0,#1
00003c  68a1              LDR      r1,[r4,#8]
00003e  1845              ADDS     r5,r0,r1
                  |L32.64|
;;;812      }
;;;813      if (NumBytes > Avail) {
000040  42ae              CMP      r6,r5
000042  d90c              BLS      |L32.94|
;;;814        pRing->RdOff += (NumBytes - Avail);
000044  6920              LDR      r0,[r4,#0x10]
000046  1b71              SUBS     r1,r6,r5
000048  1840              ADDS     r0,r0,r1
00004a  6120              STR      r0,[r4,#0x10]
;;;815        while (pRing->RdOff >= pRing->SizeOfBuffer) {
00004c  e003              B        |L32.86|
                  |L32.78|
;;;816          pRing->RdOff -= pRing->SizeOfBuffer;
00004e  6920              LDR      r0,[r4,#0x10]
000050  68a1              LDR      r1,[r4,#8]
000052  1a40              SUBS     r0,r0,r1
000054  6120              STR      r0,[r4,#0x10]
                  |L32.86|
000056  6920              LDR      r0,[r4,#0x10]         ;815
000058  68a1              LDR      r1,[r4,#8]            ;815
00005a  4288              CMP      r0,r1                 ;815
00005c  d2f7              BCS      |L32.78|
                  |L32.94|
;;;817        }
;;;818      }
;;;819      //
;;;820      // Write all data, no need to check the RdOff, but possibly handle multiple wrap-arounds
;;;821      //
;;;822      Avail = pRing->SizeOfBuffer - pRing->WrOff;
00005e  68e1              LDR      r1,[r4,#0xc]
000060  68a0              LDR      r0,[r4,#8]
000062  1a45              SUBS     r5,r0,r1
;;;823      do {
000064  bf00              NOP      
                  |L32.102|
;;;824        if (Avail > NumBytes) {
000066  42b5              CMP      r5,r6
000068  d90a              BLS      |L32.128|
;;;825          //
;;;826          // Last round
;;;827          //
;;;828    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;829          pDst = pRing->pBuffer + pRing->WrOff;
;;;830          Avail = NumBytes;
;;;831          while (NumBytes--) {
;;;832            *pDst++ = *pData++;
;;;833          };
;;;834          pRing->WrOff += Avail;
;;;835    #else
;;;836          SEGGER_RTT_MEMCPY(pRing->pBuffer + pRing->WrOff, pData, NumBytes);
00006a  68e2              LDR      r2,[r4,#0xc]
00006c  6861              LDR      r1,[r4,#4]
00006e  1888              ADDS     r0,r1,r2
000070  4632              MOV      r2,r6
000072  9901              LDR      r1,[sp,#4]
000074  f7fffffe          BL       __aeabi_memcpy
;;;837          pRing->WrOff += NumBytes;
000078  68e0              LDR      r0,[r4,#0xc]
00007a  1980              ADDS     r0,r0,r6
00007c  60e0              STR      r0,[r4,#0xc]
;;;838    #endif
;;;839          break;
00007e  e010              B        |L32.162|
                  |L32.128|
;;;840        } else {
;;;841          //
;;;842          //  Wrap-around necessary, write until wrap-around and reset WrOff
;;;843          //
;;;844    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;845          pDst = pRing->pBuffer + pRing->WrOff;
;;;846          NumBytes -= Avail;
;;;847          while (Avail--) {
;;;848            *pDst++ = *pData++;
;;;849          };
;;;850          pRing->WrOff = 0;
;;;851    #else
;;;852          SEGGER_RTT_MEMCPY(pRing->pBuffer + pRing->WrOff, pData, Avail);
000080  68e2              LDR      r2,[r4,#0xc]
000082  6861              LDR      r1,[r4,#4]
000084  1888              ADDS     r0,r1,r2
000086  462a              MOV      r2,r5
000088  9901              LDR      r1,[sp,#4]
00008a  f7fffffe          BL       __aeabi_memcpy
;;;853          pData += Avail;
00008e  9801              LDR      r0,[sp,#4]
000090  1940              ADDS     r0,r0,r5
000092  9001              STR      r0,[sp,#4]
;;;854          pRing->WrOff = 0;
000094  2000              MOVS     r0,#0
000096  60e0              STR      r0,[r4,#0xc]
;;;855          NumBytes -= Avail;
000098  1b76              SUBS     r6,r6,r5
;;;856    #endif
;;;857          Avail = (pRing->SizeOfBuffer - 1);
00009a  68a0              LDR      r0,[r4,#8]
00009c  1e45              SUBS     r5,r0,#1
;;;858        }
;;;859      } while (NumBytes);
00009e  2e00              CMP      r6,#0
0000a0  d1e1              BNE      |L32.102|
                  |L32.162|
0000a2  bf00              NOP                            ;839
;;;860    }
0000a4  b005              ADD      sp,sp,#0x14
0000a6  bdf0              POP      {r4-r7,pc}
;;;861    
                          ENDP

                  |L32.168|
                          DCD      _SEGGER_RTT+0x18

                          AREA ||i._DoInit||, CODE, READONLY, ALIGN=2

                  _DoInit PROC
;;;274                    } while (0)
;;;275    static void _DoInit(void) {
000000  b510              PUSH     {r4,lr}
;;;276      SEGGER_RTT_CB* p;
;;;277      //
;;;278      // Initialize control block
;;;279      //
;;;280      p = &_SEGGER_RTT;
000002  4c12              LDR      r4,|L33.76|
;;;281      p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
000004  2003              MOVS     r0,#3
000006  6120              STR      r0,[r4,#0x10]
;;;282      p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
000008  6160              STR      r0,[r4,#0x14]
;;;283      //
;;;284      // Initialize up buffer 0
;;;285      //
;;;286      p->aUp[0].sName         = "Terminal";
00000a  a011              ADR      r0,|L33.80|
00000c  61a0              STR      r0,[r4,#0x18]
;;;287      p->aUp[0].pBuffer       = _acUpBuffer;
00000e  4913              LDR      r1,|L33.92|
000010  61e1              STR      r1,[r4,#0x1c]
;;;288      p->aUp[0].SizeOfBuffer  = sizeof(_acUpBuffer);
000012  2101              MOVS     r1,#1
000014  0289              LSLS     r1,r1,#10
000016  6221              STR      r1,[r4,#0x20]
;;;289      p->aUp[0].RdOff         = 0u;
000018  2100              MOVS     r1,#0
00001a  62a1              STR      r1,[r4,#0x28]
;;;290      p->aUp[0].WrOff         = 0u;
00001c  6261              STR      r1,[r4,#0x24]
;;;291      p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
00001e  62e1              STR      r1,[r4,#0x2c]
;;;292      //
;;;293      // Initialize down buffer 0
;;;294      //
;;;295      p->aDown[0].sName         = "Terminal";
000020  a00b              ADR      r0,|L33.80|
000022  6620              STR      r0,[r4,#0x60]
;;;296      p->aDown[0].pBuffer       = _acDownBuffer;
000024  490e              LDR      r1,|L33.96|
000026  6661              STR      r1,[r4,#0x64]
;;;297      p->aDown[0].SizeOfBuffer  = sizeof(_acDownBuffer);
000028  2110              MOVS     r1,#0x10
00002a  66a1              STR      r1,[r4,#0x68]
;;;298      p->aDown[0].RdOff         = 0u;
00002c  2100              MOVS     r1,#0
00002e  6721              STR      r1,[r4,#0x70]
;;;299      p->aDown[0].WrOff         = 0u;
000030  66e1              STR      r1,[r4,#0x6c]
;;;300      p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
000032  6761              STR      r1,[r4,#0x74]
;;;301      //
;;;302      // Finish initialization of the control block.
;;;303      // Copy Id string in three steps to make sure "SEGGER RTT" is not found
;;;304      // in initializer memory (usually flash) by J-Link
;;;305      //
;;;306      STRCPY(&p->acID[7], "RTT", 9);
000034  a10b              ADR      r1,|L33.100|
000036  1de0              ADDS     r0,r4,#7
000038  f7fffffe          BL       strcpy
;;;307      STRCPY(&p->acID[0], "SEGGER", 7);
00003c  a10a              ADR      r1,|L33.104|
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       strcpy
;;;308      p->acID[6] = ' ';
000044  2020              MOVS     r0,#0x20
000046  71a0              STRB     r0,[r4,#6]
;;;309    }
000048  bd10              POP      {r4,pc}
;;;310    
                          ENDP

00004a  0000              DCW      0x0000
                  |L33.76|
                          DCD      _SEGGER_RTT
                  |L33.80|
000050  5465726d          DCB      "Terminal",0
000054  696e616c
000058  00      
000059  00                DCB      0
00005a  00                DCB      0
00005b  00                DCB      0
                  |L33.92|
                          DCD      _acUpBuffer
                  |L33.96|
                          DCD      _acDownBuffer
                  |L33.100|
000064  52545400          DCB      "RTT",0
                  |L33.104|
000068  53454747          DCB      "SEGGER",0
00006c  455200  
00006f  00                DCB      0

                          AREA ||i._GetAvailWriteSpace||, CODE, READONLY, ALIGN=1

                  _GetAvailWriteSpace PROC
;;;479    */
;;;480    static unsigned _GetAvailWriteSpace(SEGGER_RTT_BUFFER_UP* pRing) {
000000  b510              PUSH     {r4,lr}
000002  4601              MOV      r1,r0
;;;481      unsigned RdOff;
;;;482      unsigned WrOff;
;;;483      unsigned r;
;;;484      //
;;;485      // Avoid warnings regarding volatile access order.  It's not a problem
;;;486      // in this case, but dampen compiler enthusiasm.
;;;487      //
;;;488      RdOff = pRing->RdOff;
000004  690a              LDR      r2,[r1,#0x10]
;;;489      WrOff = pRing->WrOff;
000006  68cb              LDR      r3,[r1,#0xc]
;;;490      if (RdOff <= WrOff) {
000008  429a              CMP      r2,r3
00000a  d804              BHI      |L34.22|
;;;491        r = pRing->SizeOfBuffer - 1u - WrOff + RdOff;
00000c  688c              LDR      r4,[r1,#8]
00000e  1e64              SUBS     r4,r4,#1
000010  1ae4              SUBS     r4,r4,r3
000012  18a0              ADDS     r0,r4,r2
000014  e001              B        |L34.26|
                  |L34.22|
;;;492      } else {
;;;493        r = RdOff - WrOff - 1u;
000016  1ad4              SUBS     r4,r2,r3
000018  1e60              SUBS     r0,r4,#1
                  |L34.26|
;;;494      }
;;;495      return r;
;;;496    }
00001a  bd10              POP      {r4,pc}
;;;497    
                          ENDP


                          AREA ||i._PostTerminalSwitch||, CODE, READONLY, ALIGN=2

                  _PostTerminalSwitch PROC
;;;457    */
;;;458    static void _PostTerminalSwitch(SEGGER_RTT_BUFFER_UP* pRing, unsigned char TerminalId) {
000000  b538              PUSH     {r3-r5,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;459      unsigned char ac[2];
;;;460    
;;;461      ac[0] = 0xFFu;
000006  21ff              MOVS     r1,#0xff
000008  4668              MOV      r0,sp
00000a  7001              STRB     r1,[r0,#0]
;;;462      ac[1] = _aTerminalId[TerminalId];  // Caller made already sure that TerminalId does not exceed our terminal limit
00000c  4804              LDR      r0,|L35.32|
00000e  5d01              LDRB     r1,[r0,r4]
000010  4668              MOV      r0,sp
000012  7041              STRB     r1,[r0,#1]
;;;463      _WriteBlocking(pRing, (const char*)ac, 2u);
000014  2202              MOVS     r2,#2
000016  4669              MOV      r1,sp
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       _WriteBlocking
;;;464    }
00001e  bd38              POP      {r3-r5,pc}
;;;465    
                          ENDP

                  |L35.32|
                          DCD      _aTerminalId

                          AREA ||i._WriteBlocking||, CODE, READONLY, ALIGN=1

                  _WriteBlocking PROC
;;;329    */
;;;330    static unsigned _WriteBlocking(SEGGER_RTT_BUFFER_UP* pRing, const char* pBuffer, unsigned NumBytes) {
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
000002  b082              SUB      sp,sp,#8
000004  4604              MOV      r4,r0
000006  4617              MOV      r7,r2
;;;331      unsigned NumBytesToWrite;
;;;332      unsigned NumBytesWritten;
;;;333      unsigned RdOff;
;;;334      unsigned WrOff;
;;;335    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;336      char*    pDst;
;;;337    #endif
;;;338      //
;;;339      // Write data to buffer and handle wrap-around if necessary
;;;340      //
;;;341      NumBytesWritten = 0u;
000008  2000              MOVS     r0,#0
00000a  9001              STR      r0,[sp,#4]
;;;342      WrOff = pRing->WrOff;
00000c  68e5              LDR      r5,[r4,#0xc]
;;;343      do {
00000e  bf00              NOP      
                  |L36.16|
;;;344        RdOff = pRing->RdOff;                         // May be changed by host (debug probe) in the meantime
000010  6920              LDR      r0,[r4,#0x10]
000012  9000              STR      r0,[sp,#0]
;;;345        if (RdOff > WrOff) {
000014  9800              LDR      r0,[sp,#0]
000016  42a8              CMP      r0,r5
000018  d903              BLS      |L36.34|
;;;346          NumBytesToWrite = RdOff - WrOff - 1u;
00001a  9800              LDR      r0,[sp,#0]
00001c  1b40              SUBS     r0,r0,r5
00001e  1e46              SUBS     r6,r0,#1
000020  e004              B        |L36.44|
                  |L36.34|
;;;347        } else {
;;;348          NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
000022  68a1              LDR      r1,[r4,#8]
000024  9800              LDR      r0,[sp,#0]
000026  1a28              SUBS     r0,r5,r0
000028  1c40              ADDS     r0,r0,#1
00002a  1a0e              SUBS     r6,r1,r0
                  |L36.44|
;;;349        }
;;;350        NumBytesToWrite = MIN(NumBytesToWrite, (pRing->SizeOfBuffer - WrOff));      // Number of bytes that can be written until buffer wrap-around
00002c  68a0              LDR      r0,[r4,#8]
00002e  1b40              SUBS     r0,r0,r5
000030  42b0              CMP      r0,r6
000032  d901              BLS      |L36.56|
000034  4630              MOV      r0,r6
000036  e001              B        |L36.60|
                  |L36.56|
000038  68a0              LDR      r0,[r4,#8]
00003a  1b40              SUBS     r0,r0,r5
                  |L36.60|
00003c  4606              MOV      r6,r0
;;;351        NumBytesToWrite = MIN(NumBytesToWrite, NumBytes);
00003e  42be              CMP      r6,r7
000040  d201              BCS      |L36.70|
000042  4630              MOV      r0,r6
000044  e000              B        |L36.72|
                  |L36.70|
000046  4638              MOV      r0,r7
                  |L36.72|
000048  4606              MOV      r6,r0
;;;352    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;353        pDst = pRing->pBuffer + WrOff;
;;;354        NumBytesWritten += NumBytesToWrite;
;;;355        NumBytes        -= NumBytesToWrite;
;;;356        WrOff           += NumBytesToWrite;
;;;357        while (NumBytesToWrite--) {
;;;358          *pDst++ = *pBuffer++;
;;;359        };
;;;360    #else
;;;361        SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pBuffer, NumBytesToWrite);
00004a  6861              LDR      r1,[r4,#4]
00004c  1948              ADDS     r0,r1,r5
00004e  4632              MOV      r2,r6
000050  9903              LDR      r1,[sp,#0xc]
000052  f7fffffe          BL       __aeabi_memcpy
;;;362        NumBytesWritten += NumBytesToWrite;
000056  9801              LDR      r0,[sp,#4]
000058  1980              ADDS     r0,r0,r6
00005a  9001              STR      r0,[sp,#4]
;;;363        pBuffer         += NumBytesToWrite;
00005c  9803              LDR      r0,[sp,#0xc]
00005e  1980              ADDS     r0,r0,r6
000060  9003              STR      r0,[sp,#0xc]
;;;364        NumBytes        -= NumBytesToWrite;
000062  1bbf              SUBS     r7,r7,r6
;;;365        WrOff           += NumBytesToWrite;
000064  19ad              ADDS     r5,r5,r6
;;;366    #endif
;;;367        if (WrOff == pRing->SizeOfBuffer) {
000066  68a0              LDR      r0,[r4,#8]
000068  42a8              CMP      r0,r5
00006a  d100              BNE      |L36.110|
;;;368          WrOff = 0u;
00006c  2500              MOVS     r5,#0
                  |L36.110|
;;;369        }
;;;370        pRing->WrOff = WrOff;
00006e  60e5              STR      r5,[r4,#0xc]
;;;371      } while (NumBytes);
000070  2f00              CMP      r7,#0
000072  d1cd              BNE      |L36.16|
;;;372      //
;;;373      return NumBytesWritten;
000074  9801              LDR      r0,[sp,#4]
;;;374    }
000076  b005              ADD      sp,sp,#0x14
000078  bdf0              POP      {r4-r7,pc}
;;;375    
                          ENDP


                          AREA ||i._WriteNoCheck||, CODE, READONLY, ALIGN=1

                  _WriteNoCheck PROC
;;;393    */
;;;394    static void _WriteNoCheck(SEGGER_RTT_BUFFER_UP* pRing, const char* pData, unsigned NumBytes) {
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
000002  b082              SUB      sp,sp,#8
000004  4604              MOV      r4,r0
000006  4615              MOV      r5,r2
;;;395      unsigned NumBytesAtOnce;
;;;396      unsigned WrOff;
;;;397      unsigned Rem;
;;;398    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;399      char*    pDst;
;;;400    #endif
;;;401    
;;;402      WrOff = pRing->WrOff;
000008  68e6              LDR      r6,[r4,#0xc]
;;;403      Rem = pRing->SizeOfBuffer - WrOff;
00000a  68a0              LDR      r0,[r4,#8]
00000c  1b87              SUBS     r7,r0,r6
;;;404      if (Rem > NumBytes) {
00000e  42af              CMP      r7,r5
000010  d908              BLS      |L37.36|
;;;405        //
;;;406        // All data fits before wrap around
;;;407        //
;;;408    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;409        pDst = pRing->pBuffer + WrOff;
;;;410        WrOff += NumBytes;
;;;411        while (NumBytes--) {
;;;412          *pDst++ = *pData++;
;;;413        };
;;;414        pRing->WrOff = WrOff;
;;;415    #else
;;;416        SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pData, NumBytes);
000012  6861              LDR      r1,[r4,#4]
000014  1988              ADDS     r0,r1,r6
000016  462a              MOV      r2,r5
000018  9903              LDR      r1,[sp,#0xc]
00001a  f7fffffe          BL       __aeabi_memcpy
;;;417        pRing->WrOff = WrOff + NumBytes;
00001e  1970              ADDS     r0,r6,r5
000020  60e0              STR      r0,[r4,#0xc]
000022  e010              B        |L37.70|
                  |L37.36|
;;;418    #endif
;;;419      } else {
;;;420        //
;;;421        // We reach the end of the buffer, so need to wrap around
;;;422        //
;;;423    #if SEGGER_RTT_MEMCPY_USE_BYTELOOP
;;;424        pDst = pRing->pBuffer + WrOff;
;;;425        NumBytesAtOnce = Rem;
;;;426        while (NumBytesAtOnce--) {
;;;427          *pDst++ = *pData++;
;;;428        };
;;;429        pDst = pRing->pBuffer;
;;;430        NumBytesAtOnce = NumBytes - Rem;
;;;431        while (NumBytesAtOnce--) {
;;;432          *pDst++ = *pData++;
;;;433        };
;;;434        pRing->WrOff = NumBytes - Rem;
;;;435    #else
;;;436        NumBytesAtOnce = Rem;
000024  9701              STR      r7,[sp,#4]
;;;437        SEGGER_RTT_MEMCPY(pRing->pBuffer + WrOff, pData, NumBytesAtOnce);
000026  6861              LDR      r1,[r4,#4]
000028  1988              ADDS     r0,r1,r6
00002a  9a01              LDR      r2,[sp,#4]
00002c  9903              LDR      r1,[sp,#0xc]
00002e  f7fffffe          BL       __aeabi_memcpy
;;;438        NumBytesAtOnce = NumBytes - Rem;
000032  1be8              SUBS     r0,r5,r7
000034  9001              STR      r0,[sp,#4]
;;;439        SEGGER_RTT_MEMCPY(pRing->pBuffer, pData + Rem, NumBytesAtOnce);
000036  9a03              LDR      r2,[sp,#0xc]
000038  19d1              ADDS     r1,r2,r7
00003a  6860              LDR      r0,[r4,#4]
00003c  9a01              LDR      r2,[sp,#4]
00003e  f7fffffe          BL       __aeabi_memcpy
;;;440        pRing->WrOff = NumBytesAtOnce;
000042  9801              LDR      r0,[sp,#4]
000044  60e0              STR      r0,[r4,#0xc]
                  |L37.70|
;;;441    #endif
;;;442      }
;;;443    }
000046  b005              ADD      sp,sp,#0x14
000048  bdf0              POP      {r4-r7,pc}
;;;444    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  _SEGGER_RTT
                          %        168
                  _acUpBuffer
                          %        1024
                  _acDownBuffer
                          %        16

                          AREA ||.data||, DATA, ALIGN=0

                  _aTerminalId
000000  30313233          DCB      0x30,0x31,0x32,0x33
000004  34353637          DCB      0x34,0x35,0x36,0x37
000008  38394142          DCB      0x38,0x39,0x41,0x42
00000c  43444546          DCB      0x43,0x44,0x45,0x46
                  _ActiveTerminal
000010  00                DCB      0x00
