; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\eeprom.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\eeprom.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\FTLib\CMSIS\inc -I..\FTLib\Inc -I..\FTLib\Lib -I..\usb\inc -I..\user -I..\RTT -IC:\Users\Tom\AppData\Local\Arm\Packs\FMD\FT32F0xx_DFP\1.0.2\Drivers\CMSIS\FT32F0xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=533 -DFT32F072x8 -DFT32F072x8 --omf_browse=.\objects\eeprom.crf ..\user\eeprom.c]
                          THUMB

                          AREA ||i.eeprom_config||, CODE, READONLY, ALIGN=1

                  eeprom_config PROC
;;;80     
;;;81     void eeprom_config(eeprom_t* eeprom, size_t start, size_t size, size_t flash_start)
000000  b5f8              PUSH     {r3-r7,lr}
;;;82     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
;;;83     	if( eeprom != NULL && (eeprom->init == 0xBB || eeprom->init == 0xAA) )
00000a  2c00              CMP      r4,#0
00000c  d015              BEQ      |L1.58|
00000e  7d20              LDRB     r0,[r4,#0x14]
000010  28bb              CMP      r0,#0xbb
000012  d002              BEQ      |L1.26|
000014  7d20              LDRB     r0,[r4,#0x14]
000016  28aa              CMP      r0,#0xaa
000018  d10f              BNE      |L1.58|
                  |L1.26|
;;;84     	{
;;;85     		eeprom->size = size;
00001a  4621              MOV      r1,r4
00001c  3108              ADDS     r1,r1,#8
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       __aeabi_uwrite4
;;;86     		eeprom->start = start;
000024  1d21              ADDS     r1,r4,#4
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       __aeabi_uwrite4
;;;87     		eeprom->flash_start = flash_start;
00002c  4621              MOV      r1,r4
00002e  310c              ADDS     r1,r1,#0xc
000030  4638              MOV      r0,r7
000032  f7fffffe          BL       __aeabi_uwrite4
;;;88     		eeprom->init = 0xBB;
000036  20bb              MOVS     r0,#0xbb
000038  7520              STRB     r0,[r4,#0x14]
                  |L1.58|
;;;89     	}
;;;90     }
00003a  bdf8              POP      {r3-r7,pc}
;;;91     
                          ENDP


                          AREA ||i.eeprom_free||, CODE, READONLY, ALIGN=1

                  eeprom_free PROC
;;;310    
;;;311    void eeprom_free(eeprom_t* eeprom)
000000  b510              PUSH     {r4,lr}
;;;312    {
000002  4604              MOV      r4,r0
;;;313    	if(eeprom != NULL && eeprom->init == 0xCC)
000004  2c00              CMP      r4,#0
000006  d006              BEQ      |L2.22|
000008  7d20              LDRB     r0,[r4,#0x14]
00000a  28cc              CMP      r0,#0xcc
00000c  d103              BNE      |L2.22|
;;;314    	{
;;;315    		memset(eeprom, 0x00, sizeof(eeprom_t));
00000e  211d              MOVS     r1,#0x1d
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       __aeabi_memclr
                  |L2.22|
;;;316    	}
;;;317    }
000016  bd10              POP      {r4,pc}
;;;318    
                          ENDP


                          AREA ||i.eeprom_init||, CODE, READONLY, ALIGN=1

                  eeprom_init PROC
;;;59     
;;;60     void eeprom_init(eeprom_t* eeprom, uint8_t* buffer, size_t len)
000000  b570              PUSH     {r4-r6,lr}
;;;61     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;62     	if(eeprom != NULL)
000008  2c00              CMP      r4,#0
00000a  d011              BEQ      |L3.48|
;;;63     	{
;;;64     		if(buffer != NULL)
00000c  2d00              CMP      r5,#0
00000e  d00f              BEQ      |L3.48|
;;;65     		{
;;;66     			memset(buffer, 0xFF, len);
000010  22ff              MOVS     r2,#0xff
000012  4631              MOV      r1,r6
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       __aeabi_memset
;;;67     			eeprom->buffer = buffer;
00001a  4621              MOV      r1,r4
00001c  3110              ADDS     r1,r1,#0x10
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       __aeabi_uwrite4
;;;68     			eeprom->page_size = len;
000024  4621              MOV      r1,r4
000026  4630              MOV      r0,r6
000028  f7fffffe          BL       __aeabi_uwrite4
;;;69     			eeprom->init = 0xAA;
00002c  20aa              MOVS     r0,#0xaa
00002e  7520              STRB     r0,[r4,#0x14]
                  |L3.48|
;;;70     		}
;;;71     	}
;;;72     }
000030  bd70              POP      {r4-r6,pc}
;;;73     
                          ENDP


                          AREA ||i.eeprom_read||, CODE, READONLY, ALIGN=1

                  eeprom_read PROC
;;;133    
;;;134    size_t eeprom_read(eeprom_t* eeprom, size_t addr, uint8_t* data, size_t len)
000000  b5ff              PUSH     {r0-r7,lr}
;;;135    {
000002  b081              SUB      sp,sp,#4
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;136    	
;;;137    	size_t i;
;;;138    	size_t conut = 0;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;139    	
;;;140    	if( eeprom != NULL && eeprom->init == 0xCC )
00000c  2c00              CMP      r4,#0
00000e  d029              BEQ      |L4.100|
000010  7d20              LDRB     r0,[r4,#0x14]
000012  28cc              CMP      r0,#0xcc
000014  d126              BNE      |L4.100|
;;;141    	{	
;;;142    		if( data == NULL || ( addr + len ) > ( eeprom->start + eeprom->size ) )
000016  9803              LDR      r0,[sp,#0xc]
000018  2800              CMP      r0,#0
00001a  d00c              BEQ      |L4.54|
00001c  1d20              ADDS     r0,r4,#4
00001e  f7fffffe          BL       __aeabi_uread4
000022  4607              MOV      r7,r0
000024  4620              MOV      r0,r4
000026  3008              ADDS     r0,r0,#8
000028  f7fffffe          BL       __aeabi_uread4
00002c  1839              ADDS     r1,r7,r0
00002e  9804              LDR      r0,[sp,#0x10]
000030  1828              ADDS     r0,r5,r0
000032  4281              CMP      r1,r0
000034  d202              BCS      |L4.60|
                  |L4.54|
;;;143    		{
;;;144    			return 0;
000036  2000              MOVS     r0,#0
                  |L4.56|
;;;145    		}
;;;146    
;;;147    		for( i = addr; i < addr + len; ++i )
;;;148    		{
;;;149    			data[conut++] = read_byte( eeprom->start, i );
;;;150    		}
;;;151    		
;;;152    	}
;;;153    	return conut;
;;;154    }
000038  b005              ADD      sp,sp,#0x14
00003a  bdf0              POP      {r4-r7,pc}
                  |L4.60|
00003c  462e              MOV      r6,r5                 ;147
00003e  e00d              B        |L4.92|
                  |L4.64|
000040  1d20              ADDS     r0,r4,#4              ;149
000042  f7fffffe          BL       __aeabi_uread4
000046  4607              MOV      r7,r0                 ;149
000048  4631              MOV      r1,r6                 ;149
00004a  f7fffffe          BL       read_byte
00004e  4601              MOV      r1,r0                 ;149
000050  9800              LDR      r0,[sp,#0]            ;149
000052  1c42              ADDS     r2,r0,#1              ;149
000054  9200              STR      r2,[sp,#0]            ;149
000056  9a03              LDR      r2,[sp,#0xc]          ;149
000058  5411              STRB     r1,[r2,r0]            ;149
00005a  1c76              ADDS     r6,r6,#1              ;147
                  |L4.92|
00005c  9804              LDR      r0,[sp,#0x10]         ;147
00005e  1828              ADDS     r0,r5,r0              ;147
000060  42b0              CMP      r0,r6                 ;147
000062  d8ed              BHI      |L4.64|
                  |L4.100|
000064  9800              LDR      r0,[sp,#0]            ;153
000066  e7e7              B        |L4.56|
;;;155    
                          ENDP


                          AREA ||i.eeprom_register||, CODE, READONLY, ALIGN=1

                  eeprom_register PROC
;;;98     
;;;99     void eeprom_register(eeprom_t* eeprom, erase_t erase, write_t write)
000000  b570              PUSH     {r4-r6,lr}
;;;100    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;101    	if( eeprom != NULL && (eeprom->init == 0xBB || eeprom->init == 0xAA) )
000008  2c00              CMP      r4,#0
00000a  d011              BEQ      |L5.48|
00000c  7d20              LDRB     r0,[r4,#0x14]
00000e  28bb              CMP      r0,#0xbb
000010  d002              BEQ      |L5.24|
000012  7d20              LDRB     r0,[r4,#0x14]
000014  28aa              CMP      r0,#0xaa
000016  d10b              BNE      |L5.48|
                  |L5.24|
;;;102    	{
;;;103    		eeprom->write = write;
000018  4621              MOV      r1,r4
00001a  3119              ADDS     r1,r1,#0x19
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       __aeabi_uwrite4
;;;104    		eeprom->erase = erase;
000022  4621              MOV      r1,r4
000024  3115              ADDS     r1,r1,#0x15
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       __aeabi_uwrite4
;;;105    		eeprom->init = 0xCC;
00002c  20cc              MOVS     r0,#0xcc
00002e  7520              STRB     r0,[r4,#0x14]
                  |L5.48|
;;;106    	}
;;;107    }
000030  bd70              POP      {r4-r6,pc}
;;;108    
                          ENDP


                          AREA ||i.eeprom_write||, CODE, READONLY, ALIGN=1

                  eeprom_write PROC
;;;280    
;;;281    void eeprom_write(eeprom_t* eeprom, size_t addr, const uint8_t* data, size_t len)
000000  b5ff              PUSH     {r0-r7,lr}
;;;282    {
000002  b0ff              SUB      sp,sp,#0x1fc
000004  b0c2              SUB      sp,sp,#0x108
000006  4605              MOV      r5,r0
;;;283    	int i, page_num = 0;
000008  2600              MOVS     r6,#0
;;;284    	page_data_t pdata[64];
;;;285    	
;;;286    	if(eeprom != NULL && eeprom->init == 0xCC)
00000a  2d00              CMP      r5,#0
00000c  d027              BEQ      |L6.94|
00000e  7d28              LDRB     r0,[r5,#0x14]
000010  28cc              CMP      r0,#0xcc
000012  d124              BNE      |L6.94|
;;;287    	{	
;;;288    		page_num = verify_data(eeprom, addr, data, len, pdata);
000014  a801              ADD      r0,sp,#4
000016  9000              STR      r0,[sp,#0]
000018  4628              MOV      r0,r5
00001a  a9c2              ADD      r1,sp,#0x308
00001c  c90e              LDM      r1,{r1-r3}
00001e  f7fffffe          BL       verify_data
000022  4606              MOV      r6,r0
;;;289    		if(page_num > 1)
000024  2e01              CMP      r6,#1
000026  dd14              BLE      |L6.82|
;;;290    		{
;;;291    			/*需要跨页*/
;;;292    			for(i = 0; i < page_num; ++i)
000028  2400              MOVS     r4,#0
00002a  e00f              B        |L6.76|
                  |L6.44|
;;;293    			{
;;;294    				eeprom_write_nverify(eeprom, pdata[i].addr, pdata[i].data, pdata[i].len);
00002c  200c              MOVS     r0,#0xc
00002e  4360              MULS     r0,r4,r0
000030  af01              ADD      r7,sp,#4
000032  19c0              ADDS     r0,r0,r7
000034  6843              LDR      r3,[r0,#4]
000036  200c              MOVS     r0,#0xc
000038  4360              MULS     r0,r4,r0
00003a  19c0              ADDS     r0,r0,r7
00003c  6882              LDR      r2,[r0,#8]
00003e  200c              MOVS     r0,#0xc
000040  4360              MULS     r0,r4,r0
000042  5839              LDR      r1,[r7,r0]
000044  4628              MOV      r0,r5
000046  f7fffffe          BL       eeprom_write_nverify
00004a  1c64              ADDS     r4,r4,#1              ;292
                  |L6.76|
00004c  42b4              CMP      r4,r6                 ;292
00004e  dbed              BLT      |L6.44|
000050  e005              B        |L6.94|
                  |L6.82|
;;;295    			}
;;;296    		}
;;;297    		else
;;;298    		{
;;;299    			/*不需要跨页*/
;;;300    			eeprom_write_nverify(eeprom, pdata[0].addr, pdata[0].data, pdata[0].len);
000052  4628              MOV      r0,r5
000054  9b02              LDR      r3,[sp,#8]
000056  9a03              LDR      r2,[sp,#0xc]
000058  9901              LDR      r1,[sp,#4]
00005a  f7fffffe          BL       eeprom_write_nverify
                  |L6.94|
;;;301    		}
;;;302    	}
;;;303    }
00005e  b07f              ADD      sp,sp,#0x1fc
000060  b046              ADD      sp,sp,#0x118
000062  bdf0              POP      {r4-r7,pc}
;;;304    
                          ENDP


                          AREA ||i.eeprom_write_nverify||, CODE, READONLY, ALIGN=1

                  eeprom_write_nverify PROC
;;;190    
;;;191    static void eeprom_write_nverify(eeprom_t* eeprom, uint32_t addr, const uint8_t* data, size_t len)
000000  b5ff              PUSH     {r0-r7,lr}
;;;192    {
000002  b085              SUB      sp,sp,#0x14
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;193    	int i;
;;;194    	uint32_t tdata;
;;;195    	size_t offset, page_addr;
;;;196    	
;;;197    	
;;;198    	/*读页到缓存*/
;;;199    	page_addr = eeprom->start + ( ( (addr - eeprom->start) / eeprom->page_size ) * eeprom->page_size );	
000008  1d20              ADDS     r0,r4,#4
00000a  f7fffffe          BL       __aeabi_uread4
00000e  4607              MOV      r7,r0
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       __aeabi_uread4
000016  9002              STR      r0,[sp,#8]
000018  1d20              ADDS     r0,r4,#4
00001a  f7fffffe          BL       __aeabi_uread4
00001e  1a30              SUBS     r0,r6,r0
000020  9001              STR      r0,[sp,#4]
000022  9902              LDR      r1,[sp,#8]
000024  f7fffffe          BL       __aeabi_uidivmod
000028  4605              MOV      r5,r0
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       __aeabi_uread4
000030  4345              MULS     r5,r0,r5
000032  1978              ADDS     r0,r7,r5
000034  9003              STR      r0,[sp,#0xc]
;;;200    	for(int i = 0; i < eeprom->page_size; ++i)
000036  2500              MOVS     r5,#0
000038  e00a              B        |L7.80|
                  |L7.58|
;;;201    	{
;;;202    		eeprom->buffer[i] = read_byte(page_addr, i);
00003a  4629              MOV      r1,r5
00003c  9803              LDR      r0,[sp,#0xc]
00003e  f7fffffe          BL       read_byte
000042  4607              MOV      r7,r0
000044  4620              MOV      r0,r4
000046  3010              ADDS     r0,r0,#0x10
000048  f7fffffe          BL       __aeabi_uread4
00004c  5547              STRB     r7,[r0,r5]
00004e  1c6d              ADDS     r5,r5,#1              ;200
                  |L7.80|
000050  4620              MOV      r0,r4                 ;200
000052  f7fffffe          BL       __aeabi_uread4
000056  42a8              CMP      r0,r5                 ;200
000058  d8ef              BHI      |L7.58|
;;;203    	}
;;;204    	
;;;205    	/*写数据到缓存*/
;;;206    	offset = addr % eeprom->page_size;
00005a  4620              MOV      r0,r4
00005c  f7fffffe          BL       __aeabi_uread4
000060  4605              MOV      r5,r0
000062  4629              MOV      r1,r5
000064  4630              MOV      r0,r6
000066  f7fffffe          BL       __aeabi_uidivmod
00006a  9104              STR      r1,[sp,#0x10]
;;;207    	memcpy( eeprom->buffer + offset, data, len );
00006c  4620              MOV      r0,r4
00006e  3010              ADDS     r0,r0,#0x10
000070  f7fffffe          BL       __aeabi_uread4
000074  9904              LDR      r1,[sp,#0x10]
000076  1845              ADDS     r5,r0,r1
000078  4628              MOV      r0,r5
00007a  9a08              LDR      r2,[sp,#0x20]
00007c  9907              LDR      r1,[sp,#0x1c]
00007e  f7fffffe          BL       __aeabi_memcpy
;;;208    	
;;;209    	
;;;210    	/*擦除并写缓存到Flash页*/
;;;211    	eeprom->erase( addr );
000082  4620              MOV      r0,r4
000084  3015              ADDS     r0,r0,#0x15
000086  f7fffffe          BL       __aeabi_uread4
00008a  4605              MOV      r5,r0
00008c  4630              MOV      r0,r6
00008e  47a8              BLX      r5
;;;212    	eeprom_write_page( eeprom, addr);
000090  4631              MOV      r1,r6
000092  4620              MOV      r0,r4
000094  f7fffffe          BL       eeprom_write_page
;;;213    	
;;;214    	//清缓冲区
;;;215    	memset(eeprom->buffer, 0xFF, eeprom->page_size);
000098  4620              MOV      r0,r4
00009a  f7fffffe          BL       __aeabi_uread4
00009e  4605              MOV      r5,r0
0000a0  4620              MOV      r0,r4
0000a2  3010              ADDS     r0,r0,#0x10
0000a4  f7fffffe          BL       __aeabi_uread4
0000a8  4607              MOV      r7,r0
0000aa  22ff              MOVS     r2,#0xff
0000ac  4629              MOV      r1,r5
0000ae  f7fffffe          BL       __aeabi_memset
;;;216    	
;;;217    }
0000b2  b009              ADD      sp,sp,#0x24
0000b4  bdf0              POP      {r4-r7,pc}
;;;218    
                          ENDP


                          AREA ||i.eeprom_write_page||, CODE, READONLY, ALIGN=1

                  eeprom_write_page PROC
;;;159    //页写
;;;160    static void eeprom_write_page(eeprom_t* eeprom, uint32_t addr)
000000  b5fe              PUSH     {r1-r7,lr}
;;;161    {
000002  4606              MOV      r6,r0
000004  460f              MOV      r7,r1
;;;162    	size_t i; 
;;;163    	size_t write_addr = addr - addr % eeprom->page_size;
000006  4630              MOV      r0,r6
000008  f7fffffe          BL       __aeabi_uread4
00000c  4601              MOV      r1,r0
00000e  9000              STR      r0,[sp,#0]
000010  4638              MOV      r0,r7
000012  f7fffffe          BL       __aeabi_uidivmod
000016  1a78              SUBS     r0,r7,r1
000018  9001              STR      r0,[sp,#4]
;;;164    	uint32_t data = 0x00;
00001a  2500              MOVS     r5,#0
;;;165    
;;;166    	for(i = 0; i < eeprom->page_size; ++i)
00001c  2400              MOVS     r4,#0
00001e  e028              B        |L8.114|
                  |L8.32|
;;;167    	{	
;;;168    		if(i % 4 == 0)
000020  07a0              LSLS     r0,r4,#30
000022  0f80              LSRS     r0,r0,#30
000024  2800              CMP      r0,#0
000026  d123              BNE      |L8.112|
;;;169    		{
;;;170    			data |= eeprom->buffer[i + 3];
000028  4630              MOV      r0,r6
00002a  3010              ADDS     r0,r0,#0x10
00002c  f7fffffe          BL       __aeabi_uread4
000030  1ce1              ADDS     r1,r4,#3
000032  5c40              LDRB     r0,[r0,r1]
000034  4305              ORRS     r5,r5,r0
;;;171    			data <<= 8;
000036  022d              LSLS     r5,r5,#8
;;;172    			data |= eeprom->buffer[i + 2];
000038  4630              MOV      r0,r6
00003a  3010              ADDS     r0,r0,#0x10
00003c  f7fffffe          BL       __aeabi_uread4
000040  1ca1              ADDS     r1,r4,#2
000042  5c40              LDRB     r0,[r0,r1]
000044  4305              ORRS     r5,r5,r0
;;;173    			data <<= 8;
000046  022d              LSLS     r5,r5,#8
;;;174    			data |= eeprom->buffer[i + 1];
000048  4630              MOV      r0,r6
00004a  3010              ADDS     r0,r0,#0x10
00004c  f7fffffe          BL       __aeabi_uread4
000050  1c61              ADDS     r1,r4,#1
000052  5c40              LDRB     r0,[r0,r1]
000054  4305              ORRS     r5,r5,r0
;;;175    			data <<= 8;
000056  022d              LSLS     r5,r5,#8
;;;176    			data |= eeprom->buffer[i];
000058  4630              MOV      r0,r6
00005a  3010              ADDS     r0,r0,#0x10
00005c  f7fffffe          BL       __aeabi_uread4
000060  5d00              LDRB     r0,[r0,r4]
000062  4305              ORRS     r5,r5,r0
;;;177    			
;;;178    			write_word( write_addr + i, data); 
000064  9901              LDR      r1,[sp,#4]
000066  1908              ADDS     r0,r1,r4
000068  4629              MOV      r1,r5
00006a  f7fffffe          BL       write_word
;;;179    			data = 0;
00006e  2500              MOVS     r5,#0
                  |L8.112|
000070  1c64              ADDS     r4,r4,#1              ;166
                  |L8.114|
000072  4630              MOV      r0,r6                 ;166
000074  f7fffffe          BL       __aeabi_uread4
000078  42a0              CMP      r0,r4                 ;166
00007a  d8d1              BHI      |L8.32|
;;;180    		}
;;;181    	}	
;;;182    }
00007c  bdfe              POP      {r1-r7,pc}
;;;183    
                          ENDP


                          AREA ||i.erase_page||, CODE, READONLY, ALIGN=1

                  erase_page PROC
;;;23     
;;;24     void erase_page(uint32_t addr)
000000  b510              PUSH     {r4,lr}
;;;25     {
000002  4604              MOV      r4,r0
;;;26     	FLASH_Unlock();
000004  f7fffffe          BL       FLASH_Unlock
;;;27     	FLASH_ClearFlag(FLASH_FLAG_EOP | FLASH_FLAG_PGERR | FLASH_FLAG_WRPERR);
000008  2034              MOVS     r0,#0x34
00000a  f7fffffe          BL       FLASH_ClearFlag
;;;28     	while(FLASH_ErasePage(addr) != FLASH_COMPLETE);
00000e  bf00              NOP      
                  |L9.16|
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       FLASH_ErasePage
000016  2804              CMP      r0,#4
000018  d1fa              BNE      |L9.16|
;;;29     	FLASH_Lock();
00001a  f7fffffe          BL       FLASH_Lock
;;;30     }
00001e  bd10              POP      {r4,pc}
;;;31     
                          ENDP


                          AREA ||i.verify_data||, CODE, READONLY, ALIGN=1

                  verify_data PROC
;;;224    
;;;225    static int verify_data(eeprom_t* eeprom, size_t addr, const uint8_t* data, size_t len, page_data_t* pdata)
000000  b5ff              PUSH     {r0-r7,lr}
;;;226    {
000002  b087              SUB      sp,sp,#0x1c
000004  461e              MOV      r6,r3
;;;227    	
;;;228    	uint8_t exit = 0;
000006  2000              MOVS     r0,#0
000008  9006              STR      r0,[sp,#0x18]
;;;229    	size_t write_len = 0;
00000a  9005              STR      r0,[sp,#0x14]
;;;230    	size_t page_count = 0;
00000c  2400              MOVS     r4,#0
;;;231    	size_t current_len = len;
00000e  bf00              NOP      
;;;232    	uint8_t* current_data = (uint8_t*)data;
000010  9809              LDR      r0,[sp,#0x24]
000012  9004              STR      r0,[sp,#0x10]
;;;233    	size_t current_addr = addr;
000014  9808              LDR      r0,[sp,#0x20]
000016  9003              STR      r0,[sp,#0xc]
;;;234    	size_t offset = ( addr / eeprom->page_size ) * eeprom->page_size;
000018  9807              LDR      r0,[sp,#0x1c]
00001a  f7fffffe          BL       __aeabi_uread4
00001e  4601              MOV      r1,r0
000020  9001              STR      r0,[sp,#4]
000022  9808              LDR      r0,[sp,#0x20]
000024  f7fffffe          BL       __aeabi_uidivmod
000028  4607              MOV      r7,r0
00002a  9807              LDR      r0,[sp,#0x1c]
00002c  f7fffffe          BL       __aeabi_uread4
000030  4347              MULS     r7,r0,r7
000032  9702              STR      r7,[sp,#8]
;;;235    
;;;236    	/*跨页*/
;;;237    	while(1)
000034  e053              B        |L10.222|
                  |L10.54|
;;;238    	{
;;;239    		//地址 = 当页flash地址 + 偏移地址
;;;240    		current_addr = offset + ( eeprom->start + (page_count * eeprom->page_size) ) + ( current_addr % eeprom->page_size );	
000036  9807              LDR      r0,[sp,#0x1c]
000038  1d00              ADDS     r0,r0,#4
00003a  f7fffffe          BL       __aeabi_uread4
00003e  4607              MOV      r7,r0
000040  9807              LDR      r0,[sp,#0x1c]
000042  f7fffffe          BL       __aeabi_uread4
000046  4360              MULS     r0,r4,r0
000048  1839              ADDS     r1,r7,r0
00004a  9802              LDR      r0,[sp,#8]
00004c  180f              ADDS     r7,r1,r0
00004e  9807              LDR      r0,[sp,#0x1c]
000050  f7fffffe          BL       __aeabi_uread4
000054  4601              MOV      r1,r0
000056  9001              STR      r0,[sp,#4]
000058  9803              LDR      r0,[sp,#0xc]
00005a  f7fffffe          BL       __aeabi_uidivmod
00005e  1878              ADDS     r0,r7,r1
000060  9003              STR      r0,[sp,#0xc]
;;;241    		pdata[page_count].addr = current_addr;
000062  200c              MOVS     r0,#0xc
000064  4360              MULS     r0,r4,r0
000066  9a10              LDR      r2,[sp,#0x40]
000068  1881              ADDS     r1,r0,r2
00006a  9803              LDR      r0,[sp,#0xc]
00006c  f7fffffe          BL       __aeabi_uwrite4
;;;242    		
;;;243    		//指针每次都加上一次的写入长度
;;;244    		pdata[page_count].data = current_data;	
000070  200c              MOVS     r0,#0xc
000072  4360              MULS     r0,r4,r0
000074  9a10              LDR      r2,[sp,#0x40]
000076  1880              ADDS     r0,r0,r2
000078  4601              MOV      r1,r0
00007a  3108              ADDS     r1,r1,#8
00007c  9804              LDR      r0,[sp,#0x10]
00007e  f7fffffe          BL       __aeabi_uwrite4
;;;245    		
;;;246    		//长度 = 页大小 - 偏移地址
;;;247    		current_len = eeprom->page_size - current_addr % eeprom->page_size;	
000082  9807              LDR      r0,[sp,#0x1c]
000084  f7fffffe          BL       __aeabi_uread4
000088  4607              MOV      r7,r0
00008a  9807              LDR      r0,[sp,#0x1c]
00008c  f7fffffe          BL       __aeabi_uread4
000090  4601              MOV      r1,r0
000092  9001              STR      r0,[sp,#4]
000094  9803              LDR      r0,[sp,#0xc]
000096  f7fffffe          BL       __aeabi_uidivmod
00009a  1a7d              SUBS     r5,r7,r1
;;;248    		write_len += current_len;
00009c  9805              LDR      r0,[sp,#0x14]
00009e  1940              ADDS     r0,r0,r5
0000a0  9005              STR      r0,[sp,#0x14]
;;;249    		if(write_len >= len)
0000a2  9805              LDR      r0,[sp,#0x14]
0000a4  42b0              CMP      r0,r6
0000a6  d307              BCC      |L10.184|
;;;250    		{
;;;251    			if(write_len > len)
0000a8  9805              LDR      r0,[sp,#0x14]
0000aa  42b0              CMP      r0,r6
0000ac  d902              BLS      |L10.180|
;;;252    			{
;;;253    				current_len -= write_len - len;
0000ae  9805              LDR      r0,[sp,#0x14]
0000b0  1b80              SUBS     r0,r0,r6
0000b2  1a2d              SUBS     r5,r5,r0
                  |L10.180|
;;;254    			}
;;;255    			exit = 1;
0000b4  2001              MOVS     r0,#1
0000b6  9006              STR      r0,[sp,#0x18]
                  |L10.184|
;;;256    		}
;;;257    		pdata[page_count].len = current_len;
0000b8  200c              MOVS     r0,#0xc
0000ba  4360              MULS     r0,r4,r0
0000bc  9a10              LDR      r2,[sp,#0x40]
0000be  1880              ADDS     r0,r0,r2
0000c0  1d01              ADDS     r1,r0,#4
0000c2  4628              MOV      r0,r5
0000c4  f7fffffe          BL       __aeabi_uwrite4
;;;258    		page_count++;
0000c8  1c64              ADDS     r4,r4,#1
;;;259    		
;;;260    		if(exit)
0000ca  9806              LDR      r0,[sp,#0x18]
0000cc  2800              CMP      r0,#0
0000ce  d000              BEQ      |L10.210|
;;;261    		{
;;;262    			break;
0000d0  e006              B        |L10.224|
                  |L10.210|
;;;263    		}
;;;264    		
;;;265    		current_addr += current_len;
0000d2  9803              LDR      r0,[sp,#0xc]
0000d4  1940              ADDS     r0,r0,r5
0000d6  9003              STR      r0,[sp,#0xc]
;;;266    		current_data += current_len;
0000d8  9804              LDR      r0,[sp,#0x10]
0000da  1940              ADDS     r0,r0,r5
0000dc  9004              STR      r0,[sp,#0x10]
                  |L10.222|
0000de  e7aa              B        |L10.54|
                  |L10.224|
0000e0  bf00              NOP                            ;262
;;;267    	}
;;;268    
;;;269    	return page_count;
0000e2  4620              MOV      r0,r4
;;;270    }
0000e4  b00b              ADD      sp,sp,#0x2c
0000e6  bdf0              POP      {r4-r7,pc}
;;;271    
                          ENDP


                          AREA ||i.write_word||, CODE, READONLY, ALIGN=1

                  write_word PROC
;;;38     
;;;39     uint8_t write_word(size_t addr, size_t data)
000000  b570              PUSH     {r4-r6,lr}
;;;40     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;41     	
;;;42     	FLASH_Status status;
;;;43     	
;;;44     	FLASH_Unlock();
000006  f7fffffe          BL       FLASH_Unlock
;;;45     	FLASH_ClearFlag(FLASH_FLAG_EOP | FLASH_FLAG_PGERR | FLASH_FLAG_WRPERR);
00000a  2034              MOVS     r0,#0x34
00000c  f7fffffe          BL       FLASH_ClearFlag
;;;46     	status = FLASH_ProgramWord(addr, data);
000010  4629              MOV      r1,r5
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       FLASH_ProgramWord
000018  4606              MOV      r6,r0
;;;47     	FLASH_Lock();
00001a  f7fffffe          BL       FLASH_Lock
;;;48     	
;;;49     	return status;
00001e  4630              MOV      r0,r6
;;;50     }
000020  bd70              POP      {r4-r6,pc}
;;;51     
                          ENDP


                          AREA ||i.read_byte||, COMGROUP=read_byte, CODE, READONLY, ALIGN=1

                  read_byte PROC
;;;115    
;;;116    inline uint8_t read_byte(size_t eeprom_start, size_t addr)
000000  b570              PUSH     {r4-r6,lr}
;;;117    {
000002  4602              MOV      r2,r0
;;;118    
;;;119    	uint8_t byte = addr % 4;
000004  078b              LSLS     r3,r1,#30
000006  0f9b              LSRS     r3,r3,#30
;;;120    	uint32_t byte4 = addr / 4;
000008  088c              LSRS     r4,r1,#2
;;;121    	uint32_t d = 0x00;
00000a  2500              MOVS     r5,#0
;;;122    
;;;123    	d = *(uint32_t*)(eeprom_start + (byte4 * 4));
00000c  00a0              LSLS     r0,r4,#2
00000e  5815              LDR      r5,[r2,r0]
;;;124    	return d >> (byte * 8) & 0xFF;
000010  00de              LSLS     r6,r3,#3
000012  4628              MOV      r0,r5
000014  40f0              LSRS     r0,r0,r6
000016  b2c0              UXTB     r0,r0
;;;125    }
000018  bd70              POP      {r4-r6,pc}
;;;126    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\user\\eeprom.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_eeprom_c_1ce4894d____REV16|
#line 129 "..\\FTLib\\CMSIS\\inc\\core_cmInstr.h"
|__asm___8_eeprom_c_1ce4894d____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_eeprom_c_1ce4894d____REVSH|
#line 144
|__asm___8_eeprom_c_1ce4894d____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
