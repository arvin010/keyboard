L 1 "..\FTLib\Src\ft32f0xx_tim.c"
N/**
N  ******************************************************************************
N  * @file    			ft32f0xx_tim.c
N  * @author  			FMD AE
N  * @brief   			This file provides firmware functions to manage the following 
N  *          			functionalities of the TIM peripheral:
N  *            		+ TimeBase management
N  *            		+ Output Compare management
N  *            		+ Input Capture management
N  *            		+ Interrupts, DMA and flags management
N  *            		+ Clocks management
N  *            		+ Synchronization management
N  *            		+ Specific interface management
N  *            		+ Specific remapping management     
N  * @version 			V1.0.0           
N  * @data		 			2021-07-01
N	******************************************************************************
N  */
N
N/* Includes ------------------------------------------------------------------*/
N#include "ft32f0xx_tim.h"
L 1 "..\FTLib\Inc\ft32f0xx_tim.h" 1
N/**
N  ******************************************************************************
N  * @file    			ft32f0xx_tim.h
N  * @author  			FMD AE
N  * @brief   			This file contains all the functions prototypes for the TIM 
N  *          			firmware library. 
N  * @version 			V1.0.0           
N  * @data		 			2021-07-01
N  ******************************************************************************
N  */
N
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __FT32F0XX_TIM_H
N#define __FT32F0XX_TIM_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "ft32f0xx.h"
L 1 "..\FTLib\CMSIS\inc\ft32f0xx.h" 1
N/**
N  ******************************************************************************
N  * @file    			ft32f0xx.h
N  * @author  			FMD AE
N  * @brief   			CMSIS FT32F0xx Device Peripheral Access Layer Header File.    	
N  * @version 			V1.0.0           
N  * @data		 			2021-07-01
N  ******************************************************************************
N  */
N
N#ifndef __FT32F0xx_H
N#define __FT32F0xx_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif /* __cplusplus */
N 
N
N#if !defined  (FT32F0)
X#if !0L
N#define FT32F0
N#endif /* FT32F0 */
N
N
N
N/**
N  * @brief CMSIS Device version number V2.3.3
N  */
N#define __FT32F0_DEVICE_VERSION_MAIN   (0x02) /*!< [31:24] main version */
N#define __FT32F0_DEVICE_VERSION_SUB1   (0x03) /*!< [23:16] sub1 version */
N#define __FT32F0_DEVICE_VERSION_SUB2   (0x03) /*!< [15:8]  sub2 version */
N#define __FT32F0_DEVICE_VERSION_RC     (0x00) /*!< [7:0]  release candidate */ 
N#define __FT32F0_DEVICE_VERSION        ((__FT32F0_DEVICE_VERSION_MAIN << 24)\
N                                        |(__FT32F0_DEVICE_VERSION_SUB1 << 16)\
N                                        |(__FT32F0_DEVICE_VERSION_SUB2 << 8 )\
N                                        |(__FT32F0_DEVICE_VERSION_RC))
X#define __FT32F0_DEVICE_VERSION        ((__FT32F0_DEVICE_VERSION_MAIN << 24)                                        |(__FT32F0_DEVICE_VERSION_SUB1 << 16)                                        |(__FT32F0_DEVICE_VERSION_SUB2 << 8 )                                        |(__FT32F0_DEVICE_VERSION_RC))
N                                             
N
N/* Exported macro ------------------------------------------------------------*/
N#ifdef  USE_FULL_ASSERT
S
S  #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
S/* Exported functions ------------------------------------------------------- */
S  void assert_failed(uint8_t* file, uint32_t line);
N#else
N  #define assert_param(expr) ((void)0)
N#endif /* USE_FULL_ASSERT */
N
N#if defined(FT32F030x6)
X#if 0L
S  #include "ft32f030x6.h"
S#elif defined(FT32F030x8)
X#elif 0L
S  #include "ft32f030x8.h"
N#elif defined(FT32F072x8)
X#elif 1L
N  #include "ft32f072x8.h" 
L 1 "..\FTLib\CMSIS\inc\ft32f072x8.h" 1
N/**
N  ******************************************************************************
N  * @file    			ft32f072x8.h
N  * @author  			FMD AE
N  * @brief   			CMSIS Cortex-M0 Device Peripheral Access Layer Header File. 
N  * @details 			This file contains all the peripheral register's definitions, bits 
N  *          			definitions and memory mapping for FT32F072X8 devices.  
N  * @version 			V1.0.0
N  * @date    			2021-07-01 
N  *******************************************************************************	
N  */
N
N/** @addtogroup CMSIS
N  * @{
N  */
N
N/** @addtogroup ft32f030x8
N  * @{
N  */
N    
N#ifndef __FT32F072X8_H
N#define __FT32F072X8_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif 
N  
N/** @addtogroup Library_configuration_section
N  * @{
N  */
N  
N/* Uncomment the line below according to the target FT32F0 device used in your 
N   application 
N  */
N
N#if !defined (FT32F072X8)
X#if !0L
N  #define FT32F072X8 
N#endif
N
N/*  Tip: To avoid modifying this file each time you need to switch between these
N        devices, you can define the device in your toolchain compiler preprocessor.
N  */
N
N
N#if !defined  USE_STDPERIPH_DRIVER
X#if !0L
N/**
N * @brief Comment the line below if you will not use the peripherals drivers.
N   In this case, these drivers will not be included and the application code will 
N   be based on direct access to peripherals registers 
N   */
N  /*#define USE_STDPERIPH_DRIVER*/
N#endif /* USE_STDPERIPH_DRIVER */
N
N/**
N * @brief In the following line adjust the value of External High Speed oscillator (HSE)
N   used in your application 
N   
N   Tip: To avoid modifying this file each time you need to use different HSE, you
N        can define the HSE value in your toolchain compiler preprocessor.
N  */
N#if !defined  (HSE_VALUE)     
X#if !0L     
N#define HSE_VALUE    ((uint32_t)8000000) /*!< Value of the External oscillator in Hz*/
N#endif /* HSE_VALUE */
N
N/**
N * @brief In the following line adjust the External High Speed oscillator (HSE) Startup 
N   Timeout value 
N   */
N#if !defined  (HSE_STARTUP_TIMEOUT)
X#if !0L
N#define HSE_STARTUP_TIMEOUT   ((uint16_t)0x5000) /*!< Time out for HSE start up */
N#endif /* HSE_STARTUP_TIMEOUT */
N
N/**
N * @brief In the following line adjust the Internal High Speed oscillator (HSI) Startup 
N   Timeout value 
N   */
N#if !defined  (HSI_STARTUP_TIMEOUT)
X#if !0L
N#define HSI_STARTUP_TIMEOUT   ((uint16_t)0x5000) /*!< Time out for HSI start up */
N#endif /* HSI_STARTUP_TIMEOUT */
N
N#if !defined  (HSI_VALUE) 
X#if !0L 
N#define HSI_VALUE  ((uint32_t)8000000) /*!< Value of the Internal High Speed oscillator in Hz.
N                                             The real value may vary depending on the variations
N                                             in voltage and temperature.  */
N#endif /* HSI_VALUE */
N
N#if !defined  (HSI14_VALUE) 
X#if !0L 
N#define HSI14_VALUE ((uint32_t)14000000) /*!< Value of the Internal High Speed oscillator for ADC in Hz.
N                                             The real value may vary depending on the variations
N                                             in voltage and temperature.  */
N#endif /* HSI14_VALUE */
N
N#if !defined  (HSI48_VALUE) 
X#if !0L 
N#define HSI48_VALUE ((uint32_t)48000000) /*!< Value of the Internal High Speed oscillator for USB in Hz.
N                                             The real value may vary depending on the variations
N                                             in voltage and temperature.  */
N#endif /* HSI48_VALUE */
N
N#if !defined  (LSI_VALUE) 
X#if !0L 
N#define LSI_VALUE  ((uint32_t)40000)    /*!< Value of the Internal Low Speed oscillator in Hz
N                                             The real value may vary depending on the variations
N                                             in voltage and temperature.  */
N#endif /* LSI_VALUE */
N
N#if !defined  (LSE_VALUE) 
X#if !0L 
N#define LSE_VALUE  ((uint32_t)32768)    /*!< Value of the External Low Speed oscillator in Hz */
N#endif /* LSE_VALUE */
N
N/**
N * @brief FT32F0XX Standard Peripheral Library version number V1.4.0
N   */
N#define __FT32F0XX_STDPERIPH_VERSION_MAIN   (0x01) /*!< [31:24] main version */
N#define __FT32F0XX_STDPERIPH_VERSION_SUB1   (0x05) /*!< [23:16] sub1 version */
N#define __FT32F0XX_STDPERIPH_VERSION_SUB2   (0x00) /*!< [15:8]  sub2 version */
N#define __FT32F0XX_STDPERIPH_VERSION_RC     (0x00) /*!< [7:0]  release candidate */ 
N#define __FT32F0XX_STDPERIPH_VERSION        ((__FT32F0XX_STDPERIPH_VERSION_MAIN << 24)\
N                                             |(__FT32F0XX_STDPERIPH_VERSION_SUB1 << 16)\
N                                             |(__FT32F0XX_STDPERIPH_VERSION_SUB2 << 8)\
N                                             |(__FT32F0XX_STDPERIPH_VERSION_RC))
X#define __FT32F0XX_STDPERIPH_VERSION        ((__FT32F0XX_STDPERIPH_VERSION_MAIN << 24)                                             |(__FT32F0XX_STDPERIPH_VERSION_SUB1 << 16)                                             |(__FT32F0XX_STDPERIPH_VERSION_SUB2 << 8)                                             |(__FT32F0XX_STDPERIPH_VERSION_RC))
N
N/**
N  * @}
N  */
N
N/** @addtogroup Configuration_section_for_CMSIS
N  * @{
N  */
N
N/**
N * @brief FT32F072X8 Interrupt Number Definition, according to the selected device 
N *        in @ref Library_configuration_section 
N */
N#define __CM0_REV                 0 /*!< Core Revision r0p0                            */
N#define __MPU_PRESENT             0 /*!< FT32F072X8 do not provide MPU                  */
N#define __NVIC_PRIO_BITS          2 /*!< FT32F072X8 uses 2 Bits for the Priority Levels */
N#define __Vendor_SysTickConfig    0 /*!< Set to 1 if different SysTick Config is used  */
N
N/*!< Interrupt Number Definition */
Ntypedef enum IRQn
N{
N/******  Cortex-M0 Processor Exceptions Numbers ******************************************************/
N  NonMaskableInt_IRQn         = -14,    /*!< 2 Non Maskable Interrupt                                */
N  HardFault_IRQn              = -13,    /*!< 3 Cortex-M0 Hard Fault Interrupt                        */
N  SVC_IRQn                    = -5,     /*!< 11 Cortex-M0 SV Call Interrupt                          */
N  PendSV_IRQn                 = -2,     /*!< 14 Cortex-M0 Pend SV Interrupt                          */
N  SysTick_IRQn                = -1,     /*!< 15 Cortex-M0 System Tick Interrupt                      */
N  
N/******  FT32F0 specific Interrupt Numbers ******************************************************************/
N  WWDG_IRQn                   = 0,      /*!< Window WatchDog Interrupt                                     */
N  PVD_VDDIO2_IRQn             = 1,      /*!< PVD and VDDIO2 supply comparator through EXTI Line detect Interrupt */
N  RTC_IRQn                    = 2,      /*!< RTC through EXTI Line Interrupt                               */
N  FLASH_IRQn                  = 3,      /*!< FLASH Interrupt                                               */
N  RCC_CRS_IRQn                = 4,      /*!< RCC and CRS Interrupts                                        */
N  EXTI0_1_IRQn                = 5,      /*!< EXTI Line 0 and 1 Interrupts                                  */
N  EXTI2_3_IRQn                = 6,      /*!< EXTI Line 2 and 3 Interrupts                                  */
N  EXTI4_15_IRQn               = 7,      /*!< EXTI Line 4 to 15 Interrupts                                  */
N  DMA1_Channel1_IRQn          = 9,      /*!< DMA1 Channel 1 Interrupt                                      */
N  DMA1_Channel2_3_IRQn        = 10,     /*!< DMA1 Channel 2 and Channel 3 Interrupts                       */
N  DMA1_Channel4_5_IRQn        = 11,     /*!< DMA1 Channel 4, Channel 5, Channel 6 and Channel 7 Interrupts */
N  ADC1_COMP_IRQn              = 12,     /*!< ADC1, COMP1 and COMP2 Interrupts                              */
N  TIM1_BRK_UP_TRG_COM_IRQn    = 13,     /*!< TIM1 Break, Update, Trigger and Commutation Interrupts        */
N  TIM1_CC_IRQn                = 14,     /*!< TIM1 Capture Compare Interrupt                                */
N  TIM3_IRQn                   = 16,     /*!< TIM3 Interrupt                                                */
N  TIM6_DAC_IRQn               = 17,     /*!< TIM6 and DAC Interrupts                                       */
N  TIM14_IRQn                  = 19,     /*!< TIM14 Interrupt                                               */
N  TIM15_IRQn                  = 20,     /*!< TIM15 Interrupt                                               */
N  TIM16_IRQn                  = 21,     /*!< TIM16 Interrupt                                               */
N  TIM17_IRQn                  = 22,     /*!< TIM17 Interrupt                                               */
N  I2C1_IRQn                   = 23,     /*!< I2C1 Interrupt                                                */
N  I2C2_IRQn                   = 24,     /*!< I2C2 Interrupt                                                */
N  SPI1_IRQn                   = 25,     /*!< SPI1 Interrupt                                                */
N  SPI2_IRQn                   = 26,     /*!< SPI2 Interrupt                                                */
N  USART1_IRQn                 = 27,     /*!< USART1 Interrupt                                              */
N  USART2_IRQn                 = 28,     /*!< USART2 Interrupt                                              */
N  USB_IRQn                    = 31      /*!< USB Low Priority global Interrupt                             */
N}IRQn_Type;
N
N/**
N  * @}
N  */
N
N#include "core_cm0.h"
L 1 "..\FTLib\CMSIS\inc\core_cm0.h" 1
N/**************************************************************************//**
N * @file     core_cm0.h
N * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File
N * @version  V3.30
N * @date     17. February 2014
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2009 - 2014 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if defined ( __ICCARM__ )
X#if 0L
S #pragma system_include  /* treat file as system include file for MISRA check */
N#endif
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N#ifndef __CORE_CM0_H_GENERIC
N#define __CORE_CM0_H_GENERIC
N
N/** \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/** \ingroup Cortex_M0
N  @{
N */
N
N/*  CMSIS CM0 definitions */
N#define __CM0_CMSIS_VERSION_MAIN  (0x03)                                   /*!< [31:16] CMSIS HAL main version   */
N#define __CM0_CMSIS_VERSION_SUB   (0x20)                                   /*!< [15:0]  CMSIS HAL sub version    */
N#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16) | \
N                                    __CM0_CMSIS_VERSION_SUB          )     /*!< CMSIS HAL version number         */
X#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16) |                                     __CM0_CMSIS_VERSION_SUB          )      
N
N#define __CORTEX_M                (0x00)                                   /*!< Cortex-M Core                    */
N
N
N#if   defined ( __CC_ARM )
X#if   1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
N  #define __STATIC_INLINE  static __inline
N
N#elif defined ( __GNUC__ )
X#elif 1L
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __ICCARM__ )
S  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TMS470__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TI CCS Compiler       */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __CSMC__ )		/* Cosmic */
S  #define __packed
S  #define __ASM            _asm                                      /*!< asm keyword for COSMIC Compiler      */
S  #define __INLINE         inline                                    /*use -pc99 on compile line !< inline keyword for COSMIC Compiler   */
S  #define __STATIC_INLINE  static inline
S
N#endif
N
N/** __FPU_USED indicates whether an FPU is used or not. This core does not support an FPU at all
N*/
N#define __FPU_USED       0
N
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 0L
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
N  #endif
N
N#elif defined ( __GNUC__ )
X#elif 1L
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TMS470__ )
S  #if defined __TI__VFP_SUPPORT____
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __CSMC__ )		/* Cosmic */
S  #if ( __CSMC__ & 0x400)		// FPU present for parser
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
N#endif
N
N#include <stdint.h>                      /* standard types definitions                      */
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060044
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 147 "..\FTLib\CMSIS\inc\core_cm0.h" 2
N#include <core_cmInstr.h>                /* Core Instruction Access                         */
L 1 "..\FTLib\CMSIS\inc\core_cmInstr.h" 1
N/**************************************************************************//**
N * @file     core_cmInstr.h
N * @brief    CMSIS Cortex-M Core Instruction Access Header File
N * @version  V3.30
N * @date     17. February 2014
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2009 - 2014 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#ifndef __CORE_CMINSTR_H
N#define __CORE_CMINSTR_H
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5060960 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N
N/** \brief  No Operation
N
N    No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/** \brief  Wait For Interrupt
N
N    Wait For Interrupt is a hint instruction that suspends execution
N    until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/** \brief  Wait For Event
N
N    Wait For Event is a hint instruction that permits the processor to enter
N    a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/** \brief  Send Event
N
N    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/** \brief  Instruction Synchronization Barrier
N
N    Instruction Synchronization Barrier flushes the pipeline in the processor,
N    so that all instructions following the ISB are fetched from cache or
N    memory, after the instruction has been completed.
N */
N#define __ISB()                           __isb(0xF)
N
N
N/** \brief  Data Synchronization Barrier
N
N    This function acts as a special kind of Data Memory Barrier.
N    It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB()                           __dsb(0xF)
N
N
N/** \brief  Data Memory Barrier
N
N    This function ensures the apparent order of the explicit memory operations before
N    and after the instruction, without ensuring their completion.
N */
N#define __DMB()                           __dmb(0xF)
N
N
N/** \brief  Reverse byte order (32 bit)
N
N    This function reverses the byte order in integer value.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/** \brief  Reverse byte order (16 bit)
N
N    This function reverses the byte order in two unsigned short values.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N/** \brief  Reverse byte order in signed short value
N
N    This function reverses the byte order in a signed short value with sign extension to integer.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/** \brief  Rotate Right in unsigned value (32 bit)
N
N    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N
N    \param [in]    value  Value to rotate
N    \param [in]    value  Number of Bits to rotate
N    \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N/** \brief  Breakpoint
N
N    This function causes the processor to enter Debug state.
N    Debug tools can use this to investigate system state when the instruction at a particular address is reached.
N
N    \param [in]    value  is ignored by the processor.
N                   If required, a debugger can use it to store additional information about the breakpoint.
N */
N#define __BKPT(value)                       __breakpoint(value)
N
N
N#if       (__CORTEX_M >= 0x03)
X#if       ((0x00) >= 0x03)
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S#define __RBIT                            __rbit
S
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function performs a exclusive LDR command for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S#define __LDREXB(ptr)                     ((uint8_t ) __ldrex(ptr))
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function performs a exclusive LDR command for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S#define __LDREXH(ptr)                     ((uint16_t) __ldrex(ptr))
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function performs a exclusive LDR command for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S#define __LDREXW(ptr)                     ((uint32_t ) __ldrex(ptr))
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function performs a exclusive STR command for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXB(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function performs a exclusive STR command for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXH(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function performs a exclusive STR command for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXW(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
S#define __CLREX                           __clrex
S
S
S/** \brief  Signed Saturate
S
S    This function saturates a signed value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (1..32)
S    \return             Saturated value
S */
S#define __SSAT                            __ssat
S
S
S/** \brief  Unsigned Saturate
S
S    This function saturates an unsigned value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (0..31)
S    \return             Saturated value
S */
S#define __USAT                            __usat
S
S
S/** \brief  Count leading zeros
S
S    This function counts the number of leading zeros of a data value.
S
S    \param [in]  value  Value to count the leading zeros
S    \return             number of leading zeros in value
S */
S#define __CLZ                             __clz
S
N#endif /* (__CORTEX_M >= 0x03) */
N
N
N#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
X#elif 1L  
S/* GNU gcc specific functions */
S
S/* Define macros for porting to both thumb1 and thumb2.
S * For thumb1, use low register (r0-r7), specified by constrant "l"
S * Otherwise, use general registers, specified by constrant "r" */
S#if defined (__thumb__) && !defined (__thumb2__)
S#define __CMSIS_GCC_OUT_REG(r) "=l" (r)
S#define __CMSIS_GCC_USE_REG(r) "l" (r)
S#else
S#define __CMSIS_GCC_OUT_REG(r) "=r" (r)
S#define __CMSIS_GCC_USE_REG(r) "r" (r)
S#endif
S
S/** \brief  No Operation
S
S    No Operation does nothing. This instruction can be used for code alignment purposes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __NOP(void)
S{
S  __ASM volatile ("nop");
S}
S
S
S/** \brief  Wait For Interrupt
S
S    Wait For Interrupt is a hint instruction that suspends execution
S    until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFI(void)
S{
S  __ASM volatile ("wfi");
S}
S
S
S/** \brief  Wait For Event
S
S    Wait For Event is a hint instruction that permits the processor to enter
S    a low-power state until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFE(void)
S{
S  __ASM volatile ("wfe");
S}
S
S
S/** \brief  Send Event
S
S    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __SEV(void)
S{
S  __ASM volatile ("sev");
S}
S
S
S/** \brief  Instruction Synchronization Barrier
S
S    Instruction Synchronization Barrier flushes the pipeline in the processor,
S    so that all instructions following the ISB are fetched from cache or
S    memory, after the instruction has been completed.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __ISB(void)
S{
S  __ASM volatile ("isb");
S}
S
S
S/** \brief  Data Synchronization Barrier
S
S    This function acts as a special kind of Data Memory Barrier.
S    It completes when all explicit memory accesses before this instruction complete.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __DSB(void)
S{
S  __ASM volatile ("dsb");
S}
S
S
S/** \brief  Data Memory Barrier
S
S    This function ensures the apparent order of the explicit memory operations before
S    and after the instruction, without ensuring their completion.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
S{
S  __ASM volatile ("dmb");
S}
S
S
S/** \brief  Reverse byte order (32 bit)
S
S    This function reverses the byte order in integer value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV(uint32_t value)
S{
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
S  return __builtin_bswap32(value);
S#else
S  uint32_t result;
S
S  __ASM volatile ("rev %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S#endif
S}
S
S
S/** \brief  Reverse byte order (16 bit)
S
S    This function reverses the byte order in two unsigned short values.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV16(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("rev16 %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S}
S
S
S/** \brief  Reverse byte order in signed short value
S
S    This function reverses the byte order in a signed short value with sign extension to integer.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE int32_t __REVSH(int32_t value)
S{
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S  return (short)__builtin_bswap16(value);
S#else
S  uint32_t result;
S
S  __ASM volatile ("revsh %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S#endif
S}
S
S
S/** \brief  Rotate Right in unsigned value (32 bit)
S
S    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
S
S    \param [in]    value  Value to rotate
S    \param [in]    value  Number of Bits to rotate
S    \return               Rotated value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
S{
S  return (op1 >> op2) | (op1 << (32 - op2)); 
S}
S
S
S/** \brief  Breakpoint
S
S    This function causes the processor to enter Debug state.
S    Debug tools can use this to investigate system state when the instruction at a particular address is reached.
S
S    \param [in]    value  is ignored by the processor.
S                   If required, a debugger can use it to store additional information about the breakpoint.
S */
S#define __BKPT(value)                       __ASM volatile ("bkpt "#value)
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S
S   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function performs a exclusive LDR command for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __LDREXB(volatile uint8_t *addr)
S{
S    uint32_t result;
S
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S   __ASM volatile ("ldrexb %0, %1" : "=r" (result) : "Q" (*addr) );
S#else
S    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
S       accepted by assembler. So has to use following less efficient pattern.
S    */
S   __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
S#endif
S   return ((uint8_t) result);    /* Add explicit type cast here */
S}
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function performs a exclusive LDR command for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint16_t __LDREXH(volatile uint16_t *addr)
S{
S    uint32_t result;
S
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S   __ASM volatile ("ldrexh %0, %1" : "=r" (result) : "Q" (*addr) );
S#else
S    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
S       accepted by assembler. So has to use following less efficient pattern.
S    */
S   __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
S#endif
S   return ((uint16_t) result);    /* Add explicit type cast here */
S}
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function performs a exclusive LDR command for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
S{
S    uint32_t result;
S
S   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function performs a exclusive STR command for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexb %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" ((uint32_t)value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function performs a exclusive STR command for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXH(uint16_t value, volatile uint16_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexh %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" ((uint32_t)value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function performs a exclusive STR command for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
S   return(result);
S}
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __CLREX(void)
S{
S  __ASM volatile ("clrex" ::: "memory");
S}
S
S
S/** \brief  Signed Saturate
S
S    This function saturates a signed value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (1..32)
S    \return             Saturated value
S */
S#define __SSAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __SSAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Unsigned Saturate
S
S    This function saturates an unsigned value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (0..31)
S    \return             Saturated value
S */
S#define __USAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __USAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Count leading zeros
S
S    This function counts the number of leading zeros of a data value.
S
S    \param [in]  value  Value to count the leading zeros
S    \return             number of leading zeros in value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
S   return ((uint8_t) result);    /* Add explicit type cast here */
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all intrinsics,
S * Including the CMSIS ones.
S */
S
S
S#elif defined ( __CSMC__ ) /*------------------ COSMIC Compiler -------------------*/
S/* Cosmic specific functions */
S#include <cmsis_csm.h>
S
N#endif
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N#endif /* __CORE_CMINSTR_H */
L 148 "..\FTLib\CMSIS\inc\core_cm0.h" 2
N#include <core_cmFunc.h>                 /* Core Function Access                            */
L 1 "..\FTLib\CMSIS\inc\core_cmFunc.h" 1
N/**************************************************************************//**
N * @file     core_cmFunc.h
N * @brief    CMSIS Cortex-M Core Function Access Header File
N * @version  V3.30
N * @date     17. February 2014
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2009 - 2014 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#ifndef __CORE_CMFUNC_H
N#define __CORE_CMFUNC_H
N
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5060960 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N/** \brief  Get Control Register
N
N    This function returns the content of the Control Register.
N
N    \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/** \brief  Set Control Register
N
N    This function writes the given value to the Control Register.
N
N    \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/** \brief  Get IPSR Register
N
N    This function returns the content of the IPSR Register.
N
N    \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/** \brief  Get APSR Register
N
N    This function returns the content of the APSR Register.
N
N    \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/** \brief  Get xPSR Register
N
N    This function returns the content of the xPSR Register.
N
N    \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/** \brief  Get Process Stack Pointer
N
N    This function returns the current value of the Process Stack Pointer (PSP).
N
N    \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/** \brief  Set Process Stack Pointer
N
N    This function assigns the given value to the Process Stack Pointer (PSP).
N
N    \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/** \brief  Get Main Stack Pointer
N
N    This function returns the current value of the Main Stack Pointer (MSP).
N
N    \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/** \brief  Set Main Stack Pointer
N
N    This function assigns the given value to the Main Stack Pointer (MSP).
N
N    \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/** \brief  Get Priority Mask
N
N    This function returns the current state of the priority mask bit from the Priority Mask Register.
N
N    \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/** \brief  Set Priority Mask
N
N    This function assigns the given value to the Priority Mask Register.
N
N    \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if       (__CORTEX_M >= 0x03)
X#if       ((0x00) >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S#define __enable_fault_irq                __enable_fiq
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S#define __disable_fault_irq               __disable_fiq
S
S
S/** \brief  Get Base Priority
S
S    This function returns the current value of the Base Priority register.
S
S    \return               Base Priority register value
S */
S__STATIC_INLINE uint32_t  __get_BASEPRI(void)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  return(__regBasePri);
S}
S
S
S/** \brief  Set Base Priority
S
S    This function assigns the given value to the Base Priority register.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  __regBasePri = (basePri & 0xff);
S}
S
S
S/** \brief  Get Fault Mask
S
S    This function returns the current value of the Fault Mask register.
S
S    \return               Fault Mask register value
S */
S__STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  return(__regFaultMask);
S}
S
S
S/** \brief  Set Fault Mask
S
S    This function assigns the given value to the Fault Mask register.
S
S    \param [in]    faultMask  Fault Mask value to set
S */
S__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  __regFaultMask = (faultMask & (uint32_t)1);
S}
S
N#endif /* (__CORTEX_M >= 0x03) */
N
N
N#if       (__CORTEX_M == 0x04)
X#if       ((0x00) == 0x04)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  return(__regfpscr);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  __regfpscr = (fpscr);
S#endif
S}
S
N#endif /* (__CORTEX_M == 0x04) */
N
N
N#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
X#elif 1L  
S/* GNU gcc specific functions */
S
S/** \brief  Enable IRQ Interrupts
S
S  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
S{
S  __ASM volatile ("cpsie i" : : : "memory");
S}
S
S
S/** \brief  Disable IRQ Interrupts
S
S  This function disables IRQ interrupts by setting the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
S{
S  __ASM volatile ("cpsid i" : : : "memory");
S}
S
S
S/** \brief  Get Control Register
S
S    This function returns the content of the Control Register.
S
S    \return               Control Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_CONTROL(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, control" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Control Register
S
S    This function writes the given value to the Control Register.
S
S    \param [in]    control  Control Register value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_CONTROL(uint32_t control)
S{
S  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
S}
S
S
S/** \brief  Get IPSR Register
S
S    This function returns the content of the IPSR Register.
S
S    \return               IPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get APSR Register
S
S    This function returns the content of the APSR Register.
S
S    \return               APSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_APSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, apsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get xPSR Register
S
S    This function returns the content of the xPSR Register.
S
S    \return               xPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_xPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get Process Stack Pointer
S
S    This function returns the current value of the Process Stack Pointer (PSP).
S
S    \return               PSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Process Stack Pointer
S
S    This function assigns the given value to the Process Stack Pointer (PSP).
S
S    \param [in]    topOfProcStack  Process Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
S{
S  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
S}
S
S
S/** \brief  Get Main Stack Pointer
S
S    This function returns the current value of the Main Stack Pointer (MSP).
S
S    \return               MSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_MSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Main Stack Pointer
S
S    This function assigns the given value to the Main Stack Pointer (MSP).
S
S    \param [in]    topOfMainStack  Main Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
S{
S  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
S}
S
S
S/** \brief  Get Priority Mask
S
S    This function returns the current state of the priority mask bit from the Priority Mask Register.
S
S    \return               Priority Mask value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, primask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Priority Mask
S
S    This function assigns the given value to the Priority Mask Register.
S
S    \param [in]    priMask  Priority Mask
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
S{
S  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
S}
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_fault_irq(void)
S{
S  __ASM volatile ("cpsie f" : : : "memory");
S}
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_fault_irq(void)
S{
S  __ASM volatile ("cpsid f" : : : "memory");
S}
S
S
S/** \brief  Get Base Priority
S
S    This function returns the current value of the Base Priority register.
S
S    \return               Base Priority register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Base Priority
S
S    This function assigns the given value to the Base Priority register.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
S{
S  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
S}
S
S
S/** \brief  Get Fault Mask
S
S    This function returns the current value of the Fault Mask register.
S
S    \return               Fault Mask register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Fault Mask
S
S    This function assigns the given value to the Fault Mask register.
S
S    \param [in]    faultMask  Fault Mask value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S#if       (__CORTEX_M == 0x04)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  uint32_t result;
S
S  /* Empty asm statement works as a scheduling barrier */
S  __ASM volatile ("");
S  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
S  __ASM volatile ("");
S  return(result);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  /* Empty asm statement works as a scheduling barrier */
S  __ASM volatile ("");
S  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc");
S  __ASM volatile ("");
S#endif
S}
S
S#endif /* (__CORTEX_M == 0x04) */
S
S
S#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all intrinsics,
S * Including the CMSIS ones.
S */
S
S
S#elif defined ( __CSMC__ ) /*------------------ COSMIC Compiler -------------------*/
S/* Cosmic specific functions */
S#include <cmsis_csm.h>
S
N#endif
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N#endif /* __CORE_CMFUNC_H */
L 149 "..\FTLib\CMSIS\inc\core_cm0.h" 2
N
N#endif /* __CORE_CM0_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM0_H_DEPENDANT
N#define __CORE_CM0_H_DEPENDANT
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM0_REV
S    #define __CM0_REV               0x0000
S    #warning "__CM0_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          2
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions                 */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions                 */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions                */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions              */
N
N/*@} end of group Cortex_M0 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N ******************************************************************************/
N/** \defgroup CMSIS_core_register Defines and Type Definitions
N    \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_CORE  Status and Control Registers
N    \brief  Core Register type definitions.
N  @{
N */
N
N/** \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N#if (__CORTEX_M != 0x04)
X#if ((0x00) != 0x04)
N    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved                           */
N#else
S    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved                           */
N#endif
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} APSR_Type;
N
N
N/** \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} IPSR_Type;
N
N
N/** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N#if (__CORTEX_M != 0x04)
X#if ((0x00) != 0x04)
N    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved                           */
N#else
S    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved                           */
N#endif
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
N    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0)          */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} xPSR_Type;
N
N
N/** \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
N    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag           */
N    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} CONTROL_Type;
N
N/*@} end of group CMSIS_CORE */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N    \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IO uint32_t ISER[1];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register           */
X  volatile uint32_t ISER[1];                  
N       uint32_t RESERVED0[31];
N  __IO uint32_t ICER[1];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register          */
X  volatile uint32_t ICER[1];                  
N       uint32_t RSERVED1[31];
N  __IO uint32_t ISPR[1];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register           */
X  volatile uint32_t ISPR[1];                  
N       uint32_t RESERVED2[31];
N  __IO uint32_t ICPR[1];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register         */
X  volatile uint32_t ICPR[1];                  
N       uint32_t RESERVED3[31];
N       uint32_t RESERVED4[64];
N  __IO uint32_t IP[8];                   /*!< Offset: 0x300 (R/W)  Interrupt Priority Register              */
X  volatile uint32_t IP[8];                    
N}  NVIC_Type;
N
N/*@} end of group CMSIS_NVIC */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SCB     System Control Block (SCB)
N    \brief      Type definitions for the System Control Block Registers
N  @{
N */
N
N/** \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPUID Base Register                                   */
X  volatile const  uint32_t CPUID;                    
N  __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register                  */
X  volatile uint32_t ICSR;                     
N       uint32_t RESERVED0;
N  __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register      */
X  volatile uint32_t AIRCR;                    
N  __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register                               */
X  volatile uint32_t SCR;                      
N  __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register                        */
X  volatile uint32_t CCR;                      
N       uint32_t RESERVED1;
N  __IO uint32_t SHP[2];                  /*!< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED   */
X  volatile uint32_t SHP[2];                   
N  __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State Register             */
X  volatile uint32_t SHCSR;                    
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N    \brief      Type definitions for the System Timer Registers.
N  @{
N */
N
N/** \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register       */
X  volatile uint32_t LOAD;                     
N  __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register      */
X  volatile uint32_t VAL;                      
N  __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register        */
X  volatile const  uint32_t CALIB;                    
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N    \brief      Cortex-M0 Core Debug Registers (DCB registers, SHCSR, and DFSR)
N                are only accessible over DAP and not via processor. Therefore
N                they are not covered by the Cortex-M0 header file.
N  @{
N */
N/*@} end of group CMSIS_CoreDebug */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_core_base     Core Definitions
N    \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Cortex-M0 Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address              */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address                 */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct           */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct       */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct          */
N
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/** \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N    \brief      Functions that manage interrupts and exceptions via the NVIC.
N    @{
N */
N
N/* Interrupt Priorities are WORD accessible only under ARMv6M                   */
N/* The following MACROS handle generation of the register offset and byte masks */
N#define _BIT_SHIFT(IRQn)         (  (((uint32_t)(IRQn)       )    &  0x03) * 8 )
N#define _SHP_IDX(IRQn)           ( ((((uint32_t)(IRQn) & 0x0F)-8) >>    2)     )
N#define _IP_IDX(IRQn)            (   ((uint32_t)(IRQn)            >>    2)     )
N
N
N/** \brief  Enable External Interrupt
N
N    The function enables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Disable External Interrupt
N
N    The function disables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Get Pending Interrupt
N
N    The function reads the pending register in the NVIC and returns the pending bit
N    for the specified interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N
N    \return             0  Interrupt status is not pending.
N    \return             1  Interrupt status is pending.
N */
N__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t) ((NVIC->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));
X  return((uint32_t) ((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));
N}
N
N
N/** \brief  Set Pending Interrupt
N
N    The function sets the pending bit of an external interrupt.
N
N    \param [in]      IRQn  Interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Clear Pending Interrupt
N
N    The function clears the pending bit of an external interrupt.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N
N/** \brief  Set Interrupt Priority
N
N    The function sets the priority of an interrupt.
N
N    \note The priority cannot be set for every core interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N    \param [in]  priority  Priority to set.
N */
N__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if(IRQn < 0) {
N    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] = (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] & ~(0xFF << ( (((uint32_t)(IRQn) ) & 0x03) * 8 ))) |
N        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
X        (((priority << (8 - 2)) & 0xFF) << ( (((uint32_t)(IRQn) ) & 0x03) * 8 )); }
N  else {
N    NVIC->IP[_IP_IDX(IRQn)] = (NVIC->IP[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( ((uint32_t)(IRQn) >> 2) )] = (((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( ((uint32_t)(IRQn) >> 2) )] & ~(0xFF << ( (((uint32_t)(IRQn) ) & 0x03) * 8 ))) |
N        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
X        (((priority << (8 - 2)) & 0xFF) << ( (((uint32_t)(IRQn) ) & 0x03) * 8 )); }
N}
N
N
N/** \brief  Get Interrupt Priority
N
N    The function reads the priority of an interrupt. The interrupt
N    number can be positive to specify an external (device specific)
N    interrupt, or negative to specify an internal (core) interrupt.
N
N
N    \param [in]   IRQn  Interrupt number.
N    \return             Interrupt Priority. Value is aligned automatically to the implemented
N                        priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if(IRQn < 0) {
N    return((uint32_t)(((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & 0xFF) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M0 system interrupts */
X    return((uint32_t)(((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] >> ( (((uint32_t)(IRQn) ) & 0x03) * 8 ) ) & 0xFF) >> (8 - 2)));  }  
N  else {
N    return((uint32_t)(((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & 0xFF) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[ ( ((uint32_t)(IRQn) >> 2) )] >> ( (((uint32_t)(IRQn) ) & 0x03) * 8 ) ) & 0xFF) >> (8 - 2)));  }  
N}
N
N
N/** \brief  System Reset
N
N    The function initiates a system reset request to reset the MCU.
N */
N__STATIC_INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  __DSB();                                                     /* Ensure all outstanding memory accesses included
X  __dsb(0xF);                                                     
N                                                                  buffered write are completed before reset */
N  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = ((0x5FA << 16)      |
N                 SCB_AIRCR_SYSRESETREQ_Msk);
X                 (1UL << 2));
N  __DSB();                                                     /* Ensure completion of memory access */
X  __dsb(0xF);                                                      
N  while(1);                                                    /* wait until reset */
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N    \brief      Functions that configure the System.
N  @{
N */
N
N#if (__Vendor_SysTickConfig == 0)
X#if (0 == 0)
N
N/** \brief  System Tick Configuration
N
N    The function initializes the System Timer and its interrupt, and starts the System Tick Timer.
N    Counter is in free running mode to generate periodic interrupts.
N
N    \param [in]  ticks  Number of ticks between two interrupts.
N
N    \return          0  Function succeeded.
N    \return          1  Function failed.
N
N    \note     When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N    must contain a vendor-specific implementation of this function.
N
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */
X  if ((ticks - 1) > (0xFFFFFFUL << 0))  return (1);       
N
N  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = ticks - 1;                                   
N  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
X  NVIC_SetPriority (SysTick_IRQn, (1<<2) - 1);   
N  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0;                                           
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1)   |
N                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL << 0);                     
N  return (0);                                                  /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N
N#endif /* __CORE_CM0_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
N
N#ifdef __cplusplus
S}
N#endif
L 183 "..\FTLib\CMSIS\inc\ft32f072x8.h" 2
N#include "ft32f0xx.h"
L 1 "..\FTLib\CMSIS\inc\ft32f0xx.h" 1
N/**
N  ******************************************************************************
N  * @file    			ft32f0xx.h
N  * @author  			FMD AE
N  * @brief   			CMSIS FT32F0xx Device Peripheral Access Layer Header File.    	
N  * @version 			V1.0.0           
N  * @data		 			2021-07-01
N  ******************************************************************************
N  */
N
N#ifndef __FT32F0xx_H
S#define __FT32F0xx_H
S
S#ifdef __cplusplus
S extern "C" {
S#endif /* __cplusplus */
S 
S
S#if !defined  (FT32F0)
S#define FT32F0
S#endif /* FT32F0 */
S
S
S
S/**
S  * @brief CMSIS Device version number V2.3.3
S  */
S#define __FT32F0_DEVICE_VERSION_MAIN   (0x02) /*!< [31:24] main version */
S#define __FT32F0_DEVICE_VERSION_SUB1   (0x03) /*!< [23:16] sub1 version */
S#define __FT32F0_DEVICE_VERSION_SUB2   (0x03) /*!< [15:8]  sub2 version */
S#define __FT32F0_DEVICE_VERSION_RC     (0x00) /*!< [7:0]  release candidate */ 
S#define __FT32F0_DEVICE_VERSION        ((__FT32F0_DEVICE_VERSION_MAIN << 24)\
S                                        |(__FT32F0_DEVICE_VERSION_SUB1 << 16)\
S                                        |(__FT32F0_DEVICE_VERSION_SUB2 << 8 )\
S                                        |(__FT32F0_DEVICE_VERSION_RC))
X#define __FT32F0_DEVICE_VERSION        ((__FT32F0_DEVICE_VERSION_MAIN << 24)                                        |(__FT32F0_DEVICE_VERSION_SUB1 << 16)                                        |(__FT32F0_DEVICE_VERSION_SUB2 << 8 )                                        |(__FT32F0_DEVICE_VERSION_RC))
S                                             
S
S/* Exported macro ------------------------------------------------------------*/
S#ifdef  USE_FULL_ASSERT
S
S  #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
S/* Exported functions ------------------------------------------------------- */
S  void assert_failed(uint8_t* file, uint32_t line);
S#else
S  #define assert_param(expr) ((void)0)
S#endif /* USE_FULL_ASSERT */
S
S#if defined(FT32F030x6)
S  #include "ft32f030x6.h"
S#elif defined(FT32F030x8)
S  #include "ft32f030x8.h"
S#elif defined(FT32F072x8)
S  #include "ft32f072x8.h" 
S#else
S #error "Please select first the target FT32F0xx device used in your application (in ft32f0xx.h file)"
S#endif
S
S/**
S  * @}
S  */
S
S
S
S/**
S  * @}
S  */
S
S
S/** @addtogroup Exported_macros
S  * @{
S  */
S#define SET_BIT(REG, BIT)     ((REG) |= (BIT))
S
S#define CLEAR_BIT(REG, BIT)   ((REG) &= ~(BIT))
S
S#define READ_BIT(REG, BIT)    ((REG) & (BIT))
S
S#define CLEAR_REG(REG)        ((REG) = (0x0))
S
S#define WRITE_REG(REG, VAL)   ((REG) = (VAL))
S
S#define READ_REG(REG)         ((REG))
S
S#define MODIFY_REG(REG, CLEARMASK, SETMASK)  WRITE_REG((REG), (((READ_REG(REG)) & (~(CLEARMASK))) | (SETMASK)))
S
S
S#ifdef __cplusplus
S}
S#endif /* __cplusplus */
S
N#endif /* __FT32F0xx_H */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N  
N
N
N
N/*****************************END OF FILE****/
L 184 "..\FTLib\CMSIS\inc\ft32f072x8.h" 2
N#include "system_ft32f0xx.h"
L 1 "..\FTLib\CMSIS\inc\system_ft32f0xx.h" 1
N/**
N  ******************************************************************************
N  * @file    			system_ft32f0xx.h
N  * @author  			FMD AE
N  * @brief   			CMSIS Cortex-M0 Device Peripheral Access Layer System Header File.
N  * @details 			        			  
N  * @version 			V1.0.0
N  * @date    			2021-07-01 
N  *******************************************************************************	
N  */
N  
N/**
N  * @brief Define to prevent recursive inclusion
N  */
N#ifndef __SYSTEM_FT32F0xx_H
N#define __SYSTEM_FT32F0xx_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif 
N
Nextern uint32_t SystemCoreClock;          /*!< System Clock Frequency (Core Clock) */
N
Nextern void SystemInit(void);
Nextern void SystemCoreClockUpdate(void);
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* */
N
N/**
N  * @}
N  */
N  
N/**
N  * @}
N  */  
N/************************ (C) COPYRIGHT FMD *****END OF FILE****/
L 185 "..\FTLib\CMSIS\inc\ft32f072x8.h" 2
N#include <stdint.h>
N
N/** @addtogroup Exported_types
N  * @{
N  */  
N/** @addtogroup Exported_types
N  * @{
N  */ 
Ntypedef enum 
N{
N  RESET = 0, 
N  SET = !RESET
N} FlagStatus, ITStatus;
N
Ntypedef enum 
N{
N  DISABLE = 0, 
N  ENABLE = !DISABLE
N} FunctionalState;
N#define IS_FUNCTIONAL_STATE(STATE) (((STATE) == DISABLE) || ((STATE) == ENABLE))
N
Ntypedef enum 
N{
N  ERROR = 0, 
N  SUCCESS = !ERROR
N} ErrorStatus;
N
N
N/** @addtogroup Peripheral_registers_structures
N  * @{
N  */   
N
N/** 
N  * @brief Analog to Digital Converter  
N  */
N
Ntypedef struct
N{
N  __IO uint32_t ISR;          /*!< ADC Interrupt and Status register,                          Address offset:0x00 */
X  volatile uint32_t ISR;           
N  __IO uint32_t IER;          /*!< ADC Interrupt Enable register,                              Address offset:0x04 */
X  volatile uint32_t IER;           
N  __IO uint32_t CR;           /*!< ADC Control register,                                       Address offset:0x08 */
X  volatile uint32_t CR;            
N  __IO uint32_t CFGR1;        /*!< ADC Configuration register 1,                               Address offset:0x0C */
X  volatile uint32_t CFGR1;         
N  __IO uint32_t CFGR2;        /*!< ADC Configuration register 2,                               Address offset:0x10 */
X  volatile uint32_t CFGR2;         
N  __IO uint32_t SMPR;         /*!< ADC Sampling time register,                                 Address offset:0x14 */
X  volatile uint32_t SMPR;          
N  uint32_t   RESERVED1;       /*!< Reserved,                                                                  0x18 */
N  uint32_t   RESERVED2;       /*!< Reserved,                                                                  0x1C */
N  __IO uint32_t TR;           /*!< ADC watchdog threshold register,                            Address offset:0x20 */
X  volatile uint32_t TR;            
N  uint32_t   RESERVED3;       /*!< Reserved,                                                                  0x24 */
N  __IO uint32_t CHSELR;       /*!< ADC channel selection register,                             Address offset:0x28 */
X  volatile uint32_t CHSELR;        
N  uint32_t   RESERVED4[5];    /*!< Reserved,                                                                  0x2C */
N   __IO uint32_t DR;          /*!< ADC data register,                                          Address offset:0x40 */
X   volatile uint32_t DR;           
N} ADC_TypeDef;
N
Ntypedef struct
N{
N  __IO uint32_t CCR;					/*Address offset:0x308 */
X  volatile uint32_t CCR;					 
N  __IO uint32_t CR2; 					/*Address offset:0x30C */
X  volatile uint32_t CR2; 					 
N} ADC_Common_TypeDef;
N
N/**
N  * @brief Comparator 
N  */
N
Ntypedef struct
N{
N	__IO uint32_t RESERVED[7];     /*!< Reserved,                               Address offset: 0x18-0x00 */
X	volatile uint32_t RESERVED[7];      
N  __IO uint32_t CSR;    				 /*!< COMP comparator control and status register, Address offset: 0x1C */
X  volatile uint32_t CSR;    				  
N} COMP_TypeDef;
N/**
N  * @brief OPA 
N  */
Ntypedef struct
N{
N	__IO uint32_t RESERVED[12];     /*!< Reserved,                               Address offset: 0x2C-0x00 */
X	volatile uint32_t RESERVED[12];      
N  __IO uint32_t CR;    				 /*!< COMP comparator control and status register, Address offset: 0x30 */
X  volatile uint32_t CR;    				  
N} OPA_TypeDef;
N
N/**
N  * @brief DAC Configuration
N  */
Ntypedef struct
N{
N	__IO uint32_t RESERVED[8];    /*!< Reserved,                                          Address offset: 0x1C-0x00 */
X	volatile uint32_t RESERVED[8];     
N  __IO uint32_t CTRL;           /*!< DAC configuration register                              Address offset: 0x20 */
X  volatile uint32_t CTRL;            
N  __IO uint32_t DATA1;          /*!< DAC1 Input  data                                        Address offset: 0x24 */
X  volatile uint32_t DATA1;           
N  __IO uint32_t DATA2;          /*!< DAC2 Input  data                                        Address offset: 0x28 */
X  volatile uint32_t DATA2;           
N}DAC_TypeDef;
N
N/** 
N  * @brief CRC calculation unit 
N  */
N
Ntypedef struct
N{
N  __IO uint32_t DR;          /*!< CRC Data register,                           Address offset: 0x00 */
X  volatile uint32_t DR;           
N	__IO uint32_t IDR;         /*!< CRC Independent data register,               Address offset: 0x04 */
X	volatile uint32_t IDR;          
N  __IO uint32_t CR;          /*!< CRC Control register,                        Address offset: 0x08 */ 
X  volatile uint32_t CR;            
N  uint32_t      RESERVED2;   /*!< Reserved,                                                    0x0C */
N  __IO uint32_t INIT;        /*!< Initial CRC value register,                  Address offset: 0x10 */
X  volatile uint32_t INIT;         
N  __IO uint32_t RESERVED3;   /*!< Reserved,                                                    0x14 */
X  volatile uint32_t RESERVED3;    
N} CRC_TypeDef;
N
N/**
N  * @brief Clock Recovery System 
N  */
Ntypedef struct 
N{
N__IO uint32_t CR;     /*!< CRS ccontrol register,              Address offset: 0x00 */
Xvolatile uint32_t CR;      
N__IO uint32_t CFGR;   /*!< CRS configuration register,         Address offset: 0x04 */
Xvolatile uint32_t CFGR;    
N__IO uint32_t ISR;    /*!< CRS interrupt and status register,  Address offset: 0x08 */
Xvolatile uint32_t ISR;     
N__IO uint32_t ICR;    /*!< CRS interrupt flag clear register,  Address offset: 0x0C */
Xvolatile uint32_t ICR;     
N} CRS_TypeDef;
N
N/** 
N  * @brief Debug MCU
N  */
N
Ntypedef struct
N{
N  __IO uint32_t IDCODE;       /*!< MCU device ID code,                          Address offset: 0x00 */
X  volatile uint32_t IDCODE;        
N  __IO uint32_t CR;           /*!< Debug MCU configuration register,            Address offset: 0x04 */
X  volatile uint32_t CR;            
N  __IO uint32_t APB1FZ;       /*!< Debug MCU APB1 freeze register,              Address offset: 0x08 */
X  volatile uint32_t APB1FZ;        
N  __IO uint32_t APB2FZ;       /*!< Debug MCU APB2 freeze register,              Address offset: 0x0C */
X  volatile uint32_t APB2FZ;        
N}DBGMCU_TypeDef;
N
N/** 
N  * @brief DMA Controller
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CCR;          /*!< DMA channel x configuration register                                           */
X  volatile uint32_t CCR;           
N  __IO uint32_t CNDTR;        /*!< DMA channel x number of data register                                          */
X  volatile uint32_t CNDTR;         
N  __IO uint32_t CPAR;         /*!< DMA channel x peripheral address register                                      */
X  volatile uint32_t CPAR;          
N  __IO uint32_t CMAR;         /*!< DMA channel x memory address register                                          */
X  volatile uint32_t CMAR;          
N} DMA_Channel_TypeDef;
N
Ntypedef struct
N{
N  __IO uint32_t ISR;          /*!< DMA interrupt status register,                            Address offset: 0x00 */
X  volatile uint32_t ISR;           
N  __IO uint32_t IFCR;         /*!< DMA interrupt flag clear register,                        Address offset: 0x04 */
X  volatile uint32_t IFCR;          
N}DMA_TypeDef;
N
N/** 
N  * @brief External Interrupt/Event Controller
N  */
N
Ntypedef struct
N{
N  __IO uint32_t IMR;          /*!<EXTI Interrupt mask register,                             Address offset: 0x00 */
X  volatile uint32_t IMR;           
N  __IO uint32_t EMR;          /*!<EXTI Event mask register,                                 Address offset: 0x04 */
X  volatile uint32_t EMR;           
N  __IO uint32_t RTSR;         /*!<EXTI Rising trigger selection register ,                  Address offset: 0x08 */
X  volatile uint32_t RTSR;          
N  __IO uint32_t FTSR;         /*!<EXTI Falling trigger selection register,                  Address offset: 0x0C */
X  volatile uint32_t FTSR;          
N  __IO uint32_t SWIER;        /*!<EXTI Software interrupt event register,                   Address offset: 0x10 */
X  volatile uint32_t SWIER;         
N  __IO uint32_t PR;           /*!<EXTI Pending register,                                    Address offset: 0x14 */
X  volatile uint32_t PR;            
N}EXTI_TypeDef;
N
N/** 
N  * @brief FLASH Registers
N  */
Ntypedef struct
N{
N  __IO uint32_t ACR;          /*!<FLASH access control register,                 Address offset: 0x00 */
X  volatile uint32_t ACR;           
N  __IO uint32_t KEYR;         /*!<FLASH key register,                            Address offset: 0x04 */
X  volatile uint32_t KEYR;          
N  __IO uint32_t OPTKEYR;      /*!<FLASH OPT key register,                        Address offset: 0x08 */
X  volatile uint32_t OPTKEYR;       
N  __IO uint32_t SR;           /*!<FLASH status register,                         Address offset: 0x0C */
X  volatile uint32_t SR;            
N  __IO uint32_t CR;           /*!<FLASH control register,                        Address offset: 0x10 */
X  volatile uint32_t CR;            
N  __IO uint32_t AR;           /*!<FLASH address register,                        Address offset: 0x14 */
X  volatile uint32_t AR;            
N  __IO uint32_t RESERVED;     /*!< Reserved,                                                     0x18 */
X  volatile uint32_t RESERVED;      
N  __IO uint32_t OBR;          /*!<FLASH option bytes register,                   Address offset: 0x1C */
X  volatile uint32_t OBR;           
N  __IO uint32_t WRPR;         /*!<FLASH option bytes register,                   Address offset: 0x20 */
X  volatile uint32_t WRPR;          
N} FLASH_TypeDef;
N
N
N/** 
N  * @brief Option Bytes Registers
N  */
Ntypedef struct
N{
N  __IO uint32_t USER_RDP;          /*!< FLASH option byte Read protection,             Address offset: 0x00-0x03 */
X  volatile uint32_t USER_RDP;           
N  __IO uint32_t DATA1_DATA0;       /*!< User data byte 0 (stored in FLASH_OBR[23:16]), Address offset: 0x04-0x07 */
X  volatile uint32_t DATA1_DATA0;        
N  __IO uint32_t WRP1_WRP0;         /*!< FLASH option byte write protection 0,1         Address offset: 0x08-0x0b */
X  volatile uint32_t WRP1_WRP0;          
N  __IO uint32_t WRP3_WRP2;         /*!< FLASH option byte write protection 2,          Address offset: 0x0C-0x0f */
X  volatile uint32_t WRP3_WRP2;          
N} OB_TypeDef;
N  
N
N/** 
N  * @brief General Purpose IO
N  */
N
Ntypedef struct
N{
N  __IO uint32_t MODER;        /*!< GPIO port mode register,                                  Address offset: 0x00 */
X  volatile uint32_t MODER;         
N  __IO uint16_t OTYPER;       /*!< GPIO port output type register,                           Address offset: 0x04 */
X  volatile uint16_t OTYPER;        
N  uint16_t RESERVED0;         /*!< Reserved,                                                                 0x06 */
N  __IO uint32_t OSPEEDR;      /*!< GPIO port output speed register,                          Address offset: 0x08 */
X  volatile uint32_t OSPEEDR;       
N  __IO uint32_t PUPDR;        /*!< GPIO port pull-up/pull-down register,                     Address offset: 0x0C */
X  volatile uint32_t PUPDR;         
N  __IO uint16_t IDR;          /*!< GPIO port input data register,                            Address offset: 0x10 */
X  volatile uint16_t IDR;           
N  uint16_t RESERVED1;         /*!< Reserved,                                                                 0x12 */
N  __IO uint16_t ODR;          /*!< GPIO port output data register,                           Address offset: 0x14 */
X  volatile uint16_t ODR;           
N  uint16_t RESERVED2;         /*!< Reserved,                                                                 0x16 */
N  __IO uint32_t BSRR;         /*!< GPIO port bit set/reset registerBSRR,                     Address offset: 0x18 */
X  volatile uint32_t BSRR;          
N  __IO uint32_t LCKR;         /*!< GPIO port configuration lock register,                    Address offset: 0x1C */
X  volatile uint32_t LCKR;          
N  __IO uint32_t AFR[2];       /*!< GPIO alternate function low register,                Address offset: 0x20-0x24 */
X  volatile uint32_t AFR[2];        
N  __IO uint16_t BRR;          /*!< GPIO bit reset register,                                  Address offset: 0x28 */
X  volatile uint16_t BRR;           
N  uint32_t RESERVED3;         /*!< Reserved,                                                                 0x2C */
N  __IO uint32_t LEDM;         /*!< GPIO LEDM register,                                       Address offset: 0x30 */
X  volatile uint32_t LEDM;          
N}GPIO_TypeDef;
N
N/** 
N  * @brief SysTem Configuration
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CFGR1;          /*!< SYSCFG configuration register 1,                        Address offset: 0x00 */
X  volatile uint32_t CFGR1;           
N       uint32_t RESERVED;       /*!< Reserved,                                                               0x04 */
N  __IO uint32_t EXTICR[4];      /*!< SYSCFG external interrupt configuration register,  Address offset: 0x14-0x08 */
X  volatile uint32_t EXTICR[4];       
N  __IO uint32_t CFGR2;          /*!< SYSCFG configuration register 2,                        Address offset: 0x18 */      
X  volatile uint32_t CFGR2;                 
N}SYSCFG_TypeDef;
N
N/** 
N  * @brief Inter-integrated Circuit Interface
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR1;      /*!< I2C Control register 1,            Address offset: 0x00 */
X  volatile uint32_t CR1;       
N  __IO uint32_t CR2;      /*!< I2C Control register 2,            Address offset: 0x04 */
X  volatile uint32_t CR2;       
N  __IO uint32_t OAR1;     /*!< I2C Own address 1 register,        Address offset: 0x08 */
X  volatile uint32_t OAR1;      
N  __IO uint32_t OAR2;     /*!< I2C Own address 2 register,        Address offset: 0x0C */
X  volatile uint32_t OAR2;      
N  __IO uint32_t TIMINGR;  /*!< I2C Timing register,               Address offset: 0x10 */
X  volatile uint32_t TIMINGR;   
N  __IO uint32_t TIMEOUTR; /*!< I2C Timeout register,              Address offset: 0x14 */
X  volatile uint32_t TIMEOUTR;  
N  __IO uint32_t ISR;      /*!< I2C Interrupt and status register, Address offset: 0x18 */
X  volatile uint32_t ISR;       
N  __IO uint32_t ICR;      /*!< I2C Interrupt clear register,      Address offset: 0x1C */
X  volatile uint32_t ICR;       
N  __IO uint32_t PECR;     /*!< I2C PEC register,                  Address offset: 0x20 */
X  volatile uint32_t PECR;      
N  __IO uint32_t RXDR;     /*!< I2C Receive data register,         Address offset: 0x24 */
X  volatile uint32_t RXDR;      
N  __IO uint32_t TXDR;     /*!< I2C Transmit data register,        Address offset: 0x28 */
X  volatile uint32_t TXDR;      
N}I2C_TypeDef;
N
N
N/** 
N  * @brief Independent WATCHDOG
N  */
Ntypedef struct
N{
N  __IO uint32_t KR;   /*!< IWDG Key register,       Address offset: 0x00 */
X  volatile uint32_t KR;    
N  __IO uint32_t PR;   /*!< IWDG Prescaler register, Address offset: 0x04 */
X  volatile uint32_t PR;    
N  __IO uint32_t RLR;  /*!< IWDG Reload register,    Address offset: 0x08 */
X  volatile uint32_t RLR;   
N  __IO uint32_t SR;   /*!< IWDG Status register,    Address offset: 0x0C */
X  volatile uint32_t SR;    
N  __IO uint32_t WINR; /*!< IWDG Window register,    Address offset: 0x10 */
X  volatile uint32_t WINR;  
N} IWDG_TypeDef;
N
N/**
N  * @brief USB
N  */
Ntypedef struct
N{ 
N	__IO uint8_t FADDR;      /*!<  function address register,                            Address offset: 0x00 */
X	volatile uint8_t FADDR;       
N	__IO uint8_t POWER;      /*!<  power management register,                            Address offset: 0x01 */
X	volatile uint8_t POWER;       
N	__IO uint8_t INTRIN;     /*!<  interrupt register endpint0 plus IN Endpoit 1 to 7,   Address offset: 0x02 */
X	volatile uint8_t INTRIN;      
N	__IO uint8_t RES1; 		 /*!<  RES1          									 	 Address offset: 0x03 */
X	volatile uint8_t RES1; 		  
N	__IO uint8_t INTROUT;    /*!<  interrupt register for OUT Endpoints 1 to 7,          Address offset: 0x04 */
X	volatile uint8_t INTROUT;     
N	__IO uint8_t RES2;		 /*!<  RES2          									 	 Address offset: 0x05 */
X	volatile uint8_t RES2;		  
N	__IO uint8_t INTRUSB;    /*!<  interrupt register for common USB interrrupts,        Address offset: 0x06 */
X	volatile uint8_t INTRUSB;     
N	__IO uint8_t INTRINE;    /*!<  inerrupt enable register for INTRIN,                  Address offset: 0x07 */
X	volatile uint8_t INTRINE;     
N	__IO uint8_t RES3; 		 /*!<  RES3          									 	 Address offset: 0x08 */
X	volatile uint8_t RES3; 		  
N	__IO uint8_t INTROUTE;   /*!<  inerrupt enable register for INTROUT,                 Address offset: 0x09 */
X	volatile uint8_t INTROUTE;    
N	__IO uint8_t RES4; 		 /*!<  RES4          									 	 Address offset: 0x0A */
X	volatile uint8_t RES4; 		  
N	__IO uint8_t INTRUSBE;   /*!<  inerrupt enable register for INTRUSB,                 Address offset: 0x0B */
X	volatile uint8_t INTRUSBE;    
N	__IO uint8_t FRAM1;      /*!<  frame number bits 0 to 7,                             Address offset: 0x0C */
X	volatile uint8_t FRAM1;       
N	__IO uint8_t FRAM2;      /*!<  frame number bits 8 to 15,                            Address offset: 0x0D */
X	volatile uint8_t FRAM2;       
N	__IO uint8_t INDEX;      /*!<  selecting then endpoint status and control register , Address offset: 0x0E */
X	volatile uint8_t INDEX;       
N	__IO uint8_t PDCTRL;     /*!<  pull down pull up control ,                           Address offset: 0x0F */
X	volatile uint8_t PDCTRL;      
N	__IO uint8_t INMAXP;	 /*!<  Maximum packet size for IN endpoint,                  Address offset: 0x10 */
X	volatile uint8_t INMAXP;	  
N	union 
N	{
N		__IO uint8_t INCSR0; /*!<  control status register fie endpoint 0,           	 Address offset: 0x11 */
X		volatile uint8_t INCSR0;  
N		__IO uint8_t INCSR1; /*!<  Control Status register 1 for IN Endpoint,        	 Address offset: 0x11 */
X		volatile uint8_t INCSR1;  
N	}INCSR;
N	//__IO uint8_t INCSR2;     /*!<  Control Status register 2 for IN Endpoint,            Address offset: 0x12 */
N	__IO uint8_t RES;        /*!<  Control Status register 2 for IN Endpoint,            Address offset: 0x12 */
X	volatile uint8_t RES;         
N	__IO uint8_t OUTMAXP;    /*!<  Maximum packet size for OUT endpoint,                 Address offset: 0x13 */
X	volatile uint8_t OUTMAXP;     
N	__IO uint8_t OUTCSR1;    /*!<  Control Status register 1 for OUT Endpoint,           Address offset: 0x14 */	
X	volatile uint8_t OUTCSR1;     	
N	__IO uint8_t OUTCSR2;    /*!<  Control Status register 2 for OUT Endpoint,           Address offset: 0x15 */ 
X	volatile uint8_t OUTCSR2;      
N	__IO uint8_t OUTCOUNTER; /*!<  number of bytes in OUT endpoint FIFO ,                Address offset: 0x16 */
X	volatile uint8_t OUTCOUNTER;  
N	__IO uint8_t RES5; 		 /*!<  RES5          									 	 Address offset: 0x17 */
X	volatile uint8_t RES5; 		  
N	__IO uint8_t RES6; 		 /*!<  RES6          									 	 Address offset: 0x18 */
X	volatile uint8_t RES6; 		  
N	__IO uint8_t RES7; 		 /*!<  RES7          									 	 Address offset: 0x19 */
X	volatile uint8_t RES7; 		  
N	__IO uint8_t FIFO0;      /*!<  FIFO for Endpoint 0,                                  Address offset: 0x20 */
X	volatile uint8_t FIFO0;       
N	__IO uint8_t RES8; 		 /*!<  RES8         									 	 Address offset: 0x21 */
X	volatile uint8_t RES8; 		  
N	__IO uint8_t RES9; 		 /*!<  RES9         									 	 Address offset: 0x22 */
X	volatile uint8_t RES9; 		  
N	__IO uint8_t RES10; 	 /*!<  RES10        									 	 Address offset: 0x23 */	
X	volatile uint8_t RES10; 	  	
N	__IO uint8_t FIFO1;      /*!<  FIFO for Endpoint 1,                              	 Address offset: 0x24 */
X	volatile uint8_t FIFO1;       
N	__IO uint8_t RES11; 	 /*!<  RES11          									 	 Address offset: 0x25 */
X	volatile uint8_t RES11; 	  
N	__IO uint8_t RES12; 	 /*!<  RES12          									 	 Address offset: 0x26 */
X	volatile uint8_t RES12; 	  
N	__IO uint8_t RES13; 	 /*!<  RES13          									 	 Address offset: 0x27 */	
X	volatile uint8_t RES13; 	  	
N	__IO uint8_t FIFO2;      /*!<  FIFO for Endpoint 2,                              	 Address offset: 0x28 */
X	volatile uint8_t FIFO2;       
N	__IO uint8_t RES14; 	 /*!<  RES14          									 	 Address offset: 0x29 */
X	volatile uint8_t RES14; 	  
N	__IO uint8_t RES15; 	 /*!<  RES15          									 	 Address offset: 0x2A */
X	volatile uint8_t RES15; 	  
N	__IO uint8_t RES16; 	 /*!<  RES16          									 	 Address offset: 0x2B */	
X	volatile uint8_t RES16; 	  	
N	__IO uint8_t FIFO3;      /*!<  FIFO for Endpoint 3,                              	 Address offset: 0x2C */
X	volatile uint8_t FIFO3;       
N	__IO uint8_t RES17; 	 /*!<  RES17          									 	 Address offset: 0x2D */
X	volatile uint8_t RES17; 	  
N	__IO uint8_t RES18; 	 /*!<  RES18          									 	 Address offset: 0x2E */
X	volatile uint8_t RES18; 	  
N	__IO uint8_t RES19; 	 /*!<  RES19          									 	 Address offset: 0x2F */	
X	volatile uint8_t RES19; 	  	
N	__IO uint8_t FIFO4;      /*!<  FIFO for Endpoint 4,                              	 Address offset: 0x30 */
X	volatile uint8_t FIFO4;       
N	__IO uint8_t RES20; 	 /*!<  RES20          									 	 Address offset: 0x31 */
X	volatile uint8_t RES20; 	  
N	__IO uint8_t RES21; 	 /*!<  RES21          									 	 Address offset: 0x32 */
X	volatile uint8_t RES21; 	  
N	__IO uint8_t RES22; 	 /*!<  RES22          									 	 Address offset: 0x33 */	
X	volatile uint8_t RES22; 	  	
N	__IO uint8_t FIFO5;      /*!<  FIFO for Endpoint 5,                              	 Address offset: 0x34 */
X	volatile uint8_t FIFO5;       
N	__IO uint8_t RES23; 	 /*!<  RES23         									 	 Address offset: 0x35 */
X	volatile uint8_t RES23; 	  
N	__IO uint8_t RES24; 	 /*!<  RES24         									 	 Address offset: 0x36 */
X	volatile uint8_t RES24; 	  
N	__IO uint8_t RES25; 	 /*!<  RES25         									 	 Address offset: 0x37 */	
X	volatile uint8_t RES25; 	  	
N	__IO uint8_t FIFO6;      /*!<  FIFO for Endpoint 6,                              	 Address offset: 0x38 */
X	volatile uint8_t FIFO6;       
N	__IO uint8_t RES26; 	 /*!<  RES26          									 	 Address offset: 0x39 */
X	volatile uint8_t RES26; 	  
N	__IO uint8_t RES27; 	 /*!<  RES27          									 	 Address offset: 0x3A */
X	volatile uint8_t RES27; 	  
N	__IO uint8_t RES28; 	 /*!<  RES28          									 	 Address offset: 0x3B */	
X	volatile uint8_t RES28; 	  	
N	__IO uint8_t FIFO7;      /*!<  FIFO for Endpoint 7,                                  Address offset: 0x3C */
X	volatile uint8_t FIFO7;       
N}USB_TypeDef;
N
N/** 
N  * @brief Power Control
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;   /*!< PWR power control register,        Address offset: 0x00 */
X  volatile uint32_t CR;    
N  __IO uint32_t CSR;  /*!< PWR power control/status register, Address offset: 0x04 */
X  volatile uint32_t CSR;   
N} PWR_TypeDef;
N
N
N/** 
N  * @brief Reset and Clock Control
N  */
Ntypedef struct
N{
N  __IO uint32_t CR;         /*!< RCC clock control register,                                  Address offset: 0x00 */
X  volatile uint32_t CR;          
N  __IO uint32_t CFGR;       /*!< RCC clock configuration register,                            Address offset: 0x04 */
X  volatile uint32_t CFGR;        
N  __IO uint32_t CIR;        /*!< RCC clock interrupt register,                                Address offset: 0x08 */
X  volatile uint32_t CIR;         
N  __IO uint32_t APB2RSTR;   /*!< RCC APB2 peripheral reset register,                          Address offset: 0x0C */
X  volatile uint32_t APB2RSTR;    
N  __IO uint32_t APB1RSTR;   /*!< RCC APB1 peripheral reset register,                          Address offset: 0x10 */
X  volatile uint32_t APB1RSTR;    
N  __IO uint32_t AHBENR;     /*!< RCC AHB peripheral clock register,                           Address offset: 0x14 */
X  volatile uint32_t AHBENR;      
N  __IO uint32_t APB2ENR;    /*!< RCC APB2 peripheral clock enable register,                   Address offset: 0x18 */
X  volatile uint32_t APB2ENR;     
N  __IO uint32_t APB1ENR;    /*!< RCC APB1 peripheral clock enable register,                   Address offset: 0x1C */
X  volatile uint32_t APB1ENR;     
N  __IO uint32_t BDCR;       /*!< RCC Backup domain control register,                          Address offset: 0x20 */ 
X  volatile uint32_t BDCR;         
N  __IO uint32_t CSR;        /*!< RCC clock control & status register,                         Address offset: 0x24 */
X  volatile uint32_t CSR;         
N  __IO uint32_t AHBRSTR;    /*!< RCC AHB peripheral reset register,                           Address offset: 0x28 */
X  volatile uint32_t AHBRSTR;     
N  __IO uint32_t CFGR2;      /*!< RCC clock configuration register 2,                          Address offset: 0x2C */
X  volatile uint32_t CFGR2;       
N  __IO uint32_t CFGR3;      /*!< RCC clock configuration register 3,                          Address offset: 0x30 */
X  volatile uint32_t CFGR3;       
N  __IO uint32_t CR2;        /*!< RCC clock control register 2,                                Address offset: 0x34 */
X  volatile uint32_t CR2;         
N  __IO uint32_t HSECFG;      /*!< RCC clock configuration register 2,                         Address offset: 0x38 New*/
X  volatile uint32_t HSECFG;       
N  __IO uint32_t CFGR4;      /*!< RCC clock configuration register 3,                          Address offset: 0x3C New*/
X  volatile uint32_t CFGR4;       
N  __IO uint32_t TRIM;        /*!< RCC clock control register 2,                               Address offset: 0x40 New*/
X  volatile uint32_t TRIM;         
N} RCC_TypeDef;
N
N/** 
N  * @brief Real-Time Clock
N  */
N
Ntypedef struct
N{
N  __IO uint32_t TR;         /*!< RTC time register,                                         Address offset: 0x00 */
X  volatile uint32_t TR;          
N  __IO uint32_t DR;         /*!< RTC date register,                                         Address offset: 0x04 */
X  volatile uint32_t DR;          
N  __IO uint32_t CR;         /*!< RTC control register,                                      Address offset: 0x08 */                                                                                            
X  volatile uint32_t CR;                                                                                                      
N  __IO uint32_t ISR;        /*!< RTC initialization and status register,                    Address offset: 0x0C */
X  volatile uint32_t ISR;         
N  __IO uint32_t PRER;       /*!< RTC prescaler register,                                    Address offset: 0x10 */
X  volatile uint32_t PRER;        
N       uint32_t RESERVED1;  /*!< Reserved,                                                  Address offset: 0x14 */
N       uint32_t RESERVED2;  /*!< Reserved,                                                  Address offset: 0x18 */
N  __IO uint32_t ALRMAR;     /*!< RTC alarm A register,                                      Address offset: 0x1C */
X  volatile uint32_t ALRMAR;      
N       uint32_t RESERVED3;  /*!< Reserved,                                                  Address offset: 0x20 */
N  __IO uint32_t WPR;        /*!< RTC write protection register,                             Address offset: 0x24 */
X  volatile uint32_t WPR;         
N  __IO uint32_t SSR;        /*!< RTC sub second register,                                   Address offset: 0x28 */
X  volatile uint32_t SSR;         
N  __IO uint32_t SHIFTR;     /*!< RTC shift control register,                                Address offset: 0x2C */
X  volatile uint32_t SHIFTR;      
N  __IO uint32_t TSTR;       /*!< RTC time stamp time register,                              Address offset: 0x30 */
X  volatile uint32_t TSTR;        
N  __IO uint32_t TSDR;       /*!< RTC time stamp date register,                              Address offset: 0x34 */
X  volatile uint32_t TSDR;        
N  __IO uint32_t TSSSR;      /*!< RTC time-stamp sub second register,                        Address offset: 0x38 */
X  volatile uint32_t TSSSR;       
N  __IO uint32_t CALR;       /*!< RTC calibration register,                                  Address offset: 0x3C */
X  volatile uint32_t CALR;        
N  __IO uint32_t TAFCR;      /*!< RTC tamper and alternate function configuration register,  Address offset: 0x40 */
X  volatile uint32_t TAFCR;       
N  __IO uint32_t ALRMASSR;   /*!< RTC alarm A sub second register,                           Address offset: 0x44 */
X  volatile uint32_t ALRMASSR;    
N} RTC_TypeDef;
N
N/* Old register name definition maintained for legacy purpose */
N#define CAL   CALR
N
N/** 
N  * @brief Serial Peripheral Interface
N  */
N  
Ntypedef struct
N{
N  __IO uint16_t CR1;      /*!< SPI Control register 1 (not used in I2S mode),       Address offset: 0x00 */
X  volatile uint16_t CR1;       
N  uint16_t  RESERVED0;    /*!< Reserved, 0x02                                                            */
N  __IO uint16_t CR2;      /*!< SPI Control register 2,                              Address offset: 0x04 */
X  volatile uint16_t CR2;       
N  uint16_t  RESERVED1;    /*!< Reserved, 0x06                                                            */
N  __IO uint16_t SR;       /*!< SPI Status register,                                 Address offset: 0x08 */
X  volatile uint16_t SR;        
N  uint16_t  RESERVED2;    /*!< Reserved, 0x0A                                                            */
N  __IO uint16_t DR;       /*!< SPI data register,                                   Address offset: 0x0C */
X  volatile uint16_t DR;        
N  uint16_t  RESERVED3;    /*!< Reserved, 0x0E                                                            */
N  __IO uint16_t CRCPR;    /*!< SPI CRC polynomial register (not used in I2S mode),  Address offset: 0x10 */
X  volatile uint16_t CRCPR;     
N  uint16_t  RESERVED4;    /*!< Reserved, 0x12                                                            */
N  __IO uint16_t RXCRCR;   /*!< SPI Rx CRC register (not used in I2S mode),          Address offset: 0x14 */
X  volatile uint16_t RXCRCR;    
N  uint16_t  RESERVED5;    /*!< Reserved, 0x16                                                            */
N  __IO uint16_t TXCRCR;   /*!< SPI Tx CRC register (not used in I2S mode),          Address offset: 0x18 */
X  volatile uint16_t TXCRCR;    
N  uint16_t  RESERVED6;    /*!< Reserved, 0x1A                                                            */ 
N // __IO uint16_t I2SCFGR;  /*!< SPI_I2S configuration register,                      Address offset: 0x1C */
N // uint16_t  RESERVED7;    /*!< Reserved, 0x1E                                                            */
N // __IO uint16_t I2SPR;    /*!< SPI_I2S prescaler register,                          Address offset: 0x20 */
N  //uint16_t  RESERVED8;    /*!< Reserved, 0x22                                                            */    
N} SPI_TypeDef;
N
N
N/** 
N  * @brief TIM
N  */
Ntypedef struct
N{
N  __IO uint16_t CR1;             /*!< TIM control register 1,                      Address offset: 0x00 */
X  volatile uint16_t CR1;              
N  uint16_t      RESERVED0;       /*!< Reserved,                                                    0x02 */
N  __IO uint16_t CR2;             /*!< TIM control register 2,                      Address offset: 0x04 */
X  volatile uint16_t CR2;              
N  uint16_t      RESERVED1;       /*!< Reserved,                                                    0x06 */
N  __IO uint16_t SMCR;            /*!< TIM slave Mode Control register,             Address offset: 0x08 */
X  volatile uint16_t SMCR;             
N  uint16_t      RESERVED2;       /*!< Reserved,                                                    0x0A */
N  __IO uint16_t DIER;            /*!< TIM DMA/interrupt enable register,           Address offset: 0x0C */
X  volatile uint16_t DIER;             
N  uint16_t      RESERVED3;       /*!< Reserved,                                                    0x0E */
N  __IO uint16_t SR;              /*!< TIM status register,                         Address offset: 0x10 */
X  volatile uint16_t SR;               
N  uint16_t      RESERVED4;       /*!< Reserved,                                                    0x12 */
N  __IO uint16_t EGR;             /*!< TIM event generation register,               Address offset: 0x14 */
X  volatile uint16_t EGR;              
N  uint16_t      RESERVED5;       /*!< Reserved,                                                    0x16 */
N  __IO uint16_t CCMR1;           /*!< TIM  capture/compare mode register 1,        Address offset: 0x18 */
X  volatile uint16_t CCMR1;            
N  uint16_t      RESERVED6;       /*!< Reserved,                                                    0x1A */
N  __IO uint16_t CCMR2;           /*!< TIM  capture/compare mode register 2,        Address offset: 0x1C */
X  volatile uint16_t CCMR2;            
N  uint16_t      RESERVED7;       /*!< Reserved,                                                    0x1E */
N  __IO uint16_t CCER;            /*!< TIM capture/compare enable register,         Address offset: 0x20 */
X  volatile uint16_t CCER;             
N  uint16_t      RESERVED8;       /*!< Reserved,                                                    0x22 */
N  __IO uint32_t CNT;             /*!< TIM counter register,                        Address offset: 0x24 */
X  volatile uint32_t CNT;              
N  __IO uint16_t PSC;             /*!< TIM prescaler register,                      Address offset: 0x28 */
X  volatile uint16_t PSC;              
N  uint16_t      RESERVED10;      /*!< Reserved,                                                    0x2A */
N  __IO uint32_t ARR;             /*!< TIM auto-reload register,                    Address offset: 0x2C */
X  volatile uint32_t ARR;              
N  __IO uint16_t RCR;             /*!< TIM  repetition counter register,            Address offset: 0x30 */
X  volatile uint16_t RCR;              
N  uint16_t      RESERVED12;      /*!< Reserved,                                                    0x32 */
N  __IO uint32_t CCR1;            /*!< TIM capture/compare register 1,              Address offset: 0x34 */
X  volatile uint32_t CCR1;             
N  __IO uint32_t CCR2;            /*!< TIM capture/compare register 2,              Address offset: 0x38 */
X  volatile uint32_t CCR2;             
N  __IO uint32_t CCR3;            /*!< TIM capture/compare register 3,              Address offset: 0x3C */
X  volatile uint32_t CCR3;             
N  __IO uint32_t CCR4;            /*!< TIM capture/compare register 4,              Address offset: 0x40 */
X  volatile uint32_t CCR4;             
N  __IO uint16_t BDTR;            /*!< TIM break and dead-time register,            Address offset: 0x44 */
X  volatile uint16_t BDTR;             
N  uint16_t      RESERVED17;      /*!< Reserved,                                                    0x26 */
N  __IO uint16_t DCR;             /*!< TIM DMA control register,                    Address offset: 0x48 */
X  volatile uint16_t DCR;              
N  uint16_t      RESERVED18;      /*!< Reserved,                                                    0x4A */
N  __IO uint16_t DMAR;            /*!< TIM DMA address for full transfer register,  Address offset: 0x4C */
X  volatile uint16_t DMAR;             
N  uint16_t      RESERVED19;      /*!< Reserved,                                                    0x4E */
N  __IO uint16_t OR;              /*!< TIM option register,                         Address offset: 0x50 */
X  volatile uint16_t OR;               
N  uint16_t      RESERVED20;      /*!< Reserved,                                                    0x52 */
N} TIM_TypeDef;
N
N/**
N  * @brief TSC 
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;          /*!< TSC configer register                          Address offset: 0x00 */
X  volatile uint32_t CR;           
N  __IO uint32_t CFGR;        /*!< TSC configuration register,                    Address offset: 0x04 */
X  volatile uint32_t CFGR;         
N}TSC_TypeDef;
N
N/** 
N  * @brief Universal Synchronous Asynchronous Receiver Transmitter
N  */
N  
Ntypedef struct
N{
N  __IO uint32_t CR1;    /*!< USART Control register 1,                 Address offset: 0x00 */ 
X  volatile uint32_t CR1;      
N  __IO uint32_t CR2;    /*!< USART Control register 2,                 Address offset: 0x04 */ 
X  volatile uint32_t CR2;      
N  __IO uint32_t CR3;    /*!< USART Control register 3,                 Address offset: 0x08 */
X  volatile uint32_t CR3;     
N  __IO uint16_t BRR;    /*!< USART Baud rate register,                 Address offset: 0x0C */
X  volatile uint16_t BRR;     
N  //uint16_t  RESERVED1;  /*!< Reserved, 0x0E                                                 */  
N  //__IO uint16_t GTPR;   /*!< USART Guard time and prescaler register,  Address offset: 0x10 */
N  //uint16_t  RESERVED2;  /*!< Reserved, 0x12                                                 */
N  uint32_t  RESERVED2;  /*!< Reserved, 0x12                                                 */
N  __IO uint32_t RTOR;   /*!< USART Receiver Time Out register,         Address offset: 0x14 */  
X  volatile uint32_t RTOR;      
N  __IO uint16_t RQR;    /*!< USART Request register,                   Address offset: 0x18 */
X  volatile uint16_t RQR;     
N  uint16_t  RESERVED3;  /*!< Reserved, 0x1A                                                 */
N  __IO uint32_t ISR;    /*!< USART Interrupt and status register,      Address offset: 0x1C */
X  volatile uint32_t ISR;     
N  __IO uint32_t ICR;    /*!< USART Interrupt flag Clear register,      Address offset: 0x20 */
X  volatile uint32_t ICR;     
N  __IO uint16_t RDR;    /*!< USART Receive Data register,              Address offset: 0x24 */
X  volatile uint16_t RDR;     
N  uint16_t  RESERVED4;  /*!< Reserved, 0x26                                                 */
N  __IO uint16_t TDR;    /*!< USART Transmit Data register,             Address offset: 0x28 */
X  volatile uint16_t TDR;     
N  uint16_t  RESERVED5;  /*!< Reserved, 0x2A                                                 */
N} USART_TypeDef;
N
N
N/** 
N  * @brief Window WATCHDOG
N  */
Ntypedef struct
N{
N  __IO uint32_t CR;   /*!< WWDG Control register,       Address offset: 0x00 */
X  volatile uint32_t CR;    
N  __IO uint32_t CFR;  /*!< WWDG Configuration register, Address offset: 0x04 */
X  volatile uint32_t CFR;   
N  __IO uint32_t SR;   /*!< WWDG Status register,        Address offset: 0x08 */
X  volatile uint32_t SR;    
N} WWDG_TypeDef;
N
N/**
N  * @}
N  */
N  
N/** @addtogroup Peripheral_memory_map
N  * @{
N  */
N
N#define FLASH_BASE            ((uint32_t)0x08000000) /*!< FLASH base address in the alias region */
N#define SRAM_BASE             ((uint32_t)0x20000000) /*!< SRAM base address in the alias region */
N#define PERIPH_BASE           ((uint32_t)0x40000000) /*!< Peripheral base address in the alias region */
N
N/*!< Peripheral memory map */
N#define APBPERIPH_BASE        PERIPH_BASE
N#define AHBPERIPH_BASE        (PERIPH_BASE + 0x00020000)
N#define AHB2PERIPH_BASE       (PERIPH_BASE + 0x08000000)
N
N#define TIM2_BASE             (APBPERIPH_BASE + 0x00000000)
N#define TIM3_BASE             (APBPERIPH_BASE + 0x00000400)
N#define TIM6_BASE             (APBPERIPH_BASE + 0x00001000)
N//#define TIM7_BASE             (APBPERIPH_BASE + 0x00001400)
N#define TIM14_BASE            (APBPERIPH_BASE + 0x00002000)
N#define RTC_BASE              (APBPERIPH_BASE + 0x00002800)
N#define WWDG_BASE             (APBPERIPH_BASE + 0x00002C00)
N#define IWDG_BASE             (APBPERIPH_BASE + 0x00003000)
N#define SPI2_BASE             (APBPERIPH_BASE + 0x00003800)
N#define USART2_BASE           (APBPERIPH_BASE + 0x00004400)
N#define I2C1_BASE             (APBPERIPH_BASE + 0x00005400)
N#define I2C2_BASE             (APBPERIPH_BASE + 0x00005800)
N#define USB_BASE              (APBPERIPH_BASE + 0x00005C00)
N#define CRS_BASE              (APBPERIPH_BASE + 0x00006C00)
N#define PWR_BASE              (APBPERIPH_BASE + 0x00007000)
N
N#define SYSCFG_BASE           (APBPERIPH_BASE + 0x00010000)
N#define COMP_BASE             (APBPERIPH_BASE + 0x00010000)
N#define OPA_BASE             (APBPERIPH_BASE + 0x00010000)
N#define DAC_BASE              (APBPERIPH_BASE + 0x00010000)
N
N#define EXTI_BASE             (APBPERIPH_BASE + 0x00010400)
N#define ADC1_BASE             (APBPERIPH_BASE + 0x00012400) /* KVL: TBC*/
N#define ADC_BASE              (APBPERIPH_BASE + 0x00012708) /* KVL: TBC*/
N#define TIM1_BASE             (APBPERIPH_BASE + 0x00012C00)
N#define SPI1_BASE             (APBPERIPH_BASE + 0x00013000)
N#define USART1_BASE           (APBPERIPH_BASE + 0x00013800)
N#define TIM15_BASE            (APBPERIPH_BASE + 0x00014000)
N#define TIM16_BASE            (APBPERIPH_BASE + 0x00014400)
N#define TIM17_BASE            (APBPERIPH_BASE + 0x00014800)
N#define DBGMCU_BASE           (APBPERIPH_BASE + 0x00015800)
N
N#define DMA1_BASE             (AHBPERIPH_BASE + 0x00000000)
N#define DMA1_Channel1_BASE    (DMA1_BASE + 0x00000008)
N#define DMA1_Channel2_BASE    (DMA1_BASE + 0x0000001C)
N#define DMA1_Channel3_BASE    (DMA1_BASE + 0x00000030)
N#define DMA1_Channel4_BASE    (DMA1_BASE + 0x00000044)
N#define DMA1_Channel5_BASE    (DMA1_BASE + 0x00000058)
N#define DMA1_Channel6_BASE    (DMA1_BASE + 0x0000006C)
N#define DMA1_Channel7_BASE    (DMA1_BASE + 0x00000080)
N
N#define RCC_BASE              (AHBPERIPH_BASE + 0x00001000)
N#define FLASH_R_BASE          (AHBPERIPH_BASE + 0x00002000) /*!< FLASH registers base address */
N#define OB_BASE               ((uint32_t)0x1FFFF800)        /*!< FLASH Option Bytes base address */
N#define CRC_BASE              (AHBPERIPH_BASE + 0x00003000)
N#define TSC_BASE              (AHBPERIPH_BASE + 0x00004000)
N
N#define GPIOA_BASE            (AHB2PERIPH_BASE + 0x00000000)
N#define GPIOB_BASE            (AHB2PERIPH_BASE + 0x00000400)
N#define GPIOC_BASE            (AHB2PERIPH_BASE + 0x00000800)
N#define GPIOD_BASE            (AHB2PERIPH_BASE + 0x00000C00)
N//#define GPIOE_BASE            (AHB2PERIPH_BASE + 0x00001000)
N#define GPIOF_BASE            (AHB2PERIPH_BASE + 0x00001400)
N
N/**
N  * @}
N  */
N  
N/** @addtogroup Peripheral_declaration
N  * @{
N  */  
N
N#define TIM2                ((TIM_TypeDef *) TIM2_BASE)
N#define TIM3                ((TIM_TypeDef *) TIM3_BASE)
N#define TIM6                ((TIM_TypeDef *) TIM6_BASE)
N#define TIM7                ((TIM_TypeDef *) TIM7_BASE)
N#define TIM14               ((TIM_TypeDef *) TIM14_BASE)
N#define RTC                 ((RTC_TypeDef *) RTC_BASE)
N#define WWDG                ((WWDG_TypeDef *) WWDG_BASE)
N#define IWDG                ((IWDG_TypeDef *) IWDG_BASE)
N#define SPI2                ((SPI_TypeDef *) SPI2_BASE)
N#define USART2              ((USART_TypeDef *) USART2_BASE)
N#define I2C1                ((I2C_TypeDef *) I2C1_BASE)
N#define I2C2                ((I2C_TypeDef *) I2C2_BASE)
N#define USB                 ((USB_TypeDef *) USB_BASE)
N#define CRS                 ((CRS_TypeDef *) CRS_BASE)
N#define PWR                 ((PWR_TypeDef *) PWR_BASE)
N
N#define SYSCFG              ((SYSCFG_TypeDef *) SYSCFG_BASE)
N#define COMP                ((COMP_TypeDef *) COMP_BASE)
N#define OPA                 ((OPA_TypeDef *) OPA_BASE)
N#define DAC                 ((DAC_TypeDef *) DAC_BASE)
N#define EXTI                ((EXTI_TypeDef *) EXTI_BASE)
N#define ADC1                ((ADC_TypeDef *) ADC1_BASE)
N#define ADC                 ((ADC_Common_TypeDef *) ADC_BASE)
N#define TIM1                ((TIM_TypeDef *) TIM1_BASE)
N#define SPI1                ((SPI_TypeDef *) SPI1_BASE)
N#define USART1              ((USART_TypeDef *) USART1_BASE)
N#define TIM15               ((TIM_TypeDef *) TIM15_BASE)
N#define TIM16               ((TIM_TypeDef *) TIM16_BASE)
N#define TIM17               ((TIM_TypeDef *) TIM17_BASE)
N#define DBGMCU              ((DBGMCU_TypeDef *) DBGMCU_BASE)
N
N#define DMA1                ((DMA_TypeDef *) DMA1_BASE)
N#define DMA1_Channel1       ((DMA_Channel_TypeDef *) DMA1_Channel1_BASE)
N#define DMA1_Channel2       ((DMA_Channel_TypeDef *) DMA1_Channel2_BASE)
N#define DMA1_Channel3       ((DMA_Channel_TypeDef *) DMA1_Channel3_BASE)
N#define DMA1_Channel4       ((DMA_Channel_TypeDef *) DMA1_Channel4_BASE)
N#define DMA1_Channel5       ((DMA_Channel_TypeDef *) DMA1_Channel5_BASE)
N#define DMA1_Channel6       ((DMA_Channel_TypeDef *) DMA1_Channel6_BASE)
N#define DMA1_Channel7       ((DMA_Channel_TypeDef *) DMA1_Channel7_BASE)
N
N#define FLASH               ((FLASH_TypeDef *) FLASH_R_BASE)
N#define OB                  ((OB_TypeDef *) OB_BASE) 
N#define RCC                 ((RCC_TypeDef *) RCC_BASE)
N#define CRC                 ((CRC_TypeDef *) CRC_BASE)
N#define TSC                 ((TSC_TypeDef *) TSC_BASE)
N
N#define GPIOA               ((GPIO_TypeDef *) GPIOA_BASE)
N#define GPIOB               ((GPIO_TypeDef *) GPIOB_BASE)
N#define GPIOC               ((GPIO_TypeDef *) GPIOC_BASE)
N#define GPIOD               ((GPIO_TypeDef *) GPIOD_BASE)
N#define GPIOE               ((GPIO_TypeDef *) GPIOE_BASE)
N#define GPIOF               ((GPIO_TypeDef *) GPIOF_BASE)
N
N/**
N  * @}
N  */
N
N/** @addtogroup Exported_constants
N  * @{
N  */
N  
N  /** @addtogroup Peripheral_Registers_Bits_Definition
N  * @{
N  */
N    
N/******************************************************************************/
N/*                         Peripheral Registers Bits Definition               */
N/******************************************************************************/
N/******************************************************************************/
N/*                                                                            */
N/*                      Analog to Digital Converter (ADC)                     */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bits definition for ADC_ISR register  ******************/
N#define ADC_ISR_AWD                          ((uint32_t)0x00000080)        /*!< Analog watchdog flag */
N#define ADC_ISR_OVR                          ((uint32_t)0x00000010)        /*!< Overrun flag */
N#define ADC_ISR_EOSEQ                        ((uint32_t)0x00000008)        /*!< End of Sequence flag */
N#define ADC_ISR_EOC                          ((uint32_t)0x00000004)        /*!< End of Conversion */
N#define ADC_ISR_EOSMP                        ((uint32_t)0x00000002)        /*!< End of sampling flag */
N#define ADC_ISR_ADRDY                        ((uint32_t)0x00000001)        /*!< ADC Ready */
N
N/* Old EOSEQ bit definition, maintained for legacy purpose */
N#define ADC_ISR_EOS                          ADC_ISR_EOSEQ
N
N/********************  Bits definition for ADC_IER register  ******************/
N#define ADC_IER_AWDIE                        ((uint32_t)0x00000080)        /*!< Analog Watchdog interrupt enable */
N#define ADC_IER_OVRIE                        ((uint32_t)0x00000010)        /*!< Overrun interrupt enable */
N#define ADC_IER_EOSEQIE                      ((uint32_t)0x00000008)        /*!< End of Sequence of conversion interrupt enable */
N#define ADC_IER_EOCIE                        ((uint32_t)0x00000004)        /*!< End of Conversion interrupt enable */
N#define ADC_IER_EOSMPIE                      ((uint32_t)0x00000002)        /*!< End of sampling interrupt enable */
N#define ADC_IER_ADRDYIE                      ((uint32_t)0x00000001)        /*!< ADC Ready interrupt enable */
N
N/* Old EOSEQIE bit definition, maintained for legacy purpose */
N#define ADC_IER_EOSIE                        ADC_IER_EOSEQIE
N
N/********************  Bits definition for ADC_CR register  *******************/
N#define ADC_CR_ADCAL                         ((uint32_t)0x80000000)        /*!< ADC calibration */
N#define ADC_CR_ADSTP                         ((uint32_t)0x00000010)        /*!< ADC stop of conversion command */
N#define ADC_CR_ADSTART                       ((uint32_t)0x00000004)        /*!< ADC start of conversion */
N#define ADC_CR_ADDIS                         ((uint32_t)0x00000002)        /*!< ADC disable command */
N#define ADC_CR_ADEN                          ((uint32_t)0x00000001)        /*!< ADC enable control */
N
N/*******************  Bits definition for ADC_CFGR1 register  *****************/
N#define  ADC_CFGR1_AWDCH                      ((uint32_t)0x7C000000)       /*!< AWDCH[4:0] bits (Analog watchdog channel select bits) */
N#define  ADC_CFGR1_AWDCH_0                    ((uint32_t)0x04000000)       /*!< Bit 0 */
N#define  ADC_CFGR1_AWDCH_1                    ((uint32_t)0x08000000)       /*!< Bit 1 */
N#define  ADC_CFGR1_AWDCH_2                    ((uint32_t)0x10000000)       /*!< Bit 2 */
N#define  ADC_CFGR1_AWDCH_3                    ((uint32_t)0x20000000)       /*!< Bit 3 */
N#define  ADC_CFGR1_AWDCH_4                    ((uint32_t)0x40000000)       /*!< Bit 4 */
N#define  ADC_CFGR1_AWDEN                      ((uint32_t)0x00800000)       /*!< Analog watchdog enable on regular channels */
N#define  ADC_CFGR1_AWDSGL                     ((uint32_t)0x00400000)       /*!< Enable the watchdog on a single channel or on all channels  */
N#define  ADC_CFGR1_DISCEN                     ((uint32_t)0x00010000)       /*!< Discontinuous mode on regular channels */
N#define  ADC_CFGR1_AUTOFF                     ((uint32_t)0x00008000)       /*!< ADC auto power off */
N#define  ADC_CFGR1_WAIT                       ((uint32_t)0x00004000)       /*!< ADC wait conversion mode */
N#define  ADC_CFGR1_CONT                       ((uint32_t)0x00002000)       /*!< Continuous Conversion */
N#define  ADC_CFGR1_OVRMOD                     ((uint32_t)0x00001000)       /*!< Overrun mode */
N#define  ADC_CFGR1_EXTEN                      ((uint32_t)0x00000C00)       /*!< EXTEN[1:0] bits (External Trigger Conversion mode for regular channels) */
N#define  ADC_CFGR1_EXTEN_0                    ((uint32_t)0x00000400)       /*!< Bit 0 */
N#define  ADC_CFGR1_EXTEN_1                    ((uint32_t)0x00000800)       /*!< Bit 1 */
N#define  ADC_CFGR1_EXTSEL                     ((uint32_t)0x000001C0)       /*!< EXTSEL[2:0] bits (External Event Select for regular group) */
N#define  ADC_CFGR1_EXTSEL_0                   ((uint32_t)0x00000040)       /*!< Bit 0 */
N#define  ADC_CFGR1_EXTSEL_1                   ((uint32_t)0x00000080)       /*!< Bit 1 */
N#define  ADC_CFGR1_EXTSEL_2                   ((uint32_t)0x00000100)       /*!< Bit 2 */
N#define  ADC_CFGR1_ALIGN                      ((uint32_t)0x00000020)       /*!< Data Alignment */
N#define  ADC_CFGR1_RES                        ((uint32_t)0x00000018)       /*!< RES[1:0] bits (Resolution) */
N#define  ADC_CFGR1_RES_0                      ((uint32_t)0x00000008)       /*!< Bit 0 */
N#define  ADC_CFGR1_RES_1                      ((uint32_t)0x00000010)       /*!< Bit 1 */
N#define  ADC_CFGR1_SCANDIR                    ((uint32_t)0x00000004)       /*!< Sequence scan direction */
N#define  ADC_CFGR1_DMACFG                     ((uint32_t)0x00000002)       /*!< Direct memory access configuration */
N#define  ADC_CFGR1_DMAEN                      ((uint32_t)0x00000001)       /*!< Direct memory access enable */
N
N/* Old WAIT bit definition, maintained for legacy purpose */
N#define  ADC_CFGR1_AUTDLY                     ADC_CFGR1_WAIT
N
N/*******************  Bits definition for ADC_CFGR2 register  *****************/
N#define  ADC_CFGR2_CKMODE                     ((uint32_t)0xC0000000)       /*!< ADC clock mode */
N#define  ADC_CFGR2_CKMODE_1                   ((uint32_t)0x80000000)       /*!< ADC clocked by PCLK div4 */
N#define  ADC_CFGR2_CKMODE_0                   ((uint32_t)0x40000000)       /*!< ADC clocked by PCLK div2 */
N
N/* Old bit definition, maintained for legacy purpose */
N#define  ADC_CFGR2_JITOFFDIV4                 ADC_CFGR2_CKMODE_1           /*!< ADC clocked by PCLK div4 */
N#define  ADC_CFGR2_JITOFFDIV2                 ADC_CFGR2_CKMODE_0           /*!< ADC clocked by PCLK div2 */
N
N/******************  Bit definition for ADC_SMPR register  ********************/
N#define  ADC_SMPR_SMP                      ((uint32_t)0x00000007)        /*!< SMP[2:0] bits (Sampling time selection) */
N#define  ADC_SMPR_SMP_0                    ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  ADC_SMPR_SMP_1                    ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  ADC_SMPR_SMP_2                    ((uint32_t)0x00000004)        /*!< Bit 2 */
N
N/* Old bit definition, maintained for legacy purpose */
N#define  ADC_SMPR1_SMPR                      ADC_SMPR_SMP        /*!< SMP[2:0] bits (Sampling time selection) */
N#define  ADC_SMPR1_SMPR_0                    ADC_SMPR_SMP_0        /*!< Bit 0 */
N#define  ADC_SMPR1_SMPR_1                    ADC_SMPR_SMP_1        /*!< Bit 1 */
N#define  ADC_SMPR1_SMPR_2                    ADC_SMPR_SMP_2        /*!< Bit 2 */
N
N/*******************  Bit definition for ADC_TR register  ********************/
N#define  ADC_TR_HT                          ((uint32_t)0x0FFF0000)        /*!< Analog watchdog high threshold */
N#define  ADC_TR_LT                          ((uint32_t)0x00000FFF)        /*!< Analog watchdog low threshold */
N
N/* Old bit definition, maintained for legacy purpose */
N#define  ADC_HTR_HT                          ADC_TR_HT                    /*!< Analog watchdog high threshold */
N#define  ADC_LTR_LT                          ADC_TR_LT                    /*!< Analog watchdog low threshold */
N
N/******************  Bit definition for ADC_CHSELR register  ******************/
N#define  ADC_CHSELR_CHSEL19                   ((uint32_t)0x00080000)        /*!< Channel 19 selection */
N#define  ADC_CHSELR_CHSEL18                   ((uint32_t)0x00040000)        /*!< Channel 18 selection */
N#define  ADC_CHSELR_CHSEL17                   ((uint32_t)0x00020000)        /*!< Channel 17 selection */
N#define  ADC_CHSELR_CHSEL16                   ((uint32_t)0x00010000)        /*!< Channel 16 selection */
N#define  ADC_CHSELR_CHSEL15                   ((uint32_t)0x00008000)        /*!< Channel 15 selection */
N#define  ADC_CHSELR_CHSEL14                   ((uint32_t)0x00004000)        /*!< Channel 14 selection */
N#define  ADC_CHSELR_CHSEL13                   ((uint32_t)0x00002000)        /*!< Channel 13 selection */
N#define  ADC_CHSELR_CHSEL12                   ((uint32_t)0x00001000)        /*!< Channel 12 selection */
N#define  ADC_CHSELR_CHSEL11                   ((uint32_t)0x00000800)        /*!< Channel 11 selection */
N#define  ADC_CHSELR_CHSEL10                   ((uint32_t)0x00000400)        /*!< Channel 10 selection */
N#define  ADC_CHSELR_CHSEL9                    ((uint32_t)0x00000200)        /*!< Channel 9 selection */
N#define  ADC_CHSELR_CHSEL8                    ((uint32_t)0x00000100)        /*!< Channel 8 selection */
N#define  ADC_CHSELR_CHSEL7                    ((uint32_t)0x00000080)        /*!< Channel 7 selection */
N#define  ADC_CHSELR_CHSEL6                    ((uint32_t)0x00000040)        /*!< Channel 6 selection */
N#define  ADC_CHSELR_CHSEL5                    ((uint32_t)0x00000020)        /*!< Channel 5 selection */
N#define  ADC_CHSELR_CHSEL4                    ((uint32_t)0x00000010)        /*!< Channel 4 selection */
N#define  ADC_CHSELR_CHSEL3                    ((uint32_t)0x00000008)        /*!< Channel 3 selection */
N#define  ADC_CHSELR_CHSEL2                    ((uint32_t)0x00000004)        /*!< Channel 2 selection */
N#define  ADC_CHSELR_CHSEL1                    ((uint32_t)0x00000002)        /*!< Channel 1 selection */
N#define  ADC_CHSELR_CHSEL0                    ((uint32_t)0x00000001)        /*!< Channel 0 selection */
N
N/********************  Bit definition for ADC_DR register  ********************/
N#define  ADC_DR_DATA                         ((uint32_t)0x0000FFFF)        /*!< Regular data */
N
N/*******************  Bit definition for ADC_CCR register  ********************/
N#define  ADC_CCR_VBATEN                       ((uint32_t)0x01000000)       /*!< Voltage battery enable */
N#define  ADC_CCR_TSEN                         ((uint32_t)0x00800000)       /*!< Tempurature sensore enable */
N#define  ADC_CCR_VREFEN                       ((uint32_t)0x00400000)       /*!< Vrefint enable */
N/******************************************************************************/
N/*                                                                            */
N/*                      Analog Comparators (COMP)                             */
N/*                                                                            */
N/******************************************************************************/
N/***********************  Bit definition for COMP_CSR register  ***************/
N/* NCOMP bits definition */
N#define	COMP_CSR_NCOMPEN							 ((uint32_t)0x00000001) /*!< MCOMP enable */
N#define	COMP_CSR_NCOMP_VIP_SEL				 ((uint32_t)0x0000000e) /*!<  */
N#define	COMP_CSR_NCOMP_VIP_SEL_0			 ((uint32_t)0x00000002) /*!<  */
N#define	COMP_CSR_NCOMP_VIP_SEL_1			 ((uint32_t)0x00000004) /*!<  */
N#define	COMP_CSR_NCOMP_VIP_SEL_2			 ((uint32_t)0x00000008) /*!<  */
N#define	COMP_CSR_NCOMP_VIN_SEL				 ((uint32_t)0x00000030) /*!<  */
N#define	COMP_CSR_NCOMP_VIN_SEL_0			 ((uint32_t)0x00000010) /*!<  */
N#define	COMP_CSR_NCOMP_VIN_SEL_1			 ((uint32_t)0x00000020) /*!<  */
N#define	COMP_CSR_NCOMPOUTSEL					 ((uint32_t)0x00000600) /*!<  */
N#define	COMP_CSR_NCOMPOUTSEL_0				 ((uint32_t)0x00000200) /*!<  */
N#define	COMP_CSR_NCOMPOUTSEL_1				 ((uint32_t)0x00000400) /*!<  */
N#define	COMP_CSR_NCOMP_POL						 ((uint32_t)0x00000800) /*!<  */
N#define	COMP_CSR_COMP1OUT							 ((uint32_t)0x00004000) /*!<  */
N#define	COMP_CSR_NCOMPLOCK						 ((uint32_t)0x00008000) /*!<  */
N
N/* PCOMP bits definition */
N#define	COMP_CSR_PCOMPEN							 ((uint32_t)0x00010000) /*!< PCOMP enable */
N#define	COMP_CSR_PCOMP_VIP_SEL				 ((uint32_t)0x00060000) /*!<  */
N#define	COMP_CSR_PCOMP_VIP_SEL_0			 ((uint32_t)0x00020000) /*!<  */
N#define	COMP_CSR_PCOMP_VIP_SEL_1			 ((uint32_t)0x00040000) /*!<  */
N#define	COMP_CSR_PCOMP_VIN_SEL				 ((uint32_t)0x00180000) /*!<  */
N#define	COMP_CSR_PCOMP_VIN_SEL_0			 ((uint32_t)0x00080000) /*!<  */
N#define	COMP_CSR_PCOMP_VIN_SEL_1			 ((uint32_t)0x00100000) /*!<  */
N#define	COMP_CSR_WNDWEN								 ((uint32_t)0x00800000) /*!<  */
N
N#define	COMP_CSR_PCOMPOUTSEL					 ((uint32_t)0x07000000) /*!<  */
N#define	COMP_CSR_PCOMPOUTSEL_0				 ((uint32_t)0x01000000) /*!<  */
N#define	COMP_CSR_PCOMPOUTSEL_1				 ((uint32_t)0x02000000) /*!<  */
N#define	COMP_CSR_PCOMPOUTSEL_2				 ((uint32_t)0x04000000) /*!<  */
N#define	COMP_CSR_PCOMP_POL						 ((uint32_t)0x08000000) /*!<  */
N#define	COMP_CSR_COMP2OUT							 ((uint32_t)0x40000000) /*!<  */
N#define	COMP_CSR_PCOMP_LOCK						 ((uint32_t)0x80000000) /*!<  */
N
N/******************************************************************************/
N/*                                                                            */
N/*                       CRC calculation unit (CRC)                           */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for CRC_DR register  *********************/
N#define  CRC_DR_DR                           ((uint32_t)0xFFFFFFFF) /*!< Data register bits */
N
N/*******************  Bit definition for CRC_IDR register  ********************/
N#define  CRC_IDR_IDR                         ((uint8_t)0xFF)        /*!< General-purpose 8-bit data register bits */
N
N/********************  Bit definition for CRC_CR register  ********************/
N#define  CRC_CR_RESET                        ((uint32_t)0x00000001) /*!< RESET the CRC computation unit bit */
N//#define  CRC_CR_POLSIZE                      ((uint32_t)0x00000018) /*!< Polynomial size bits (only for FT32F072X8 devices)*/
N//#define  CRC_CR_POLSIZE_0                    ((uint32_t)0x00000008) /*!< Polynomial size bit 0 (only for FT32F072X8 devices) */
N//#define  CRC_CR_POLSIZE_1                    ((uint32_t)0x00000010) /*!< Polynomial size bit 1 (only for FT32F072X8 devices) */
N#define  CRC_CR_REV_IN                       ((uint32_t)0x00000060) /*!< REV_IN Reverse Input Data bits */
N#define  CRC_CR_REV_IN_0                     ((uint32_t)0x00000020) /*!< REV_IN Bit 0 */
N#define  CRC_CR_REV_IN_1                     ((uint32_t)0x00000040) /*!< REV_IN Bit 1 */
N#define  CRC_CR_REV_OUT                      ((uint32_t)0x00000080) /*!< REV_OUT Reverse Output Data bits */
N
N/*******************  Bit definition for CRC_INIT register  *******************/
N#define  CRC_INIT_INIT                       ((uint32_t)0xFFFFFFFF) /*!< Initial CRC value bits */
N
N/*******************  Bit definition for CRC_POL register  ********************/
N//#define  CRC_POL_POL                         ((uint32_t)0xFFFFFFFF) /*!< Coefficients of the polynomial (only for FT32F072X8 devices) */
N
N/******************************************************************************/
N/*                                                                            */
N/*                          CRS Clock Recovery System                         */
N/*                   (Available only for FT32F072X8 devices)                */
N/******************************************************************************/
N
N/*******************  Bit definition for CRS_CR register  *********************/
N#define  CRS_CR_SYNCOKIE                     ((uint32_t)0x00000001) /* SYNC event OK interrupt enable        */
N#define  CRS_CR_SYNCWARNIE                   ((uint32_t)0x00000002) /* SYNC warning interrupt enable         */
N#define  CRS_CR_ERRIE                        ((uint32_t)0x00000004) /* SYNC error interrupt enable           */
N#define  CRS_CR_ESYNCIE                      ((uint32_t)0x00000008) /* Expected SYNC(ESYNCF) interrupt Enable*/
N#define  CRS_CR_CEN                          ((uint32_t)0x00000020) /* Frequency error counter enable        */
N#define  CRS_CR_AUTOTRIMEN                   ((uint32_t)0x00000040) /* Automatic trimming enable             */
N#define  CRS_CR_SWSYNC                       ((uint32_t)0x00000080) /* A Software SYNC event is generated    */
N#define  CRS_CR_TRIM                         ((uint32_t)0x00003F00) /* HSI48 oscillator smooth trimming      */
N
N/*******************  Bit definition for CRS_CFGR register  *********************/
N#define  CRS_CFGR_RELOAD                     ((uint32_t)0x0000FFFF) /* Counter reload value               */
N#define  CRS_CFGR_FELIM                      ((uint32_t)0x00FF0000) /* Frequency error limit              */
N#define  CRS_CFGR_SYNCDIV                    ((uint32_t)0x07000000) /* SYNC divider                       */
N#define  CRS_CFGR_SYNCDIV_0                  ((uint32_t)0x01000000) /* Bit 0                              */
N#define  CRS_CFGR_SYNCDIV_1                  ((uint32_t)0x02000000) /* Bit 1                              */
N#define  CRS_CFGR_SYNCDIV_2                  ((uint32_t)0x04000000) /* Bit 2                              */
N#define  CRS_CFGR_SYNCSRC                    ((uint32_t)0x30000000) /* SYNC signal source selection       */
N#define  CRS_CFGR_SYNCSRC_0                  ((uint32_t)0x10000000) /* Bit 0                              */
N#define  CRS_CFGR_SYNCSRC_1                  ((uint32_t)0x20000000) /* Bit 1                              */
N#define  CRS_CFGR_SYNCPOL                    ((uint32_t)0x80000000) /* SYNC polarity selection            */
N
N/*******************  Bit definition for CRS_ISR register  *********************/
N#define  CRS_ISR_SYNCOKF                     ((uint32_t)0x00000001) /* SYNC event OK flag             */
N#define  CRS_ISR_SYNCWARNF                   ((uint32_t)0x00000002) /* SYNC warning                   */
N#define  CRS_ISR_ERRF                        ((uint32_t)0x00000004) /* SYNC error flag                */
N#define  CRS_ISR_ESYNCF                      ((uint32_t)0x00000008) /* Expected SYNC flag             */
N#define  CRS_ISR_SYNCERR                     ((uint32_t)0x00000100) /* SYNC error                     */
N#define  CRS_ISR_SYNCMISS                    ((uint32_t)0x00000200) /* SYNC missed                    */
N#define  CRS_ISR_TRIMOVF                     ((uint32_t)0x00000400) /* Trimming overflow or underflow */
N#define  CRS_ISR_FEDIR                       ((uint32_t)0x00008000) /* Frequency error direction      */
N#define  CRS_ISR_FECAP                       ((uint32_t)0xFFFF0000) /* Frequency error capture        */
N
N/*******************  Bit definition for CRS_ICR register  *********************/
N#define  CRS_ICR_SYNCOKC                     ((uint32_t)0x00000001) /* SYNC event OK clear flag     */
N#define  CRS_ICR_SYNCWARNC                   ((uint32_t)0x00000002) /* SYNC warning clear flag      */
N#define  CRS_ICR_ERRC                        ((uint32_t)0x00000004) /* Error clear flag        */
N#define  CRS_ICR_ESYNCC                      ((uint32_t)0x00000008) /* Expected SYNC clear flag     */
N
N/******************************************************************************/
N/*                                                                            */
N/*                 Digital to Analog Converter (DAC)                          */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for DAC_CTRL register  ********************/
N#define	DAC_CTRL_EN		((uint32_t)(0x00000001))
N#define	DAC_CTRL_REF_SEL	((uint32_t)(0x00000006))	
N#define	DAC_CTRL_REF_SEL_0	((uint32_t)(0x00000000))		// 2V
N#define	DAC_CTRL_REF_SEL_1	((uint32_t)(0x00000002))		// 3V
N#define	DAC_CTRL_REF_SEL_2	((uint32_t)(0x00000004))		// 4V
N#define	DAC_CTRL_REF_SEL_3	((uint32_t)(0x00000006))		// VDDA
N
N#define IS_DAC_REF_SEL(SEL)	(((SEL) == DAC_CTRL_REF_SEL_0) ||\
N				(((SEL) == DAC_CTRL_REF_SEL_1) ||\
N				(((SEL) == DAC_CTRL_REF_SEL_2) ||\
N				((SEL) == DAC_CTRL_REF_SEL_3))
X#define IS_DAC_REF_SEL(SEL)	(((SEL) == DAC_CTRL_REF_SEL_0) ||				(((SEL) == DAC_CTRL_REF_SEL_1) ||				(((SEL) == DAC_CTRL_REF_SEL_2) ||				((SEL) == DAC_CTRL_REF_SEL_3))
N
N/******************************************************************************/
N/*                                                                            */
N/*                           Debug MCU (DBGMCU)                               */
N/*                                                                            */
N/******************************************************************************/
N
N/****************  Bit definition for DBGMCU_IDCODE register  *****************/
N//#define  DBGMCU_IDCODE_DEV_ID                ((uint32_t)0x00000FFF)        /*!< Device Identifier */
N//
N//#define  DBGMCU_IDCODE_REV_ID                ((uint32_t)0xFFFF0000)        /*!< REV_ID[15:0] bits (Revision Identifier) */
N//#define  DBGMCU_IDCODE_REV_ID_0              ((uint32_t)0x00010000)        /*!< Bit 0 */
N//#define  DBGMCU_IDCODE_REV_ID_1              ((uint32_t)0x00020000)        /*!< Bit 1 */
N//#define  DBGMCU_IDCODE_REV_ID_2              ((uint32_t)0x00040000)        /*!< Bit 2 */
N//#define  DBGMCU_IDCODE_REV_ID_3              ((uint32_t)0x00080000)        /*!< Bit 3 */
N//#define  DBGMCU_IDCODE_REV_ID_4              ((uint32_t)0x00100000)        /*!< Bit 4 */
N//#define  DBGMCU_IDCODE_REV_ID_5              ((uint32_t)0x00200000)        /*!< Bit 5 */
N//#define  DBGMCU_IDCODE_REV_ID_6              ((uint32_t)0x00400000)        /*!< Bit 6 */
N//#define  DBGMCU_IDCODE_REV_ID_7              ((uint32_t)0x00800000)        /*!< Bit 7 */
N//#define  DBGMCU_IDCODE_REV_ID_8              ((uint32_t)0x01000000)        /*!< Bit 8 */
N//#define  DBGMCU_IDCODE_REV_ID_9              ((uint32_t)0x02000000)        /*!< Bit 9 */
N//#define  DBGMCU_IDCODE_REV_ID_10             ((uint32_t)0x04000000)        /*!< Bit 10 */
N//#define  DBGMCU_IDCODE_REV_ID_11             ((uint32_t)0x08000000)        /*!< Bit 11 */
N//#define  DBGMCU_IDCODE_REV_ID_12             ((uint32_t)0x10000000)        /*!< Bit 12 */
N//#define  DBGMCU_IDCODE_REV_ID_13             ((uint32_t)0x20000000)        /*!< Bit 13 */
N//#define  DBGMCU_IDCODE_REV_ID_14             ((uint32_t)0x40000000)        /*!< Bit 14 */
N//#define  DBGMCU_IDCODE_REV_ID_15             ((uint32_t)0x80000000)        /*!< Bit 15 */
N
N#define  DBGMCU_IDCODE_DESIGNER								 ((uint32_t)0x00000FFE)        /*!< Device Identifier */
N
N#define  DBGMCU_IDCODE_PARTNO								   ((uint32_t)0x0FFFF000)        /*!< Device Identifier */
N#define  DBGMCU_IDCODE_PARTNO_0                ((uint32_t)0x00010000)        /*!< Bit 0 */
N#define  DBGMCU_IDCODE_PARTNO_1                ((uint32_t)0x00020000)        /*!< Bit 1 */
N#define  DBGMCU_IDCODE_PARTNO_2                ((uint32_t)0x00040000)        /*!< Bit 2 */
N#define  DBGMCU_IDCODE_PARTNO_3                ((uint32_t)0x00080000)        /*!< Bit 3 */
N#define  DBGMCU_IDCODE_PARTNO_4                ((uint32_t)0x00100000)        /*!< Bit 4 */
N#define  DBGMCU_IDCODE_PARTNO_5                ((uint32_t)0x00200000)        /*!< Bit 5 */
N#define  DBGMCU_IDCODE_PARTNO_6                ((uint32_t)0x00400000)        /*!< Bit 6 */
N#define  DBGMCU_IDCODE_PARTNO_7                ((uint32_t)0x00800000)        /*!< Bit 7 */
N#define  DBGMCU_IDCODE_PARTNO_8                ((uint32_t)0x01000000)        /*!< Bit 8 */
N#define  DBGMCU_IDCODE_PARTNO_9                ((uint32_t)0x02000000)        /*!< Bit 9 */
N#define  DBGMCU_IDCODE_PARTNO_10               ((uint32_t)0x04000000)        /*!< Bit 10 */
N#define  DBGMCU_IDCODE_PARTNO_11               ((uint32_t)0x08000000)        /*!< Bit 11 */
N#define  DBGMCU_IDCODE_PARTNO_12               ((uint32_t)0x10000000)        /*!< Bit 12 */
N#define  DBGMCU_IDCODE_PARTNO_13               ((uint32_t)0x20000000)        /*!< Bit 13 */
N#define  DBGMCU_IDCODE_PARTNO_14               ((uint32_t)0x40000000)        /*!< Bit 14 */
N#define  DBGMCU_IDCODE_PARTNO_15               ((uint32_t)0x80000000)        /*!< Bit 15 */
N
N#define  DBGMCU_IDCODE_VERSION								 ((uint32_t)0xF0000000)        /*!< Device Identifier */
N
N/******************  Bit definition for DBGMCU_CR register  *******************/
N#define  DBGMCU_CR_DBG_STOP                  ((uint32_t)0x00000002)        /*!< Debug Stop Mode */
N#define  DBGMCU_CR_DBG_STANDBY               ((uint32_t)0x00000004)        /*!< Debug Standby mode */
N
N/******************  Bit definition for DBGMCU_APB1_FZ register  **************/
N//#define  DBGMCU_APB1_FZ_DBG_TIM2_STOP        ((uint32_t)0x00000001)        /*!< TIM2 counter stopped when core is halted */
N#define  DBGMCU_APB1_FZ_DBG_TIM3_STOP        ((uint32_t)0x00000002)        /*!< TIM3 counter stopped when core is halted */
N#define  DBGMCU_APB1_FZ_DBG_TIM6_STOP        ((uint32_t)0x00000010)        /*!< TIM6 counter stopped when core is halted */
N#define  DBGMCU_APB1_FZ_DBG_TIM7_STOP        ((uint32_t)0x00000020)        /*!< TIM7 counter stopped when core is halted (only for FT32F072X8 devices) */
N#define  DBGMCU_APB1_FZ_DBG_TIM14_STOP       ((uint32_t)0x00000100)        /*!< TIM14 counter stopped when core is halted */
N#define  DBGMCU_APB1_FZ_DBG_RTC_STOP         ((uint32_t)0x00000400)        /*!< RTC Calendar frozen when core is halted */
N#define  DBGMCU_APB1_FZ_DBG_WWDG_STOP        ((uint32_t)0x00000800)        /*!< Debug Window Watchdog stopped when Core is halted */
N#define  DBGMCU_APB1_FZ_DBG_IWDG_STOP        ((uint32_t)0x00001000)        /*!< Debug Independent Watchdog stopped when Core is halted */
N#define  DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT    ((uint32_t)0x20000000)   /*!< I2C1 SMBUS timeout mode stopped when Core is halted */
N//#define  DBGMCU_APB1_FZ_DBG_CAN_STOP         ((uint32_t)0x02000000)        /*!< CAN debug stopped when Core is halted (only for FT32F072X8 devices) */
N
N/******************  Bit definition for DBGMCU_APB2_FZ register  **************/
N#define  DBGMCU_APB2_FZ_DBG_TIM1_STOP        ((uint32_t)0x00000800)        /*!< TIM1 counter stopped when core is halted */
N#define  DBGMCU_APB2_FZ_DBG_TIM15_STOP       ((uint32_t)0x00010000)        /*!< TIM15 counter stopped when core is halted */
N#define  DBGMCU_APB2_FZ_DBG_TIM16_STOP       ((uint32_t)0x00020000)        /*!< TIM16 counter stopped when core is halted */
N#define  DBGMCU_APB2_FZ_DBG_TIM17_STOP       ((uint32_t)0x00040000)        /*!< TIM17 counter stopped when core is halted */
N
N/******************************************************************************/
N/*                                                                            */
N/*                           DMA Controller (DMA)                             */
N/*                                                                            */
N/******************************************************************************/
N
N/*******************  Bit definition for DMA_ISR register  ********************/
N#define  DMA_ISR_GIF1                        ((uint32_t)0x00000001)        /*!< Channel 1 Global interrupt flag    */
N#define  DMA_ISR_TCIF1                       ((uint32_t)0x00000002)        /*!< Channel 1 Transfer Complete flag   */
N#define  DMA_ISR_HTIF1                       ((uint32_t)0x00000004)        /*!< Channel 1 Half Transfer flag       */
N#define  DMA_ISR_TEIF1                       ((uint32_t)0x00000008)        /*!< Channel 1 Transfer Error flag      */
N#define  DMA_ISR_GIF2                        ((uint32_t)0x00000010)        /*!< Channel 2 Global interrupt flag    */
N#define  DMA_ISR_TCIF2                       ((uint32_t)0x00000020)        /*!< Channel 2 Transfer Complete flag   */
N#define  DMA_ISR_HTIF2                       ((uint32_t)0x00000040)        /*!< Channel 2 Half Transfer flag       */
N#define  DMA_ISR_TEIF2                       ((uint32_t)0x00000080)        /*!< Channel 2 Transfer Error flag      */
N#define  DMA_ISR_GIF3                        ((uint32_t)0x00000100)        /*!< Channel 3 Global interrupt flag    */
N#define  DMA_ISR_TCIF3                       ((uint32_t)0x00000200)        /*!< Channel 3 Transfer Complete flag   */
N#define  DMA_ISR_HTIF3                       ((uint32_t)0x00000400)        /*!< Channel 3 Half Transfer flag       */
N#define  DMA_ISR_TEIF3                       ((uint32_t)0x00000800)        /*!< Channel 3 Transfer Error flag      */
N#define  DMA_ISR_GIF4                        ((uint32_t)0x00001000)        /*!< Channel 4 Global interrupt flag    */
N#define  DMA_ISR_TCIF4                       ((uint32_t)0x00002000)        /*!< Channel 4 Transfer Complete flag   */
N#define  DMA_ISR_HTIF4                       ((uint32_t)0x00004000)        /*!< Channel 4 Half Transfer flag       */
N#define  DMA_ISR_TEIF4                       ((uint32_t)0x00008000)        /*!< Channel 4 Transfer Error flag      */
N#define  DMA_ISR_GIF5                        ((uint32_t)0x00010000)        /*!< Channel 5 Global interrupt flag    */
N#define  DMA_ISR_TCIF5                       ((uint32_t)0x00020000)        /*!< Channel 5 Transfer Complete flag   */
N#define  DMA_ISR_HTIF5                       ((uint32_t)0x00040000)        /*!< Channel 5 Half Transfer flag       */
N#define  DMA_ISR_TEIF5                       ((uint32_t)0x00080000)        /*!< Channel 5 Transfer Error flag      */
N//#define  DMA_ISR_GIF6                        ((uint32_t)0x00100000)        /*!< Channel 6 Global interrupt flag (only for FT32F072X8 devices) */
N//#define  DMA_ISR_TCIF6                       ((uint32_t)0x00200000)        /*!< Channel 6 Transfer Complete flag (only for FT32F072X8 devices) */
N//#define  DMA_ISR_HTIF6                       ((uint32_t)0x00400000)        /*!< Channel 6 Half Transfer flag (only for FT32F072X8 devices) */
N//#define  DMA_ISR_TEIF6                       ((uint32_t)0x00800000)        /*!< Channel 6 Transfer Error flag (only for FT32F072X8 devices) */
N//#define  DMA_ISR_GIF7                        ((uint32_t)0x01000000)        /*!< Channel 7 Global interrupt flag (only for FT32F072X8 devices) */
N//#define  DMA_ISR_TCIF7                       ((uint32_t)0x02000000)        /*!< Channel 7 Transfer Complete flag (only for FT32F072X8 devices) */
N//#define  DMA_ISR_HTIF7                       ((uint32_t)0x04000000)        /*!< Channel 7 Half Transfer flag (only for FT32F072X8 devices) */
N//#define  DMA_ISR_TEIF7                       ((uint32_t)0x08000000)        /*!< Channel 7 Transfer Error flag (only for FT32F072X8 devices) */
N
N/*******************  Bit definition for DMA_IFCR register  *******************/
N#define  DMA_IFCR_CGIF1                      ((uint32_t)0x00000001)        /*!< Channel 1 Global interrupt clear    */
N#define  DMA_IFCR_CTCIF1                     ((uint32_t)0x00000002)        /*!< Channel 1 Transfer Complete clear   */
N#define  DMA_IFCR_CHTIF1                     ((uint32_t)0x00000004)        /*!< Channel 1 Half Transfer clear       */
N#define  DMA_IFCR_CTEIF1                     ((uint32_t)0x00000008)        /*!< Channel 1 Transfer Error clear      */
N#define  DMA_IFCR_CGIF2                      ((uint32_t)0x00000010)        /*!< Channel 2 Global interrupt clear    */
N#define  DMA_IFCR_CTCIF2                     ((uint32_t)0x00000020)        /*!< Channel 2 Transfer Complete clear   */
N#define  DMA_IFCR_CHTIF2                     ((uint32_t)0x00000040)        /*!< Channel 2 Half Transfer clear       */
N#define  DMA_IFCR_CTEIF2                     ((uint32_t)0x00000080)        /*!< Channel 2 Transfer Error clear      */
N#define  DMA_IFCR_CGIF3                      ((uint32_t)0x00000100)        /*!< Channel 3 Global interrupt clear    */
N#define  DMA_IFCR_CTCIF3                     ((uint32_t)0x00000200)        /*!< Channel 3 Transfer Complete clear   */
N#define  DMA_IFCR_CHTIF3                     ((uint32_t)0x00000400)        /*!< Channel 3 Half Transfer clear       */
N#define  DMA_IFCR_CTEIF3                     ((uint32_t)0x00000800)        /*!< Channel 3 Transfer Error clear      */
N#define  DMA_IFCR_CGIF4                      ((uint32_t)0x00001000)        /*!< Channel 4 Global interrupt clear    */
N#define  DMA_IFCR_CTCIF4                     ((uint32_t)0x00002000)        /*!< Channel 4 Transfer Complete clear   */
N#define  DMA_IFCR_CHTIF4                     ((uint32_t)0x00004000)        /*!< Channel 4 Half Transfer clear       */
N#define  DMA_IFCR_CTEIF4                     ((uint32_t)0x00008000)        /*!< Channel 4 Transfer Error clear      */
N#define  DMA_IFCR_CGIF5                      ((uint32_t)0x00010000)        /*!< Channel 5 Global interrupt clear    */
N#define  DMA_IFCR_CTCIF5                     ((uint32_t)0x00020000)        /*!< Channel 5 Transfer Complete clear   */
N#define  DMA_IFCR_CHTIF5                     ((uint32_t)0x00040000)        /*!< Channel 5 Half Transfer clear       */
N#define  DMA_IFCR_CTEIF5                     ((uint32_t)0x00080000)        /*!< Channel 5 Transfer Error clear      */
N//#define  DMA_IFCR_CGIF6                      ((uint32_t)0x00100000)        /*!< Channel 6 Global interrupt clear (only for FT32F072X8 devices) */
N//#define  DMA_IFCR_CTCIF6                     ((uint32_t)0x00200000)        /*!< Channel 6 Transfer Complete clear (only for FT32F072X8 devices) */
N//#define  DMA_IFCR_CHTIF6                     ((uint32_t)0x00400000)        /*!< Channel 6 Half Transfer clear (only for FT32F072X8 devices) */
N//#define  DMA_IFCR_CTEIF6                     ((uint32_t)0x00800000)        /*!< Channel 6 Transfer Error clear (only for FT32F072X8 devices) */
N//#define  DMA_IFCR_CGIF7                      ((uint32_t)0x01000000)        /*!< Channel 7 Global interrupt clear (only for FT32F072X8 devices) */
N//#define  DMA_IFCR_CTCIF7                     ((uint32_t)0x02000000)        /*!< Channel 7 Transfer Complete clear (only for FT32F072X8 devices) */
N//#define  DMA_IFCR_CHTIF7                     ((uint32_t)0x04000000)        /*!< Channel 7 Half Transfer clear (only for FT32F072X8 devices) */
N//#define  DMA_IFCR_CTEIF7                     ((uint32_t)0x08000000)        /*!< Channel 7 Transfer Error clear (only for FT32F072X8 devices) */
N
N/*******************  Bit definition for DMA_CCR register  ********************/
N#define  DMA_CCR_EN                          ((uint32_t)0x00000001)        /*!< Channel enable                      */
N#define  DMA_CCR_TCIE                        ((uint32_t)0x00000002)        /*!< Transfer complete interrupt enable  */
N#define  DMA_CCR_HTIE                        ((uint32_t)0x00000004)        /*!< Half Transfer interrupt enable      */
N#define  DMA_CCR_TEIE                        ((uint32_t)0x00000008)        /*!< Transfer error interrupt enable     */
N#define  DMA_CCR_DIR                         ((uint32_t)0x00000010)        /*!< Data transfer direction             */
N#define  DMA_CCR_CIRC                        ((uint32_t)0x00000020)        /*!< Circular mode                       */
N#define  DMA_CCR_PINC                        ((uint32_t)0x00000040)        /*!< Peripheral increment mode           */
N#define  DMA_CCR_MINC                        ((uint32_t)0x00000080)        /*!< Memory increment mode               */
N
N#define  DMA_CCR_PSIZE                       ((uint32_t)0x00000300)        /*!< PSIZE[1:0] bits (Peripheral size)   */
N#define  DMA_CCR_PSIZE_0                     ((uint32_t)0x00000100)        /*!< Bit 0                               */
N#define  DMA_CCR_PSIZE_1                     ((uint32_t)0x00000200)        /*!< Bit 1                               */
N
N#define  DMA_CCR_MSIZE                       ((uint32_t)0x00000C00)        /*!< MSIZE[1:0] bits (Memory size)       */
N#define  DMA_CCR_MSIZE_0                     ((uint32_t)0x00000400)        /*!< Bit 0                               */
N#define  DMA_CCR_MSIZE_1                     ((uint32_t)0x00000800)        /*!< Bit 1                               */
N
N#define  DMA_CCR_PL                          ((uint32_t)0x00003000)        /*!< PL[1:0] bits(Channel Priority level)*/
N#define  DMA_CCR_PL_0                        ((uint32_t)0x00001000)        /*!< Bit 0                               */
N#define  DMA_CCR_PL_1                        ((uint32_t)0x00002000)        /*!< Bit 1                               */
N
N#define  DMA_CCR_MEM2MEM                     ((uint32_t)0x00004000)        /*!< Memory to memory mode               */
N
N/******************  Bit definition for DMA_CNDTR register  *******************/
N#define  DMA_CNDTR_NDT                       ((uint32_t)0x00000FFF)        /*!< Number of data to Transfer          */
N
N/******************  Bit definition for DMA_CPAR register  ********************/
N#define  DMA_CPAR1_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address                  */
N#define  DMA_CPAR2_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address                  */
N#define  DMA_CPAR3_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address                  */
N#define  DMA_CPAR4_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address                  */
N#define  DMA_CPAR5_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address                  */
N
N/******************  Bit definition for DMA_CMAR register  ********************/
N#define  DMA_CMAR1_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address                      */
N#define  DMA_CMAR2_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address                      */
N#define  DMA_CMAR3_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address                      */
N#define  DMA_CMAR4_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address                      */
N#define  DMA_CMAR5_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address                      */
N
N/******************  Bit definition for DMA_RMPCR1 register  ********************/
N//#define DMA_RMPCR1_DEFAULT                  ((uint32_t)0x00000000)        /*!< Default remap position for DMA1 */
N//#define DMA_RMPCR1_CH1_ADC                  ((uint32_t)0x00000001)        /*!< Remap ADC on DMA1 Channel 1*/
N//#define DMA_RMPCR1_CH1_TIM17_CH1            ((uint32_t)0x00000007)        /*!< Remap TIM17 channel 1 on DMA1 channel 1 */
N//#define DMA_RMPCR1_CH1_TIM17_UP             ((uint32_t)0x00000007)        /*!< Remap TIM17 up on DMA1 channel 1 */
N//#define DMA_RMPCR1_CH1_USART1_RX            ((uint32_t)0x00000008)        /*!< Remap USART1 Rx on DMA1 channel 1 */
N//#define DMA_RMPCR1_CH1_USART2_RX            ((uint32_t)0x00000009)        /*!< Remap USART2 Rx on DMA1 channel 1 */
N//#define DMA_RMPCR1_CH1_USART3_RX            ((uint32_t)0x0000000A)        /*!< Remap USART3 Rx on DMA1 channel 1 */
N//#define DMA_RMPCR1_CH1_USART4_RX            ((uint32_t)0x0000000B)        /*!< Remap USART4 Rx on DMA1 channel 1 */
N//#define DMA_RMPCR1_CH1_USART5_RX            ((uint32_t)0x0000000C)        /*!< Remap USART5 Rx on DMA1 channel 1 */
N//#define DMA_RMPCR1_CH1_USART6_RX            ((uint32_t)0x0000000D)        /*!< Remap USART6 Rx on DMA1 channel 1 */
N//#define DMA_RMPCR1_CH1_USART7_RX            ((uint32_t)0x0000000E)        /*!< Remap USART7 Rx on DMA1 channel 1 */
N//#define DMA_RMPCR1_CH1_USART8_RX            ((uint32_t)0x0000000F)        /*!< Remap USART8 Rx on DMA1 channel 1 */
N//#define DMA_RMPCR1_CH2_ADC                  ((uint32_t)0x00000010)        /*!< Remap ADC on DMA1 channel 2 */
N//#define DMA_RMPCR1_CH2_I2C1_TX              ((uint32_t)0x00000020)        /*!< Remap I2C1 Tx on DMA1 channel 2 */
N//#define DMA_RMPCR1_CH2_SPI_1RX              ((uint32_t)0x00000030)        /*!< Remap SPI1 Rx on DMA1 channel 2 */
N//#define DMA_RMPCR1_CH2_TIM1_CH1             ((uint32_t)0x00000040)        /*!< Remap TIM1 channel 1 on DMA1 channel 2 */
N//#define DMA_RMPCR1_CH2_TIM17_CH1            ((uint32_t)0x00000070)        /*!< Remap TIM17 channel 1 on DMA1 channel 2 */
N//#define DMA_RMPCR1_CH2_TIM17_UP             ((uint32_t)0x00000070)        /*!< Remap TIM17 up on DMA1 channel 2 */
N//#define DMA_RMPCR1_CH2_USART1_TX            ((uint32_t)0x00000080)        /*!< Remap USART1 Tx on DMA1 channel 2 */
N//#define DMA_RMPCR1_CH2_USART2_TX            ((uint32_t)0x00000090)        /*!< Remap USART2 Tx on DMA1 channel 2 */
N//#define DMA_RMPCR1_CH2_USART3_TX            ((uint32_t)0x000000A0)        /*!< Remap USART3 Tx on DMA1 channel 2 */
N//#define DMA_RMPCR1_CH2_USART4_TX            ((uint32_t)0x000000B0)        /*!< Remap USART4 Tx on DMA1 channel 2 */
N//#define DMA_RMPCR1_CH2_USART5_TX            ((uint32_t)0x000000C0)        /*!< Remap USART5 Tx on DMA1 channel 2 */
N//#define DMA_RMPCR1_CH2_USART6_TX            ((uint32_t)0x000000D0)        /*!< Remap USART6 Tx on DMA1 channel 2 */
N//#define DMA_RMPCR1_CH2_USART7_TX            ((uint32_t)0x000000E0)        /*!< Remap USART7 Tx on DMA1 channel 2 */
N//#define DMA_RMPCR1_CH2_USART8_TX            ((uint32_t)0x000000F0)        /*!< Remap USART8 Tx on DMA1 channel 2 */
N//#define DMA_RMPCR1_CH3_TIM6_UP              ((uint32_t)0x00000100)        /*!< Remap TIM6 up on DMA1 channel 3 */
N//#define DMA_RMPCR1_CH3_DAC_CH1              ((uint32_t)0x00000100)        /*!< Remap DAC Channel 1on DMA1 channel 3 */
N//#define DMA_RMPCR1_CH3_I2C1_RX              ((uint32_t)0x00000200)        /*!< Remap I2C1 Rx on DMA1 channel 3 */
N//#define DMA_RMPCR1_CH3_SPI1_TX              ((uint32_t)0x00000300)        /*!< Remap SPI1 Tx on DMA1 channel 3 */
N//#define DMA_RMPCR1_CH3_TIM1_CH2             ((uint32_t)0x00000400)        /*!< Remap TIM1 channel 2 on DMA1 channel 3 */
N//#define DMA_RMPCR1_CH3_TIM2_CH2             ((uint32_t)0x00000500)        /*!< Remap TIM2 channel 2 on DMA1 channel 3 */
N//#define DMA_RMPCR1_CH3_TIM16_CH1            ((uint32_t)0x00000700)        /*!< Remap TIM16 channel 1 on DMA1 channel 3 */
N//#define DMA_RMPCR1_CH3_TIM16_UP             ((uint32_t)0x00000700)        /*!< Remap TIM16 up on DMA1 channel 3 */
N//#define DMA_RMPCR1_CH3_USART1_RX            ((uint32_t)0x00000800)        /*!< Remap USART1 Rx on DMA1 channel 3 */
N//#define DMA_RMPCR1_CH3_USART2_RX            ((uint32_t)0x00000900)        /*!< Remap USART2 Rx on DMA1 channel 3 */
N//#define DMA_RMPCR1_CH3_USART3_RX            ((uint32_t)0x00000A00)        /*!< Remap USART3 Rx on DMA1 channel 3 */
N//#define DMA_RMPCR1_CH3_USART4_RX            ((uint32_t)0x00000B00)        /*!< Remap USART4 Rx on DMA1 channel 3 */
N//#define DMA_RMPCR1_CH3_USART5_RX            ((uint32_t)0x00000C00)        /*!< Remap USART5 Rx on DMA1 channel 3 */
N//#define DMA_RMPCR1_CH3_USART6_RX            ((uint32_t)0x00000D00)        /*!< Remap USART6 Rx on DMA1 channel 3 */
N//#define DMA_RMPCR1_CH3_USART7_RX            ((uint32_t)0x00000E00)        /*!< Remap USART7 Rx on DMA1 channel 3 */
N//#define DMA_RMPCR1_CH3_USART8_RX            ((uint32_t)0x00000F00)        /*!< Remap USART8 Rx on DMA1 channel 3 */
N//#define DMA_RMPCR1_CH4_TIM7_UP              ((uint32_t)0x00001000)        /*!< Remap TIM7 up on DMA1 channel 4 */
N//#define DMA_RMPCR1_CH4_DAC_CH2              ((uint32_t)0x00001000)        /*!< Remap DAC Channel 2 on DMA1 channel 4 */
N//#define DMA_RMPCR1_CH4_I2C2_TX              ((uint32_t)0x00002000)        /*!< Remap I2C2 Tx on DMA1 channel 4 */
N//#define DMA_RMPCR1_CH4_SPI2_RX              ((uint32_t)0x00003000)        /*!< Remap SPI2 Rx on DMA1 channel 4 */
N//#define DMA_RMPCR1_CH4_TIM2_CH4             ((uint32_t)0x00005000)        /*!< Remap TIM2 channel 4 on DMA1 channel 4 */
N//#define DMA_RMPCR1_CH4_TIM3_CH1             ((uint32_t)0x00006000)        /*!< Remap TIM3 channel 1 on DMA1 channel 4 */
N//#define DMA_RMPCR1_CH4_TIM3_TRIG            ((uint32_t)0x00006000)        /*!< Remap TIM3 Trig on DMA1 channel 4 */
N//#define DMA_RMPCR1_CH4_TIM16_CH1            ((uint32_t)0x00007000)        /*!< Remap TIM16 channel 1 on DMA1 channel 4 */
N//#define DMA_RMPCR1_CH4_TIM16_UP             ((uint32_t)0x00007000)        /*!< Remap TIM16 up on DMA1 channel 4 */
N//#define DMA_RMPCR1_CH4_USART1_TX            ((uint32_t)0x00008000)        /*!< Remap USART1 Tx on DMA1 channel 4 */
N//#define DMA_RMPCR1_CH4_USART2_TX            ((uint32_t)0x00009000)        /*!< Remap USART2 Tx on DMA1 channel 4 */
N//#define DMA_RMPCR1_CH4_USART3_TX            ((uint32_t)0x0000A000)        /*!< Remap USART3 Tx on DMA1 channel 4 */
N//#define DMA_RMPCR1_CH4_USART4_TX            ((uint32_t)0x0000B000)        /*!< Remap USART4 Tx on DMA1 channel 4 */
N//#define DMA_RMPCR1_CH4_USART5_TX            ((uint32_t)0x0000C000)        /*!< Remap USART5 Tx on DMA1 channel 4 */
N//#define DMA_RMPCR1_CH4_USART6_TX            ((uint32_t)0x0000D000)        /*!< Remap USART6 Tx on DMA1 channel 4 */
N//#define DMA_RMPCR1_CH4_USART7_TX            ((uint32_t)0x0000E000)        /*!< Remap USART7 Tx on DMA1 channel 4 */
N//#define DMA_RMPCR1_CH4_USART8_TX            ((uint32_t)0x0000F000)        /*!< Remap USART8 Tx on DMA1 channel 4 */
N//#define DMA_RMPCR1_CH5_I2C2_RX              ((uint32_t)0x00020000)        /*!< Remap I2C2 Rx on DMA1 channel 5 */
N//#define DMA_RMPCR1_CH5_SPI2_TX              ((uint32_t)0x00030000)        /*!< Remap SPI1 Tx on DMA1 channel 5 */
N//#define DMA_RMPCR1_CH5_TIM1_CH3             ((uint32_t)0x00040000)        /*!< Remap TIM1 channel 3 on DMA1 channel 5 */
N//#define DMA_RMPCR1_CH5_USART1_RX            ((uint32_t)0x00080000)        /*!< Remap USART1 Rx on DMA1 channel 5 */
N//#define DMA_RMPCR1_CH5_USART2_RX            ((uint32_t)0x00090000)        /*!< Remap USART2 Rx on DMA1 channel 5 */
N//#define DMA_RMPCR1_CH5_USART3_RX            ((uint32_t)0x000A0000)        /*!< Remap USART3 Rx on DMA1 channel 5 */
N//#define DMA_RMPCR1_CH5_USART4_RX            ((uint32_t)0x000B0000)        /*!< Remap USART4 Rx on DMA1 channel 5 */
N//#define DMA_RMPCR1_CH5_USART5_RX            ((uint32_t)0x000C0000)        /*!< Remap USART5 Rx on DMA1 channel 5 */
N//#define DMA_RMPCR1_CH5_USART6_RX            ((uint32_t)0x000D0000)        /*!< Remap USART6 Rx on DMA1 channel 5 */
N//#define DMA_RMPCR1_CH5_USART7_RX            ((uint32_t)0x000E0000)        /*!< Remap USART7 Rx on DMA1 channel 5 */
N//#define DMA_RMPCR1_CH5_USART8_RX            ((uint32_t)0x000F0000)        /*!< Remap USART8 Rx on DMA1 channel 5 */
N//#define DMA_RMPCR1_CH6_I2C1_TX              ((uint32_t)0x00200000)        /*!< Remap I2C1 Tx on DMA1 channel 6 */
N//#define DMA_RMPCR1_CH6_SPI2_RX              ((uint32_t)0x00300000)        /*!< Remap SPI2 Rx on DMA1 channel 6 */
N//#define DMA_RMPCR1_CH6_TIM1_CH1             ((uint32_t)0x00400000)        /*!< Remap TIM1 channel 1 on DMA1 channel 6 */
N//#define DMA_RMPCR1_CH6_TIM1_CH2             ((uint32_t)0x00400000)        /*!< Remap TIM1 channel 2 on DMA1 channel 6 */
N//#define DMA_RMPCR1_CH6_TIM1_CH3             ((uint32_t)0x00400000)        /*!< Remap TIM1 channel 3 on DMA1 channel 6 */
N//#define DMA_RMPCR1_CH6_TIM3_CH1             ((uint32_t)0x00600000)        /*!< Remap TIM3 channel 1 on DMA1 channel 6 */
N//#define DMA_RMPCR1_CH6_TIM3_TRIG            ((uint32_t)0x00600000)        /*!< Remap TIM3 Trig on DMA1 channel 6 */
N//#define DMA_RMPCR1_CH6_TIM16_CH1            ((uint32_t)0x00700000)        /*!< Remap TIM16 channel 1 on DMA1 channel 6 */
N//#define DMA_RMPCR1_CH6_TIM16_UP             ((uint32_t)0x00700000)        /*!< Remap TIM16 up on DMA1 channel 6 */
N//#define DMA_RMPCR1_CH6_USART1_RX            ((uint32_t)0x00800000)        /*!< Remap USART1 Rx on DMA1 channel 6 */
N//#define DMA_RMPCR1_CH6_USART2_RX            ((uint32_t)0x00900000)        /*!< Remap USART2 Rx on DMA1 channel 6 */
N//#define DMA_RMPCR1_CH6_USART3_RX            ((uint32_t)0x00A00000)        /*!< Remap USART3 Rx on DMA1 channel 6 */
N//#define DMA_RMPCR1_CH6_USART4_RX            ((uint32_t)0x00B00000)        /*!< Remap USART4 Rx on DMA1 channel 6 */
N//#define DMA_RMPCR1_CH6_USART5_RX            ((uint32_t)0x00C00000)        /*!< Remap USART5 Rx on DMA1 channel 6 */
N//#define DMA_RMPCR1_CH6_USART6_RX            ((uint32_t)0x00D00000)        /*!< Remap USART6 Rx on DMA1 channel 6 */
N//#define DMA_RMPCR1_CH6_USART7_RX            ((uint32_t)0x00E00000)        /*!< Remap USART7 Rx on DMA1 channel 6 */
N//#define DMA_RMPCR1_CH6_USART8_RX            ((uint32_t)0x00F00000)        /*!< Remap USART8 Rx on DMA1 channel 6 */
N//#define DMA_RMPCR1_CH7_I2C1_RX              ((uint32_t)0x02000000)        /*!< Remap I2C1 Rx on DMA1 channel 7 */
N//#define DMA_RMPCR1_CH7_SPI2_TX              ((uint32_t)0x03000000)        /*!< Remap SPI2 Tx on DMA1 channel 7 */
N//#define DMA_RMPCR1_CH7_TIM2_CH2             ((uint32_t)0x05000000)        /*!< Remap TIM2 channel 2 on DMA1 channel 7 */
N//#define DMA_RMPCR1_CH7_TIM2_CH4             ((uint32_t)0x05000000)        /*!< Remap TIM2 channel 4 on DMA1 channel 7 */
N//#define DMA_RMPCR1_CH7_TIM17_CH1            ((uint32_t)0x07000000)        /*!< Remap TIM17 channel 1 on DMA1 channel 7 */
N//#define DMA_RMPCR1_CH7_TIM17_UP             ((uint32_t)0x07000000)        /*!< Remap TIM17 up on DMA1 channel 7 */
N//#define DMA_RMPCR1_CH7_USART1_TX            ((uint32_t)0x08000000)        /*!< Remap USART1 Tx on DMA1 channel 7 */
N//#define DMA_RMPCR1_CH7_USART2_TX            ((uint32_t)0x09000000)        /*!< Remap USART2 Tx on DMA1 channel 7 */
N//#define DMA_RMPCR1_CH7_USART3_TX            ((uint32_t)0x0A000000)        /*!< Remap USART3 Tx on DMA1 channel 7 */
N//#define DMA_RMPCR1_CH7_USART4_TX            ((uint32_t)0x0B000000)        /*!< Remap USART4 Tx on DMA1 channel 7 */
N//#define DMA_RMPCR1_CH7_USART5_TX            ((uint32_t)0x0C000000)        /*!< Remap USART5 Tx on DMA1 channel 7 */
N//#define DMA_RMPCR1_CH7_USART6_TX            ((uint32_t)0x0D000000)        /*!< Remap USART6 Tx on DMA1 channel 7 */
N//#define DMA_RMPCR1_CH7_USART7_TX            ((uint32_t)0x0E000000)        /*!< Remap USART7 Tx on DMA1 channel 7 */
N//#define DMA_RMPCR1_CH7_USART8_TX            ((uint32_t)0x0F000000)        /*!< Remap USART8 Tx on DMA1 channel 7 */
N//
N///******************  Bit definition for DMA_RMPCR2 register  ********************/
N//#define DMA_RMPCR2_DEFAULT                  ((uint32_t)0x00000000)        /*!< Default remap position for DMA2 */
N//#define DMA_RMPCR2_CH1_I2C2_TX              ((uint32_t)0x00000002)        /*!< Remap I2C2 TX on DMA2 channel 1 */
N//#define DMA_RMPCR2_CH1_USART1_TX            ((uint32_t)0x00000008)        /*!< Remap USART1 Tx on DMA2 channel 1 */
N//#define DMA_RMPCR2_CH1_USART2_TX            ((uint32_t)0x00000009)        /*!< Remap USART2 Tx on DMA2 channel 1 */
N//#define DMA_RMPCR2_CH1_USART3_TX            ((uint32_t)0x0000000A)        /*!< Remap USART3 Tx on DMA2 channel 1 */
N//#define DMA_RMPCR2_CH1_USART4_TX            ((uint32_t)0x0000000B)        /*!< Remap USART4 Tx on DMA2 channel 1 */
N//#define DMA_RMPCR2_CH1_USART5_TX            ((uint32_t)0x0000000C)        /*!< Remap USART5 Tx on DMA2 channel 1 */
N//#define DMA_RMPCR2_CH1_USART6_TX            ((uint32_t)0x0000000D)        /*!< Remap USART6 Tx on DMA2 channel 1 */
N//#define DMA_RMPCR2_CH1_USART7_TX            ((uint32_t)0x0000000E)        /*!< Remap USART7 Tx on DMA2 channel 1 */
N//#define DMA_RMPCR2_CH1_USART8_TX            ((uint32_t)0x0000000F)        /*!< Remap USART8 Tx on DMA2 channel 1 */
N//#define DMA_RMPCR2_CH2_I2C2_RX              ((uint32_t)0x00000020)        /*!< Remap I2C2 Rx on DMA2 channel 2 */
N//#define DMA_RMPCR2_CH2_USART1_RX            ((uint32_t)0x00000080)        /*!< Remap USART1 Rx on DMA2 channel 2 */
N//#define DMA_RMPCR2_CH2_USART2_RX            ((uint32_t)0x00000090)        /*!< Remap USART2 Rx on DMA2 channel 2 */
N//#define DMA_RMPCR2_CH2_USART3_RX            ((uint32_t)0x000000A0)        /*!< Remap USART3 Rx on DMA2 channel 2 */
N//#define DMA_RMPCR2_CH2_USART4_RX            ((uint32_t)0x000000B0)        /*!< Remap USART4 Rx on DMA2 channel 2 */
N//#define DMA_RMPCR2_CH2_USART5_RX            ((uint32_t)0x000000C0)        /*!< Remap USART5 Rx on DMA2 channel 2 */
N//#define DMA_RMPCR2_CH2_USART6_RX            ((uint32_t)0x000000D0)        /*!< Remap USART6 Rx on DMA2 channel 2 */
N//#define DMA_RMPCR2_CH2_USART7_RX            ((uint32_t)0x000000E0)        /*!< Remap USART7 Rx on DMA2 channel 2 */
N//#define DMA_RMPCR2_CH2_USART8_RX            ((uint32_t)0x000000F0)        /*!< Remap USART8 Rx on DMA2 channel 2 */
N//#define DMA_RMPCR2_CH3_TIM6_UP              ((uint32_t)0x00000100)        /*!< Remap TIM6 up on DMA2 channel 3 */
N//#define DMA_RMPCR2_CH3_DAC_CH1              ((uint32_t)0x00000100)        /*!< Remap DAC channel 1 on DMA2 channel 3 */
N//#define DMA_RMPCR2_CH3_SPI1_RX              ((uint32_t)0x00000300)        /*!< Remap SPI1 Rx on DMA2 channel 3 */
N//#define DMA_RMPCR2_CH3_USART1_RX            ((uint32_t)0x00000800)        /*!< Remap USART1 Rx on DMA2 channel 3 */
N//#define DMA_RMPCR2_CH3_USART2_RX            ((uint32_t)0x00000900)        /*!< Remap USART2 Rx on DMA2 channel 3 */
N//#define DMA_RMPCR2_CH3_USART3_RX            ((uint32_t)0x00000A00)        /*!< Remap USART3 Rx on DMA2 channel 3 */
N//#define DMA_RMPCR2_CH3_USART4_RX            ((uint32_t)0x00000B00)        /*!< Remap USART4 Rx on DMA2 channel 3 */
N//#define DMA_RMPCR2_CH3_USART5_RX            ((uint32_t)0x00000C00)        /*!< Remap USART5 Rx on DMA2 channel 3 */
N//#define DMA_RMPCR2_CH3_USART6_RX            ((uint32_t)0x00000D00)        /*!< Remap USART6 Rx on DMA2 channel 3 */
N//#define DMA_RMPCR2_CH3_USART7_RX            ((uint32_t)0x00000E00)        /*!< Remap USART7 Rx on DMA2 channel 3 */
N//#define DMA_RMPCR2_CH3_USART8_RX            ((uint32_t)0x00000F00)        /*!< Remap USART8 Rx on DMA2 channel 3 */
N//#define DMA_RMPCR2_CH4_TIM7_UP              ((uint32_t)0x00001000)        /*!< Remap TIM7 up on DMA2 channel 4 */
N//#define DMA_RMPCR2_CH4_DAC_CH2              ((uint32_t)0x00001000)        /*!< Remap DAC channel 2 on DMA2 channel 4 */
N//#define DMA_RMPCR2_CH4_SPI1_TX              ((uint32_t)0x00003000)        /*!< Remap SPI1 Tx on DMA2 channel 4 */
N//#define DMA_RMPCR2_CH4_USART1_TX            ((uint32_t)0x00008000)        /*!< Remap USART1 Tx on DMA2 channel 4 */
N//#define DMA_RMPCR2_CH4_USART2_TX            ((uint32_t)0x00009000)        /*!< Remap USART2 Tx on DMA2 channel 4 */
N//#define DMA_RMPCR2_CH4_USART3_TX            ((uint32_t)0x0000A000)        /*!< Remap USART3 Tx on DMA2 channel 4 */
N//#define DMA_RMPCR2_CH4_USART4_TX            ((uint32_t)0x0000B000)        /*!< Remap USART4 Tx on DMA2 channel 4 */
N//#define DMA_RMPCR2_CH4_USART5_TX            ((uint32_t)0x0000C000)        /*!< Remap USART5 Tx on DMA2 channel 4 */
N//#define DMA_RMPCR2_CH4_USART6_TX            ((uint32_t)0x0000D000)        /*!< Remap USART6 Tx on DMA2 channel 4 */
N//#define DMA_RMPCR2_CH4_USART7_TX            ((uint32_t)0x0000E000)        /*!< Remap USART7 Tx on DMA2 channel 4 */
N//#define DMA_RMPCR2_CH4_USART8_TX            ((uint32_t)0x0000F000)        /*!< Remap USART8 Tx on DMA2 channel 4 */
N//#define DMA_RMPCR2_CH5_ADC                  ((uint32_t)0x00010000)        /*!< Remap ADC on DMA2 channel 5 */
N//#define DMA_RMPCR2_CH5_USART1_TX            ((uint32_t)0x00080000)        /*!< Remap USART1 Tx on DMA2 channel 5 */
N//#define DMA_RMPCR2_CH5_USART2_TX            ((uint32_t)0x00090000)        /*!< Remap USART2 Tx on DMA2 channel 5 */
N//#define DMA_RMPCR2_CH5_USART3_TX            ((uint32_t)0x000A0000)        /*!< Remap USART3 Tx on DMA2 channel 5 */
N//#define DMA_RMPCR2_CH5_USART4_TX            ((uint32_t)0x000B0000)        /*!< Remap USART4 Tx on DMA2 channel 5 */
N//#define DMA_RMPCR2_CH5_USART5_TX            ((uint32_t)0x000C0000)        /*!< Remap USART5 Tx on DMA2 channel 5 */
N//#define DMA_RMPCR2_CH5_USART6_TX            ((uint32_t)0x000D0000)        /*!< Remap USART6 Tx on DMA2 channel 5 */
N//#define DMA_RMPCR2_CH5_USART7_TX            ((uint32_t)0x000E0000)        /*!< Remap USART7 Tx on DMA2 channel 5 */
N//#define DMA_RMPCR2_CH5_USART8_TX            ((uint32_t)0x000F0000)        /*!< Remap USART8 Tx on DMA2 channel 5 */
N
N/******************************************************************************/
N/*                                                                            */
N/*                 External Interrupt/Event Controller (EXTI)                 */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for EXTI_IMR register  *******************/
N#define  EXTI_IMR_MR0                        ((uint32_t)0x00000001)        /*!< Interrupt Mask on line 0  */
N#define  EXTI_IMR_MR1                        ((uint32_t)0x00000002)        /*!< Interrupt Mask on line 1  */
N#define  EXTI_IMR_MR2                        ((uint32_t)0x00000004)        /*!< Interrupt Mask on line 2  */
N#define  EXTI_IMR_MR3                        ((uint32_t)0x00000008)        /*!< Interrupt Mask on line 3  */
N#define  EXTI_IMR_MR4                        ((uint32_t)0x00000010)        /*!< Interrupt Mask on line 4  */
N#define  EXTI_IMR_MR5                        ((uint32_t)0x00000020)        /*!< Interrupt Mask on line 5  */
N#define  EXTI_IMR_MR6                        ((uint32_t)0x00000040)        /*!< Interrupt Mask on line 6  */
N#define  EXTI_IMR_MR7                        ((uint32_t)0x00000080)        /*!< Interrupt Mask on line 7  */
N#define  EXTI_IMR_MR8                        ((uint32_t)0x00000100)        /*!< Interrupt Mask on line 8  */
N#define  EXTI_IMR_MR9                        ((uint32_t)0x00000200)        /*!< Interrupt Mask on line 9  */
N#define  EXTI_IMR_MR10                       ((uint32_t)0x00000400)        /*!< Interrupt Mask on line 10 */
N#define  EXTI_IMR_MR11                       ((uint32_t)0x00000800)        /*!< Interrupt Mask on line 11 */
N#define  EXTI_IMR_MR12                       ((uint32_t)0x00001000)        /*!< Interrupt Mask on line 12 */
N#define  EXTI_IMR_MR13                       ((uint32_t)0x00002000)        /*!< Interrupt Mask on line 13 */
N#define  EXTI_IMR_MR14                       ((uint32_t)0x00004000)        /*!< Interrupt Mask on line 14 */
N#define  EXTI_IMR_MR15                       ((uint32_t)0x00008000)        /*!< Interrupt Mask on line 15 */
N#define  EXTI_IMR_MR16                       ((uint32_t)0x00010000)        /*!< Interrupt Mask on line 16 */
N#define  EXTI_IMR_MR17                       ((uint32_t)0x00020000)        /*!< Interrupt Mask on line 17 */
N#define  EXTI_IMR_MR18                       ((uint32_t)0x00040000)        /*!< Interrupt Mask on line 18 */
N#define  EXTI_IMR_MR19                       ((uint32_t)0x00080000)        /*!< Interrupt Mask on line 19 */
N#define  EXTI_IMR_MR20                       ((uint32_t)0x00100000)        /*!< Interrupt Mask on line 20 */
N#define  EXTI_IMR_MR21                       ((uint32_t)0x00200000)        /*!< Interrupt Mask on line 21 */
N#define  EXTI_IMR_MR22                       ((uint32_t)0x00400000)        /*!< Interrupt Mask on line 22 */
N#define  EXTI_IMR_MR23                       ((uint32_t)0x00800000)        /*!< Interrupt Mask on line 23 */
N#define  EXTI_IMR_MR24                       ((uint32_t)0x01000000)        /*!< Interrupt Mask on line 24 */
N#define  EXTI_IMR_MR25                       ((uint32_t)0x02000000)        /*!< Interrupt Mask on line 25 */
N#define  EXTI_IMR_MR26                       ((uint32_t)0x04000000)        /*!< Interrupt Mask on line 26 */
N#define  EXTI_IMR_MR27                       ((uint32_t)0x08000000)        /*!< Interrupt Mask on line 27 */
N#define  EXTI_IMR_MR28                       ((uint32_t)0x10000000)        /*!< Interrupt Mask on line 28 */
N#define  EXTI_IMR_MR29                       ((uint32_t)0x20000000)        /*!< Interrupt Mask on line 29 */
N#define  EXTI_IMR_MR30                       ((uint32_t)0x40000000)        /*!< Interrupt Mask on line 30 */
N#define  EXTI_IMR_MR31                       ((uint32_t)0x80000000)        /*!< Interrupt Mask on line 31 */
N
N/******************  Bit definition for EXTI_EMR register  ********************/
N#define  EXTI_EMR_MR0                        ((uint32_t)0x00000001)        /*!< Event Mask on line 0  */
N#define  EXTI_EMR_MR1                        ((uint32_t)0x00000002)        /*!< Event Mask on line 1  */
N#define  EXTI_EMR_MR2                        ((uint32_t)0x00000004)        /*!< Event Mask on line 2  */
N#define  EXTI_EMR_MR3                        ((uint32_t)0x00000008)        /*!< Event Mask on line 3  */
N#define  EXTI_EMR_MR4                        ((uint32_t)0x00000010)        /*!< Event Mask on line 4  */
N#define  EXTI_EMR_MR5                        ((uint32_t)0x00000020)        /*!< Event Mask on line 5  */
N#define  EXTI_EMR_MR6                        ((uint32_t)0x00000040)        /*!< Event Mask on line 6  */
N#define  EXTI_EMR_MR7                        ((uint32_t)0x00000080)        /*!< Event Mask on line 7  */
N#define  EXTI_EMR_MR8                        ((uint32_t)0x00000100)        /*!< Event Mask on line 8  */
N#define  EXTI_EMR_MR9                        ((uint32_t)0x00000200)        /*!< Event Mask on line 9  */
N#define  EXTI_EMR_MR10                       ((uint32_t)0x00000400)        /*!< Event Mask on line 10 */
N#define  EXTI_EMR_MR11                       ((uint32_t)0x00000800)        /*!< Event Mask on line 11 */
N#define  EXTI_EMR_MR12                       ((uint32_t)0x00001000)        /*!< Event Mask on line 12 */
N#define  EXTI_EMR_MR13                       ((uint32_t)0x00002000)        /*!< Event Mask on line 13 */
N#define  EXTI_EMR_MR14                       ((uint32_t)0x00004000)        /*!< Event Mask on line 14 */
N#define  EXTI_EMR_MR15                       ((uint32_t)0x00008000)        /*!< Event Mask on line 15 */
N#define  EXTI_EMR_MR16                       ((uint32_t)0x00010000)        /*!< Event Mask on line 16 */
N#define  EXTI_EMR_MR17                       ((uint32_t)0x00020000)        /*!< Event Mask on line 17 */
N#define  EXTI_EMR_MR18                       ((uint32_t)0x00040000)        /*!< Event Mask on line 18 */
N#define  EXTI_EMR_MR19                       ((uint32_t)0x00080000)        /*!< Event Mask on line 19 */
N#define  EXTI_EMR_MR20                       ((uint32_t)0x00100000)        /*!< Event Mask on line 20 */
N#define  EXTI_EMR_MR21                       ((uint32_t)0x00200000)        /*!< Event Mask on line 21 */
N#define  EXTI_EMR_MR22                       ((uint32_t)0x00400000)        /*!< Event Mask on line 22 */
N#define  EXTI_EMR_MR23                       ((uint32_t)0x00800000)        /*!< Event Mask on line 23 */
N#define  EXTI_EMR_MR24                       ((uint32_t)0x01000000)        /*!< Event Mask on line 24 */
N#define  EXTI_EMR_MR25                       ((uint32_t)0x02000000)        /*!< Event Mask on line 25 */
N#define  EXTI_EMR_MR26                       ((uint32_t)0x04000000)        /*!< Event Mask on line 26 */
N#define  EXTI_EMR_MR27                       ((uint32_t)0x08000000)        /*!< Event Mask on line 27 */
N#define  EXTI_EMR_MR28                       ((uint32_t)0x10000000)        /*!< Event Mask on line 28 */
N#define  EXTI_EMR_MR29                       ((uint32_t)0x20000000)        /*!< Event Mask on line 29 */
N#define  EXTI_EMR_MR30                       ((uint32_t)0x40000000)        /*!< Event Mask on line 30 */
N#define  EXTI_EMR_MR31                       ((uint32_t)0x80000000)        /*!< Event Mask on line 31 */
N
N/*******************  Bit definition for EXTI_RTSR register  ******************/
N#define  EXTI_RTSR_TR0                       ((uint32_t)0x00000001)        /*!< Rising trigger event configuration bit of line 0 */
N#define  EXTI_RTSR_TR1                       ((uint32_t)0x00000002)        /*!< Rising trigger event configuration bit of line 1 */
N#define  EXTI_RTSR_TR2                       ((uint32_t)0x00000004)        /*!< Rising trigger event configuration bit of line 2 */
N#define  EXTI_RTSR_TR3                       ((uint32_t)0x00000008)        /*!< Rising trigger event configuration bit of line 3 */
N#define  EXTI_RTSR_TR4                       ((uint32_t)0x00000010)        /*!< Rising trigger event configuration bit of line 4 */
N#define  EXTI_RTSR_TR5                       ((uint32_t)0x00000020)        /*!< Rising trigger event configuration bit of line 5 */
N#define  EXTI_RTSR_TR6                       ((uint32_t)0x00000040)        /*!< Rising trigger event configuration bit of line 6 */
N#define  EXTI_RTSR_TR7                       ((uint32_t)0x00000080)        /*!< Rising trigger event configuration bit of line 7 */
N#define  EXTI_RTSR_TR8                       ((uint32_t)0x00000100)        /*!< Rising trigger event configuration bit of line 8 */
N#define  EXTI_RTSR_TR9                       ((uint32_t)0x00000200)        /*!< Rising trigger event configuration bit of line 9 */
N#define  EXTI_RTSR_TR10                      ((uint32_t)0x00000400)        /*!< Rising trigger event configuration bit of line 10 */
N#define  EXTI_RTSR_TR11                      ((uint32_t)0x00000800)        /*!< Rising trigger event configuration bit of line 11 */
N#define  EXTI_RTSR_TR12                      ((uint32_t)0x00001000)        /*!< Rising trigger event configuration bit of line 12 */
N#define  EXTI_RTSR_TR13                      ((uint32_t)0x00002000)        /*!< Rising trigger event configuration bit of line 13 */
N#define  EXTI_RTSR_TR14                      ((uint32_t)0x00004000)        /*!< Rising trigger event configuration bit of line 14 */
N#define  EXTI_RTSR_TR15                      ((uint32_t)0x00008000)        /*!< Rising trigger event configuration bit of line 15 */
N#define  EXTI_RTSR_TR16                      ((uint32_t)0x00010000)        /*!< Rising trigger event configuration bit of line 16 */
N#define  EXTI_RTSR_TR17                      ((uint32_t)0x00020000)        /*!< Rising trigger event configuration bit of line 17 */
N#define  EXTI_RTSR_TR19                      ((uint32_t)0x00080000)        /*!< Rising trigger event configuration bit of line 19 */
N//#define  EXTI_RTSR_TR20                      ((uint32_t)0x00100000)        /*!< Rising trigger event configuration bit of line 20 */
N#define  EXTI_RTSR_TR21                      ((uint32_t)0x00200000)        /*!< Rising trigger event configuration bit of line 21 */
N#define  EXTI_RTSR_TR22                      ((uint32_t)0x00400000)        /*!< Rising trigger event configuration bit of line 22 */
N
N/*******************  Bit definition for EXTI_FTSR register *******************/
N#define  EXTI_FTSR_TR0                       ((uint32_t)0x00000001)        /*!< Falling trigger event configuration bit of line 0 */
N#define  EXTI_FTSR_TR1                       ((uint32_t)0x00000002)        /*!< Falling trigger event configuration bit of line 1 */
N#define  EXTI_FTSR_TR2                       ((uint32_t)0x00000004)        /*!< Falling trigger event configuration bit of line 2 */
N#define  EXTI_FTSR_TR3                       ((uint32_t)0x00000008)        /*!< Falling trigger event configuration bit of line 3 */
N#define  EXTI_FTSR_TR4                       ((uint32_t)0x00000010)        /*!< Falling trigger event configuration bit of line 4 */
N#define  EXTI_FTSR_TR5                       ((uint32_t)0x00000020)        /*!< Falling trigger event configuration bit of line 5 */
N#define  EXTI_FTSR_TR6                       ((uint32_t)0x00000040)        /*!< Falling trigger event configuration bit of line 6 */
N#define  EXTI_FTSR_TR7                       ((uint32_t)0x00000080)        /*!< Falling trigger event configuration bit of line 7 */
N#define  EXTI_FTSR_TR8                       ((uint32_t)0x00000100)        /*!< Falling trigger event configuration bit of line 8 */
N#define  EXTI_FTSR_TR9                       ((uint32_t)0x00000200)        /*!< Falling trigger event configuration bit of line 9 */
N#define  EXTI_FTSR_TR10                      ((uint32_t)0x00000400)        /*!< Falling trigger event configuration bit of line 10 */
N#define  EXTI_FTSR_TR11                      ((uint32_t)0x00000800)        /*!< Falling trigger event configuration bit of line 11 */
N#define  EXTI_FTSR_TR12                      ((uint32_t)0x00001000)        /*!< Falling trigger event configuration bit of line 12 */
N#define  EXTI_FTSR_TR13                      ((uint32_t)0x00002000)        /*!< Falling trigger event configuration bit of line 13 */
N#define  EXTI_FTSR_TR14                      ((uint32_t)0x00004000)        /*!< Falling trigger event configuration bit of line 14 */
N#define  EXTI_FTSR_TR15                      ((uint32_t)0x00008000)        /*!< Falling trigger event configuration bit of line 15 */
N#define  EXTI_FTSR_TR16                      ((uint32_t)0x00010000)        /*!< Falling trigger event configuration bit of line 16 */
N#define  EXTI_FTSR_TR17                      ((uint32_t)0x00020000)        /*!< Falling trigger event configuration bit of line 17 */
N#define  EXTI_FTSR_TR19                      ((uint32_t)0x00080000)        /*!< Falling trigger event configuration bit of line 19 */
N//#define  EXTI_FTSR_TR20                      ((uint32_t)0x00100000)        /*!< Falling trigger event configuration bit of line 20 */
N#define  EXTI_FTSR_TR21                      ((uint32_t)0x00200000)        /*!< Falling trigger event configuration bit of line 21 */
N#define  EXTI_FTSR_TR22                      ((uint32_t)0x00400000)        /*!< Falling trigger event configuration bit of line 22 */
N
N/******************* Bit definition for EXTI_SWIER register *******************/
N#define  EXTI_SWIER_SWIER0                   ((uint32_t)0x00000001)        /*!< Software Interrupt on line 0  */
N#define  EXTI_SWIER_SWIER1                   ((uint32_t)0x00000002)        /*!< Software Interrupt on line 1  */
N#define  EXTI_SWIER_SWIER2                   ((uint32_t)0x00000004)        /*!< Software Interrupt on line 2  */
N#define  EXTI_SWIER_SWIER3                   ((uint32_t)0x00000008)        /*!< Software Interrupt on line 3  */
N#define  EXTI_SWIER_SWIER4                   ((uint32_t)0x00000010)        /*!< Software Interrupt on line 4  */
N#define  EXTI_SWIER_SWIER5                   ((uint32_t)0x00000020)        /*!< Software Interrupt on line 5  */
N#define  EXTI_SWIER_SWIER6                   ((uint32_t)0x00000040)        /*!< Software Interrupt on line 6  */
N#define  EXTI_SWIER_SWIER7                   ((uint32_t)0x00000080)        /*!< Software Interrupt on line 7  */
N#define  EXTI_SWIER_SWIER8                   ((uint32_t)0x00000100)        /*!< Software Interrupt on line 8  */
N#define  EXTI_SWIER_SWIER9                   ((uint32_t)0x00000200)        /*!< Software Interrupt on line 9  */
N#define  EXTI_SWIER_SWIER10                  ((uint32_t)0x00000400)        /*!< Software Interrupt on line 10 */
N#define  EXTI_SWIER_SWIER11                  ((uint32_t)0x00000800)        /*!< Software Interrupt on line 11 */
N#define  EXTI_SWIER_SWIER12                  ((uint32_t)0x00001000)        /*!< Software Interrupt on line 12 */
N#define  EXTI_SWIER_SWIER13                  ((uint32_t)0x00002000)        /*!< Software Interrupt on line 13 */
N#define  EXTI_SWIER_SWIER14                  ((uint32_t)0x00004000)        /*!< Software Interrupt on line 14 */
N#define  EXTI_SWIER_SWIER15                  ((uint32_t)0x00008000)        /*!< Software Interrupt on line 15 */
N#define  EXTI_SWIER_SWIER16                  ((uint32_t)0x00010000)        /*!< Software Interrupt on line 16 */
N#define  EXTI_SWIER_SWIER17                  ((uint32_t)0x00020000)        /*!< Software Interrupt on line 17 */
N#define  EXTI_SWIER_SWIER19                  ((uint32_t)0x00080000)        /*!< Software Interrupt on line 19 */
N//#define  EXTI_SWIER_SWIER20                  ((uint32_t)0x00100000)        /*!< Software Interrupt on line 20 */
N#define  EXTI_SWIER_SWIER21                  ((uint32_t)0x00200000)        /*!< Software Interrupt on line 21 */
N#define  EXTI_SWIER_SWIER22                  ((uint32_t)0x00400000)        /*!< Software Interrupt on line 22 */
N
N/******************  Bit definition for EXTI_PR register  *********************/
N#define  EXTI_PR_PR0                         ((uint32_t)0x00000001)        /*!< Pending bit 0  */
N#define  EXTI_PR_PR1                         ((uint32_t)0x00000002)        /*!< Pending bit 1  */
N#define  EXTI_PR_PR2                         ((uint32_t)0x00000004)        /*!< Pending bit 2  */
N#define  EXTI_PR_PR3                         ((uint32_t)0x00000008)        /*!< Pending bit 3  */
N#define  EXTI_PR_PR4                         ((uint32_t)0x00000010)        /*!< Pending bit 4  */
N#define  EXTI_PR_PR5                         ((uint32_t)0x00000020)        /*!< Pending bit 5  */
N#define  EXTI_PR_PR6                         ((uint32_t)0x00000040)        /*!< Pending bit 6  */
N#define  EXTI_PR_PR7                         ((uint32_t)0x00000080)        /*!< Pending bit 7  */
N#define  EXTI_PR_PR8                         ((uint32_t)0x00000100)        /*!< Pending bit 8  */
N#define  EXTI_PR_PR9                         ((uint32_t)0x00000200)        /*!< Pending bit 9  */
N#define  EXTI_PR_PR10                        ((uint32_t)0x00000400)        /*!< Pending bit 10 */
N#define  EXTI_PR_PR11                        ((uint32_t)0x00000800)        /*!< Pending bit 11 */
N#define  EXTI_PR_PR12                        ((uint32_t)0x00001000)        /*!< Pending bit 12 */
N#define  EXTI_PR_PR13                        ((uint32_t)0x00002000)        /*!< Pending bit 13 */
N#define  EXTI_PR_PR14                        ((uint32_t)0x00004000)        /*!< Pending bit 14 */
N#define  EXTI_PR_PR15                        ((uint32_t)0x00008000)        /*!< Pending bit 15 */
N#define  EXTI_PR_PR16                        ((uint32_t)0x00010000)        /*!< Pending bit 16 */
N#define  EXTI_PR_PR17                        ((uint32_t)0x00020000)        /*!< Pending bit 17 */
N#define  EXTI_PR_PR19                        ((uint32_t)0x00080000)        /*!< Pending bit 19 */
N//#define  EXTI_PR_PR20                        ((uint32_t)0x00100000)        /*!< Pending bit 20 */
N#define  EXTI_PR_PR21                        ((uint32_t)0x00200000)        /*!< Pending bit 21 */
N#define  EXTI_PR_PR22                        ((uint32_t)0x00400000)        /*!< Pending bit 22 */
N
N/******************************************************************************/
N/*                                                                            */
N/*                      FLASH and Option Bytes Registers                      */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for FLASH_ACR register  ******************/
N#define  FLASH_ACR_LATENCY                   ((uint32_t)0x00000001)        /*!< LATENCY bit (Latency) */
N
N#define  FLASH_ACR_PRFTBE                    ((uint32_t)0x00000010)        /*!< Prefetch Buffer Enable */
N#define  FLASH_ACR_PRFTBS                    ((uint32_t)0x00000020)        /*!< Prefetch Buffer Status */
N
N/******************  Bit definition for FLASH_KEYR register  ******************/
N#define  FLASH_KEYR_FKEYR                    ((uint32_t)0xFFFFFFFF)        /*!< FPEC Key */
N
N/*****************  Bit definition for FLASH_OPTKEYR register  ****************/
N#define  FLASH_OPTKEYR_OPTKEYR               ((uint32_t)0xFFFFFFFF)        /*!< Option Byte Key */
N
N/******************  FLASH Keys  **********************************************/
N#define FLASH_FKEY1                          ((uint32_t)0x45670123)        /*!< Flash program erase key1 */
N#define FLASH_FKEY2                          ((uint32_t)0xCDEF89AB)        /*!< Flash program erase key2: used with FLASH_PEKEY1
N                                                                                to unlock the write access to the FPEC. */
N                                                               
N#define FLASH_OPTKEY1                        ((uint32_t)0x45670123)        /*!< Flash option key1 */
N#define FLASH_OPTKEY2                        ((uint32_t)0xCDEF89AB)        /*!< Flash option key2: used with FLASH_OPTKEY1 to
N                                                                                unlock the write access to the option byte block */
N
N/******************  Bit definition for FLASH_SR register  *******************/
N#define  FLASH_SR_BSY                        ((uint32_t)0x00000001)        /*!< Busy */
N#define  FLASH_SR_PGERR                      ((uint32_t)0x00000004)        /*!< Programming Error */
N#define  FLASH_SR_WRPRTERR                   ((uint32_t)0x00000010)        /*!< Write Protection Error */
N#define  FLASH_SR_EOP                        ((uint32_t)0x00000020)        /*!< End of operation */
N#define  FLASH_SR_WRPERR                     FLASH_SR_WRPRTERR             /*!< Legacy of Write Protection Error */
N
N/*******************  Bit definition for FLASH_CR register  *******************/
N#define  FLASH_CR_PG                         ((uint32_t)0x00000001)        /*!< Programming */
N#define  FLASH_CR_PER                        ((uint32_t)0x00000002)        /*!< Page Erase */
N#define  FLASH_CR_MER                        ((uint32_t)0x00000004)        /*!< Mass Erase */
N#define  FLASH_CR_MAS2K                      ((uint32_t)0x00000008)        /*!< Mass Erase */
N#define  FLASH_CR_OPTPG                      ((uint32_t)0x00000010)        /*!< Option Byte Programming */
N#define  FLASH_CR_OPTER                      ((uint32_t)0x00000020)        /*!< Option Byte Erase */
N#define  FLASH_CR_STRT                       ((uint32_t)0x00000040)        /*!< Start */
N#define  FLASH_CR_LOCK                       ((uint32_t)0x00000080)        /*!< Lock */
N#define  FLASH_CR_OPTWRE                     ((uint32_t)0x00000200)        /*!< Option Bytes Write Enable */
N#define  FLASH_CR_ERRIE                      ((uint32_t)0x00000400)        /*!< Error Interrupt Enable */
N#define  FLASH_CR_EOPIE                      ((uint32_t)0x00001000)        /*!< End of operation interrupt enable */
N#define  FLASH_CR_OBL_LAUNCH                 ((uint32_t)0x00002000)        /*!< Option Bytes Loader Launch */
N
N/*******************  Bit definition for FLASH_AR register  *******************/
N#define  FLASH_AR_FAR                        ((uint32_t)0xFFFFFFFF)        /*!< Flash Address */
N
N/******************  Bit definition for FLASH_OBR register  *******************/
N#define  FLASH_OBR_OPTERR                    ((uint32_t)0x00000001)        /*!< Option Byte Error */
N#define  FLASH_OBR_RDPRT1                    ((uint32_t)0x00000002)        /*!< Read protection Level bit 1 */
N#define  FLASH_OBR_RDPRT2                    ((uint32_t)0x00000004)        /*!< Read protection Level bit 2 */
N
N//#define  FLASH_OBR_USER                      ((uint32_t)0x00003700)        /*!< User Option Bytes */
N#define  FLASH_OBR_IWDG_SW                   ((uint32_t)0x00000100)        /*!< IWDG SW */
N#define  FLASH_OBR_nRST_STOP                 ((uint32_t)0x00000200)        /*!< nRST_STOP */
N#define  FLASH_OBR_nRST_STDBY                ((uint32_t)0x00000400)        /*!< nRST_STDBY */
N//#define  FLASH_OBR_nBOOT0                    ((uint32_t)0x00000800)        /*!< nBOOT0 */
N#define  FLASH_OBR_nBOOT1                    ((uint32_t)0x00001000)        /*!< nBOOT1 */
N#define  FLASH_OBR_VDDA_MONITOR              ((uint32_t)0x00002000)        /*!< VDDA power supply supervisor */
N//#define  FLASH_OBR_RAM_PARITY_CHECK          ((uint32_t)0x00004000)        /*!< RAM Parity Check */
N//#define  FLASH_OBR_nBOOT0_SW                 ((uint32_t)0x00008000)        /*!< nBOOT0 SW*/
N#define  FLASH_OBR_DATA0                     ((uint32_t)0x00FF0000)        /*!< DATA0 */
N#define  FLASH_OBR_DATA1                     ((uint32_t)0xFF000000)        /*!< DATA0 */
N
N/* Old BOOT1 bit definition, maintained for legacy purpose */
N#define FLASH_OBR_BOOT1                      FLASH_OBR_nBOOT1
N
N/* Old OBR_VDDA bit definition, maintained for legacy purpose */
N#define FLASH_OBR_VDDA_ANALOG                FLASH_OBR_VDDA_MONITOR
N
N/******************  Bit definition for FLASH_WRPR register  ******************/
N#define  FLASH_WRPR_WRP                      ((uint32_t)0xFFFFFFFF)        /*!< Write Protect */
N
N/*----------------------------------------------------------------------------*/
N
N/******************  Bit definition for OB_RDP register  **********************/
N#define  OB_RDP_RDP                          ((uint32_t)0x000000FF)        /*!< Read protection option byte */
N#define  OB_RDP_nRDP                         ((uint32_t)0x0000FF00)        /*!< Read protection complemented option byte */
N
N/******************  Bit definition for OB_USER register  *********************/
N#define  OB_USER_USER                        ((uint32_t)0x00FF0000)        /*!< User option byte */
N#define  OB_USER_nUSER                       ((uint32_t)0xFF000000)        /*!< User complemented option byte */
N
N/******************  Bit definition for OB_WRP0 register  *********************/
N#define  OB_WRP0_WRP0                        ((uint32_t)0x000000FF)        /*!< Flash memory write protection option bytes */
N#define  OB_WRP0_nWRP0                       ((uint32_t)0x0000FF00)        /*!< Flash memory write protection complemented option bytes */
N
N/******************  Bit definition for OB_WRP1 register  *********************/
N#define  OB_WRP1_WRP1                        ((uint32_t)0x00FF0000)        /*!< Flash memory write protection option bytes */
N#define  OB_WRP1_nWRP1                       ((uint32_t)0xFF000000)        /*!< Flash memory write protection complemented option bytes */
N
N/******************  Bit definition for OB_WRP2 register  *********************/
N#define  OB_WRP2_WRP2                        ((uint32_t)0x000000FF)        /*!< Flash memory write protection option bytes (only for FT32F072X8 devices) */
N#define  OB_WRP2_nWRP2                       ((uint32_t)0x0000FF00)        /*!< Flash memory write protection complemented option bytes (only for FT32F072X8 devices) */
N
N/******************  Bit definition for OB_WRP3 register  *********************/
N#define  OB_WRP3_WRP3                        ((uint32_t)0x00FF0000)        /*!< Flash memory write protection option bytes (only for FT32F072X8 devices) */
N#define  OB_WRP3_nWRP3                       ((uint32_t)0xFF000000)        /*!< Flash memory write protection complemented option bytes (only for FT32F072X8 devices) */
N
N/******************************************************************************/
N/*                                                                            */
N/*                       General Purpose IOs (GPIO)                           */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for GPIO_MODER register  *****************/
N#define GPIO_MODER_MODER0          ((uint32_t)0x00000003)
N#define GPIO_MODER_MODER0_0        ((uint32_t)0x00000001)
N#define GPIO_MODER_MODER0_1        ((uint32_t)0x00000002)
N#define GPIO_MODER_MODER1          ((uint32_t)0x0000000C)
N#define GPIO_MODER_MODER1_0        ((uint32_t)0x00000004)
N#define GPIO_MODER_MODER1_1        ((uint32_t)0x00000008)
N#define GPIO_MODER_MODER2          ((uint32_t)0x00000030)
N#define GPIO_MODER_MODER2_0        ((uint32_t)0x00000010)
N#define GPIO_MODER_MODER2_1        ((uint32_t)0x00000020)
N#define GPIO_MODER_MODER3          ((uint32_t)0x000000C0)
N#define GPIO_MODER_MODER3_0        ((uint32_t)0x00000040)
N#define GPIO_MODER_MODER3_1        ((uint32_t)0x00000080)
N#define GPIO_MODER_MODER4          ((uint32_t)0x00000300)
N#define GPIO_MODER_MODER4_0        ((uint32_t)0x00000100)
N#define GPIO_MODER_MODER4_1        ((uint32_t)0x00000200)
N#define GPIO_MODER_MODER5          ((uint32_t)0x00000C00)
N#define GPIO_MODER_MODER5_0        ((uint32_t)0x00000400)
N#define GPIO_MODER_MODER5_1        ((uint32_t)0x00000800)
N#define GPIO_MODER_MODER6          ((uint32_t)0x00003000)
N#define GPIO_MODER_MODER6_0        ((uint32_t)0x00001000)
N#define GPIO_MODER_MODER6_1        ((uint32_t)0x00002000)
N#define GPIO_MODER_MODER7          ((uint32_t)0x0000C000)
N#define GPIO_MODER_MODER7_0        ((uint32_t)0x00004000)
N#define GPIO_MODER_MODER7_1        ((uint32_t)0x00008000)
N#define GPIO_MODER_MODER8          ((uint32_t)0x00030000)
N#define GPIO_MODER_MODER8_0        ((uint32_t)0x00010000)
N#define GPIO_MODER_MODER8_1        ((uint32_t)0x00020000)
N#define GPIO_MODER_MODER9          ((uint32_t)0x000C0000)
N#define GPIO_MODER_MODER9_0        ((uint32_t)0x00040000)
N#define GPIO_MODER_MODER9_1        ((uint32_t)0x00080000)
N#define GPIO_MODER_MODER10         ((uint32_t)0x00300000)
N#define GPIO_MODER_MODER10_0       ((uint32_t)0x00100000)
N#define GPIO_MODER_MODER10_1       ((uint32_t)0x00200000)
N#define GPIO_MODER_MODER11         ((uint32_t)0x00C00000)
N#define GPIO_MODER_MODER11_0       ((uint32_t)0x00400000)
N#define GPIO_MODER_MODER11_1       ((uint32_t)0x00800000)
N#define GPIO_MODER_MODER12         ((uint32_t)0x03000000)
N#define GPIO_MODER_MODER12_0       ((uint32_t)0x01000000)
N#define GPIO_MODER_MODER12_1       ((uint32_t)0x02000000)
N#define GPIO_MODER_MODER13         ((uint32_t)0x0C000000)
N#define GPIO_MODER_MODER13_0       ((uint32_t)0x04000000)
N#define GPIO_MODER_MODER13_1       ((uint32_t)0x08000000)
N#define GPIO_MODER_MODER14         ((uint32_t)0x30000000)
N#define GPIO_MODER_MODER14_0       ((uint32_t)0x10000000)
N#define GPIO_MODER_MODER14_1       ((uint32_t)0x20000000)
N#define GPIO_MODER_MODER15         ((uint32_t)0xC0000000)
N#define GPIO_MODER_MODER15_0       ((uint32_t)0x40000000)
N#define GPIO_MODER_MODER15_1       ((uint32_t)0x80000000)
N
N/******************  Bit definition for GPIO_OTYPER register  *****************/
N#define GPIO_OTYPER_OT_0           ((uint32_t)0x00000001)
N#define GPIO_OTYPER_OT_1           ((uint32_t)0x00000002)
N#define GPIO_OTYPER_OT_2           ((uint32_t)0x00000004)
N#define GPIO_OTYPER_OT_3           ((uint32_t)0x00000008)
N#define GPIO_OTYPER_OT_4           ((uint32_t)0x00000010)
N#define GPIO_OTYPER_OT_5           ((uint32_t)0x00000020)
N#define GPIO_OTYPER_OT_6           ((uint32_t)0x00000040)
N#define GPIO_OTYPER_OT_7           ((uint32_t)0x00000080)
N#define GPIO_OTYPER_OT_8           ((uint32_t)0x00000100)
N#define GPIO_OTYPER_OT_9           ((uint32_t)0x00000200)
N#define GPIO_OTYPER_OT_10          ((uint32_t)0x00000400)
N#define GPIO_OTYPER_OT_11          ((uint32_t)0x00000800)
N#define GPIO_OTYPER_OT_12          ((uint32_t)0x00001000)
N#define GPIO_OTYPER_OT_13          ((uint32_t)0x00002000)
N#define GPIO_OTYPER_OT_14          ((uint32_t)0x00004000)
N#define GPIO_OTYPER_OT_15          ((uint32_t)0x00008000)
N
N/****************  Bit definition for GPIO_OSPEEDR register  ******************/
N#define GPIO_OSPEEDR_OSPEEDR0     ((uint32_t)0x00000003)
N#define GPIO_OSPEEDR_OSPEEDR0_0   ((uint32_t)0x00000001)
N#define GPIO_OSPEEDR_OSPEEDR0_1   ((uint32_t)0x00000002)
N#define GPIO_OSPEEDR_OSPEEDR1     ((uint32_t)0x0000000C)
N#define GPIO_OSPEEDR_OSPEEDR1_0   ((uint32_t)0x00000004)
N#define GPIO_OSPEEDR_OSPEEDR1_1   ((uint32_t)0x00000008)
N#define GPIO_OSPEEDR_OSPEEDR2     ((uint32_t)0x00000030)
N#define GPIO_OSPEEDR_OSPEEDR2_0   ((uint32_t)0x00000010)
N#define GPIO_OSPEEDR_OSPEEDR2_1   ((uint32_t)0x00000020)
N#define GPIO_OSPEEDR_OSPEEDR3     ((uint32_t)0x000000C0)
N#define GPIO_OSPEEDR_OSPEEDR3_0   ((uint32_t)0x00000040)
N#define GPIO_OSPEEDR_OSPEEDR3_1   ((uint32_t)0x00000080)
N#define GPIO_OSPEEDR_OSPEEDR4     ((uint32_t)0x00000300)
N#define GPIO_OSPEEDR_OSPEEDR4_0   ((uint32_t)0x00000100)
N#define GPIO_OSPEEDR_OSPEEDR4_1   ((uint32_t)0x00000200)
N#define GPIO_OSPEEDR_OSPEEDR5     ((uint32_t)0x00000C00)
N#define GPIO_OSPEEDR_OSPEEDR5_0   ((uint32_t)0x00000400)
N#define GPIO_OSPEEDR_OSPEEDR5_1   ((uint32_t)0x00000800)
N#define GPIO_OSPEEDR_OSPEEDR6     ((uint32_t)0x00003000)
N#define GPIO_OSPEEDR_OSPEEDR6_0   ((uint32_t)0x00001000)
N#define GPIO_OSPEEDR_OSPEEDR6_1   ((uint32_t)0x00002000)
N#define GPIO_OSPEEDR_OSPEEDR7     ((uint32_t)0x0000C000)
N#define GPIO_OSPEEDR_OSPEEDR7_0   ((uint32_t)0x00004000)
N#define GPIO_OSPEEDR_OSPEEDR7_1   ((uint32_t)0x00008000)
N#define GPIO_OSPEEDR_OSPEEDR8     ((uint32_t)0x00030000)
N#define GPIO_OSPEEDR_OSPEEDR8_0   ((uint32_t)0x00010000)
N#define GPIO_OSPEEDR_OSPEEDR8_1   ((uint32_t)0x00020000)
N#define GPIO_OSPEEDR_OSPEEDR9     ((uint32_t)0x000C0000)
N#define GPIO_OSPEEDR_OSPEEDR9_0   ((uint32_t)0x00040000)
N#define GPIO_OSPEEDR_OSPEEDR9_1   ((uint32_t)0x00080000)
N#define GPIO_OSPEEDR_OSPEEDR10    ((uint32_t)0x00300000)
N#define GPIO_OSPEEDR_OSPEEDR10_0  ((uint32_t)0x00100000)
N#define GPIO_OSPEEDR_OSPEEDR10_1  ((uint32_t)0x00200000)
N#define GPIO_OSPEEDR_OSPEEDR11    ((uint32_t)0x00C00000)
N#define GPIO_OSPEEDR_OSPEEDR11_0  ((uint32_t)0x00400000)
N#define GPIO_OSPEEDR_OSPEEDR11_1  ((uint32_t)0x00800000)
N#define GPIO_OSPEEDR_OSPEEDR12    ((uint32_t)0x03000000)
N#define GPIO_OSPEEDR_OSPEEDR12_0  ((uint32_t)0x01000000)
N#define GPIO_OSPEEDR_OSPEEDR12_1  ((uint32_t)0x02000000)
N#define GPIO_OSPEEDR_OSPEEDR13    ((uint32_t)0x0C000000)
N#define GPIO_OSPEEDR_OSPEEDR13_0  ((uint32_t)0x04000000)
N#define GPIO_OSPEEDR_OSPEEDR13_1  ((uint32_t)0x08000000)
N#define GPIO_OSPEEDR_OSPEEDR14    ((uint32_t)0x30000000)
N#define GPIO_OSPEEDR_OSPEEDR14_0  ((uint32_t)0x10000000)
N#define GPIO_OSPEEDR_OSPEEDR14_1  ((uint32_t)0x20000000)
N#define GPIO_OSPEEDR_OSPEEDR15    ((uint32_t)0xC0000000)
N#define GPIO_OSPEEDR_OSPEEDR15_0  ((uint32_t)0x40000000)
N#define GPIO_OSPEEDR_OSPEEDR15_1  ((uint32_t)0x80000000)
N
N/* Old Bit definition for GPIO_OSPEEDR register maintained for legacy purpose */
N#define GPIO_OSPEEDER_OSPEEDR0     GPIO_OSPEEDR_OSPEEDR0
N#define GPIO_OSPEEDER_OSPEEDR0_0   GPIO_OSPEEDR_OSPEEDR0_0
N#define GPIO_OSPEEDER_OSPEEDR0_1   GPIO_OSPEEDR_OSPEEDR0_1
N#define GPIO_OSPEEDER_OSPEEDR1     GPIO_OSPEEDR_OSPEEDR1
N#define GPIO_OSPEEDER_OSPEEDR1_0   GPIO_OSPEEDR_OSPEEDR1_0
N#define GPIO_OSPEEDER_OSPEEDR1_1   GPIO_OSPEEDR_OSPEEDR1_1
N#define GPIO_OSPEEDER_OSPEEDR2     GPIO_OSPEEDR_OSPEEDR2
N#define GPIO_OSPEEDER_OSPEEDR2_0   GPIO_OSPEEDR_OSPEEDR2_0
N#define GPIO_OSPEEDER_OSPEEDR2_1   GPIO_OSPEEDR_OSPEEDR2_1
N#define GPIO_OSPEEDER_OSPEEDR3     GPIO_OSPEEDR_OSPEEDR3
N#define GPIO_OSPEEDER_OSPEEDR3_0   GPIO_OSPEEDR_OSPEEDR3_0
N#define GPIO_OSPEEDER_OSPEEDR3_1   GPIO_OSPEEDR_OSPEEDR3_1
N#define GPIO_OSPEEDER_OSPEEDR4     GPIO_OSPEEDR_OSPEEDR4
N#define GPIO_OSPEEDER_OSPEEDR4_0   GPIO_OSPEEDR_OSPEEDR4_0
N#define GPIO_OSPEEDER_OSPEEDR4_1   GPIO_OSPEEDR_OSPEEDR4_1
N#define GPIO_OSPEEDER_OSPEEDR5     GPIO_OSPEEDR_OSPEEDR5
N#define GPIO_OSPEEDER_OSPEEDR5_0   GPIO_OSPEEDR_OSPEEDR5_0
N#define GPIO_OSPEEDER_OSPEEDR5_1   GPIO_OSPEEDR_OSPEEDR5_1
N#define GPIO_OSPEEDER_OSPEEDR6     GPIO_OSPEEDR_OSPEEDR6
N#define GPIO_OSPEEDER_OSPEEDR6_0   GPIO_OSPEEDR_OSPEEDR6_0
N#define GPIO_OSPEEDER_OSPEEDR6_1   GPIO_OSPEEDR_OSPEEDR6_1
N#define GPIO_OSPEEDER_OSPEEDR7     GPIO_OSPEEDR_OSPEEDR7
N#define GPIO_OSPEEDER_OSPEEDR7_0   GPIO_OSPEEDR_OSPEEDR7_0
N#define GPIO_OSPEEDER_OSPEEDR7_1   GPIO_OSPEEDR_OSPEEDR7_1
N#define GPIO_OSPEEDER_OSPEEDR8     GPIO_OSPEEDR_OSPEEDR8
N#define GPIO_OSPEEDER_OSPEEDR8_0   GPIO_OSPEEDR_OSPEEDR8_0
N#define GPIO_OSPEEDER_OSPEEDR8_1   GPIO_OSPEEDR_OSPEEDR8_1
N#define GPIO_OSPEEDER_OSPEEDR9     GPIO_OSPEEDR_OSPEEDR9
N#define GPIO_OSPEEDER_OSPEEDR9_0   GPIO_OSPEEDR_OSPEEDR9_0
N#define GPIO_OSPEEDER_OSPEEDR9_1   GPIO_OSPEEDR_OSPEEDR9_1
N#define GPIO_OSPEEDER_OSPEEDR10    GPIO_OSPEEDR_OSPEEDR10
N#define GPIO_OSPEEDER_OSPEEDR10_0  GPIO_OSPEEDR_OSPEEDR10_0
N#define GPIO_OSPEEDER_OSPEEDR10_1  GPIO_OSPEEDR_OSPEEDR10_1
N#define GPIO_OSPEEDER_OSPEEDR11    GPIO_OSPEEDR_OSPEEDR11
N#define GPIO_OSPEEDER_OSPEEDR11_0  GPIO_OSPEEDR_OSPEEDR11_0
N#define GPIO_OSPEEDER_OSPEEDR11_1  GPIO_OSPEEDR_OSPEEDR11_1
N#define GPIO_OSPEEDER_OSPEEDR12    GPIO_OSPEEDR_OSPEEDR12
N#define GPIO_OSPEEDER_OSPEEDR12_0  GPIO_OSPEEDR_OSPEEDR12_0
N#define GPIO_OSPEEDER_OSPEEDR12_1  GPIO_OSPEEDR_OSPEEDR12_1
N#define GPIO_OSPEEDER_OSPEEDR13    GPIO_OSPEEDR_OSPEEDR13
N#define GPIO_OSPEEDER_OSPEEDR13_0  GPIO_OSPEEDR_OSPEEDR13_0
N#define GPIO_OSPEEDER_OSPEEDR13_1  GPIO_OSPEEDR_OSPEEDR13_1
N#define GPIO_OSPEEDER_OSPEEDR14    GPIO_OSPEEDR_OSPEEDR14
N#define GPIO_OSPEEDER_OSPEEDR14_0  GPIO_OSPEEDR_OSPEEDR14_0
N#define GPIO_OSPEEDER_OSPEEDR14_1  GPIO_OSPEEDR_OSPEEDR14_1
N#define GPIO_OSPEEDER_OSPEEDR15    GPIO_OSPEEDR_OSPEEDR15
N#define GPIO_OSPEEDER_OSPEEDR15_0  GPIO_OSPEEDR_OSPEEDR15_0
N#define GPIO_OSPEEDER_OSPEEDR15_1  GPIO_OSPEEDR_OSPEEDR15_1
N
N/*******************  Bit definition for GPIO_PUPDR register ******************/
N#define GPIO_PUPDR_PUPDR0          ((uint32_t)0x00000003)
N#define GPIO_PUPDR_PUPDR0_0        ((uint32_t)0x00000001)
N#define GPIO_PUPDR_PUPDR0_1        ((uint32_t)0x00000002)
N#define GPIO_PUPDR_PUPDR1          ((uint32_t)0x0000000C)
N#define GPIO_PUPDR_PUPDR1_0        ((uint32_t)0x00000004)
N#define GPIO_PUPDR_PUPDR1_1        ((uint32_t)0x00000008)
N#define GPIO_PUPDR_PUPDR2          ((uint32_t)0x00000030)
N#define GPIO_PUPDR_PUPDR2_0        ((uint32_t)0x00000010)
N#define GPIO_PUPDR_PUPDR2_1        ((uint32_t)0x00000020)
N#define GPIO_PUPDR_PUPDR3          ((uint32_t)0x000000C0)
N#define GPIO_PUPDR_PUPDR3_0        ((uint32_t)0x00000040)
N#define GPIO_PUPDR_PUPDR3_1        ((uint32_t)0x00000080)
N#define GPIO_PUPDR_PUPDR4          ((uint32_t)0x00000300)
N#define GPIO_PUPDR_PUPDR4_0        ((uint32_t)0x00000100)
N#define GPIO_PUPDR_PUPDR4_1        ((uint32_t)0x00000200)
N#define GPIO_PUPDR_PUPDR5          ((uint32_t)0x00000C00)
N#define GPIO_PUPDR_PUPDR5_0        ((uint32_t)0x00000400)
N#define GPIO_PUPDR_PUPDR5_1        ((uint32_t)0x00000800)
N#define GPIO_PUPDR_PUPDR6          ((uint32_t)0x00003000)
N#define GPIO_PUPDR_PUPDR6_0        ((uint32_t)0x00001000)
N#define GPIO_PUPDR_PUPDR6_1        ((uint32_t)0x00002000)
N#define GPIO_PUPDR_PUPDR7          ((uint32_t)0x0000C000)
N#define GPIO_PUPDR_PUPDR7_0        ((uint32_t)0x00004000)
N#define GPIO_PUPDR_PUPDR7_1        ((uint32_t)0x00008000)
N#define GPIO_PUPDR_PUPDR8          ((uint32_t)0x00030000)
N#define GPIO_PUPDR_PUPDR8_0        ((uint32_t)0x00010000)
N#define GPIO_PUPDR_PUPDR8_1        ((uint32_t)0x00020000)
N#define GPIO_PUPDR_PUPDR9          ((uint32_t)0x000C0000)
N#define GPIO_PUPDR_PUPDR9_0        ((uint32_t)0x00040000)
N#define GPIO_PUPDR_PUPDR9_1        ((uint32_t)0x00080000)
N#define GPIO_PUPDR_PUPDR10         ((uint32_t)0x00300000)
N#define GPIO_PUPDR_PUPDR10_0       ((uint32_t)0x00100000)
N#define GPIO_PUPDR_PUPDR10_1       ((uint32_t)0x00200000)
N#define GPIO_PUPDR_PUPDR11         ((uint32_t)0x00C00000)
N#define GPIO_PUPDR_PUPDR11_0       ((uint32_t)0x00400000)
N#define GPIO_PUPDR_PUPDR11_1       ((uint32_t)0x00800000)
N#define GPIO_PUPDR_PUPDR12         ((uint32_t)0x03000000)
N#define GPIO_PUPDR_PUPDR12_0       ((uint32_t)0x01000000)
N#define GPIO_PUPDR_PUPDR12_1       ((uint32_t)0x02000000)
N#define GPIO_PUPDR_PUPDR13         ((uint32_t)0x0C000000)
N#define GPIO_PUPDR_PUPDR13_0       ((uint32_t)0x04000000)
N#define GPIO_PUPDR_PUPDR13_1       ((uint32_t)0x08000000)
N#define GPIO_PUPDR_PUPDR14         ((uint32_t)0x30000000)
N#define GPIO_PUPDR_PUPDR14_0       ((uint32_t)0x10000000)
N#define GPIO_PUPDR_PUPDR14_1       ((uint32_t)0x20000000)
N#define GPIO_PUPDR_PUPDR15         ((uint32_t)0xC0000000)
N#define GPIO_PUPDR_PUPDR15_0       ((uint32_t)0x40000000)
N#define GPIO_PUPDR_PUPDR15_1       ((uint32_t)0x80000000)
N
N/*******************  Bit definition for GPIO_IDR register  *******************/
N#define GPIO_IDR_0                 ((uint32_t)0x00000001)
N#define GPIO_IDR_1                 ((uint32_t)0x00000002)
N#define GPIO_IDR_2                 ((uint32_t)0x00000004)
N#define GPIO_IDR_3                 ((uint32_t)0x00000008)
N#define GPIO_IDR_4                 ((uint32_t)0x00000010)
N#define GPIO_IDR_5                 ((uint32_t)0x00000020)
N#define GPIO_IDR_6                 ((uint32_t)0x00000040)
N#define GPIO_IDR_7                 ((uint32_t)0x00000080)
N#define GPIO_IDR_8                 ((uint32_t)0x00000100)
N#define GPIO_IDR_9                 ((uint32_t)0x00000200)
N#define GPIO_IDR_10                ((uint32_t)0x00000400)
N#define GPIO_IDR_11                ((uint32_t)0x00000800)
N#define GPIO_IDR_12                ((uint32_t)0x00001000)
N#define GPIO_IDR_13                ((uint32_t)0x00002000)
N#define GPIO_IDR_14                ((uint32_t)0x00004000)
N#define GPIO_IDR_15                ((uint32_t)0x00008000)
N
N/******************  Bit definition for GPIO_ODR register  ********************/
N#define GPIO_ODR_0                 ((uint32_t)0x00000001)
N#define GPIO_ODR_1                 ((uint32_t)0x00000002)
N#define GPIO_ODR_2                 ((uint32_t)0x00000004)
N#define GPIO_ODR_3                 ((uint32_t)0x00000008)
N#define GPIO_ODR_4                 ((uint32_t)0x00000010)
N#define GPIO_ODR_5                 ((uint32_t)0x00000020)
N#define GPIO_ODR_6                 ((uint32_t)0x00000040)
N#define GPIO_ODR_7                 ((uint32_t)0x00000080)
N#define GPIO_ODR_8                 ((uint32_t)0x00000100)
N#define GPIO_ODR_9                 ((uint32_t)0x00000200)
N#define GPIO_ODR_10                ((uint32_t)0x00000400)
N#define GPIO_ODR_11                ((uint32_t)0x00000800)
N#define GPIO_ODR_12                ((uint32_t)0x00001000)
N#define GPIO_ODR_13                ((uint32_t)0x00002000)
N#define GPIO_ODR_14                ((uint32_t)0x00004000)
N#define GPIO_ODR_15                ((uint32_t)0x00008000)
N
N/****************** Bit definition for GPIO_BSRR register  ********************/
N#define GPIO_BSRR_BS_0             ((uint32_t)0x00000001)
N#define GPIO_BSRR_BS_1             ((uint32_t)0x00000002)
N#define GPIO_BSRR_BS_2             ((uint32_t)0x00000004)
N#define GPIO_BSRR_BS_3             ((uint32_t)0x00000008)
N#define GPIO_BSRR_BS_4             ((uint32_t)0x00000010)
N#define GPIO_BSRR_BS_5             ((uint32_t)0x00000020)
N#define GPIO_BSRR_BS_6             ((uint32_t)0x00000040)
N#define GPIO_BSRR_BS_7             ((uint32_t)0x00000080)
N#define GPIO_BSRR_BS_8             ((uint32_t)0x00000100)
N#define GPIO_BSRR_BS_9             ((uint32_t)0x00000200)
N#define GPIO_BSRR_BS_10            ((uint32_t)0x00000400)
N#define GPIO_BSRR_BS_11            ((uint32_t)0x00000800)
N#define GPIO_BSRR_BS_12            ((uint32_t)0x00001000)
N#define GPIO_BSRR_BS_13            ((uint32_t)0x00002000)
N#define GPIO_BSRR_BS_14            ((uint32_t)0x00004000)
N#define GPIO_BSRR_BS_15            ((uint32_t)0x00008000)
N#define GPIO_BSRR_BR_0             ((uint32_t)0x00010000)
N#define GPIO_BSRR_BR_1             ((uint32_t)0x00020000)
N#define GPIO_BSRR_BR_2             ((uint32_t)0x00040000)
N#define GPIO_BSRR_BR_3             ((uint32_t)0x00080000)
N#define GPIO_BSRR_BR_4             ((uint32_t)0x00100000)
N#define GPIO_BSRR_BR_5             ((uint32_t)0x00200000)
N#define GPIO_BSRR_BR_6             ((uint32_t)0x00400000)
N#define GPIO_BSRR_BR_7             ((uint32_t)0x00800000)
N#define GPIO_BSRR_BR_8             ((uint32_t)0x01000000)
N#define GPIO_BSRR_BR_9             ((uint32_t)0x02000000)
N#define GPIO_BSRR_BR_10            ((uint32_t)0x04000000)
N#define GPIO_BSRR_BR_11            ((uint32_t)0x08000000)
N#define GPIO_BSRR_BR_12            ((uint32_t)0x10000000)
N#define GPIO_BSRR_BR_13            ((uint32_t)0x20000000)
N#define GPIO_BSRR_BR_14            ((uint32_t)0x40000000)
N#define GPIO_BSRR_BR_15            ((uint32_t)0x80000000)
N
N/****************** Bit definition for GPIO_LCKR register  ********************/
N#define GPIO_LCKR_LCK0             ((uint32_t)0x00000001)
N#define GPIO_LCKR_LCK1             ((uint32_t)0x00000002)
N#define GPIO_LCKR_LCK2             ((uint32_t)0x00000004)
N#define GPIO_LCKR_LCK3             ((uint32_t)0x00000008)
N#define GPIO_LCKR_LCK4             ((uint32_t)0x00000010)
N#define GPIO_LCKR_LCK5             ((uint32_t)0x00000020)
N#define GPIO_LCKR_LCK6             ((uint32_t)0x00000040)
N#define GPIO_LCKR_LCK7             ((uint32_t)0x00000080)
N#define GPIO_LCKR_LCK8             ((uint32_t)0x00000100)
N#define GPIO_LCKR_LCK9             ((uint32_t)0x00000200)
N#define GPIO_LCKR_LCK10            ((uint32_t)0x00000400)
N#define GPIO_LCKR_LCK11            ((uint32_t)0x00000800)
N#define GPIO_LCKR_LCK12            ((uint32_t)0x00001000)
N#define GPIO_LCKR_LCK13            ((uint32_t)0x00002000)
N#define GPIO_LCKR_LCK14            ((uint32_t)0x00004000)
N#define GPIO_LCKR_LCK15            ((uint32_t)0x00008000)
N#define GPIO_LCKR_LCKK             ((uint32_t)0x00010000)
N
N/****************** Bit definition for GPIO_AFRL register  ********************/
N#define GPIO_AFRL_AFR0            ((uint32_t)0x0000000F)
N#define GPIO_AFRL_AFR1            ((uint32_t)0x000000F0)
N#define GPIO_AFRL_AFR2            ((uint32_t)0x00000F00)
N#define GPIO_AFRL_AFR3            ((uint32_t)0x0000F000)
N#define GPIO_AFRL_AFR4            ((uint32_t)0x000F0000)
N#define GPIO_AFRL_AFR5            ((uint32_t)0x00F00000)
N#define GPIO_AFRL_AFR6            ((uint32_t)0x0F000000)
N#define GPIO_AFRL_AFR7            ((uint32_t)0xF0000000)
N
N/****************** Bit definition for GPIO_AFRH register  ********************/
N#define GPIO_AFRH_AFR8            ((uint32_t)0x0000000F)
N#define GPIO_AFRH_AFR9            ((uint32_t)0x000000F0)
N#define GPIO_AFRH_AFR10            ((uint32_t)0x00000F00)
N#define GPIO_AFRH_AFR11            ((uint32_t)0x0000F000)
N#define GPIO_AFRH_AFR12            ((uint32_t)0x000F0000)
N#define GPIO_AFRH_AFR13            ((uint32_t)0x00F00000)
N#define GPIO_AFRH_AFR14            ((uint32_t)0x0F000000)
N#define GPIO_AFRH_AFR15            ((uint32_t)0xF0000000)
N
N/* Old Bit definition for GPIO_AFRL register maintained for legacy purpose ****/
N#define GPIO_AFRL_AFRL0            GPIO_AFRL_AFR0
N#define GPIO_AFRL_AFRL1            GPIO_AFRL_AFR1
N#define GPIO_AFRL_AFRL2            GPIO_AFRL_AFR2
N#define GPIO_AFRL_AFRL3            GPIO_AFRL_AFR3
N#define GPIO_AFRL_AFRL4            GPIO_AFRL_AFR4
N#define GPIO_AFRL_AFRL5            GPIO_AFRL_AFR5
N#define GPIO_AFRL_AFRL6            GPIO_AFRL_AFR6
N#define GPIO_AFRL_AFRL7            GPIO_AFRL_AFR7
N
N/* Old Bit definition for GPIO_AFRH register maintained for legacy purpose ****/
N#define GPIO_AFRH_AFRH0            GPIO_AFRH_AFR8
N#define GPIO_AFRH_AFRH1            GPIO_AFRH_AFR9
N#define GPIO_AFRH_AFRH2            GPIO_AFRH_AFR10
N#define GPIO_AFRH_AFRH3            GPIO_AFRH_AFR11
N#define GPIO_AFRH_AFRH4            GPIO_AFRH_AFR12
N#define GPIO_AFRH_AFRH5            GPIO_AFRH_AFR13
N#define GPIO_AFRH_AFRH6            GPIO_AFRH_AFR14
N#define GPIO_AFRH_AFRH7            GPIO_AFRH_AFR15
N
N/****************** Bit definition for GPIO_BRR register  *********************/
N#define GPIO_BRR_BR_0              ((uint32_t)0x00000001)
N#define GPIO_BRR_BR_1              ((uint32_t)0x00000002)
N#define GPIO_BRR_BR_2              ((uint32_t)0x00000004)
N#define GPIO_BRR_BR_3              ((uint32_t)0x00000008)
N#define GPIO_BRR_BR_4              ((uint32_t)0x00000010)
N#define GPIO_BRR_BR_5              ((uint32_t)0x00000020)
N#define GPIO_BRR_BR_6              ((uint32_t)0x00000040)
N#define GPIO_BRR_BR_7              ((uint32_t)0x00000080)
N#define GPIO_BRR_BR_8              ((uint32_t)0x00000100)
N#define GPIO_BRR_BR_9              ((uint32_t)0x00000200)
N#define GPIO_BRR_BR_10             ((uint32_t)0x00000400)
N#define GPIO_BRR_BR_11             ((uint32_t)0x00000800)
N#define GPIO_BRR_BR_12             ((uint32_t)0x00001000)
N#define GPIO_BRR_BR_13             ((uint32_t)0x00002000)
N#define GPIO_BRR_BR_14             ((uint32_t)0x00004000)
N#define GPIO_BRR_BR_15             ((uint32_t)0x00008000)
N
N#define GPIO_BRR_BR0               GPIO_BRR_BR_0 
N#define GPIO_BRR_BR1               GPIO_BRR_BR_1 
N#define GPIO_BRR_BR2               GPIO_BRR_BR_2 
N#define GPIO_BRR_BR3               GPIO_BRR_BR_3 
N#define GPIO_BRR_BR4               GPIO_BRR_BR_4 
N#define GPIO_BRR_BR5               GPIO_BRR_BR_5 
N#define GPIO_BRR_BR6               GPIO_BRR_BR_6 
N#define GPIO_BRR_BR7               GPIO_BRR_BR_7 
N#define GPIO_BRR_BR8               GPIO_BRR_BR_8 
N#define GPIO_BRR_BR9               GPIO_BRR_BR_9 
N#define GPIO_BRR_BR10              GPIO_BRR_BR_10
N#define GPIO_BRR_BR11              GPIO_BRR_BR_11
N#define GPIO_BRR_BR12              GPIO_BRR_BR_12
N#define GPIO_BRR_BR13              GPIO_BRR_BR_13
N#define GPIO_BRR_BR14              GPIO_BRR_BR_14
N#define GPIO_BRR_BR15              GPIO_BRR_BR_15     
N
N/*******************  Bit definition for GPIO_LEDM register  *******************/
N#define	GPIOA_LEDM_LEDM8					((uint32_t)0x00000100)
N#define	GPIOA_LEDM_LEDM9					((uint32_t)0x00000200)
N#define	GPIOA_LEDM_LEDM10					((uint32_t)0x00000400)
N#define	GPIOA_LEDM_LEDM13					((uint32_t)0x00002000)
N#define	GPIOA_LEDM_LEDM14					((uint32_t)0x00004000)
N#define	GPIOA_LEDM_LEDM15					((uint32_t)0x00008000)
N
N
N#define	GPIOB_LEDM_LEDM0					((uint32_t)0x00000001)
N#define	GPIOB_LEDM_LEDM1					((uint32_t)0x00000002)
N#define	GPIOB_LEDM_LEDM3					((uint32_t)0x00000008)
N#define	GPIOB_LEDM_LEDM4					((uint32_t)0x00000010)
N#define	GPIOB_LEDM_LEDM5					((uint32_t)0x00000020)
N#define	GPIOB_LEDM_LEDM6					((uint32_t)0x00000040)
N#define	GPIOB_LEDM_LEDM7					((uint32_t)0x00000080)
N/******************************************************************************/
N/*                                                                            */
N/*                   Inter-integrated Circuit Interface (I2C)                 */
N/*                                                                            */
N/******************************************************************************/
N
N/*******************  Bit definition for I2C_CR1 register  *******************/
N#define  I2C_CR1_PE                          ((uint32_t)0x00000001)        /*!< Peripheral enable */
N#define  I2C_CR1_TXIE                        ((uint32_t)0x00000002)        /*!< TX interrupt enable */
N#define  I2C_CR1_RXIE                        ((uint32_t)0x00000004)        /*!< RX interrupt enable */
N#define  I2C_CR1_ADDRIE                      ((uint32_t)0x00000008)        /*!< Address match interrupt enable */
N#define  I2C_CR1_NACKIE                      ((uint32_t)0x00000010)        /*!< NACK received interrupt enable */
N#define  I2C_CR1_STOPIE                      ((uint32_t)0x00000020)        /*!< STOP detection interrupt enable */
N#define  I2C_CR1_TCIE                        ((uint32_t)0x00000040)        /*!< Transfer complete interrupt enable */
N#define  I2C_CR1_ERRIE                       ((uint32_t)0x00000080)        /*!< Errors interrupt enable */
N#define  I2C_CR1_DFN                         ((uint32_t)0x00000F00)        /*!< Digital noise filter */
N#define  I2C_CR1_ANFOFF                      ((uint32_t)0x00001000)        /*!< Analog noise filter OFF */
N//#define  I2C_CR1_SWRST                       ((uint32_t)0x00002000)        /*!< Software reset */
N#define  I2C_CR1_TXDMAEN                     ((uint32_t)0x00004000)        /*!< DMA transmission requests enable */
N#define  I2C_CR1_RXDMAEN                     ((uint32_t)0x00008000)        /*!< DMA reception requests enable */
N#define  I2C_CR1_SBC                         ((uint32_t)0x00010000)        /*!< Slave byte control */
N#define  I2C_CR1_NOSTRETCH                   ((uint32_t)0x00020000)        /*!< Clock stretching disable */
N#define  I2C_CR1_GCEN                        ((uint32_t)0x00080000)        /*!< General call enable */
N#define  I2C_CR1_SMBHEN                      ((uint32_t)0x00100000)        /*!< SMBus host address enable */
N#define  I2C_CR1_SMBDEN                      ((uint32_t)0x00200000)        /*!< SMBus device default address enable */
N#define  I2C_CR1_ALERTEN                     ((uint32_t)0x00400000)        /*!< SMBus alert enable */
N#define  I2C_CR1_PECEN                       ((uint32_t)0x00800000)        /*!< PEC enable */
N
N/******************  Bit definition for I2C_CR2 register  ********************/
N#define  I2C_CR2_SADD                        ((uint32_t)0x000003FF)        /*!< Slave address (master mode) */
N#define  I2C_CR2_RD_WRN                      ((uint32_t)0x00000400)        /*!< Transfer direction (master mode) */
N#define  I2C_CR2_ADD10                       ((uint32_t)0x00000800)        /*!< 10-bit addressing mode (master mode) */
N#define  I2C_CR2_HEAD10R                     ((uint32_t)0x00001000)        /*!< 10-bit address header only read direction (master mode) */
N#define  I2C_CR2_START                       ((uint32_t)0x00002000)        /*!< START generation */
N#define  I2C_CR2_STOP                        ((uint32_t)0x00004000)        /*!< STOP generation (master mode) */
N#define  I2C_CR2_NACK                        ((uint32_t)0x00008000)        /*!< NACK generation (slave mode) */
N#define  I2C_CR2_NBYTES                      ((uint32_t)0x00FF0000)        /*!< Number of bytes */
N#define  I2C_CR2_RELOAD                      ((uint32_t)0x01000000)        /*!< NBYTES reload mode */
N#define  I2C_CR2_AUTOEND                     ((uint32_t)0x02000000)        /*!< Automatic end mode (master mode) */
N#define  I2C_CR2_PECBYTE                     ((uint32_t)0x04000000)        /*!< Packet error checking byte */
N
N/*******************  Bit definition for I2C_OAR1 register  ******************/
N#define  I2C_OAR1_OA1                        ((uint32_t)0x000003FF)        /*!< Interface own address 1 */
N#define  I2C_OAR1_OA1MODE                    ((uint32_t)0x00000400)        /*!< Own address 1 10-bit mode */
N#define  I2C_OAR1_OA1EN                      ((uint32_t)0x00008000)        /*!< Own address 1 enable */
N
N/*******************  Bit definition for I2C_OAR2 register  ******************/
N#define  I2C_OAR2_OA2                        ((uint32_t)0x000000FE)        /*!< Interface own address 2 */
N#define  I2C_OAR2_OA2MSK                     ((uint32_t)0x00000700)        /*!< Own address 2 masks */
N#define  I2C_OAR2_OA2EN                      ((uint32_t)0x00008000)        /*!< Own address 2 enable */
N
N/*******************  Bit definition for I2C_TIMINGR register *******************/
N#define  I2C_TIMINGR_SCLL                    ((uint32_t)0x000000FF)        /*!< SCL low period (master mode) */
N#define  I2C_TIMINGR_SCLH                    ((uint32_t)0x0000FF00)        /*!< SCL high period (master mode) */
N#define  I2C_TIMINGR_SDADEL                  ((uint32_t)0x000F0000)        /*!< Data hold time */
N#define  I2C_TIMINGR_SCLDEL                  ((uint32_t)0x00F00000)        /*!< Data setup time */
N#define  I2C_TIMINGR_PRESC                   ((uint32_t)0xF0000000)        /*!< Timings prescaler */
N
N/******************* Bit definition for I2C_TIMEOUTR register *******************/
N#define  I2C_TIMEOUTR_TIMEOUTA               ((uint32_t)0x00000FFF)        /*!< Bus timeout A */
N#define  I2C_TIMEOUTR_TIDLE                  ((uint32_t)0x00001000)        /*!< Idle clock timeout detection */
N#define  I2C_TIMEOUTR_TIMOUTEN               ((uint32_t)0x00008000)        /*!< Clock timeout enable */
N#define  I2C_TIMEOUTR_TIMEOUTB               ((uint32_t)0x0FFF0000)        /*!< Bus timeout B*/
N#define  I2C_TIMEOUTR_TEXTEN                 ((uint32_t)0x80000000)        /*!< Extended clock timeout enable */
N
N/******************  Bit definition for I2C_ISR register  *********************/
N#define  I2C_ISR_TXE                         ((uint32_t)0x00000001)        /*!< Transmit data register empty */
N#define  I2C_ISR_TXIS                        ((uint32_t)0x00000002)        /*!< Transmit interrupt status */
N#define  I2C_ISR_RXNE                        ((uint32_t)0x00000004)        /*!< Receive data register not empty */
N#define  I2C_ISR_ADDR                        ((uint32_t)0x00000008)        /*!< Address matched (slave mode)*/
N#define  I2C_ISR_NACKF                       ((uint32_t)0x00000010)        /*!< NACK received flag */
N#define  I2C_ISR_STOPF                       ((uint32_t)0x00000020)        /*!< STOP detection flag */
N#define  I2C_ISR_TC                          ((uint32_t)0x00000040)        /*!< Transfer complete (master mode) */
N#define  I2C_ISR_TCR                         ((uint32_t)0x00000080)        /*!< Transfer complete reload */
N#define  I2C_ISR_BERR                        ((uint32_t)0x00000100)        /*!< Bus error */
N#define  I2C_ISR_ARLO                        ((uint32_t)0x00000200)        /*!< Arbitration lost */
N#define  I2C_ISR_OVR                         ((uint32_t)0x00000400)        /*!< Overrun/Underrun */
N#define  I2C_ISR_PECERR                      ((uint32_t)0x00000800)        /*!< PEC error in reception */
N#define  I2C_ISR_TIMEOUT                     ((uint32_t)0x00001000)        /*!< Timeout or Tlow detection flag */
N#define  I2C_ISR_ALERT                       ((uint32_t)0x00002000)        /*!< SMBus alert */
N#define  I2C_ISR_BUSY                        ((uint32_t)0x00008000)        /*!< Bus busy */
N#define  I2C_ISR_DIR                         ((uint32_t)0x00010000)        /*!< Transfer direction (slave mode) */
N#define  I2C_ISR_ADDCODE                     ((uint32_t)0x00FE0000)        /*!< Address match code (slave mode) */
N
N/******************  Bit definition for I2C_ICR register  *********************/
N#define  I2C_ICR_ADDRCF                      ((uint32_t)0x00000008)        /*!< Address matched clear flag */
N#define  I2C_ICR_NACKCF                      ((uint32_t)0x00000010)        /*!< NACK clear flag */
N#define  I2C_ICR_STOPCF                      ((uint32_t)0x00000020)        /*!< STOP detection clear flag */
N#define  I2C_ICR_BERRCF                      ((uint32_t)0x00000100)        /*!< Bus error clear flag */
N#define  I2C_ICR_ARLOCF                      ((uint32_t)0x00000200)        /*!< Arbitration lost clear flag */
N#define  I2C_ICR_OVRCF                       ((uint32_t)0x00000400)        /*!< Overrun/Underrun clear flag */
N#define  I2C_ICR_PECCF                       ((uint32_t)0x00000800)        /*!< PAC error clear flag */
N#define  I2C_ICR_TIMOUTCF                    ((uint32_t)0x00001000)        /*!< Timeout clear flag */
N#define  I2C_ICR_ALERTCF                     ((uint32_t)0x00002000)        /*!< Alert clear flag */
N
N/******************  Bit definition for I2C_PECR register  *********************/
N#define  I2C_PECR_PEC                        ((uint32_t)0x000000FF)       /*!< PEC register */
N
N/******************  Bit definition for I2C_RXDR register  *********************/
N#define  I2C_RXDR_RXDATA                     ((uint32_t)0x000000FF)        /*!< 8-bit receive data */
N
N/******************  Bit definition for I2C_TXDR register  *********************/
N#define  I2C_TXDR_TXDATA                     ((uint32_t)0x000000FF)        /*!< 8-bit transmit data */
N
N/******************************************************************************/
N/*                                                                            */
N/*                        Independent WATCHDOG (IWDG)                         */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for IWDG_KR register  ********************/
N#define  IWDG_KR_KEY                         ((uint16_t)0xFFFF)            /*!< Key value (write only, read 0000h) */
N
N/*******************  Bit definition for IWDG_PR register  ********************/
N#define  IWDG_PR_PR                          ((uint8_t)0x07)               /*!< PR[2:0] (Prescaler divider) */
N#define  IWDG_PR_PR_0                        ((uint8_t)0x01)               /*!< Bit 0 */
N#define  IWDG_PR_PR_1                        ((uint8_t)0x02)               /*!< Bit 1 */
N#define  IWDG_PR_PR_2                        ((uint8_t)0x04)               /*!< Bit 2 */
N
N/*******************  Bit definition for IWDG_RLR register  *******************/
N#define  IWDG_RLR_RL                         ((uint16_t)0x0FFF)            /*!< Watchdog counter reload value */
N
N/*******************  Bit definition for IWDG_SR register  ********************/
N#define  IWDG_SR_PVU                         ((uint8_t)0x01)               /*!< Watchdog prescaler value update */
N#define  IWDG_SR_RVU                         ((uint8_t)0x02)               /*!< Watchdog counter reload value update */
N#define  IWDG_SR_WVU                         ((uint8_t)0x04)               /*!< Watchdog counter window value update */
N
N/*******************  Bit definition for IWDG_KR register  ********************/
N#define  IWDG_WINR_WIN                         ((uint16_t)0x0FFF)            /*!< Watchdog counter window value */
N
N/******************************************************************************/
N/*                                                                            */
N/*                          Power Control (PWR)                               */
N/*                                                                            */
N/******************************************************************************/
N
N/********************  Bit definition for PWR_CR register  ********************/
N#define  PWR_CR_LPDS                         ((uint16_t)0x0001)     /*!< Low-power deepsleep/sleep */
N#define  PWR_CR_PDDS                         ((uint16_t)0x0002)     /*!< Power Down Deepsleep */
N#define  PWR_CR_CWUF                         ((uint16_t)0x0004)     /*!< Clear Wakeup Flag */
N#define  PWR_CR_CSBF                         ((uint16_t)0x0008)     /*!< Clear Standby Flag */
N#define  PWR_CR_PVDE                         ((uint16_t)0x0010)     /*!< Power Voltage Detector Enable */
N
N#define  PWR_CR_PLS                          ((uint16_t)0x02E0)     /*!< PLS[3] PLS[2:0] bits (PVD Level Selection) */
N#define  PWR_CR_PLS_0                        ((uint16_t)0x0020)     /*!< Bit 0 */
N#define  PWR_CR_PLS_1                        ((uint16_t)0x0040)     /*!< Bit 1 */
N#define  PWR_CR_PLS_2                        ((uint16_t)0x0080)     /*!< Bit 2 */
N#define  PWR_CR_PLS_3                        ((uint16_t)0x0200)     /*!< Bit 3 */
N#define  PWR_CR_DBP                          ((uint16_t)0x0100)     /*!<       */
N
N/* PVD level configuration */
N#define  PWR_CR_PLS_LEV0                     ((uint16_t)0x0000)     /*!< PVD level 0 */
N#define  PWR_CR_PLS_LEV1                     ((uint16_t)0x0020)     /*!< PVD level 1 */
N#define  PWR_CR_PLS_LEV2                     ((uint16_t)0x0040)     /*!< PVD level 2 */
N#define  PWR_CR_PLS_LEV3                     ((uint16_t)0x0060)     /*!< PVD level 3 */
N#define  PWR_CR_PLS_LEV4                     ((uint16_t)0x0080)     /*!< PVD level 4 */
N#define  PWR_CR_PLS_LEV5                     ((uint16_t)0x00A0)     /*!< PVD level 5 */
N#define  PWR_CR_PLS_LEV6                     ((uint16_t)0x00C0)     /*!< PVD level 6 */
N#define  PWR_CR_PLS_LEV7                     ((uint16_t)0x00E0)     /*!< PVD level 7 */
N#define  PWR_CR_PLS_LEV8                     ((uint16_t)0x0200)     /*!< PVD level 8 */
N#define  PWR_CR_PLS_LEV9                     ((uint16_t)0x0220)     /*!< PVD level 9 */
N#define  PWR_CR_PLS_LEV10                    ((uint16_t)0x0240)     /*!< PVD level 10 */
N#define  PWR_CR_PLS_LEV11                    ((uint16_t)0x0260)     /*!< PVD level 11 */
N#define  PWR_CR_PLS_LEV12                    ((uint16_t)0x0280)     /*!< PVD level 12 */
N#define  PWR_CR_PLS_LEV13                    ((uint16_t)0x02A0)     /*!< PVD level 13 */
N#define  PWR_CR_PLS_LEV14                    ((uint16_t)0x02C0)     /*!< PVD level 14 */
N#define  PWR_CR_PLS_LEV15                    ((uint16_t)0x02E0)     /*!< PVD level 15 */
N
N
N#define  PWR_CR_DBP                          ((uint16_t)0x0100)     /*!< Disable Backup Domain write protection */
N
N/* Old Bit definition maintained for legacy purpose ****/
N#define  PWR_CR_LPSDSR                       PWR_CR_LPDS     /*!< Low-power deepsleep */
N
N/*******************  Bit definition for PWR_CSR register  ********************/
N#define  PWR_CSR_WUF                         ((uint16_t)0x0001)     /*!< Wakeup Flag */
N#define  PWR_CSR_SBF                         ((uint16_t)0x0002)     /*!< Standby Flag */
N#define  PWR_CSR_PVDO                        ((uint16_t)0x0004)     /*!< PVD Output */
N//#define  PWR_CSR_VREFINTRDY                  ((uint16_t)0x0008)     /*!< Internal voltage reference (VREFINT) ready */
N
N#define  PWR_CSR_EWUP1                       ((uint16_t)0x0100)     /*!< Enable WKUP pin 1 */
N#define  PWR_CSR_EWUP2                       ((uint16_t)0x0200)     /*!< Enable WKUP pin 2 */
N//#define  PWR_CSR_EWUP3                       ((uint16_t)0x0400)     /*!< Enable WKUP pin 3 */
N//#define  PWR_CSR_EWUP4                       ((uint16_t)0x0800)     /*!< Enable WKUP pin 4 */
N//#define  PWR_CSR_EWUP5                       ((uint16_t)0x1000)     /*!< Enable WKUP pin 5 */
N//#define  PWR_CSR_EWUP6                       ((uint16_t)0x2000)     /*!< Enable WKUP pin 6 */
N//#define  PWR_CSR_EWUP7                       ((uint16_t)0x4000)     /*!< Enable WKUP pin 7 */
N//#define  PWR_CSR_EWUP8                       ((uint16_t)0x8000)     /*!< Enable WKUP pin 8 */
N
N/* Old Bit definition maintained for legacy purpose ****/
N//#define  PWR_CSR_VREFINTRDYF                 PWR_CSR_VREFINTRDY     /*!< Internal voltage reference (VREFINT) ready flag */
N/******************************************************************************/
N/*                                                                            */
N/*                         Reset and Clock Control                            */
N/*                                                                            */
N/******************************************************************************/
N
N/********************  Bit definition for RCC_CR register  ********************/
N#define  RCC_CR_HSION                        ((uint32_t)0x00000001)        /*!< Internal High Speed clock enable */
N#define  RCC_CR_HSIRDY                       ((uint32_t)0x00000002)        /*!< Internal High Speed clock ready flag */
N#define  RCC_CR_HSITRIM                      ((uint32_t)0x000000F8)        /*!< Internal High Speed clock trimming */
N#define  RCC_CR_HSICAL                       ((uint32_t)0x0000FF00)        /*!< Internal High Speed clock Calibration */
N#define  RCC_CR_HSEON                        ((uint32_t)0x00010000)        /*!< External High Speed clock enable */
N#define  RCC_CR_HSERDY                       ((uint32_t)0x00020000)        /*!< External High Speed clock ready flag */
N#define  RCC_CR_HSEBYP                       ((uint32_t)0x00040000)        /*!< External High Speed clock Bypass */
N#define  RCC_CR_CSSON                        ((uint32_t)0x00080000)        /*!< Clock Security System enable */
N#define  RCC_CR_PLLON                        ((uint32_t)0x01000000)        /*!< PLL enable */
N#define  RCC_CR_PLLRDY                       ((uint32_t)0x02000000)        /*!< PLL clock ready flag */
N
N/*******************  Bit definition for RCC_CFGR register  *******************/
N#define  RCC_CFGR_SW                         ((uint32_t)0x00000003)        /*!< SW[1:0] bits (System clock Switch) */
N#define  RCC_CFGR_SW_0                       ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  RCC_CFGR_SW_1                       ((uint32_t)0x00000002)        /*!< Bit 1 */
N/* SW configuration */
N#define  RCC_CFGR_SW_HSI                     ((uint32_t)0x00000000)        /*!< HSI selected as system clock */
N#define  RCC_CFGR_SW_HSE                     ((uint32_t)0x00000001)        /*!< HSE selected as system clock */
N#define  RCC_CFGR_SW_PLL                     ((uint32_t)0x00000002)        /*!< PLL selected as system clock */
N#define  RCC_CFGR_SW_HSI48                   ((uint32_t)0x00000003)        /*!< HSI48 selected as system clock */
N
N#define  RCC_CFGR_SWS                        ((uint32_t)0x0000000C)        /*!< SWS[1:0] bits (System Clock Switch Status) */
N#define  RCC_CFGR_SWS_0                      ((uint32_t)0x00000004)        /*!< Bit 0 */
N#define  RCC_CFGR_SWS_1                      ((uint32_t)0x00000008)        /*!< Bit 1 */
N/* SWS configuration */
N#define  RCC_CFGR_SWS_HSI                    ((uint32_t)0x00000000)        /*!< HSI oscillator used as system clock */
N#define  RCC_CFGR_SWS_HSE                    ((uint32_t)0x00000004)        /*!< HSE oscillator used as system clock */
N#define  RCC_CFGR_SWS_PLL                    ((uint32_t)0x00000008)        /*!< PLL used as system clock */
N#define  RCC_CFGR_SWS_HSI48                  ((uint32_t)0x0000000C)        /*!< HSI48 used as system clock */
N
N#define  RCC_CFGR_HPRE                       ((uint32_t)0x000000F0)        /*!< HPRE[3:0] bits (AHB prescaler) */
N#define  RCC_CFGR_HPRE_0                     ((uint32_t)0x00000010)        /*!< Bit 0 */
N#define  RCC_CFGR_HPRE_1                     ((uint32_t)0x00000020)        /*!< Bit 1 */
N#define  RCC_CFGR_HPRE_2                     ((uint32_t)0x00000040)        /*!< Bit 2 */
N#define  RCC_CFGR_HPRE_3                     ((uint32_t)0x00000080)        /*!< Bit 3 */
N/* HPRE configuration */
N#define  RCC_CFGR_HPRE_DIV1                  ((uint32_t)0x00000000)        /*!< SYSCLK not divided */
N#define  RCC_CFGR_HPRE_DIV2                  ((uint32_t)0x00000080)        /*!< SYSCLK divided by 2 */
N#define  RCC_CFGR_HPRE_DIV4                  ((uint32_t)0x00000090)        /*!< SYSCLK divided by 4 */
N#define  RCC_CFGR_HPRE_DIV8                  ((uint32_t)0x000000A0)        /*!< SYSCLK divided by 8 */
N#define  RCC_CFGR_HPRE_DIV16                 ((uint32_t)0x000000B0)        /*!< SYSCLK divided by 16 */
N#define  RCC_CFGR_HPRE_DIV64                 ((uint32_t)0x000000C0)        /*!< SYSCLK divided by 64 */
N#define  RCC_CFGR_HPRE_DIV128                ((uint32_t)0x000000D0)        /*!< SYSCLK divided by 128 */
N#define  RCC_CFGR_HPRE_DIV256                ((uint32_t)0x000000E0)        /*!< SYSCLK divided by 256 */
N#define  RCC_CFGR_HPRE_DIV512                ((uint32_t)0x000000F0)        /*!< SYSCLK divided by 512 */
N
N#define  RCC_CFGR_PPRE                       ((uint32_t)0x00000700)        /*!< PRE[2:0] bits (APB prescaler) */
N#define  RCC_CFGR_PPRE_0                     ((uint32_t)0x00000100)        /*!< Bit 0 */
N#define  RCC_CFGR_PPRE_1                     ((uint32_t)0x00000200)        /*!< Bit 1 */
N#define  RCC_CFGR_PPRE_2                     ((uint32_t)0x00000400)        /*!< Bit 2 */
N/* PPRE configuration */
N#define  RCC_CFGR_PPRE_DIV1                  ((uint32_t)0x00000000)        /*!< HCLK not divided */
N#define  RCC_CFGR_PPRE_DIV2                  ((uint32_t)0x00000400)        /*!< HCLK divided by 2 */
N#define  RCC_CFGR_PPRE_DIV4                  ((uint32_t)0x00000500)        /*!< HCLK divided by 4 */
N#define  RCC_CFGR_PPRE_DIV8                  ((uint32_t)0x00000600)        /*!< HCLK divided by 8 */
N#define  RCC_CFGR_PPRE_DIV16                 ((uint32_t)0x00000700)        /*!< HCLK divided by 16 */
N
N#define  RCC_CFGR_ADCPRE                     ((uint32_t)0x00004000)        /*!< ADC prescaler: Obsolete. Proper ADC clock selection is 
N                                                                                done inside the ADC_CFGR2 */
N
N#define  RCC_CFGR_PLLSRC                     ((uint32_t)0x00018000)        /*!< PLL entry clock source */
N#define  RCC_CFGR_PLLSRC_0                   ((uint32_t)0x00008000)        /*!< Bit 0 (available only in the FT32F072X8 devices) */
N#define  RCC_CFGR_PLLSRC_1                   ((uint32_t)0x00010000)        /*!< Bit 1 */
N
N#define  RCC_CFGR_PLLSRC_PREDIV1             ((uint32_t)0x00010000)        /*!< PREDIV1 clock selected as PLL entry clock source; 
N                                                                                Old PREDIV1 bit definition, maintained for legacy purpose */
N#define  RCC_CFGR_PLLSRC_HSI_DIV2            ((uint32_t)0x00000000)        /*!< HSI clock divided by 2 selected as PLL entry clock source */
N#define  RCC_CFGR_PLLSRC_HSI_PREDIV          ((uint32_t)0x00008000)        /*!< HSI PREDIV clock selected as PLL entry clock source 
N                                                                                (This bit and configuration is only available for FT32F072X8 devices)*/
N#define  RCC_CFGR_PLLSRC_HSE_PREDIV          ((uint32_t)0x00010000)        /*!< HSE PREDIV clock selected as PLL entry clock source */
N#define  RCC_CFGR_PLLSRC_HSI48_PREDIV        ((uint32_t)0x00018000)        /*!< HSI48 PREDIV clock selected as PLL entry clock source */
N
N#define  RCC_CFGR_PLLXTPRE                   ((uint32_t)0x00020000)        /*!< HSE divider for PLL entry */
N#define  RCC_CFGR_PLLXTPRE_PREDIV1           ((uint32_t)0x00000000)        /*!< PREDIV1 clock not divided for PLL entry */
N#define  RCC_CFGR_PLLXTPRE_PREDIV1_Div2      ((uint32_t)0x00020000)        /*!< PREDIV1 clock divided by 2 for PLL entry */
N
N/*!< Old bit definition maintained for legacy purposes */
N#define  RCC_CFGR_PLLSRC_HSI_Div2            RCC_CFGR_PLLSRC_HSI_DIV2
N
N/* PLLMUL configuration */
N#define  RCC_CFGR_PLLMUL                    ((uint32_t)0x003C0000)        /*!< PLLMUL[3:0] bits (PLL multiplication factor) */
N#define  RCC_CFGR_PLLMUL_0                  ((uint32_t)0x00040000)        /*!< Bit 0 */
N#define  RCC_CFGR_PLLMUL_1                  ((uint32_t)0x00080000)        /*!< Bit 1 */
N#define  RCC_CFGR_PLLMUL_2                  ((uint32_t)0x00100000)        /*!< Bit 2 */
N#define  RCC_CFGR_PLLMUL_3                  ((uint32_t)0x00200000)        /*!< Bit 3 */
N
N#define  RCC_CFGR_PLLMUL2                   ((uint32_t)0x00000000)        /*!< PLL input clock*2 */
N#define  RCC_CFGR_PLLMUL3                   ((uint32_t)0x00040000)        /*!< PLL input clock*3 */
N#define  RCC_CFGR_PLLMUL4                   ((uint32_t)0x00080000)        /*!< PLL input clock*4 */
N#define  RCC_CFGR_PLLMUL5                   ((uint32_t)0x000C0000)        /*!< PLL input clock*5 */
N#define  RCC_CFGR_PLLMUL6                   ((uint32_t)0x00100000)        /*!< PLL input clock*6 */
N#define  RCC_CFGR_PLLMUL7                   ((uint32_t)0x00140000)        /*!< PLL input clock*7 */
N#define  RCC_CFGR_PLLMUL8                   ((uint32_t)0x00180000)        /*!< PLL input clock*8 */
N#define  RCC_CFGR_PLLMUL9                   ((uint32_t)0x001C0000)        /*!< PLL input clock*9 */
N#define  RCC_CFGR_PLLMUL10                  ((uint32_t)0x00200000)        /*!< PLL input clock10 */
N#define  RCC_CFGR_PLLMUL11                  ((uint32_t)0x00240000)        /*!< PLL input clock*11 */
N#define  RCC_CFGR_PLLMUL12                  ((uint32_t)0x00280000)        /*!< PLL input clock*12 */
N#define  RCC_CFGR_PLLMUL13                  ((uint32_t)0x002C0000)        /*!< PLL input clock*13 */
N#define  RCC_CFGR_PLLMUL14                  ((uint32_t)0x00300000)        /*!< PLL input clock*14 */
N#define  RCC_CFGR_PLLMUL15                  ((uint32_t)0x00340000)        /*!< PLL input clock*15 */
N#define  RCC_CFGR_PLLMUL16                  ((uint32_t)0x00380000)        /*!< PLL input clock*16 */
N
N/* Old PLLMUL configuration bit definition maintained for legacy purposes */
N#define  RCC_CFGR_PLLMULL                    RCC_CFGR_PLLMUL        /*!< PLLMUL[3:0] bits (PLL multiplication factor) */
N#define  RCC_CFGR_PLLMULL_0                  RCC_CFGR_PLLMUL_0        /*!< Bit 0 */
N#define  RCC_CFGR_PLLMULL_1                  RCC_CFGR_PLLMUL_1        /*!< Bit 1 */
N#define  RCC_CFGR_PLLMULL_2                  RCC_CFGR_PLLMUL_2        /*!< Bit 2 */
N#define  RCC_CFGR_PLLMULL_3                  RCC_CFGR_PLLMUL_3       /*!< Bit 3 */
N
N#define  RCC_CFGR_PLLMULL2                   RCC_CFGR_PLLMUL2       /*!< PLL input clock*2 */
N#define  RCC_CFGR_PLLMULL3                   RCC_CFGR_PLLMUL3        /*!< PLL input clock*3 */
N#define  RCC_CFGR_PLLMULL4                   RCC_CFGR_PLLMUL4        /*!< PLL input clock*4 */
N#define  RCC_CFGR_PLLMULL5                   RCC_CFGR_PLLMUL5        /*!< PLL input clock*5 */
N#define  RCC_CFGR_PLLMULL6                   RCC_CFGR_PLLMUL6        /*!< PLL input clock*6 */
N#define  RCC_CFGR_PLLMULL7                   RCC_CFGR_PLLMUL7        /*!< PLL input clock*7 */
N#define  RCC_CFGR_PLLMULL8                   RCC_CFGR_PLLMUL8        /*!< PLL input clock*8 */
N#define  RCC_CFGR_PLLMULL9                   RCC_CFGR_PLLMUL9        /*!< PLL input clock*9 */
N#define  RCC_CFGR_PLLMULL10                  RCC_CFGR_PLLMUL10        /*!< PLL input clock10 */
N#define  RCC_CFGR_PLLMULL11                  RCC_CFGR_PLLMUL11        /*!< PLL input clock*11 */
N#define  RCC_CFGR_PLLMULL12                  RCC_CFGR_PLLMUL12        /*!< PLL input clock*12 */
N#define  RCC_CFGR_PLLMULL13                  RCC_CFGR_PLLMUL13        /*!< PLL input clock*13 */
N#define  RCC_CFGR_PLLMULL14                  RCC_CFGR_PLLMUL14        /*!< PLL input clock*14 */
N#define  RCC_CFGR_PLLMULL15                  RCC_CFGR_PLLMUL15        /*!< PLL input clock*15 */
N#define  RCC_CFGR_PLLMULL16                  RCC_CFGR_PLLMUL16        /*!< PLL input clock*16 */
N
N#define  RCC_CFGR_MCO                        ((uint32_t)0x0F000000)        /*!< MCO[2:0] bits (Microcontroller Clock Output) */
N#define  RCC_CFGR_MCO_0                      ((uint32_t)0x01000000)        /*!< Bit 0 */
N#define  RCC_CFGR_MCO_1                      ((uint32_t)0x02000000)        /*!< Bit 1 */
N#define  RCC_CFGR_MCO_2                      ((uint32_t)0x04000000)        /*!< Bit 2 */
N#define  RCC_CFGR_MCO_3                      ((uint32_t)0x08000000)        /*!< Bit 3 */
N/* MCO configuration */
N#define  RCC_CFGR_MCO_NOCLOCK                ((uint32_t)0x00000000)        /*!< No clock */
N#define  RCC_CFGR_MCO_HSI14                  ((uint32_t)0x01000000)        /*!< HSI14 clock selected as MCO source */
N#define  RCC_CFGR_MCO_LSI                    ((uint32_t)0x02000000)        /*!< LSI clock selected as MCO source */
N#define  RCC_CFGR_MCO_LSE                    ((uint32_t)0x03000000)        /*!< LSE clock selected as MCO source */
N#define  RCC_CFGR_MCO_SYSCLK                 ((uint32_t)0x04000000)        /*!< System clock selected as MCO source */
N#define  RCC_CFGR_MCO_HSI                    ((uint32_t)0x05000000)        /*!< HSI clock selected as MCO source */
N#define  RCC_CFGR_MCO_HSE                    ((uint32_t)0x06000000)        /*!< HSE clock selected as MCO source  */
N#define  RCC_CFGR_MCO_PLL                    ((uint32_t)0x07000000)        /*!< PLL clock selected as MCO source */
N#define  RCC_CFGR_MCO_HSI48                  ((uint32_t)0x08000000)        /*!< HSI48 clock selected as MCO source */
N
N#define  RCC_CFGR_MCO_PRE                    ((uint32_t)0x70000000)        /*!< MCO prescaler*/
N#define  RCC_CFGR_MCO_PRE_1                  ((uint32_t)0x00000000)        /*!< MCO is divided by 1*/
N#define  RCC_CFGR_MCO_PRE_2                  ((uint32_t)0x10000000)        /*!< MCO is divided by 2*/
N#define  RCC_CFGR_MCO_PRE_4                  ((uint32_t)0x20000000)        /*!< MCO is divided by 4*/
N#define  RCC_CFGR_MCO_PRE_8                  ((uint32_t)0x30000000)        /*!< MCO is divided by 8*/
N#define  RCC_CFGR_MCO_PRE_16                 ((uint32_t)0x40000000)        /*!< MCO is divided by 16*/
N#define  RCC_CFGR_MCO_PRE_32                 ((uint32_t)0x50000000)        /*!< MCO is divided by 32*/
N#define  RCC_CFGR_MCO_PRE_64                 ((uint32_t)0x60000000)        /*!< MCO is divided by 64*/
N#define  RCC_CFGR_MCO_PRE_128                ((uint32_t)0x70000000)        /*!< MCO is divided by 128*/
N
N#define  RCC_CFGR_MCOPRE                     RCC_CFGR_MCO_PRE            /*!< MCO prescaler*/
N#define  RCC_CFGR_MCOPRE_1                   RCC_CFGR_MCO_PRE_1          /*!< MCO is divided by 1*/
N#define  RCC_CFGR_MCOPRE_2                   RCC_CFGR_MCO_PRE_2          /*!< MCO is divided by 2*/
N#define  RCC_CFGR_MCOPRE_4                   RCC_CFGR_MCO_PRE_4          /*!< MCO is divided by 4*/
N#define  RCC_CFGR_MCOPRE_8                   RCC_CFGR_MCO_PRE_8          /*!< MCO is divided by 8*/
N#define  RCC_CFGR_MCOPRE_16                  RCC_CFGR_MCO_PRE_16         /*!< MCO is divided by 16*/
N#define  RCC_CFGR_MCOPRE_32                  RCC_CFGR_MCO_PRE_32         /*!< MCO is divided by 32*/
N#define  RCC_CFGR_MCOPRE_64                  RCC_CFGR_MCO_PRE_64         /*!< MCO is divided by 64*/
N#define  RCC_CFGR_MCOPRE_128                 RCC_CFGR_MCO_PRE_128        /*!< MCO is divided by 128*/
N
N#define  RCC_CFGR_PLLNODIV                   ((uint32_t)0x80000000)        /*!< PLL is not divided to MCO */
N
N/*******************  Bit definition for RCC_CIR register  ********************/
N#define  RCC_CIR_LSIRDYF                     ((uint32_t)0x00000001)        /*!< LSI Ready Interrupt flag */
N#define  RCC_CIR_LSERDYF                     ((uint32_t)0x00000002)        /*!< LSE Ready Interrupt flag */
N#define  RCC_CIR_HSIRDYF                     ((uint32_t)0x00000004)        /*!< HSI Ready Interrupt flag */
N#define  RCC_CIR_HSERDYF                     ((uint32_t)0x00000008)        /*!< HSE Ready Interrupt flag */
N#define  RCC_CIR_PLLRDYF                     ((uint32_t)0x00000010)        /*!< PLL Ready Interrupt flag */
N#define  RCC_CIR_HSI14RDYF                   ((uint32_t)0x00000020)        /*!< HSI14 Ready Interrupt flag */
N//#define  RCC_CIR_HSI48RDYF                   ((uint32_t)0x00000040)        /*!< HSI48 Ready Interrupt flag */
N#define  RCC_CIR_CSSF                        ((uint32_t)0x00000080)        /*!< Clock Security System Interrupt flag */
N#define  RCC_CIR_LSIRDYIE                    ((uint32_t)0x00000100)        /*!< LSI Ready Interrupt Enable */
N#define  RCC_CIR_LSERDYIE                    ((uint32_t)0x00000200)        /*!< LSE Ready Interrupt Enable */
N#define  RCC_CIR_HSIRDYIE                    ((uint32_t)0x00000400)        /*!< HSI Ready Interrupt Enable */
N#define  RCC_CIR_HSERDYIE                    ((uint32_t)0x00000800)        /*!< HSE Ready Interrupt Enable */
N#define  RCC_CIR_PLLRDYIE                    ((uint32_t)0x00001000)        /*!< PLL Ready Interrupt Enable */
N#define  RCC_CIR_HSI14RDYIE                  ((uint32_t)0x00002000)        /*!< HSI14 Ready Interrupt Enable */
N#define  RCC_CIR_HSI48RDYIE                  ((uint32_t)0x00004000)        /*!< HSI48 Ready Interrupt Enable */
N#define  RCC_CIR_LSIRDYC                     ((uint32_t)0x00010000)        /*!< LSI Ready Interrupt Clear */
N#define  RCC_CIR_LSERDYC                     ((uint32_t)0x00020000)        /*!< LSE Ready Interrupt Clear */
N#define  RCC_CIR_HSIRDYC                     ((uint32_t)0x00040000)        /*!< HSI Ready Interrupt Clear */
N#define  RCC_CIR_HSERDYC                     ((uint32_t)0x00080000)        /*!< HSE Ready Interrupt Clear */
N#define  RCC_CIR_PLLRDYC                     ((uint32_t)0x00100000)        /*!< PLL Ready Interrupt Clear */
N#define  RCC_CIR_HSI14RDYC                   ((uint32_t)0x00200000)        /*!< HSI14 Ready Interrupt Clear */
N#define  RCC_CIR_HSI48RDYC                   ((uint32_t)0x00400000)        /*!< HSI48 Ready Interrupt Clear */
N#define  RCC_CIR_CSSC                        ((uint32_t)0x00800000)        /*!< Clock Security System Interrupt Clear */
N
N/*****************  Bit definition for RCC_APB2RSTR register  *****************/
N#define  RCC_APB2RSTR_SYSCFGRST              ((uint32_t)0x00000001)        /*!< SYSCFG clock reset */
N//#define  RCC_APB2RSTR_USART8RST              ((uint32_t)0x00000080)        /*!< USART8 clock reset */
N//#define  RCC_APB2RSTR_USART7RST              ((uint32_t)0x00000040)        /*!< USART7 clock reset */
N//#define  RCC_APB2RSTR_USART6RST              ((uint32_t)0x00000020)        /*!< USART6 clock reset */
N#define  RCC_APB2RSTR_ADCRST                 ((uint32_t)0x00000200)        /*!< ADC clock reset */
N#define  RCC_APB2RSTR_TIM1RST                ((uint32_t)0x00000800)        /*!< TIM1 clock reset */
N#define  RCC_APB2RSTR_SPI1RST                ((uint32_t)0x00001000)        /*!< SPI1 clock reset */
N#define  RCC_APB2RSTR_USART1RST              ((uint32_t)0x00004000)        /*!< USART1 clock reset */
N#define  RCC_APB2RSTR_TIM15RST               ((uint32_t)0x00010000)        /*!< TIM15 clock reset */
N#define  RCC_APB2RSTR_TIM16RST               ((uint32_t)0x00020000)        /*!< TIM16 clock reset */
N#define  RCC_APB2RSTR_TIM17RST               ((uint32_t)0x00040000)        /*!< TIM17 clock reset */
N#define  RCC_APB2RSTR_DBGMCURST              ((uint32_t)0x00400000)        /*!< DBGMCU clock reset */
N
N/* Old ADC1 clock reset bit definition maintained for legacy purpose */
N#define  RCC_APB2RSTR_ADC1RST                RCC_APB2RSTR_ADCRST          
N
N/*****************  Bit definition for RCC_APB1RSTR register  *****************/
N//#define  RCC_APB1RSTR_TIM2RST                ((uint32_t)0x00000001)        /*!< Timer 2 clock reset */
N#define  RCC_APB1RSTR_TIM3RST                ((uint32_t)0x00000002)        /*!< Timer 3 clock reset */
N#define  RCC_APB1RSTR_TIM6RST                ((uint32_t)0x00000010)        /*!< Timer 6 clock reset */
N//#define  RCC_APB1RSTR_TIM7RST                ((uint32_t)0x00000020)        /*!< Timer 7 clock reset */
N#define  RCC_APB1RSTR_TIM14RST               ((uint32_t)0x00000100)        /*!< Timer 14 clock reset */
N#define  RCC_APB1RSTR_WWDGRST                ((uint32_t)0x00000800)        /*!< Window Watchdog clock reset */
N#define  RCC_APB1RSTR_SPI2RST                ((uint32_t)0x00004000)        /*!< SPI2 clock reset */
N#define  RCC_APB1RSTR_USART2RST              ((uint32_t)0x00020000)        /*!< USART 2 clock reset */
N//#define  RCC_APB1RSTR_USART3RST              ((uint32_t)0x00040000)        /*!< USART 3 clock reset */
N//#define  RCC_APB1RSTR_USART4RST              ((uint32_t)0x00080000)        /*!< USART 4 clock reset */
N//#define  RCC_APB1RSTR_USART5RST              ((uint32_t)0x00100000)        /*!< USART 5 clock reset */
N#define  RCC_APB1RSTR_I2C1RST                ((uint32_t)0x00200000)        /*!< I2C 1 clock reset */
N#define  RCC_APB1RSTR_I2C2RST                ((uint32_t)0x00400000)        /*!< I2C 2 clock reset */
N#define  RCC_APB1RSTR_USBRST                 ((uint32_t)0x00800000)        /*!< USB clock reset */
N//#define  RCC_APB1RSTR_CANRST                 ((uint32_t)0x02000000)        /*!< CAN clock reset */
N#define  RCC_APB1RSTR_CRSRST                 ((uint32_t)0x08000000)        /*!< CRS clock reset */
N#define  RCC_APB1RSTR_PWRRST                 ((uint32_t)0x10000000)        /*!< PWR clock reset */
N//#define  RCC_APB1RSTR_DACRST                 ((uint32_t)0x20000000)        /*!< DAC clock reset */
N//#define  RCC_APB1RSTR_CECRST                 ((uint32_t)0x40000000)        /*!< CEC clock reset */
N
N/******************  Bit definition for RCC_AHBENR register  ******************/
N#define  RCC_AHBENR_DMAEN                    ((uint32_t)0x00000001)        /*!< DMA clock enable */
N//#define  RCC_AHBENR_DMA2EN                   ((uint32_t)0x00000002)        /*!< DMA2 clock enable */
N#define  RCC_AHBENR_SRAMEN                   ((uint32_t)0x00000004)        /*!< SRAM interface clock enable */
N//#define  RCC_AHBENR_FLITFEN                  ((uint32_t)0x00000010)        /*!< FLITF clock enable */
N#define  RCC_AHBENR_CRCEN                    ((uint32_t)0x00000040)        /*!< CRC clock enable */
N#define  RCC_AHBENR_GPIOAEN                  ((uint32_t)0x00020000)        /*!< GPIOA clock enable */
N#define  RCC_AHBENR_GPIOBEN                  ((uint32_t)0x00040000)        /*!< GPIOB clock enable */
N#define  RCC_AHBENR_GPIOCEN                  ((uint32_t)0x00080000)        /*!< GPIOC clock enable */
N#define  RCC_AHBENR_GPIODEN                  ((uint32_t)0x00100000)        /*!< GPIOD clock enable */
N//#define  RCC_AHBENR_GPIOEEN                  ((uint32_t)0x00200000)        /*!< GPIOE clock enable */
N#define  RCC_AHBENR_GPIOFEN                  ((uint32_t)0x00400000)        /*!< GPIOF clock enable */
N#define  RCC_AHBENR_TSCEN                    ((uint32_t)0x01000000)        /*!< TS controller clock enable */
N
N#define  RCC_AHBENR_IOPAEN                  RCC_AHBENR_GPIOAEN          /*!< GPIOA clock enable */
N#define  RCC_AHBENR_IOPBEN                  RCC_AHBENR_GPIOBEN          /*!< GPIOB clock enable */
N#define  RCC_AHBENR_IOPCEN                  RCC_AHBENR_GPIOCEN          /*!< GPIOC clock enable */
N#define  RCC_AHBENR_IOPDEN                  RCC_AHBENR_GPIODEN          /*!< GPIOD clock enable */
N                                              
N#define  RCC_AHBENR_IOPFEN                  RCC_AHBENR_GPIOFEN          /*!< GPIOF clock enable */
N/* Old Bit definition maintained for legacy purpose */
N#define  RCC_AHBENR_DMA1EN                   RCC_AHBENR_DMAEN        /*!< DMA1 clock enable */
N#define  RCC_AHBENR_TSEN                     RCC_AHBENR_TSCEN        /*!< TS clock enable */
N
N/*****************  Bit definition for RCC_APB2ENR register  ******************/
N#define  RCC_APB2ENR_SYSCFGCOMPEN            ((uint32_t)0x00000001)        /*!< SYSCFG and comparator clock enable */
N//#define  RCC_APB2ENR_USART6EN                ((uint32_t)0x00000020)        /*!< USART6 clock enable */
N//#define  RCC_APB2ENR_USART7EN                ((uint32_t)0x00000040)        /*!< USART7 clock enable */
N//#define  RCC_APB2ENR_USART8EN                ((uint32_t)0x00000080)        /*!< USART8 clock enable */
N#define  RCC_APB2ENR_ADCEN                   ((uint32_t)0x00000200)        /*!< ADC1 clock enable */
N#define  RCC_APB2ENR_TIM1EN                  ((uint32_t)0x00000800)        /*!< TIM1 clock enable */
N#define  RCC_APB2ENR_SPI1EN                  ((uint32_t)0x00001000)        /*!< SPI1 clock enable */
N#define  RCC_APB2ENR_USART1EN                ((uint32_t)0x00004000)        /*!< USART1 clock enable */
N#define  RCC_APB2ENR_TIM15EN                 ((uint32_t)0x00010000)        /*!< TIM15 clock enable */
N#define  RCC_APB2ENR_TIM16EN                 ((uint32_t)0x00020000)        /*!< TIM16 clock enable */
N#define  RCC_APB2ENR_TIM17EN                 ((uint32_t)0x00040000)        /*!< TIM17 clock enable */
N#define  RCC_APB2ENR_DBGMCUEN                ((uint32_t)0x00400000)        /*!< DBGMCU clock enable */
N
N/* Old Bit definition maintained for legacy purpose */
N#define  RCC_APB2ENR_SYSCFGEN                RCC_APB2ENR_SYSCFGCOMPEN        /*!< SYSCFG clock enable */
N#define  RCC_APB2ENR_ADC1EN                  RCC_APB2ENR_ADCEN               /*!< ADC1 clock enable */
N
N/*****************  Bit definition for RCC_APB1ENR register  ******************/
N//#define  RCC_APB1ENR_TIM2EN                  ((uint32_t)0x00000001)        /*!< Timer 2 clock enable */
N#define  RCC_APB1ENR_TIM3EN                  ((uint32_t)0x00000002)        /*!< Timer 3 clock enable */
N#define  RCC_APB1ENR_TIM6EN                  ((uint32_t)0x00000010)        /*!< Timer 6 clock enable */
N//#define  RCC_APB1ENR_TIM7EN                  ((uint32_t)0x00000020)        /*!< Timer 7 clock enable */
N#define  RCC_APB1ENR_TIM14EN                 ((uint32_t)0x00000100)        /*!< Timer 14 clock enable */
N#define  RCC_APB1ENR_WWDGEN                  ((uint32_t)0x00000800)        /*!< Window Watchdog clock enable */
N#define  RCC_APB1ENR_SPI2EN                  ((uint32_t)0x00004000)        /*!< SPI2 clock enable */
N#define  RCC_APB1ENR_USART2EN                ((uint32_t)0x00020000)        /*!< USART2 clock enable */
N//#define  RCC_APB1ENR_USART3EN                ((uint32_t)0x00040000)        /*!< USART3 clock enable */
N//#define  RCC_APB1ENR_USART4EN                ((uint32_t)0x00080000)        /*!< USART4 clock enable */
N//#define  RCC_APB1ENR_USART5EN                ((uint32_t)0x00100000)        /*!< USART5 clock enable */
N#define  RCC_APB1ENR_I2C1EN                  ((uint32_t)0x00200000)        /*!< I2C1 clock enable */
N#define  RCC_APB1ENR_I2C2EN                  ((uint32_t)0x00400000)        /*!< I2C2 clock enable */
N#define  RCC_APB1ENR_USBEN                   ((uint32_t)0x00800000)        /*!< USB clock enable */
N//#define  RCC_APB1ENR_CANEN                   ((uint32_t)0x02000000)         /*!< CAN clock enable */
N#define  RCC_APB1ENR_CRSEN                   ((uint32_t)0x08000000)        /*!< CRS clock enable */
N#define  RCC_APB1ENR_PWREN                   ((uint32_t)0x10000000)        /*!< PWR clock enable */
N//#define  RCC_APB1ENR_DACEN                   ((uint32_t)0x20000000)        /*!< DAC clock enable */
N//#define  RCC_APB1ENR_CECEN                   ((uint32_t)0x40000000)        /*!< CEC clock enable */
N
N/*******************  Bit definition for RCC_BDCR register  *******************/
N#define  RCC_BDCR_LSEON                      ((uint32_t)0x00000001)        /*!< External Low Speed oscillator enable */
N#define  RCC_BDCR_LSERDY                     ((uint32_t)0x00000002)        /*!< External Low Speed oscillator Ready */
N#define  RCC_BDCR_LSEBYP                     ((uint32_t)0x00000004)        /*!< External Low Speed oscillator Bypass */
N
N#define  RCC_BDCR_LSEDRV                     ((uint32_t)0x00000038)        /*!< LSEDRV[1:0] bits (LSE Osc. drive capability) */
N#define  RCC_BDCR_LSEDRV_0                   ((uint32_t)0x00000008)        /*!< Bit 0 */
N#define  RCC_BDCR_LSEDRV_1                   ((uint32_t)0x00000010)        /*!< Bit 1 */
N#define  RCC_BDCR_LSEDRV_2                   ((uint32_t)0x00000020)        /*!< Bit 2 */
N
N#define  RCC_BDCR_RTCSEL                     ((uint32_t)0x00000300)        /*!< RTCSEL[1:0] bits (RTC clock source selection) */
N#define  RCC_BDCR_RTCSEL_0                   ((uint32_t)0x00000100)        /*!< Bit 0 */
N#define  RCC_BDCR_RTCSEL_1                   ((uint32_t)0x00000200)        /*!< Bit 1 */
N
N/* RTC configuration */
N#define  RCC_BDCR_RTCSEL_NOCLOCK             ((uint32_t)0x00000000)        /*!< No clock */
N#define  RCC_BDCR_RTCSEL_LSE                 ((uint32_t)0x00000100)        /*!< LSE oscillator clock used as RTC clock */
N#define  RCC_BDCR_RTCSEL_LSI                 ((uint32_t)0x00000200)        /*!< LSI oscillator clock used as RTC clock */
N#define  RCC_BDCR_RTCSEL_HSE                 ((uint32_t)0x00000300)        /*!< HSE oscillator clock divided by 32 used as RTC clock */
N
N#define  RCC_BDCR_RTCISO                     ((uint32_t)0x00002000)        /*!<  */
N#define  RCC_BDCR_RTCPD                      ((uint32_t)0x00004000)        /*!<   */
N#define  RCC_BDCR_RTCEN                      ((uint32_t)0x00008000)        /*!< RTC clock enable */
N#define  RCC_BDCR_BDRST                      ((uint32_t)0x00010000)        /*!< Backup domain software reset  */
N
N/*******************  Bit definition for RCC_CSR register  ********************/  
N#define  RCC_CSR_LSION                       ((uint32_t)0x00000001)        /*!< Internal Low Speed oscillator enable */
N#define  RCC_CSR_LSIRDY                      ((uint32_t)0x00000002)        /*!< Internal Low Speed oscillator Ready */
N#define  RCC_CSR_V18PWRRSTF                  ((uint32_t)0x00800000)        /*!< V1.8 power domain reset flag */
N#define  RCC_CSR_RMVF                        ((uint32_t)0x01000000)        /*!< Remove reset flag */
N#define  RCC_CSR_OBLRSTF                     ((uint32_t)0x02000000)        /*!< OBL reset flag */
N#define  RCC_CSR_PINRSTF                     ((uint32_t)0x04000000)        /*!< PIN reset flag */
N#define  RCC_CSR_PORRSTF                     ((uint32_t)0x08000000)        /*!< POR/PDR reset flag */
N#define  RCC_CSR_SFTRSTF                     ((uint32_t)0x10000000)        /*!< Software Reset flag */
N#define  RCC_CSR_IWDGRSTF                    ((uint32_t)0x20000000)        /*!< Independent Watchdog reset flag */
N#define  RCC_CSR_WWDGRSTF                    ((uint32_t)0x40000000)        /*!< Window watchdog reset flag */
N#define  RCC_CSR_LPWRRSTF                    ((uint32_t)0x80000000)        /*!< Low-Power reset flag */
N
N/* Old Bit definition maintained for legacy purpose */
N#define  RCC_CSR_OBL                         RCC_CSR_OBLRSTF        /*!< OBL reset flag */
N/*******************  Bit definition for RCC_AHBRSTR register  ****************/
N#define  RCC_AHBRSTR_GPIOARST                ((uint32_t)0x00020000)         /*!< GPIOA clock reset */
N#define  RCC_AHBRSTR_GPIOBRST                ((uint32_t)0x00040000)         /*!< GPIOB clock reset */
N#define  RCC_AHBRSTR_GPIOCRST                ((uint32_t)0x00080000)         /*!< GPIOC clock reset */
N#define  RCC_AHBRSTR_GPIODRST                ((uint32_t)0x00010000)         /*!< GPIOD clock reset */
N//#define  RCC_AHBRSTR_GPIOERST                ((uint32_t)0x00020000)         /*!< GPIOE clock reset */
N#define  RCC_AHBRSTR_GPIOFRST                ((uint32_t)0x00040000)         /*!< GPIOF clock reset */
N#define  RCC_AHBRSTR_TSCRST                  ((uint32_t)0x00100000)         /*!< TS clock reset */
N
N/* Old Bit definition maintained for legacy purpose */
N#define  RCC_AHBRSTR_TSRST                   RCC_AHBRSTR_TSCRST         /*!< TS clock reset */ 
N
N#define  RCC_AHBRSTR_IOPARST                 RCC_AHBRSTR_GPIOARST
N#define  RCC_AHBRSTR_IOPBRST                 RCC_AHBRSTR_GPIOBRST
N#define  RCC_AHBRSTR_IOPCRST                 RCC_AHBRSTR_GPIOCRST
N#define  RCC_AHBRSTR_IOPDRST                 RCC_AHBRSTR_GPIODRST
N#define  RCC_AHBRSTR_IOPFRST                 RCC_AHBRSTR_GPIOFRST
N  
N/*******************  Bit definition for RCC_CFGR2 register  ******************/
N/* PREDIV1 configuration */
N#define  RCC_CFGR2_PREDIV1                   ((uint32_t)0x0000000F)        /*!< PREDIV1[3:0] bits */
N#define  RCC_CFGR2_PREDIV1_0                 ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  RCC_CFGR2_PREDIV1_1                 ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  RCC_CFGR2_PREDIV1_2                 ((uint32_t)0x00000004)        /*!< Bit 2 */
N#define  RCC_CFGR2_PREDIV1_3                 ((uint32_t)0x00000008)        /*!< Bit 3 */
N
N#define  RCC_CFGR2_PREDIV1_DIV1              ((uint32_t)0x00000000)        /*!< PREDIV1 input clock not divided */
N#define  RCC_CFGR2_PREDIV1_DIV2              ((uint32_t)0x00000001)        /*!< PREDIV1 input clock divided by 2 */
N#define  RCC_CFGR2_PREDIV1_DIV3              ((uint32_t)0x00000002)        /*!< PREDIV1 input clock divided by 3 */
N#define  RCC_CFGR2_PREDIV1_DIV4              ((uint32_t)0x00000003)        /*!< PREDIV1 input clock divided by 4 */
N#define  RCC_CFGR2_PREDIV1_DIV5              ((uint32_t)0x00000004)        /*!< PREDIV1 input clock divided by 5 */
N#define  RCC_CFGR2_PREDIV1_DIV6              ((uint32_t)0x00000005)        /*!< PREDIV1 input clock divided by 6 */
N#define  RCC_CFGR2_PREDIV1_DIV7              ((uint32_t)0x00000006)        /*!< PREDIV1 input clock divided by 7 */
N#define  RCC_CFGR2_PREDIV1_DIV8              ((uint32_t)0x00000007)        /*!< PREDIV1 input clock divided by 8 */
N#define  RCC_CFGR2_PREDIV1_DIV9              ((uint32_t)0x00000008)        /*!< PREDIV1 input clock divided by 9 */
N#define  RCC_CFGR2_PREDIV1_DIV10             ((uint32_t)0x00000009)        /*!< PREDIV1 input clock divided by 10 */
N#define  RCC_CFGR2_PREDIV1_DIV11             ((uint32_t)0x0000000A)        /*!< PREDIV1 input clock divided by 11 */
N#define  RCC_CFGR2_PREDIV1_DIV12             ((uint32_t)0x0000000B)        /*!< PREDIV1 input clock divided by 12 */
N#define  RCC_CFGR2_PREDIV1_DIV13             ((uint32_t)0x0000000C)        /*!< PREDIV1 input clock divided by 13 */
N#define  RCC_CFGR2_PREDIV1_DIV14             ((uint32_t)0x0000000D)        /*!< PREDIV1 input clock divided by 14 */
N#define  RCC_CFGR2_PREDIV1_DIV15             ((uint32_t)0x0000000E)        /*!< PREDIV1 input clock divided by 15 */
N#define  RCC_CFGR2_PREDIV1_DIV16             ((uint32_t)0x0000000F)        /*!< PREDIV1 input clock divided by 16 */
N
N/* Old Bit definition maintained for legacy purpose */
N#define  RCC_CFGR2_PREDIV                  RCC_CFGR2_PREDIV1          
N#define  RCC_CFGR2_PREDIV_0                RCC_CFGR2_PREDIV1_0    
N#define  RCC_CFGR2_PREDIV_1                RCC_CFGR2_PREDIV1_1    
N#define  RCC_CFGR2_PREDIV_2                RCC_CFGR2_PREDIV1_2    
N#define  RCC_CFGR2_PREDIV_3                RCC_CFGR2_PREDIV1_3    
N                                                                   
N#define  RCC_CFGR2_PREDIV_DIV1             RCC_CFGR2_PREDIV1_DIV1 
N#define  RCC_CFGR2_PREDIV_DIV2             RCC_CFGR2_PREDIV1_DIV2 
N#define  RCC_CFGR2_PREDIV_DIV3             RCC_CFGR2_PREDIV1_DIV3 
N#define  RCC_CFGR2_PREDIV_DIV4             RCC_CFGR2_PREDIV1_DIV4 
N#define  RCC_CFGR2_PREDIV_DIV5             RCC_CFGR2_PREDIV1_DIV5 
N#define  RCC_CFGR2_PREDIV_DIV6             RCC_CFGR2_PREDIV1_DIV6 
N#define  RCC_CFGR2_PREDIV_DIV7             RCC_CFGR2_PREDIV1_DIV7 
N#define  RCC_CFGR2_PREDIV_DIV8             RCC_CFGR2_PREDIV1_DIV8 
N#define  RCC_CFGR2_PREDIV_DIV9             RCC_CFGR2_PREDIV1_DIV9 
N#define  RCC_CFGR2_PREDIV_DIV10            RCC_CFGR2_PREDIV1_DIV10
N#define  RCC_CFGR2_PREDIV_DIV11            RCC_CFGR2_PREDIV1_DIV11
N#define  RCC_CFGR2_PREDIV_DIV12            RCC_CFGR2_PREDIV1_DIV12
N#define  RCC_CFGR2_PREDIV_DIV13            RCC_CFGR2_PREDIV1_DIV13
N#define  RCC_CFGR2_PREDIV_DIV14            RCC_CFGR2_PREDIV1_DIV14
N#define  RCC_CFGR2_PREDIV_DIV15            RCC_CFGR2_PREDIV1_DIV15
N#define  RCC_CFGR2_PREDIV_DIV16            RCC_CFGR2_PREDIV1_DIV16
N/*******************  Bit definition for RCC_CFGR3 register  ******************/
N#define  RCC_CFGR3_USART1SW                  ((uint32_t)0x00000003)        /*!< USART1SW[1:0] bits */
N#define  RCC_CFGR3_USART1SW_0                ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  RCC_CFGR3_USART1SW_1                ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  RCC_CFGR3_I2C1SW                    ((uint32_t)0x00000010)        /*!< I2C1SW bits */
N//#define  RCC_CFGR3_CECSW                     ((uint32_t)0x00000040)        /*!< CECSW bits */
N#define  RCC_CFGR3_USBSW                     ((uint32_t)0x00000080)        /*!< USBSW bits */
N#define  RCC_CFGR3_ADCSW                     ((uint32_t)0x00000100)        /*!< ADCSW bits */
N//#define  RCC_CFGR3_USART2SW                  ((uint32_t)0x00030000)        /*!< USART2SW[1:0] bits */
N//#define  RCC_CFGR3_USART2SW_0                ((uint32_t)0x00010000)        /*!< Bit 0 */
N//#define  RCC_CFGR3_USART2SW_1                ((uint32_t)0x00020000)        /*!< Bit 1 */
N//#define  RCC_CFGR3_USART3SW                  ((uint32_t)0x000C0000)        /*!< USART3SW[1:0] bits */
N//#define  RCC_CFGR3_USART3SW_0                ((uint32_t)0x00040000)        /*!< Bit 0 */
N//#define  RCC_CFGR3_USART3SW_1                ((uint32_t)0x00080000)        /*!< Bit 1 */
N
N
N/*******************  Bit definition for RCC_CR2 register  ********************/
N#define  RCC_CR2_HSI14ON                     ((uint32_t)0x00000001)        /*!< Internal High Speed 14MHz clock enable */
N#define  RCC_CR2_HSI14RDY                    ((uint32_t)0x00000002)        /*!< Internal High Speed 14MHz clock ready flag */
N#define  RCC_CR2_HSI14DIS                    ((uint32_t)0x00000004)        /*!< Internal High Speed 14MHz clock disable */
N#define  RCC_CR2_HSI14TRIM                   ((uint32_t)0x000000F8)        /*!< Internal High Speed 14MHz clock trimming */
N#define  RCC_CR2_HSI14CAL                    ((uint32_t)0x0000FF00)        /*!< Internal High Speed 14MHz clock Calibration */
N#define  RCC_CR2_HSI48ON                     ((uint32_t)0x00010000)        /*!< Internal High Speed 48MHz clock enable */
N#define  RCC_CR2_HSI48RDY                    ((uint32_t)0x00020000)        /*!< Internal High Speed 48MHz clock ready flag */
N#define  RCC_CR2_HSI48CAL                    ((uint32_t)0xFF800000)        /*!< Internal High Speed 48MHz clock Calibration */
N
N/******************************************************************************/
N/*                                                                            */
N/*                           Real-Time Clock (RTC)                            */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bits definition for RTC_TR register  *******************/         
N#define RTC_TR_SU                            ((uint32_t)0x0000000F)      
N#define RTC_TR_SU_0                          ((uint32_t)0x00000001)        
N#define RTC_TR_SU_1                          ((uint32_t)0x00000002)        
N#define RTC_TR_SU_2                          ((uint32_t)0x00000004)        
N#define RTC_TR_SU_3                          ((uint32_t)0x00000008)         
N#define RTC_TR_ST                            ((uint32_t)0x00000070)        
N#define RTC_TR_ST_0                          ((uint32_t)0x00000010)        
N#define RTC_TR_ST_1                          ((uint32_t)0x00000020)        
N#define RTC_TR_ST_2                          ((uint32_t)0x00000040)          
N#define RTC_TR_MNU                           ((uint32_t)0x00000F00)        
N#define RTC_TR_MNU_0                         ((uint32_t)0x00000100)        
N#define RTC_TR_MNU_1                         ((uint32_t)0x00000200)        
N#define RTC_TR_MNU_2                         ((uint32_t)0x00000400)        
N#define RTC_TR_MNU_3                         ((uint32_t)0x00000800)        
N#define RTC_TR_MNT                           ((uint32_t)0x00007000)        
N#define RTC_TR_MNT_0                         ((uint32_t)0x00001000)        
N#define RTC_TR_MNT_1                         ((uint32_t)0x00002000)        
N#define RTC_TR_MNT_2                         ((uint32_t)0x00004000)       
N#define RTC_TR_HU                            ((uint32_t)0x000F0000)        
N#define RTC_TR_HU_0                          ((uint32_t)0x00010000)        
N#define RTC_TR_HU_1                          ((uint32_t)0x00020000)        
N#define RTC_TR_HU_2                          ((uint32_t)0x00040000)        
N#define RTC_TR_HU_3                          ((uint32_t)0x00080000)
N#define RTC_TR_HT                            ((uint32_t)0x00300000)        
N#define RTC_TR_HT_0                          ((uint32_t)0x00100000)        
N#define RTC_TR_HT_1                          ((uint32_t)0x00200000)  
N#define RTC_TR_PM                            ((uint32_t)0x00400000)     
N
N/********************  Bits definition for RTC_DR register  *******************/       
N#define RTC_DR_DU                            ((uint32_t)0x0000000F)        
N#define RTC_DR_DU_0                          ((uint32_t)0x00000001)        
N#define RTC_DR_DU_1                          ((uint32_t)0x00000002)        
N#define RTC_DR_DU_2                          ((uint32_t)0x00000004)        
N#define RTC_DR_DU_3                          ((uint32_t)0x00000008)           
N#define RTC_DR_DT                            ((uint32_t)0x00000030)        
N#define RTC_DR_DT_0                          ((uint32_t)0x00000010)        
N#define RTC_DR_DT_1                          ((uint32_t)0x00000020)         
N#define RTC_DR_MU                            ((uint32_t)0x00000F00)        
N#define RTC_DR_MU_0                          ((uint32_t)0x00000100)        
N#define RTC_DR_MU_1                          ((uint32_t)0x00000200)        
N#define RTC_DR_MU_2                          ((uint32_t)0x00000400)        
N#define RTC_DR_MU_3                          ((uint32_t)0x00000800)         
N#define RTC_DR_MT                            ((uint32_t)0x00001000)        
N#define RTC_DR_WDU                           ((uint32_t)0x0000E000)        
N#define RTC_DR_WDU_0                         ((uint32_t)0x00002000)        
N#define RTC_DR_WDU_1                         ((uint32_t)0x00004000)        
N#define RTC_DR_WDU_2                         ((uint32_t)0x00008000)       
N#define RTC_DR_YU                            ((uint32_t)0x000F0000)        
N#define RTC_DR_YU_0                          ((uint32_t)0x00010000)        
N#define RTC_DR_YU_1                          ((uint32_t)0x00020000)        
N#define RTC_DR_YU_2                          ((uint32_t)0x00040000)        
N#define RTC_DR_YU_3                          ((uint32_t)0x00080000) 
N#define RTC_DR_YT                            ((uint32_t)0x00F00000)        
N#define RTC_DR_YT_0                          ((uint32_t)0x00100000)        
N#define RTC_DR_YT_1                          ((uint32_t)0x00200000)        
N#define RTC_DR_YT_2                          ((uint32_t)0x00400000)        
N#define RTC_DR_YT_3                          ((uint32_t)0x00800000)    
N
N/********************  Bits definition for RTC_CR register  *******************/        
N//#define RTC_CR_WUCKSEL                       ((uint32_t)0x00000007)        
N//#define RTC_CR_WUCKSEL_0                     ((uint32_t)0x00000001)        
N//#define RTC_CR_WUCKSEL_1                     ((uint32_t)0x00000002)        
N//#define RTC_CR_WUCKSEL_2                     ((uint32_t)0x00000004)          
N#define RTC_CR_TSEDGE                        ((uint32_t)0x00000008)        
N#define RTC_CR_REFCKON                       ((uint32_t)0x00000010)          
N#define RTC_CR_BYPSHAD                       ((uint32_t)0x00000020)         
N#define RTC_CR_FMT                           ((uint32_t)0x00000040)        
N#define RTC_CR_ALRAE                         ((uint32_t)0x00000100)        
N//#define RTC_CR_WUTE                          ((uint32_t)0x00000400)        
N#define RTC_CR_TSE                           ((uint32_t)0x00000800)
N#define RTC_CR_ALRAIE                        ((uint32_t)0x00001000)       
N//#define RTC_CR_WUTIE                         ((uint32_t)0x00004000)          
N#define RTC_CR_TSIE                          ((uint32_t)0x00008000)        
N#define RTC_CR_ADD1H                         ((uint32_t)0x00010000)         
N#define RTC_CR_SUB1H                         ((uint32_t)0x00020000)        
N#define RTC_CR_BKP                           ((uint32_t)0x00040000)        
N#define RTC_CR_COSEL                         ((uint32_t)0x00080000)          
N#define RTC_CR_POL                           ((uint32_t)0x00100000)       
N#define RTC_CR_OSEL                          ((uint32_t)0x00200000)        
N//#define RTC_CR_OSEL_0                        ((uint32_t)0x00200000)        
N//#define RTC_CR_OSEL_1                        ((uint32_t)0x00400000)
N#define RTC_CR_COE                           ((uint32_t)0x00800000)
N
N/* Old bit definition maintained for legacy purpose */
N#define RTC_CR_BCK                           RTC_CR_BKP
N#define RTC_CR_CALSEL                        RTC_CR_COSEL
N
N/********************  Bits definition for RTC_ISR register  ******************/
N#define RTC_ISR_RECALPF                      ((uint32_t)0x00010000)        
N//#define RTC_ISR_TAMP3F                       ((uint32_t)0x00008000)        
N#define RTC_ISR_TAMP2F                       ((uint32_t)0x00004000)        
N#define RTC_ISR_TAMP1F                       ((uint32_t)0x00002000)        
N#define RTC_ISR_TSOVF                        ((uint32_t)0x00001000)        
N#define RTC_ISR_TSF                          ((uint32_t)0x00000800)        
N//#define RTC_ISR_WUTF                         ((uint32_t)0x00000400)        
N#define RTC_ISR_ALRAF                        ((uint32_t)0x00000100)        
N#define RTC_ISR_INIT                         ((uint32_t)0x00000080)        
N#define RTC_ISR_INITF                        ((uint32_t)0x00000040)        
N#define RTC_ISR_RSF                          ((uint32_t)0x00000020)        
N#define RTC_ISR_INITS                        ((uint32_t)0x00000010)        
N#define RTC_ISR_SHPF                         ((uint32_t)0x00000008)        
N//#define RTC_ISR_WUTWF                        ((uint32_t)0x00000004)        
N#define RTC_ISR_ALRAWF                       ((uint32_t)0x00000001)        
N
N/********************  Bits definition for RTC_PRER register  *****************/
N#define RTC_PRER_PREDIV_A                    ((uint32_t)0x007F0000)        
N#define RTC_PRER_PREDIV_S                    ((uint32_t)0x00007FFF)        
N
N/********************  Bits definition for RTC_WUTR register  *****************/
N//#define RTC_WUTR_WUT                         ((uint32_t)0x0000FFFF)
N
N/********************  Bits definition for RTC_ALRMAR register  ***************/
N#define RTC_ALRMAR_MSK4                      ((uint32_t)0x80000000)        
N#define RTC_ALRMAR_WDSEL                     ((uint32_t)0x40000000)        
N#define RTC_ALRMAR_DT                        ((uint32_t)0x30000000)        
N#define RTC_ALRMAR_DT_0                      ((uint32_t)0x10000000)        
N#define RTC_ALRMAR_DT_1                      ((uint32_t)0x20000000)        
N#define RTC_ALRMAR_DU                        ((uint32_t)0x0F000000)        
N#define RTC_ALRMAR_DU_0                      ((uint32_t)0x01000000)        
N#define RTC_ALRMAR_DU_1                      ((uint32_t)0x02000000)        
N#define RTC_ALRMAR_DU_2                      ((uint32_t)0x04000000)        
N#define RTC_ALRMAR_DU_3                      ((uint32_t)0x08000000)        
N#define RTC_ALRMAR_MSK3                      ((uint32_t)0x00800000)        
N#define RTC_ALRMAR_PM                        ((uint32_t)0x00400000)        
N#define RTC_ALRMAR_HT                        ((uint32_t)0x00300000)        
N#define RTC_ALRMAR_HT_0                      ((uint32_t)0x00100000)        
N#define RTC_ALRMAR_HT_1                      ((uint32_t)0x00200000)        
N#define RTC_ALRMAR_HU                        ((uint32_t)0x000F0000)        
N#define RTC_ALRMAR_HU_0                      ((uint32_t)0x00010000)        
N#define RTC_ALRMAR_HU_1                      ((uint32_t)0x00020000)        
N#define RTC_ALRMAR_HU_2                      ((uint32_t)0x00040000)        
N#define RTC_ALRMAR_HU_3                      ((uint32_t)0x00080000)        
N#define RTC_ALRMAR_MSK2                      ((uint32_t)0x00008000)        
N#define RTC_ALRMAR_MNT                       ((uint32_t)0x00007000)        
N#define RTC_ALRMAR_MNT_0                     ((uint32_t)0x00001000)        
N#define RTC_ALRMAR_MNT_1                     ((uint32_t)0x00002000)        
N#define RTC_ALRMAR_MNT_2                     ((uint32_t)0x00004000)        
N#define RTC_ALRMAR_MNU                       ((uint32_t)0x00000F00)        
N#define RTC_ALRMAR_MNU_0                     ((uint32_t)0x00000100)        
N#define RTC_ALRMAR_MNU_1                     ((uint32_t)0x00000200)        
N#define RTC_ALRMAR_MNU_2                     ((uint32_t)0x00000400)        
N#define RTC_ALRMAR_MNU_3                     ((uint32_t)0x00000800)        
N#define RTC_ALRMAR_MSK1                      ((uint32_t)0x00000080)        
N#define RTC_ALRMAR_ST                        ((uint32_t)0x00000070)        
N#define RTC_ALRMAR_ST_0                      ((uint32_t)0x00000010)        
N#define RTC_ALRMAR_ST_1                      ((uint32_t)0x00000020)        
N#define RTC_ALRMAR_ST_2                      ((uint32_t)0x00000040)        
N#define RTC_ALRMAR_SU                        ((uint32_t)0x0000000F)        
N#define RTC_ALRMAR_SU_0                      ((uint32_t)0x00000001)        
N#define RTC_ALRMAR_SU_1                      ((uint32_t)0x00000002)        
N#define RTC_ALRMAR_SU_2                      ((uint32_t)0x00000004)        
N#define RTC_ALRMAR_SU_3                      ((uint32_t)0x00000008)        
N
N/********************  Bits definition for RTC_WPR register  ******************/
N#define RTC_WPR_KEY                          ((uint32_t)0x000000FF)        
N
N/********************  Bits definition for RTC_SSR register  ******************/
N//#define RTC_SSR_SS                           ((uint32_t)0x0003FFFF) 
N#define RTC_SSR_SS                           ((uint32_t)0x0000FFFF)               
N
N/********************  Bits definition for RTC_SHIFTR register  ***************/
N#define RTC_SHIFTR_SUBFS                     ((uint32_t)0x00007FFF)        
N#define RTC_SHIFTR_ADD1S                     ((uint32_t)0x80000000)        
N
N/********************  Bits definition for RTC_TSTR register  *****************/
N#define RTC_TSTR_PM                          ((uint32_t)0x00400000)        
N#define RTC_TSTR_HT                          ((uint32_t)0x00300000)        
N#define RTC_TSTR_HT_0                        ((uint32_t)0x00100000)        
N#define RTC_TSTR_HT_1                        ((uint32_t)0x00200000)        
N#define RTC_TSTR_HU                          ((uint32_t)0x000F0000)        
N#define RTC_TSTR_HU_0                        ((uint32_t)0x00010000)        
N#define RTC_TSTR_HU_1                        ((uint32_t)0x00020000)        
N#define RTC_TSTR_HU_2                        ((uint32_t)0x00040000)        
N#define RTC_TSTR_HU_3                        ((uint32_t)0x00080000)        
N#define RTC_TSTR_MNT                         ((uint32_t)0x00007000)        
N#define RTC_TSTR_MNT_0                       ((uint32_t)0x00001000)        
N#define RTC_TSTR_MNT_1                       ((uint32_t)0x00002000)        
N#define RTC_TSTR_MNT_2                       ((uint32_t)0x00004000)        
N#define RTC_TSTR_MNU                         ((uint32_t)0x00000F00)        
N#define RTC_TSTR_MNU_0                       ((uint32_t)0x00000100)        
N#define RTC_TSTR_MNU_1                       ((uint32_t)0x00000200)        
N#define RTC_TSTR_MNU_2                       ((uint32_t)0x00000400)        
N#define RTC_TSTR_MNU_3                       ((uint32_t)0x00000800)        
N#define RTC_TSTR_ST                          ((uint32_t)0x00000070)        
N#define RTC_TSTR_ST_0                        ((uint32_t)0x00000010)        
N#define RTC_TSTR_ST_1                        ((uint32_t)0x00000020)        
N#define RTC_TSTR_ST_2                        ((uint32_t)0x00000040)        
N#define RTC_TSTR_SU                          ((uint32_t)0x0000000F)        
N#define RTC_TSTR_SU_0                        ((uint32_t)0x00000001)        
N#define RTC_TSTR_SU_1                        ((uint32_t)0x00000002)        
N#define RTC_TSTR_SU_2                        ((uint32_t)0x00000004)        
N#define RTC_TSTR_SU_3                        ((uint32_t)0x00000008)        
N
N/********************  Bits definition for RTC_TSDR register  *****************/
N#define RTC_TSDR_WDU                         ((uint32_t)0x0000E000)        
N#define RTC_TSDR_WDU_0                       ((uint32_t)0x00002000)        
N#define RTC_TSDR_WDU_1                       ((uint32_t)0x00004000)        
N#define RTC_TSDR_WDU_2                       ((uint32_t)0x00008000)        
N#define RTC_TSDR_MT                          ((uint32_t)0x00001000)        
N#define RTC_TSDR_MU                          ((uint32_t)0x00000F00)        
N#define RTC_TSDR_MU_0                        ((uint32_t)0x00000100)        
N#define RTC_TSDR_MU_1                        ((uint32_t)0x00000200)        
N#define RTC_TSDR_MU_2                        ((uint32_t)0x00000400)        
N#define RTC_TSDR_MU_3                        ((uint32_t)0x00000800)        
N#define RTC_TSDR_DT                          ((uint32_t)0x00000030)        
N#define RTC_TSDR_DT_0                        ((uint32_t)0x00000010)        
N#define RTC_TSDR_DT_1                        ((uint32_t)0x00000020)        
N#define RTC_TSDR_DU                          ((uint32_t)0x0000000F)        
N#define RTC_TSDR_DU_0                        ((uint32_t)0x00000001)        
N#define RTC_TSDR_DU_1                        ((uint32_t)0x00000002)        
N#define RTC_TSDR_DU_2                        ((uint32_t)0x00000004)        
N#define RTC_TSDR_DU_3                        ((uint32_t)0x00000008)        
N
N/********************  Bits definition for RTC_TSSSR register  ****************/
N//#define RTC_TSSSR_SS                         ((uint32_t)0x0003FFFF)
N#define RTC_TSSSR_SS                         ((uint32_t)0x0000FFFF)
N
N/********************  Bits definition for RTC_CALR register  ******************/
N#define RTC_CALR_CALP                         ((uint32_t)0x00008000)        
N#define RTC_CALR_CALW8                        ((uint32_t)0x00004000)        
N#define RTC_CALR_CALW16                       ((uint32_t)0x00002000)        
N#define RTC_CALR_CALM                         ((uint32_t)0x000001FF)        
N#define RTC_CALR_CALM_0                       ((uint32_t)0x00000001)        
N#define RTC_CALR_CALM_1                       ((uint32_t)0x00000002)        
N#define RTC_CALR_CALM_2                       ((uint32_t)0x00000004)        
N#define RTC_CALR_CALM_3                       ((uint32_t)0x00000008)        
N#define RTC_CALR_CALM_4                       ((uint32_t)0x00000010)        
N#define RTC_CALR_CALM_5                       ((uint32_t)0x00000020)        
N#define RTC_CALR_CALM_6                       ((uint32_t)0x00000040)        
N#define RTC_CALR_CALM_7                       ((uint32_t)0x00000080)        
N#define RTC_CALR_CALM_8                       ((uint32_t)0x00000100)
N
N/* Old Bits definition for RTC_CAL register maintained for legacy purpose */
N#define RTC_CAL_CALP                         RTC_CALR_CALP  
N#define RTC_CAL_CALW8                        RTC_CALR_CALW8 
N#define RTC_CAL_CALW16                       RTC_CALR_CALW16
N#define RTC_CAL_CALM                         RTC_CALR_CALM  
N#define RTC_CAL_CALM_0                       RTC_CALR_CALM_0
N#define RTC_CAL_CALM_1                       RTC_CALR_CALM_1
N#define RTC_CAL_CALM_2                       RTC_CALR_CALM_2
N#define RTC_CAL_CALM_3                       RTC_CALR_CALM_3
N#define RTC_CAL_CALM_4                       RTC_CALR_CALM_4
N#define RTC_CAL_CALM_5                       RTC_CALR_CALM_5
N#define RTC_CAL_CALM_6                       RTC_CALR_CALM_6
N#define RTC_CAL_CALM_7                       RTC_CALR_CALM_7
N#define RTC_CAL_CALM_8                       RTC_CALR_CALM_8
N
N/********************  Bits definition for RTC_TAFCR register  ****************/
N#define RTC_TAFCR_PC15MODE                   ((uint32_t)0x00800000)
N#define RTC_TAFCR_PC15VALUE                  ((uint32_t)0x00400000)
N#define RTC_TAFCR_PC14MODE                   ((uint32_t)0x00200000)
N#define RTC_TAFCR_PC14VALUE                  ((uint32_t)0x00100000)
N#define RTC_TAFCR_PC13MODE                   ((uint32_t)0x00080000)
N#define RTC_TAFCR_PC13VALUE                  ((uint32_t)0x00040000)        
N#define RTC_TAFCR_TAMPPUDIS                  ((uint32_t)0x00008000)        
N#define RTC_TAFCR_TAMPPRCH                   ((uint32_t)0x00006000)        
N#define RTC_TAFCR_TAMPPRCH_0                 ((uint32_t)0x00002000)        
N#define RTC_TAFCR_TAMPPRCH_1                 ((uint32_t)0x00004000)        
N#define RTC_TAFCR_TAMPFLT                    ((uint32_t)0x00001800)        
N#define RTC_TAFCR_TAMPFLT_0                  ((uint32_t)0x00000800)        
N#define RTC_TAFCR_TAMPFLT_1                  ((uint32_t)0x00001000)        
N#define RTC_TAFCR_TAMPFREQ                   ((uint32_t)0x00000700)        
N#define RTC_TAFCR_TAMPFREQ_0                 ((uint32_t)0x00000100)        
N#define RTC_TAFCR_TAMPFREQ_1                 ((uint32_t)0x00000200)        
N#define RTC_TAFCR_TAMPFREQ_2                 ((uint32_t)0x00000400)        
N#define RTC_TAFCR_TAMPTS                     ((uint32_t)0x00000080)        
N//#define RTC_TAFCR_TAMP3EDGE                  ((uint32_t)0x00000040)        
N//#define RTC_TAFCR_TAMP3E                     ((uint32_t)0x00000020)        
N#define RTC_TAFCR_TAMP2EDGE                  ((uint32_t)0x00000010)        
N#define RTC_TAFCR_TAMP2E                     ((uint32_t)0x00000008)        
N#define RTC_TAFCR_TAMPIE                     ((uint32_t)0x00000004)        
N#define RTC_TAFCR_TAMP1TRG                   ((uint32_t)0x00000002)        
N#define RTC_TAFCR_TAMP1E                     ((uint32_t)0x00000001)        
N
N/* Old bit definition maintained for legacy purpose */
N#define RTC_TAFCR_ALARMOUTTYPE               RTC_TAFCR_PC13VALUE
N#define RTC_TAFCR_TAMP2TRG									 RTC_TAFCR_TAMP2EDGE
N/********************  Bits definition for RTC_ALRMASSR register  *************/
N#define RTC_ALRMASSR_MASKSS                  ((uint32_t)0x0F000000)        
N#define RTC_ALRMASSR_MASKSS_0                ((uint32_t)0x01000000)        
N#define RTC_ALRMASSR_MASKSS_1                ((uint32_t)0x02000000)        
N#define RTC_ALRMASSR_MASKSS_2                ((uint32_t)0x04000000)        
N#define RTC_ALRMASSR_MASKSS_3                ((uint32_t)0x08000000)        
N#define RTC_ALRMASSR_SS                      ((uint32_t)0x00007FFF)        
N
N/********************  Bits definition for RTC_BKP0R register  ****************/
N#define RTC_BKP0R                            ((uint32_t)0xFFFFFFFF)        
N
N/********************  Bits definition for RTC_BKP1R register  ****************/
N#define RTC_BKP1R                            ((uint32_t)0xFFFFFFFF)        
N
N/********************  Bits definition for RTC_BKP2R register  ****************/
N#define RTC_BKP2R                            ((uint32_t)0xFFFFFFFF)        
N
N/********************  Bits definition for RTC_BKP3R register  ****************/
N#define RTC_BKP3R                            ((uint32_t)0xFFFFFFFF)        
N
N/********************  Bits definition for RTC_BKP4R register  ****************/
N#define RTC_BKP4R                            ((uint32_t)0xFFFFFFFF)        
N
N/******************************************************************************/
N/*                                                                            */
N/*                        Serial Peripheral Interface (SPI)                   */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for SPI_CR1 register  ********************/
N#define  SPI_CR1_CPHA                        ((uint16_t)0x0001)            /*!< Clock Phase */
N#define  SPI_CR1_CPOL                        ((uint16_t)0x0002)            /*!< Clock Polarity */
N#define  SPI_CR1_MSTR                        ((uint16_t)0x0004)            /*!< Master Selection */
N#define  SPI_CR1_BR                          ((uint16_t)0x0038)            /*!< BR[2:0] bits (Baud Rate Control) */
N#define  SPI_CR1_BR_0                        ((uint16_t)0x0008)            /*!< Bit 0 */
N#define  SPI_CR1_BR_1                        ((uint16_t)0x0010)            /*!< Bit 1 */
N#define  SPI_CR1_BR_2                        ((uint16_t)0x0020)            /*!< Bit 2 */
N#define  SPI_CR1_SPE                         ((uint16_t)0x0040)            /*!< SPI Enable */
N#define  SPI_CR1_LSBFIRST                    ((uint16_t)0x0080)            /*!< Frame Format */
N#define  SPI_CR1_SSI                         ((uint16_t)0x0100)            /*!< Internal slave select */
N#define  SPI_CR1_SSM                         ((uint16_t)0x0200)            /*!< Software slave management */
N#define  SPI_CR1_RXONLY                      ((uint16_t)0x0400)            /*!< Receive only */
N#define  SPI_CR1_CRCL                        ((uint16_t)0x0800)            /*!< CRC Length */
N#define  SPI_CR1_CRCNEXT                     ((uint16_t)0x1000)            /*!< Transmit CRC next */
N#define  SPI_CR1_CRCEN                       ((uint16_t)0x2000)            /*!< Hardware CRC calculation enable */
N#define  SPI_CR1_BIDIOE                      ((uint16_t)0x4000)            /*!< Output enable in bidirectional mode */
N#define  SPI_CR1_BIDIMODE                    ((uint16_t)0x8000)            /*!< Bidirectional data mode enable */
N
N/*******************  Bit definition for SPI_CR2 register  ********************/
N#define  SPI_CR2_RXDMAEN                     ((uint16_t)0x0001)            /*!< Rx Buffer DMA Enable */
N#define  SPI_CR2_TXDMAEN                     ((uint16_t)0x0002)            /*!< Tx Buffer DMA Enable */
N#define  SPI_CR2_SSOE                        ((uint16_t)0x0004)            /*!< SS Output Enable */
N#define  SPI_CR2_NSSP                        ((uint16_t)0x0008)            /*!< NSS pulse management Enable */
N#define  SPI_CR2_FRF                         ((uint16_t)0x0010)            /*!< Frame Format Enable */
N#define  SPI_CR2_ERRIE                       ((uint16_t)0x0020)            /*!< Error Interrupt Enable */
N#define  SPI_CR2_RXNEIE                      ((uint16_t)0x0040)            /*!< RX buffer Not Empty Interrupt Enable */
N#define  SPI_CR2_TXEIE                       ((uint16_t)0x0080)            /*!< Tx buffer Empty Interrupt Enable */
N#define  SPI_CR2_DS                          ((uint16_t)0x0F00)            /*!< DS[3:0] Data Size */
N#define  SPI_CR2_DS_0                        ((uint16_t)0x0100)            /*!< Bit 0 */
N#define  SPI_CR2_DS_1                        ((uint16_t)0x0200)            /*!< Bit 1 */
N#define  SPI_CR2_DS_2                        ((uint16_t)0x0400)            /*!< Bit 2 */
N#define  SPI_CR2_DS_3                        ((uint16_t)0x0800)            /*!< Bit 3 */
N#define  SPI_CR2_FRXTH                       ((uint16_t)0x1000)            /*!< FIFO reception Threshold */
N#define  SPI_CR2_LDMARX                      ((uint16_t)0x2000)            /*!< Last DMA transfer for reception */
N#define  SPI_CR2_LDMATX                      ((uint16_t)0x4000)            /*!< Last DMA transfer for transmission */
N
N/********************  Bit definition for SPI_SR register  ********************/
N#define  SPI_SR_RXNE                         ((uint16_t)0x0001)            /*!< Receive buffer Not Empty */
N#define  SPI_SR_TXE                          ((uint16_t)0x0002)            /*!< Transmit buffer Empty */
N//#define  SPI_SR_CHSIDE                       ((uint16_t)0x0004)            /*!< Channel side */
N//#define  SPI_SR_UDR                          ((uint16_t)0x0008)            /*!< Underrun flag */
N#define  SPI_SR_CRCERR                       ((uint16_t)0x0010)            /*!< CRC Error flag */
N#define  SPI_SR_MODF                         ((uint16_t)0x0020)            /*!< Mode fault */
N#define  SPI_SR_OVR                          ((uint16_t)0x0040)            /*!< Overrun flag */
N#define  SPI_SR_BSY                          ((uint16_t)0x0080)            /*!< Busy flag */
N#define  SPI_SR_FRE                          ((uint16_t)0x0100)            /*!< TI frame format error */
N#define  SPI_SR_FRLVL                        ((uint16_t)0x0600)            /*!< FIFO Reception Level */
N#define  SPI_SR_FRLVL_0                      ((uint16_t)0x0200)            /*!< Bit 0 */
N#define  SPI_SR_FRLVL_1                      ((uint16_t)0x0400)            /*!< Bit 1 */
N#define  SPI_SR_FTLVL                        ((uint16_t)0x1800)            /*!< FIFO Transmission Level */
N#define  SPI_SR_FTLVL_0                      ((uint16_t)0x0800)            /*!< Bit 0 */
N#define  SPI_SR_FTLVL_1                      ((uint16_t)0x1000)            /*!< Bit 1 */  
N
N/********************  Bit definition for SPI_DR register  ********************/
N#define  SPI_DR_DR                           ((uint16_t)0xFFFF)            /*!< Data Register */
N
N/*******************  Bit definition for SPI_CRCPR register  ******************/
N#define  SPI_CRCPR_CRCPOLY                   ((uint16_t)0xFFFF)            /*!< CRC polynomial register */
N
N/******************  Bit definition for SPI_RXCRCR register  ******************/
N#define  SPI_RXCRCR_RXCRC                    ((uint16_t)0xFFFF)            /*!< Rx CRC Register */
N
N/******************  Bit definition for SPI_TXCRCR register  ******************/
N#define  SPI_TXCRCR_TXCRC                    ((uint16_t)0xFFFF)            /*!< Tx CRC Register */
N
N/******************  Bit definition for SPI_I2SCFGR register  *****************/
N//#define  SPI_I2SCFGR_CHLEN                   ((uint16_t)0x0001)            /*!<Channel length (number of bits per audio channel) */
N//#define  SPI_I2SCFGR_DATLEN                  ((uint16_t)0x0006)            /*!<DATLEN[1:0] bits (Data length to be transferred) */
N//#define  SPI_I2SCFGR_DATLEN_0                ((uint16_t)0x0002)            /*!<Bit 0 */
N//#define  SPI_I2SCFGR_DATLEN_1                ((uint16_t)0x0004)            /*!<Bit 1 */
N//#define  SPI_I2SCFGR_CKPOL                   ((uint16_t)0x0008)            /*!<steady state clock polarity */
N//#define  SPI_I2SCFGR_I2SSTD                  ((uint16_t)0x0030)            /*!<I2SSTD[1:0] bits (I2S standard selection) */
N//#define  SPI_I2SCFGR_I2SSTD_0                ((uint16_t)0x0010)            /*!<Bit 0 */
N//#define  SPI_I2SCFGR_I2SSTD_1                ((uint16_t)0x0020)            /*!<Bit 1 */
N//#define  SPI_I2SCFGR_PCMSYNC                 ((uint16_t)0x0080)            /*!<PCM frame synchronization */
N//#define  SPI_I2SCFGR_I2SCFG                  ((uint16_t)0x0300)            /*!<I2SCFG[1:0] bits (I2S configuration mode) */
N//#define  SPI_I2SCFGR_I2SCFG_0                ((uint16_t)0x0100)            /*!<Bit 0 */
N//#define  SPI_I2SCFGR_I2SCFG_1                ((uint16_t)0x0200)            /*!<Bit 1 */
N//#define  SPI_I2SCFGR_I2SE                    ((uint16_t)0x0400)            /*!<I2S Enable */
N//#define  SPI_I2SCFGR_I2SMOD                  ((uint16_t)0x0800)            /*!<I2S mode selection */
N
N/******************  Bit definition for SPI_I2SPR register  *******************/
N//#define  SPI_I2SPR_I2SDIV                    ((uint16_t)0x00FF)            /*!<I2S Linear prescaler */
N//#define  SPI_I2SPR_ODD                       ((uint16_t)0x0100)            /*!<Odd factor for the prescaler */
N//#define  SPI_I2SPR_MCKOE                     ((uint16_t)0x0200)            /*!<Master Clock Output Enable */
N
N/******************************************************************************/
N/*                                                                            */
N/*                       System Configuration (SYSCFG)                        */
N/*                                                                            */
N/******************************************************************************/
N/*****************  Bit definition for SYSCFG_CFGR1 register  ****************/
N#define SYSCFG_CFGR1_MEM_MODE               ((uint32_t)0x00000003) /*!< SYSCFG_Memory Remap Config */
N#define SYSCFG_CFGR1_MEM_MODE_0             ((uint32_t)0x00000001) /*!< SYSCFG_Memory Remap Config Bit 0 */
N#define SYSCFG_CFGR1_MEM_MODE_1             ((uint32_t)0x00000002) /*!< SYSCFG_Memory Remap Config Bit 1 */
N#define SYSCFG_CFGR1_IRDA_ENV_SEL           ((uint32_t)0x000000C0) /*!< IRDA_SEL_ENV config */
N#define SYSCFG_CFGR1_IRDA_ENV_SEL_0         ((uint32_t)0x00000040) /*!< IRDA_SEL_ENV Bit 0 */
N#define SYSCFG_CFGR1_IRDA_ENV_SEL_1         ((uint32_t)0x00000080) /*!< IRDA_SEL_ENV Bit 1 */
N//#define SYSCFG_CFGR1_PA11_PA12_RMP          ((uint32_t)0x00000010) /*!< PA11 and PA12 remap on QFN28 and TSSOP20 packages*/
N#define SYSCFG_CFGR1_ADC_DMA_RMP            ((uint32_t)0x00000100) /*!< ADC DMA remap */
N#define SYSCFG_CFGR1_USART1TX_DMA_RMP       ((uint32_t)0x00000200) /*!< USART1 TX DMA remap */
N#define SYSCFG_CFGR1_USART1RX_DMA_RMP       ((uint32_t)0x00000400) /*!< USART1 RX DMA remap */
N#define SYSCFG_CFGR1_TIM16_DMA_RMP          ((uint32_t)0x00000800) /*!< Timer 16 DMA remap */
N#define SYSCFG_CFGR1_TIM17_DMA_RMP          ((uint32_t)0x00001000) /*!< Timer 17 DMA remap */
N//#define SYSCFG_CFGR1_TIM16_DMA_RMP2         ((uint32_t)0x00002000) /*!< Timer 16 DMA remap 2 (only for FT32F072X8) */
N//#define SYSCFG_CFGR1_TIM17_DMA_RMP2         ((uint32_t)0x00004000) /*!< Timer 17 DMA remap 2 (only for FT32F072X8) */
N#define SYSCFG_CFGR1_I2C_PB6_FMP            ((uint32_t)0x00010000) /*!< I2C PB6 Fast mode plus */
N#define SYSCFG_CFGR1_I2C_PB7_FMP            ((uint32_t)0x00020000) /*!< I2C PB7 Fast mode plus */
N#define SYSCFG_CFGR1_I2C_PB8_FMP            ((uint32_t)0x00040000) /*!< I2C PB8 Fast mode plus */
N#define SYSCFG_CFGR1_I2C_PB9_FMP            ((uint32_t)0x00080000) /*!< I2C PB9 Fast mode plus */
N#define SYSCFG_CFGR1_I2C1_FMP               ((uint32_t)0x00100000) /*!< I2C PB9 Fast mode plus */
N//#define SYSCFG_CFGR1_I2C_FMP_I2C1           ((uint32_t)0x00100000) /*!< Enable Fast Mode Plus on PB10, PB11, PF6 and PF7(only for FT32F072X8 devices) */
N//#define SYSCFG_CFGR1_I2C_FMP_I2C2           ((uint32_t)0x00200000) /*!< Enable I2C2 Fast mode plus (only for FT32F072X8) */
N//#define SYSCFG_CFGR1_I2C_FMP_PA9            ((uint32_t)0x00400000) /*!< Enable Fast Mode Plus on PA9 (only for FT32F072X8devices) */
N//#define SYSCFG_CFGR1_I2C_FMP_PA10           ((uint32_t)0x00800000) /*!< Enable Fast Mode Plus on PA10(only for FT32F072X8devices) */
N//#define SYSCFG_CFGR1_SPI2_DMA_RMP           ((uint32_t)0x01000000) /*!< SPI2 DMA remap (only for FT32F072X8) */
N//#define SYSCFG_CFGR1_USART2_DMA_RMP         ((uint32_t)0x02000000) /*!< USART2 DMA remap (only for FT32F072X8) */
N//#define SYSCFG_CFGR1_USART3_DMA_RMP         ((uint32_t)0x04000000) /*!< USART3 DMA remap (only for FT32F072X8) */
N//#define SYSCFG_CFGR1_I2C1_DMA_RMP           ((uint32_t)0x08000000) /*!< I2C1 DMA remap (only for FT32F072X8) */
N//#define SYSCFG_CFGR1_TIM1_DMA_RMP           ((uint32_t)0x10000000) /*!< TIM1 DMA remap (only for FT32F072X8) */
N//#define SYSCFG_CFGR1_TIM2_DMA_RMP           ((uint32_t)0x20000000) /*!< TIM2 DMA remap (only for FT32F072X8) */
N//#define SYSCFG_CFGR1_TIM3_DMA_RMP           ((uint32_t)0x40000000) /*!< TIM3 DMA remap (only for FT32F072X8) */
N
N
N/* Old bit definition maintained for legacy purpose */
N#define SYSCFG_CFGR1_I2C_FMP_PB6               SYSCFG_CFGR1_I2C_PB6_FMP
N#define SYSCFG_CFGR1_I2C_FMP_PB7               SYSCFG_CFGR1_I2C_PB7_FMP
N#define SYSCFG_CFGR1_I2C_FMP_PB8               SYSCFG_CFGR1_I2C_PB8_FMP
N#define SYSCFG_CFGR1_I2C_FMP_PB9               SYSCFG_CFGR1_I2C_PB9_FMP
N
N
N
N/*****************  Bit definition for SYSCFG_EXTICR1 register  ***************/
N#define SYSCFG_EXTICR1_EXTI0            ((uint16_t)0x000F) /*!< EXTI 0 configuration */
N#define SYSCFG_EXTICR1_EXTI1            ((uint16_t)0x00F0) /*!< EXTI 1 configuration */
N#define SYSCFG_EXTICR1_EXTI2            ((uint16_t)0x0F00) /*!< EXTI 2 configuration */
N#define SYSCFG_EXTICR1_EXTI3            ((uint16_t)0xF000) /*!< EXTI 3 configuration */
N
N/** 
N  * @brief  EXTI0 configuration  
N  */
N#define SYSCFG_EXTICR1_EXTI0_PA         ((uint16_t)0x0000) /*!< PA[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PB         ((uint16_t)0x0001) /*!< PB[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PC         ((uint16_t)0x0002) /*!< PC[0] pin */
N//#define SYSCFG_EXTICR1_EXTI0_PD         ((uint16_t)0x0003) /*!< PD[0] pin */
N//#define SYSCFG_EXTICR1_EXTI0_PE         ((uint16_t)0x0004) /*!< PE[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PF         ((uint16_t)0x0005) /*!< PF[0] pin */
N
N/** 
N  * @brief  EXTI1 configuration  
N  */ 
N#define SYSCFG_EXTICR1_EXTI1_PA         ((uint16_t)0x0000) /*!< PA[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PB         ((uint16_t)0x0010) /*!< PB[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PC         ((uint16_t)0x0020) /*!< PC[1] pin */
N//#define SYSCFG_EXTICR1_EXTI1_PD         ((uint16_t)0x0030) /*!< PD[1] pin */
N//#define SYSCFG_EXTICR1_EXTI1_PE         ((uint16_t)0x0040) /*!< PE[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PF         ((uint16_t)0x0050) /*!< PF[1] pin */
N
N/** 
N  * @brief  EXTI2 configuration  
N  */
N#define SYSCFG_EXTICR1_EXTI2_PA         ((uint16_t)0x0000) /*!< PA[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PB         ((uint16_t)0x0100) /*!< PB[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PC         ((uint16_t)0x0200) /*!< PC[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PD         ((uint16_t)0x0300) /*!< PD[2] pin */
N//#define SYSCFG_EXTICR1_EXTI2_PE         ((uint16_t)0x0400) /*!< PE[2] pin */
N//#define SYSCFG_EXTICR1_EXTI2_PF         ((uint16_t)0x0500) /*!< PF[2] pin */
N
N/** 
N  * @brief  EXTI3 configuration  
N  */
N#define SYSCFG_EXTICR1_EXTI3_PA         ((uint16_t)0x0000) /*!< PA[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PB         ((uint16_t)0x1000) /*!< PB[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PC         ((uint16_t)0x2000) /*!< PC[3] pin */
N//#define SYSCFG_EXTICR1_EXTI3_PD         ((uint16_t)0x3000) /*!< PD[3] pin */
N//#define SYSCFG_EXTICR1_EXTI3_PE         ((uint16_t)0x4000) /*!< PE[3] pin */
N//#define SYSCFG_EXTICR1_EXTI3_PF         ((uint16_t)0x5000) /*!< PF[3] pin */
N
N/*****************  Bit definition for SYSCFG_EXTICR2 register  *****************/
N#define SYSCFG_EXTICR2_EXTI4            ((uint16_t)0x000F) /*!< EXTI 4 configuration */
N#define SYSCFG_EXTICR2_EXTI5            ((uint16_t)0x00F0) /*!< EXTI 5 configuration */
N#define SYSCFG_EXTICR2_EXTI6            ((uint16_t)0x0F00) /*!< EXTI 6 configuration */
N#define SYSCFG_EXTICR2_EXTI7            ((uint16_t)0xF000) /*!< EXTI 7 configuration */
N
N/** 
N  * @brief  EXTI4 configuration  
N  */
N#define SYSCFG_EXTICR2_EXTI4_PA         ((uint16_t)0x0000) /*!< PA[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PB         ((uint16_t)0x0001) /*!< PB[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PC         ((uint16_t)0x0002) /*!< PC[4] pin */
N//#define SYSCFG_EXTICR2_EXTI4_PD         ((uint16_t)0x0003) /*!< PD[4] pin */
N//#define SYSCFG_EXTICR2_EXTI4_PE         ((uint16_t)0x0004) /*!< PE[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PF         ((uint16_t)0x0005) /*!< PF[4] pin */
N
N/** 
N  * @brief  EXTI5 configuration  
N  */
N#define SYSCFG_EXTICR2_EXTI5_PA         ((uint16_t)0x0000) /*!< PA[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PB         ((uint16_t)0x0010) /*!< PB[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PC         ((uint16_t)0x0020) /*!< PC[5] pin */
N//#define SYSCFG_EXTICR2_EXTI5_PD         ((uint16_t)0x0030) /*!< PD[5] pin */
N//#define SYSCFG_EXTICR2_EXTI5_PE         ((uint16_t)0x0040) /*!< PE[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PF         ((uint16_t)0x0050) /*!< PF[5] pin */
N
N/** 
N  * @brief  EXTI6 configuration  
N  */
N#define SYSCFG_EXTICR2_EXTI6_PA         ((uint16_t)0x0000) /*!< PA[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PB         ((uint16_t)0x0100) /*!< PB[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PC         ((uint16_t)0x0200) /*!< PC[6] pin */
N//#define SYSCFG_EXTICR2_EXTI6_PD         ((uint16_t)0x0300) /*!< PD[6] pin */
N//#define SYSCFG_EXTICR2_EXTI6_PE         ((uint16_t)0x0400) /*!< PE[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PF         ((uint16_t)0x0500) /*!< PF[6] pin */
N
N/** 
N  * @brief  EXTI7 configuration  
N  */
N#define SYSCFG_EXTICR2_EXTI7_PA         ((uint16_t)0x0000) /*!< PA[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PB         ((uint16_t)0x1000) /*!< PB[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PC         ((uint16_t)0x2000) /*!< PC[7] pin */
N//#define SYSCFG_EXTICR2_EXTI7_PD         ((uint16_t)0x3000) /*!< PD[7] pin */
N//#define SYSCFG_EXTICR2_EXTI7_PE         ((uint16_t)0x4000) /*!< PE[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PF         ((uint16_t)0x5000) /*!< PF[7] pin */
N
N/*****************  Bit definition for SYSCFG_EXTICR3 register  *****************/
N#define SYSCFG_EXTICR3_EXTI8            ((uint16_t)0x000F) /*!< EXTI 8 configuration */
N#define SYSCFG_EXTICR3_EXTI9            ((uint16_t)0x00F0) /*!< EXTI 9 configuration */
N#define SYSCFG_EXTICR3_EXTI10           ((uint16_t)0x0F00) /*!< EXTI 10 configuration */
N#define SYSCFG_EXTICR3_EXTI11           ((uint16_t)0xF000) /*!< EXTI 11 configuration */
N
N/** 
N  * @brief  EXTI8 configuration  
N  */
N#define SYSCFG_EXTICR3_EXTI8_PA         ((uint16_t)0x0000) /*!< PA[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PB         ((uint16_t)0x0001) /*!< PB[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PC         ((uint16_t)0x0002) /*!< PC[8] pin */
N//#define SYSCFG_EXTICR3_EXTI8_PD         ((uint16_t)0x0003) /*!< PD[8] pin */
N//#define SYSCFG_EXTICR3_EXTI8_PE         ((uint16_t)0x0004) /*!< PE[8] pin */
N
N/** 
N  * @brief  EXTI9 configuration  
N  */
N#define SYSCFG_EXTICR3_EXTI9_PA         ((uint16_t)0x0000) /*!< PA[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PB         ((uint16_t)0x0010) /*!< PB[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PC         ((uint16_t)0x0020) /*!< PC[9] pin */
N//#define SYSCFG_EXTICR3_EXTI9_PD         ((uint16_t)0x0030) /*!< PD[9] pin */
N//#define SYSCFG_EXTICR3_EXTI9_PE         ((uint16_t)0x0040) /*!< PE[9] pin */
N//#define SYSCFG_EXTICR3_EXTI9_PF         ((uint16_t)0x0050) /*!< PF[9] pin */
N
N/** 
N  * @brief  EXTI10 configuration  
N  */
N#define SYSCFG_EXTICR3_EXTI10_PA        ((uint16_t)0x0000) /*!< PA[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PB        ((uint16_t)0x0100) /*!< PB[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PC        ((uint16_t)0x0200) /*!< PC[10] pin */
N//#define SYSCFG_EXTICR3_EXTI10_PD        ((uint16_t)0x0300) /*!< PE[10] pin */
N//#define SYSCFG_EXTICR3_EXTI10_PE        ((uint16_t)0x0400) /*!< PD[10] pin */
N//#define SYSCFG_EXTICR3_EXTI10_PF        ((uint16_t)0x0500) /*!< PF[10] pin */
N
N/** 
N  * @brief  EXTI11 configuration  
N  */
N#define SYSCFG_EXTICR3_EXTI11_PA        ((uint16_t)0x0000) /*!< PA[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PB        ((uint16_t)0x1000) /*!< PB[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PC        ((uint16_t)0x2000) /*!< PC[11] pin */
N//#define SYSCFG_EXTICR3_EXTI11_PD        ((uint16_t)0x3000) /*!< PD[11] pin */
N//#define SYSCFG_EXTICR3_EXTI11_PE        ((uint16_t)0x4000) /*!< PE[11] pin */
N
N/*****************  Bit definition for SYSCFG_EXTICR4 register  *****************/
N#define SYSCFG_EXTICR4_EXTI12           ((uint16_t)0x000F) /*!< EXTI 12 configuration */
N#define SYSCFG_EXTICR4_EXTI13           ((uint16_t)0x00F0) /*!< EXTI 13 configuration */
N#define SYSCFG_EXTICR4_EXTI14           ((uint16_t)0x0F00) /*!< EXTI 14 configuration */
N#define SYSCFG_EXTICR4_EXTI15           ((uint16_t)0xF000) /*!< EXTI 15 configuration */
N
N/** 
N  * @brief  EXTI12 configuration  
N  */
N#define SYSCFG_EXTICR4_EXTI12_PA        ((uint16_t)0x0000) /*!< PA[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PB        ((uint16_t)0x0001) /*!< PB[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PC        ((uint16_t)0x0002) /*!< PC[12] pin */
N//#define SYSCFG_EXTICR4_EXTI12_PD        ((uint16_t)0x0003) /*!< PD[12] pin */
N//#define SYSCFG_EXTICR4_EXTI12_PE        ((uint16_t)0x0004) /*!< PE[12] pin */
N
N/** 
N  * @brief  EXTI13 configuration  
N  */
N#define SYSCFG_EXTICR4_EXTI13_PA        ((uint16_t)0x0000) /*!< PA[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PB        ((uint16_t)0x0010) /*!< PB[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PC        ((uint16_t)0x0020) /*!< PC[13] pin */
N//#define SYSCFG_EXTICR4_EXTI13_PD        ((uint16_t)0x0030) /*!< PD[13] pin */
N//#define SYSCFG_EXTICR4_EXTI13_PE        ((uint16_t)0x0040) /*!< PE[13] pin */
N
N/** 
N  * @brief  EXTI14 configuration  
N  */
N#define SYSCFG_EXTICR4_EXTI14_PA        ((uint16_t)0x0000) /*!< PA[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PB        ((uint16_t)0x0100) /*!< PB[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PC        ((uint16_t)0x0200) /*!< PC[14] pin */
N//#define SYSCFG_EXTICR4_EXTI14_PD        ((uint16_t)0x0300) /*!< PD[14] pin */
N//#define SYSCFG_EXTICR4_EXTI14_PE        ((uint16_t)0x0400) /*!< PE[14] pin */
N
N/** 
N  * @brief  EXTI15 configuration  
N  */
N#define SYSCFG_EXTICR4_EXTI15_PA        ((uint16_t)0x0000) /*!< PA[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PB        ((uint16_t)0x1000) /*!< PB[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PC        ((uint16_t)0x2000) /*!< PC[15] pin */
N//#define SYSCFG_EXTICR4_EXTI15_PD        ((uint16_t)0x3000) /*!< PD[15] pin */
N//#define SYSCFG_EXTICR4_EXTI15_PE        ((uint16_t)0x4000) /*!< PE[15] pin */
N
N/*****************  Bit definition for SYSCFG_CFGR2 register  ****************/
N#define SYSCFG_CFGR2_LOCKUP_LOCK               ((uint32_t)0x00000001) /*!< Enables and locks the PVD connection with Timer1 Break Input and also the PVD_EN and PVDSEL[2:0] bits of the Power Control Interface */
N#define SYSCFG_CFGR2_PVD_LOCK                  ((uint32_t)0x00000004) /*!< Enables and locks the LOCKUP (Hardfault) output of CortexM0 with Break Input of TIMER1 */
N
N/* Old Bit definition maintained for legacy purpose */
N
N
N/*****************  Bit definition for SYSCFG_xxx ISR Wrapper register  ****************/
N//#define SYSCFG_ITLINE0_SR_EWDG                ((uint32_t)0x00000001) /*!< EWDG interrupt */
N//#define SYSCFG_ITLINE1_SR_PVDOUT              ((uint32_t)0x00000001) /*!< Power voltage detection -> exti[31] Interrupt */
N//#define SYSCFG_ITLINE1_SR_VDDIO2              ((uint32_t)0x00000002) /*!< VDDIO2 -> exti[16] Interrupt */
N//#define SYSCFG_ITLINE2_SR_RTC_WAKEUP          ((uint32_t)0x00000001) /*!< RTC WAKEUP -> exti[20] Interrupt */
N//#define SYSCFG_ITLINE2_SR_RTC_TSTAMP          ((uint32_t)0x00000002) /*!< RTC Time Stamp -> exti[19] interrupt */
N//#define SYSCFG_ITLINE2_SR_RTC_ALRA            ((uint32_t)0x00000003) /*!< RTC Alarm -> exti[17] interrupt .... */
N//#define SYSCFG_ITLINE3_SR_FLASH_ITF           ((uint32_t)0x00000001) /*!< Flash ITF Interrupt */
N//#define SYSCFG_ITLINE4_SR_CRS                 ((uint32_t)0x00000001) /*!< CRS interrupt */
N//#define SYSCFG_ITLINE4_SR_CLK_CTRL            ((uint32_t)0x00000002) /*!< CLK CTRL interrupt */
N//#define SYSCFG_ITLINE5_SR_EXTI0               ((uint32_t)0x00000001) /*!< External Interrupt 0 */
N//#define SYSCFG_ITLINE5_SR_EXTI1               ((uint32_t)0x00000002) /*!< External Interrupt 1 */
N//#define SYSCFG_ITLINE6_SR_EXTI2               ((uint32_t)0x00000001) /*!< External Interrupt 2 */
N//#define SYSCFG_ITLINE6_SR_EXTI3               ((uint32_t)0x00000002) /*!< External Interrupt 3 */
N//#define SYSCFG_ITLINE7_SR_EXTI4               ((uint32_t)0x00000001) /*!< External Interrupt 15 to 4 */
N//#define SYSCFG_ITLINE7_SR_EXTI5               ((uint32_t)0x00000002) /*!< External Interrupt 15 to 4 */
N//#define SYSCFG_ITLINE7_SR_EXTI6               ((uint32_t)0x00000004) /*!< External Interrupt 15 to 4 */
N//#define SYSCFG_ITLINE7_SR_EXTI7               ((uint32_t)0x00000008) /*!< External Interrupt 15 to 4 */
N//#define SYSCFG_ITLINE7_SR_EXTI8               ((uint32_t)0x00000010) /*!< External Interrupt 15 to 4 */
N//#define SYSCFG_ITLINE7_SR_EXTI9               ((uint32_t)0x00000020) /*!< External Interrupt 15 to 4 */
N//#define SYSCFG_ITLINE7_SR_EXTI10              ((uint32_t)0x00000040) /*!< External Interrupt 15 to 4 */
N//#define SYSCFG_ITLINE7_SR_EXTI11              ((uint32_t)0x00000080) /*!< External Interrupt 15 to 4 */
N//#define SYSCFG_ITLINE7_SR_EXTI12              ((uint32_t)0x00000100) /*!< External Interrupt 15 to 4 */
N//#define SYSCFG_ITLINE7_SR_EXTI13              ((uint32_t)0x00000200) /*!< External Interrupt 15 to 4 */
N//#define SYSCFG_ITLINE7_SR_EXTI14              ((uint32_t)0x00000400) /*!< External Interrupt 15 to 4 */
N//#define SYSCFG_ITLINE7_SR_EXTI15              ((uint32_t)0x00000800) /*!< External Interrupt 15 to 4 */
N//#define SYSCFG_ITLINE8_SR_TSC_EOA             ((uint32_t)0x00000001) /*!< Touch control EOA Interrupt */
N//#define SYSCFG_ITLINE8_SR_TSC_MCE             ((uint32_t)0x00000002) /*!< Touch control MCE Interrupt */
N//#define SYSCFG_ITLINE9_SR_DMA1_CH1            ((uint32_t)0x00000001) /*!< DMA1 Channel 1 Interrupt */
N//#define SYSCFG_ITLINE10_SR_DMA1_CH2           ((uint32_t)0x00000001) /*!< DMA1 Channel 2 Interrupt */
N//#define SYSCFG_ITLINE10_SR_DMA1_CH3           ((uint32_t)0x00000002) /*!< DMA2 Channel 3 Interrupt */
N//#define SYSCFG_ITLINE10_SR_DMA2_CH1           ((uint32_t)0x00000004) /*!< DMA2 Channel 1 Interrupt */
N//#define SYSCFG_ITLINE10_SR_DMA2_CH2           ((uint32_t)0x00000008) /*!< DMA2 Channel 2 Interrupt */
N//#define SYSCFG_ITLINE11_SR_DMA1_CH4           ((uint32_t)0x00000001) /*!< DMA1 Channel 4 Interrupt */
N//#define SYSCFG_ITLINE11_SR_DMA1_CH5           ((uint32_t)0x00000002) /*!< DMA1 Channel 5 Interrupt */
N//#define SYSCFG_ITLINE11_SR_DMA1_CH6           ((uint32_t)0x00000004) /*!< DMA1 Channel 6 Interrupt */
N//#define SYSCFG_ITLINE11_SR_DMA1_CH7           ((uint32_t)0x00000008) /*!< DMA1 Channel 7 Interrupt */
N//#define SYSCFG_ITLINE11_SR_DMA2_CH3           ((uint32_t)0x00000010) /*!< DMA2 Channel 3 Interrupt */
N//#define SYSCFG_ITLINE11_SR_DMA2_CH4           ((uint32_t)0x00000020) /*!< DMA2 Channel 4 Interrupt */
N//#define SYSCFG_ITLINE11_SR_DMA2_CH5           ((uint32_t)0x00000040) /*!< DMA2 Channel 5 Interrupt */
N//#define SYSCFG_ITLINE12_SR_ADC                ((uint32_t)0x00000001) /*!< ADC Interrupt */
N//#define SYSCFG_ITLINE12_SR_COMP1              ((uint32_t)0x00000002) /*!< COMP1 Interrupt -> exti[21] */
N//#define SYSCFG_ITLINE12_SR_COMP2              ((uint32_t)0x00000004) /*!< COMP2 Interrupt -> exti[22] */
N//#define SYSCFG_ITLINE13_SR_TIM1_BRK           ((uint32_t)0x00000001) /*!< TIM1 BRK Interrupt */
N//#define SYSCFG_ITLINE13_SR_TIM1_UPD           ((uint32_t)0x00000002) /*!< TIM1 UPD Interrupt */
N//#define SYSCFG_ITLINE13_SR_TIM1_TRG           ((uint32_t)0x00000004) /*!< TIM1 TRG Interrupt */
N//#define SYSCFG_ITLINE13_SR_TIM1_CCU           ((uint32_t)0x00000008) /*!< TIM1 CCU Interrupt */
N//#define SYSCFG_ITLINE14_SR_TIM1_CC            ((uint32_t)0x00000001) /*!< TIM1 CC Interrupt */
N//#define SYSCFG_ITLINE15_SR_TIM2_GLB           ((uint32_t)0x00000001) /*!< TIM2 GLB Interrupt */
N//#define SYSCFG_ITLINE16_SR_TIM3_GLB           ((uint32_t)0x00000001) /*!< TIM3 GLB Interrupt */
N//#define SYSCFG_ITLINE17_SR_DAC                ((uint32_t)0x00000001) /*!< DAC Interrupt */
N//#define SYSCFG_ITLINE17_SR_TIM6_GLB           ((uint32_t)0x00000002) /*!< TIM6 GLB Interrupt */
N//#define SYSCFG_ITLINE18_SR_TIM7_GLB           ((uint32_t)0x00000001) /*!< TIM7 GLB Interrupt */
N//#define SYSCFG_ITLINE19_SR_TIM14_GLB          ((uint32_t)0x00000001) /*!< TIM14 GLB Interrupt */
N//#define SYSCFG_ITLINE20_SR_TIM15_GLB          ((uint32_t)0x00000001) /*!< TIM15 GLB Interrupt */
N//#define SYSCFG_ITLINE21_SR_TIM16_GLB          ((uint32_t)0x00000001) /*!< TIM16 GLB Interrupt */
N//#define SYSCFG_ITLINE22_SR_TIM17_GLB          ((uint32_t)0x00000001) /*!< TIM17 GLB Interrupt */
N//#define SYSCFG_ITLINE23_SR_I2C1_GLB           ((uint32_t)0x00000001) /*!< I2C1 GLB Interrupt -> exti[23] */
N//#define SYSCFG_ITLINE24_SR_I2C2_GLB           ((uint32_t)0x00000001) /*!< I2C2 GLB Interrupt */
N//#define SYSCFG_ITLINE25_SR_SPI1               ((uint32_t)0x00000001) /*!< SPI1 Interrupt */
N//#define SYSCFG_ITLINE26_SR_SPI2               ((uint32_t)0x00000001) /*!< SPI2  Interrupt */
N//#define SYSCFG_ITLINE27_SR_USART1_GLB         ((uint32_t)0x00000001) /*!< USART1 GLB Interrupt -> exti[25] */
N//#define SYSCFG_ITLINE28_SR_USART2_GLB         ((uint32_t)0x00000001) /*!< USART2 GLB Interrupt -> exti[26] */
N//#define SYSCFG_ITLINE29_SR_USART3_GLB         ((uint32_t)0x00000001) /*!< USART3 GLB Interrupt -> exti[28] */
N//#define SYSCFG_ITLINE29_SR_USART4_GLB         ((uint32_t)0x00000002) /*!< USART4 GLB Interrupt */
N//#define SYSCFG_ITLINE29_SR_USART5_GLB         ((uint32_t)0x00000004) /*!< USART5 GLB Interrupt */
N//#define SYSCFG_ITLINE29_SR_USART6_GLB         ((uint32_t)0x00000008) /*!< USART6 GLB Interrupt */
N//#define SYSCFG_ITLINE29_SR_USART7_GLB         ((uint32_t)0x00000010) /*!< USART7 GLB Interrupt */
N//#define SYSCFG_ITLINE29_SR_USART8_GLB         ((uint32_t)0x00000020) /*!< USART8 GLB Interrupt */
N//#define SYSCFG_ITLINE30_SR_CAN                ((uint32_t)0x00000001) /*!< CAN Interrupt */
N//#define SYSCFG_ITLINE30_SR_CEC                ((uint32_t)0x00000002) /*!< CEC Interrupt */
N
N/******************************************************************************/
N/*                                                                            */
N/*                               Timers (TIM)                                 */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for TIM_CR1 register  ********************/
N#define  TIM_CR1_CEN                         ((uint16_t)0x0001)            /*!<Counter enable */
N#define  TIM_CR1_UDIS                        ((uint16_t)0x0002)            /*!<Update disable */
N#define  TIM_CR1_URS                         ((uint16_t)0x0004)            /*!<Update request source */
N#define  TIM_CR1_OPM                         ((uint16_t)0x0008)            /*!<One pulse mode */
N#define  TIM_CR1_DIR                         ((uint16_t)0x0010)            /*!<Direction */
N
N#define  TIM_CR1_CMS                         ((uint16_t)0x0060)            /*!<CMS[1:0] bits (Center-aligned mode selection) */
N#define  TIM_CR1_CMS_0                       ((uint16_t)0x0020)            /*!<Bit 0 */
N#define  TIM_CR1_CMS_1                       ((uint16_t)0x0040)            /*!<Bit 1 */
N
N#define  TIM_CR1_ARPE                        ((uint16_t)0x0080)            /*!<Auto-reload preload enable */
N
N#define  TIM_CR1_CKD                         ((uint16_t)0x0300)            /*!<CKD[1:0] bits (clock division) */
N#define  TIM_CR1_CKD_0                       ((uint16_t)0x0100)            /*!<Bit 0 */
N#define  TIM_CR1_CKD_1                       ((uint16_t)0x0200)            /*!<Bit 1 */
N
N/*******************  Bit definition for TIM_CR2 register  ********************/
N#define  TIM_CR2_CCPC                        ((uint16_t)0x0001)            /*!<Capture/Compare Preloaded Control */
N#define  TIM_CR2_CCUS                        ((uint16_t)0x0004)            /*!<Capture/Compare Control Update Selection */
N#define  TIM_CR2_CCDS                        ((uint16_t)0x0008)            /*!<Capture/Compare DMA Selection */
N
N#define  TIM_CR2_MMS                         ((uint16_t)0x0070)            /*!<MMS[2:0] bits (Master Mode Selection) */
N#define  TIM_CR2_MMS_0                       ((uint16_t)0x0010)            /*!<Bit 0 */
N#define  TIM_CR2_MMS_1                       ((uint16_t)0x0020)            /*!<Bit 1 */
N#define  TIM_CR2_MMS_2                       ((uint16_t)0x0040)            /*!<Bit 2 */
N
N#define  TIM_CR2_TI1S                        ((uint16_t)0x0080)            /*!<TI1 Selection */
N#define  TIM_CR2_OIS1                        ((uint16_t)0x0100)            /*!<Output Idle state 1 (OC1 output) */
N#define  TIM_CR2_OIS1N                       ((uint16_t)0x0200)            /*!<Output Idle state 1 (OC1N output) */
N#define  TIM_CR2_OIS2                        ((uint16_t)0x0400)            /*!<Output Idle state 2 (OC2 output) */
N#define  TIM_CR2_OIS2N                       ((uint16_t)0x0800)            /*!<Output Idle state 2 (OC2N output) */
N#define  TIM_CR2_OIS3                        ((uint16_t)0x1000)            /*!<Output Idle state 3 (OC3 output) */
N#define  TIM_CR2_OIS3N                       ((uint16_t)0x2000)            /*!<Output Idle state 3 (OC3N output) */
N#define  TIM_CR2_OIS4                        ((uint16_t)0x4000)            /*!<Output Idle state 4 (OC4 output) */
N
N/*******************  Bit definition for TIM_SMCR register  *******************/
N#define  TIM_SMCR_SMS                        ((uint16_t)0x0007)            /*!<SMS[2:0] bits (Slave mode selection) */
N#define  TIM_SMCR_SMS_0                      ((uint16_t)0x0001)            /*!<Bit 0 */
N#define  TIM_SMCR_SMS_1                      ((uint16_t)0x0002)            /*!<Bit 1 */
N#define  TIM_SMCR_SMS_2                      ((uint16_t)0x0004)            /*!<Bit 2 */
N
N#define  TIM_SMCR_OCCS                       ((uint16_t)0x0008)            /*!< OCREF clear selection */
N
N#define  TIM_SMCR_TS                         ((uint16_t)0x0070)            /*!<TS[2:0] bits (Trigger selection) */
N#define  TIM_SMCR_TS_0                       ((uint16_t)0x0010)            /*!<Bit 0 */
N#define  TIM_SMCR_TS_1                       ((uint16_t)0x0020)            /*!<Bit 1 */
N#define  TIM_SMCR_TS_2                       ((uint16_t)0x0040)            /*!<Bit 2 */
N
N#define  TIM_SMCR_MSM                        ((uint16_t)0x0080)            /*!<Master/slave mode */
N
N#define  TIM_SMCR_ETF                        ((uint16_t)0x0F00)            /*!<ETF[3:0] bits (External trigger filter) */
N#define  TIM_SMCR_ETF_0                      ((uint16_t)0x0100)            /*!<Bit 0 */
N#define  TIM_SMCR_ETF_1                      ((uint16_t)0x0200)            /*!<Bit 1 */
N#define  TIM_SMCR_ETF_2                      ((uint16_t)0x0400)            /*!<Bit 2 */
N#define  TIM_SMCR_ETF_3                      ((uint16_t)0x0800)            /*!<Bit 3 */
N
N#define  TIM_SMCR_ETPS                       ((uint16_t)0x3000)            /*!<ETPS[1:0] bits (External trigger prescaler) */
N#define  TIM_SMCR_ETPS_0                     ((uint16_t)0x1000)            /*!<Bit 0 */
N#define  TIM_SMCR_ETPS_1                     ((uint16_t)0x2000)            /*!<Bit 1 */
N
N#define  TIM_SMCR_ECE                        ((uint16_t)0x4000)            /*!<External clock enable */
N#define  TIM_SMCR_ETP                        ((uint16_t)0x8000)            /*!<External trigger polarity */
N
N/*******************  Bit definition for TIM_DIER register  *******************/
N#define  TIM_DIER_UIE                        ((uint16_t)0x0001)            /*!<Update interrupt enable */
N#define  TIM_DIER_CC1IE                      ((uint16_t)0x0002)            /*!<Capture/Compare 1 interrupt enable */
N#define  TIM_DIER_CC2IE                      ((uint16_t)0x0004)            /*!<Capture/Compare 2 interrupt enable */
N#define  TIM_DIER_CC3IE                      ((uint16_t)0x0008)            /*!<Capture/Compare 3 interrupt enable */
N#define  TIM_DIER_CC4IE                      ((uint16_t)0x0010)            /*!<Capture/Compare 4 interrupt enable */
N#define  TIM_DIER_COMIE                      ((uint16_t)0x0020)            /*!<COM interrupt enable */
N#define  TIM_DIER_TIE                        ((uint16_t)0x0040)            /*!<Trigger interrupt enable */
N#define  TIM_DIER_BIE                        ((uint16_t)0x0080)            /*!<Break interrupt enable */
N#define  TIM_DIER_UDE                        ((uint16_t)0x0100)            /*!<Update DMA request enable */
N#define  TIM_DIER_CC1DE                      ((uint16_t)0x0200)            /*!<Capture/Compare 1 DMA request enable */
N#define  TIM_DIER_CC2DE                      ((uint16_t)0x0400)            /*!<Capture/Compare 2 DMA request enable */
N#define  TIM_DIER_CC3DE                      ((uint16_t)0x0800)            /*!<Capture/Compare 3 DMA request enable */
N#define  TIM_DIER_CC4DE                      ((uint16_t)0x1000)            /*!<Capture/Compare 4 DMA request enable */
N#define  TIM_DIER_COMDE                      ((uint16_t)0x2000)            /*!<COM DMA request enable */
N#define  TIM_DIER_TDE                        ((uint16_t)0x4000)            /*!<Trigger DMA request enable */
N
N/********************  Bit definition for TIM_SR register  ********************/
N#define  TIM_SR_UIF                          ((uint16_t)0x0001)            /*!<Update interrupt Flag */
N#define  TIM_SR_CC1IF                        ((uint16_t)0x0002)            /*!<Capture/Compare 1 interrupt Flag */
N#define  TIM_SR_CC2IF                        ((uint16_t)0x0004)            /*!<Capture/Compare 2 interrupt Flag */
N#define  TIM_SR_CC3IF                        ((uint16_t)0x0008)            /*!<Capture/Compare 3 interrupt Flag */
N#define  TIM_SR_CC4IF                        ((uint16_t)0x0010)            /*!<Capture/Compare 4 interrupt Flag */
N#define  TIM_SR_COMIF                        ((uint16_t)0x0020)            /*!<COM interrupt Flag */
N#define  TIM_SR_TIF                          ((uint16_t)0x0040)            /*!<Trigger interrupt Flag */
N#define  TIM_SR_BIF                          ((uint16_t)0x0080)            /*!<Break interrupt Flag */
N#define  TIM_SR_CC1OF                        ((uint16_t)0x0200)            /*!<Capture/Compare 1 Overcapture Flag */
N#define  TIM_SR_CC2OF                        ((uint16_t)0x0400)            /*!<Capture/Compare 2 Overcapture Flag */
N#define  TIM_SR_CC3OF                        ((uint16_t)0x0800)            /*!<Capture/Compare 3 Overcapture Flag */
N#define  TIM_SR_CC4OF                        ((uint16_t)0x1000)            /*!<Capture/Compare 4 Overcapture Flag */
N
N/*******************  Bit definition for TIM_EGR register  ********************/
N#define  TIM_EGR_UG                          ((uint8_t)0x01)               /*!<Update Generation */
N#define  TIM_EGR_CC1G                        ((uint8_t)0x02)               /*!<Capture/Compare 1 Generation */
N#define  TIM_EGR_CC2G                        ((uint8_t)0x04)               /*!<Capture/Compare 2 Generation */
N#define  TIM_EGR_CC3G                        ((uint8_t)0x08)               /*!<Capture/Compare 3 Generation */
N#define  TIM_EGR_CC4G                        ((uint8_t)0x10)               /*!<Capture/Compare 4 Generation */
N#define  TIM_EGR_COMG                        ((uint8_t)0x20)               /*!<Capture/Compare Control Update Generation */
N#define  TIM_EGR_TG                          ((uint8_t)0x40)               /*!<Trigger Generation */
N#define  TIM_EGR_BG                          ((uint8_t)0x80)               /*!<Break Generation */
N
N/******************  Bit definition for TIM_CCMR1 register  *******************/
N#define  TIM_CCMR1_CC1S                      ((uint16_t)0x0003)            /*!<CC1S[1:0] bits (Capture/Compare 1 Selection) */
N#define  TIM_CCMR1_CC1S_0                    ((uint16_t)0x0001)            /*!<Bit 0 */
N#define  TIM_CCMR1_CC1S_1                    ((uint16_t)0x0002)            /*!<Bit 1 */
N
N#define  TIM_CCMR1_OC1FE                     ((uint16_t)0x0004)            /*!<Output Compare 1 Fast enable */
N#define  TIM_CCMR1_OC1PE                     ((uint16_t)0x0008)            /*!<Output Compare 1 Preload enable */
N
N#define  TIM_CCMR1_OC1M                      ((uint16_t)0x0070)            /*!<OC1M[2:0] bits (Output Compare 1 Mode) */
N#define  TIM_CCMR1_OC1M_0                    ((uint16_t)0x0010)            /*!<Bit 0 */
N#define  TIM_CCMR1_OC1M_1                    ((uint16_t)0x0020)            /*!<Bit 1 */
N#define  TIM_CCMR1_OC1M_2                    ((uint16_t)0x0040)            /*!<Bit 2 */
N
N#define  TIM_CCMR1_OC1CE                     ((uint16_t)0x0080)            /*!<Output Compare 1Clear Enable */
N
N#define  TIM_CCMR1_CC2S                      ((uint16_t)0x0300)            /*!<CC2S[1:0] bits (Capture/Compare 2 Selection) */
N#define  TIM_CCMR1_CC2S_0                    ((uint16_t)0x0100)            /*!<Bit 0 */
N#define  TIM_CCMR1_CC2S_1                    ((uint16_t)0x0200)            /*!<Bit 1 */
N
N#define  TIM_CCMR1_OC2FE                     ((uint16_t)0x0400)            /*!<Output Compare 2 Fast enable */
N#define  TIM_CCMR1_OC2PE                     ((uint16_t)0x0800)            /*!<Output Compare 2 Preload enable */
N
N#define  TIM_CCMR1_OC2M                      ((uint16_t)0x7000)            /*!<OC2M[2:0] bits (Output Compare 2 Mode) */
N#define  TIM_CCMR1_OC2M_0                    ((uint16_t)0x1000)            /*!<Bit 0 */
N#define  TIM_CCMR1_OC2M_1                    ((uint16_t)0x2000)            /*!<Bit 1 */
N#define  TIM_CCMR1_OC2M_2                    ((uint16_t)0x4000)            /*!<Bit 2 */
N
N#define  TIM_CCMR1_OC2CE                     ((uint16_t)0x8000)            /*!<Output Compare 2 Clear Enable */
N
N/*----------------------------------------------------------------------------*/
N
N#define  TIM_CCMR1_IC1PSC                    ((uint16_t)0x000C)            /*!<IC1PSC[1:0] bits (Input Capture 1 Prescaler) */
N#define  TIM_CCMR1_IC1PSC_0                  ((uint16_t)0x0004)            /*!<Bit 0 */
N#define  TIM_CCMR1_IC1PSC_1                  ((uint16_t)0x0008)            /*!<Bit 1 */
N
N#define  TIM_CCMR1_IC1F                      ((uint16_t)0x00F0)            /*!<IC1F[3:0] bits (Input Capture 1 Filter) */
N#define  TIM_CCMR1_IC1F_0                    ((uint16_t)0x0010)            /*!<Bit 0 */
N#define  TIM_CCMR1_IC1F_1                    ((uint16_t)0x0020)            /*!<Bit 1 */
N#define  TIM_CCMR1_IC1F_2                    ((uint16_t)0x0040)            /*!<Bit 2 */
N#define  TIM_CCMR1_IC1F_3                    ((uint16_t)0x0080)            /*!<Bit 3 */
N
N#define  TIM_CCMR1_IC2PSC                    ((uint16_t)0x0C00)            /*!<IC2PSC[1:0] bits (Input Capture 2 Prescaler) */
N#define  TIM_CCMR1_IC2PSC_0                  ((uint16_t)0x0400)            /*!<Bit 0 */
N#define  TIM_CCMR1_IC2PSC_1                  ((uint16_t)0x0800)            /*!<Bit 1 */
N
N#define  TIM_CCMR1_IC2F                      ((uint16_t)0xF000)            /*!<IC2F[3:0] bits (Input Capture 2 Filter) */
N#define  TIM_CCMR1_IC2F_0                    ((uint16_t)0x1000)            /*!<Bit 0 */
N#define  TIM_CCMR1_IC2F_1                    ((uint16_t)0x2000)            /*!<Bit 1 */
N#define  TIM_CCMR1_IC2F_2                    ((uint16_t)0x4000)            /*!<Bit 2 */
N#define  TIM_CCMR1_IC2F_3                    ((uint16_t)0x8000)            /*!<Bit 3 */
N
N/******************  Bit definition for TIM_CCMR2 register  *******************/
N#define  TIM_CCMR2_CC3S                      ((uint16_t)0x0003)            /*!<CC3S[1:0] bits (Capture/Compare 3 Selection) */
N#define  TIM_CCMR2_CC3S_0                    ((uint16_t)0x0001)            /*!<Bit 0 */
N#define  TIM_CCMR2_CC3S_1                    ((uint16_t)0x0002)            /*!<Bit 1 */
N
N#define  TIM_CCMR2_OC3FE                     ((uint16_t)0x0004)            /*!<Output Compare 3 Fast enable */
N#define  TIM_CCMR2_OC3PE                     ((uint16_t)0x0008)            /*!<Output Compare 3 Preload enable */
N
N#define  TIM_CCMR2_OC3M                      ((uint16_t)0x0070)            /*!<OC3M[2:0] bits (Output Compare 3 Mode) */
N#define  TIM_CCMR2_OC3M_0                    ((uint16_t)0x0010)            /*!<Bit 0 */
N#define  TIM_CCMR2_OC3M_1                    ((uint16_t)0x0020)            /*!<Bit 1 */
N#define  TIM_CCMR2_OC3M_2                    ((uint16_t)0x0040)            /*!<Bit 2 */
N
N#define  TIM_CCMR2_OC3CE                     ((uint16_t)0x0080)            /*!<Output Compare 3 Clear Enable */
N
N#define  TIM_CCMR2_CC4S                      ((uint16_t)0x0300)            /*!<CC4S[1:0] bits (Capture/Compare 4 Selection) */
N#define  TIM_CCMR2_CC4S_0                    ((uint16_t)0x0100)            /*!<Bit 0 */
N#define  TIM_CCMR2_CC4S_1                    ((uint16_t)0x0200)            /*!<Bit 1 */
N
N#define  TIM_CCMR2_OC4FE                     ((uint16_t)0x0400)            /*!<Output Compare 4 Fast enable */
N#define  TIM_CCMR2_OC4PE                     ((uint16_t)0x0800)            /*!<Output Compare 4 Preload enable */
N
N#define  TIM_CCMR2_OC4M                      ((uint16_t)0x7000)            /*!<OC4M[2:0] bits (Output Compare 4 Mode) */
N#define  TIM_CCMR2_OC4M_0                    ((uint16_t)0x1000)            /*!<Bit 0 */
N#define  TIM_CCMR2_OC4M_1                    ((uint16_t)0x2000)            /*!<Bit 1 */
N#define  TIM_CCMR2_OC4M_2                    ((uint16_t)0x4000)            /*!<Bit 2 */
N
N#define  TIM_CCMR2_OC4CE                     ((uint16_t)0x8000)            /*!<Output Compare 4 Clear Enable */
N
N/*----------------------------------------------------------------------------*/
N
N#define  TIM_CCMR2_IC3PSC                    ((uint16_t)0x000C)            /*!<IC3PSC[1:0] bits (Input Capture 3 Prescaler) */
N#define  TIM_CCMR2_IC3PSC_0                  ((uint16_t)0x0004)            /*!<Bit 0 */
N#define  TIM_CCMR2_IC3PSC_1                  ((uint16_t)0x0008)            /*!<Bit 1 */
N
N#define  TIM_CCMR2_IC3F                      ((uint16_t)0x00F0)            /*!<IC3F[3:0] bits (Input Capture 3 Filter) */
N#define  TIM_CCMR2_IC3F_0                    ((uint16_t)0x0010)            /*!<Bit 0 */
N#define  TIM_CCMR2_IC3F_1                    ((uint16_t)0x0020)            /*!<Bit 1 */
N#define  TIM_CCMR2_IC3F_2                    ((uint16_t)0x0040)            /*!<Bit 2 */
N#define  TIM_CCMR2_IC3F_3                    ((uint16_t)0x0080)            /*!<Bit 3 */
N
N#define  TIM_CCMR2_IC4PSC                    ((uint16_t)0x0C00)            /*!<IC4PSC[1:0] bits (Input Capture 4 Prescaler) */
N#define  TIM_CCMR2_IC4PSC_0                  ((uint16_t)0x0400)            /*!<Bit 0 */
N#define  TIM_CCMR2_IC4PSC_1                  ((uint16_t)0x0800)            /*!<Bit 1 */
N
N#define  TIM_CCMR2_IC4F                      ((uint16_t)0xF000)            /*!<IC4F[3:0] bits (Input Capture 4 Filter) */
N#define  TIM_CCMR2_IC4F_0                    ((uint16_t)0x1000)            /*!<Bit 0 */
N#define  TIM_CCMR2_IC4F_1                    ((uint16_t)0x2000)            /*!<Bit 1 */
N#define  TIM_CCMR2_IC4F_2                    ((uint16_t)0x4000)            /*!<Bit 2 */
N#define  TIM_CCMR2_IC4F_3                    ((uint16_t)0x8000)            /*!<Bit 3 */
N
N/*******************  Bit definition for TIM_CCER register  *******************/
N#define  TIM_CCER_CC1E                       ((uint16_t)0x0001)            /*!<Capture/Compare 1 output enable */
N#define  TIM_CCER_CC1P                       ((uint16_t)0x0002)            /*!<Capture/Compare 1 output Polarity */
N#define  TIM_CCER_CC1NE                      ((uint16_t)0x0004)            /*!<Capture/Compare 1 Complementary output enable */
N#define  TIM_CCER_CC1NP                      ((uint16_t)0x0008)            /*!<Capture/Compare 1 Complementary output Polarity */
N#define  TIM_CCER_CC2E                       ((uint16_t)0x0010)            /*!<Capture/Compare 2 output enable */
N#define  TIM_CCER_CC2P                       ((uint16_t)0x0020)            /*!<Capture/Compare 2 output Polarity */
N#define  TIM_CCER_CC2NE                      ((uint16_t)0x0040)            /*!<Capture/Compare 2 Complementary output enable */
N#define  TIM_CCER_CC2NP                      ((uint16_t)0x0080)            /*!<Capture/Compare 2 Complementary output Polarity */
N#define  TIM_CCER_CC3E                       ((uint16_t)0x0100)            /*!<Capture/Compare 3 output enable */
N#define  TIM_CCER_CC3P                       ((uint16_t)0x0200)            /*!<Capture/Compare 3 output Polarity */
N#define  TIM_CCER_CC3NE                      ((uint16_t)0x0400)            /*!<Capture/Compare 3 Complementary output enable */
N#define  TIM_CCER_CC3NP                      ((uint16_t)0x0800)            /*!<Capture/Compare 3 Complementary output Polarity */
N#define  TIM_CCER_CC4E                       ((uint16_t)0x1000)            /*!<Capture/Compare 4 output enable */
N#define  TIM_CCER_CC4P                       ((uint16_t)0x2000)            /*!<Capture/Compare 4 output Polarity */
N/*******************  Bit definition for TIM_CNT register  ********************/
N#define  TIM_CNT_CNT                         ((uint16_t)0xFFFF)            /*!<Counter Value */
N
N/*******************  Bit definition for TIM_PSC register  ********************/
N#define  TIM_PSC_PSC                         ((uint16_t)0xFFFF)            /*!<Prescaler Value */
N
N/*******************  Bit definition for TIM_ARR register  ********************/
N#define  TIM_ARR_ARR                         ((uint16_t)0xFFFF)            /*!<actual auto-reload Value */
N
N/*******************  Bit definition for TIM_RCR register  ********************/
N#define  TIM_RCR_REP                         ((uint8_t)0xFF)               /*!<Repetition Counter Value */
N
N/*******************  Bit definition for TIM_CCR1 register  *******************/
N#define  TIM_CCR1_CCR1                       ((uint16_t)0xFFFF)            /*!<Capture/Compare 1 Value */
N
N/*******************  Bit definition for TIM_CCR2 register  *******************/
N#define  TIM_CCR2_CCR2                       ((uint16_t)0xFFFF)            /*!<Capture/Compare 2 Value */
N
N/*******************  Bit definition for TIM_CCR3 register  *******************/
N#define  TIM_CCR3_CCR3                       ((uint16_t)0xFFFF)            /*!<Capture/Compare 3 Value */
N
N/*******************  Bit definition for TIM_CCR4 register  *******************/
N#define  TIM_CCR4_CCR4                       ((uint16_t)0xFFFF)            /*!<Capture/Compare 4 Value */
N
N/*******************  Bit definition for TIM_BDTR register  *******************/
N#define  TIM_BDTR_DTG                        ((uint16_t)0x00FF)            /*!<DTG[0:7] bits (Dead-Time Generator set-up) */
N#define  TIM_BDTR_DTG_0                      ((uint16_t)0x0001)            /*!<Bit 0 */
N#define  TIM_BDTR_DTG_1                      ((uint16_t)0x0002)            /*!<Bit 1 */
N#define  TIM_BDTR_DTG_2                      ((uint16_t)0x0004)            /*!<Bit 2 */
N#define  TIM_BDTR_DTG_3                      ((uint16_t)0x0008)            /*!<Bit 3 */
N#define  TIM_BDTR_DTG_4                      ((uint16_t)0x0010)            /*!<Bit 4 */
N#define  TIM_BDTR_DTG_5                      ((uint16_t)0x0020)            /*!<Bit 5 */
N#define  TIM_BDTR_DTG_6                      ((uint16_t)0x0040)            /*!<Bit 6 */
N#define  TIM_BDTR_DTG_7                      ((uint16_t)0x0080)            /*!<Bit 7 */
N
N#define  TIM_BDTR_LOCK                       ((uint16_t)0x0300)            /*!<LOCK[1:0] bits (Lock Configuration) */
N#define  TIM_BDTR_LOCK_0                     ((uint16_t)0x0100)            /*!<Bit 0 */
N#define  TIM_BDTR_LOCK_1                     ((uint16_t)0x0200)            /*!<Bit 1 */
N
N#define  TIM_BDTR_OSSI                       ((uint16_t)0x0400)            /*!<Off-State Selection for Idle mode */
N#define  TIM_BDTR_OSSR                       ((uint16_t)0x0800)            /*!<Off-State Selection for Run mode */
N#define  TIM_BDTR_BKE                        ((uint16_t)0x1000)            /*!<Break enable */
N#define  TIM_BDTR_BKP                        ((uint16_t)0x2000)            /*!<Break Polarity */
N#define  TIM_BDTR_AOE                        ((uint16_t)0x4000)            /*!<Automatic Output enable */
N#define  TIM_BDTR_MOE                        ((uint16_t)0x8000)            /*!<Main Output enable */
N
N/*******************  Bit definition for TIM_DCR register  ********************/
N#define  TIM_DCR_DBA                         ((uint16_t)0x001F)            /*!<DBA[4:0] bits (DMA Base Address) */
N#define  TIM_DCR_DBA_0                       ((uint16_t)0x0001)            /*!<Bit 0 */
N#define  TIM_DCR_DBA_1                       ((uint16_t)0x0002)            /*!<Bit 1 */
N#define  TIM_DCR_DBA_2                       ((uint16_t)0x0004)            /*!<Bit 2 */
N#define  TIM_DCR_DBA_3                       ((uint16_t)0x0008)            /*!<Bit 3 */
N#define  TIM_DCR_DBA_4                       ((uint16_t)0x0010)            /*!<Bit 4 */
N
N#define  TIM_DCR_DBL                         ((uint16_t)0x1F00)            /*!<DBL[4:0] bits (DMA Burst Length) */
N#define  TIM_DCR_DBL_0                       ((uint16_t)0x0100)            /*!<Bit 0 */
N#define  TIM_DCR_DBL_1                       ((uint16_t)0x0200)            /*!<Bit 1 */
N#define  TIM_DCR_DBL_2                       ((uint16_t)0x0400)            /*!<Bit 2 */
N#define  TIM_DCR_DBL_3                       ((uint16_t)0x0800)            /*!<Bit 3 */
N#define  TIM_DCR_DBL_4                       ((uint16_t)0x1000)            /*!<Bit 4 */
N
N/*******************  Bit definition for TIM_DMAR register  *******************/
N#define  TIM_DMAR_DMAB                       ((uint16_t)0xFFFF)            /*!<DMA register for burst accesses */
N
N/*******************  Bit definition for TIM_OR register  *********************/
N#define TIM14_OR_TI1_RMP                       ((uint16_t)0x0003)            /*!<TI1_RMP[1:0] bits (TIM14 Input 4 remap) */
N#define TIM14_OR_TI1_RMP_0                     ((uint16_t)0x0001)            /*!<Bit 0 */
N#define TIM14_OR_TI1_RMP_1                     ((uint16_t)0x0002)            /*!<Bit 1 */
N
N
N/******************************************************************************/
N/*                                                                            */
N/*      Universal Synchronous Asynchronous Receiver Transmitter (USART)       */
N/*                                                                            */
N/******************************************************************************/
N/******************  Bit definition for USART_CR1 register  *******************/
N#define  USART_CR1_UE                        ((uint32_t)0x00000001)            /*!< USART Enable */
N#define  USART_CR1_UESM                      ((uint32_t)0x00000002)            /*!< USART Enable in STOP Mode */
N#define  USART_CR1_RE                        ((uint32_t)0x00000004)            /*!< Receiver Enable */
N#define  USART_CR1_TE                        ((uint32_t)0x00000008)            /*!< Transmitter Enable */
N#define  USART_CR1_IDLEIE                    ((uint32_t)0x00000010)            /*!< IDLE Interrupt Enable */
N#define  USART_CR1_RXNEIE                    ((uint32_t)0x00000020)            /*!< RXNE Interrupt Enable */
N#define  USART_CR1_TCIE                      ((uint32_t)0x00000040)            /*!< Transmission Complete Interrupt Enable */
N#define  USART_CR1_TXEIE                     ((uint32_t)0x00000080)            /*!< TXE Interrupt Enable */
N#define  USART_CR1_PEIE                      ((uint32_t)0x00000100)            /*!< PE Interrupt Enable */
N#define  USART_CR1_PS                        ((uint32_t)0x00000200)            /*!< Parity Selection */
N#define  USART_CR1_PCE                       ((uint32_t)0x00000400)            /*!< Parity Control Enable */
N#define  USART_CR1_WAKE                      ((uint32_t)0x00000800)            /*!< Receiver Wakeup method */
N#define  USART_CR1_M0                        ((uint32_t)0x00001000)            /*!< Word length */
N#define  USART_CR1_MME                       ((uint32_t)0x00002000)            /*!< Mute Mode Enable */
N#define  USART_CR1_CMIE                      ((uint32_t)0x00004000)            /*!< Character match interrupt enable */
N#define  USART_CR1_OVER8                     ((uint32_t)0x00008000)            /*!< Oversampling by 8-bit or 16-bit mode */
N#define  USART_CR1_DEDT                      ((uint32_t)0x001F0000)            /*!< DEDT[4:0] bits (Driver Enable Deassertion Time) */
N#define  USART_CR1_DEDT_0                    ((uint32_t)0x00010000)            /*!< Bit 0 */
N#define  USART_CR1_DEDT_1                    ((uint32_t)0x00020000)            /*!< Bit 1 */
N#define  USART_CR1_DEDT_2                    ((uint32_t)0x00040000)            /*!< Bit 2 */
N#define  USART_CR1_DEDT_3                    ((uint32_t)0x00080000)            /*!< Bit 3 */
N#define  USART_CR1_DEDT_4                    ((uint32_t)0x00100000)            /*!< Bit 4 */
N#define  USART_CR1_DEAT                      ((uint32_t)0x03E00000)            /*!< DEAT[4:0] bits (Driver Enable Assertion Time) */
N#define  USART_CR1_DEAT_0                    ((uint32_t)0x00200000)            /*!< Bit 0 */
N#define  USART_CR1_DEAT_1                    ((uint32_t)0x00400000)            /*!< Bit 1 */
N#define  USART_CR1_DEAT_2                    ((uint32_t)0x00800000)            /*!< Bit 2 */
N#define  USART_CR1_DEAT_3                    ((uint32_t)0x01000000)            /*!< Bit 3 */
N#define  USART_CR1_DEAT_4                    ((uint32_t)0x02000000)            /*!< Bit 4 */
N#define  USART_CR1_RTOIE                     ((uint32_t)0x04000000)            /*!< Receive Time Out interrupt enable */
N//#define  USART_CR1_EOBIE                     ((uint32_t)0x08000000)            /*!< End of Block interrupt enable */
N#define  USART_CR1_M1                        ((uint32_t)0x10000000)            /*!< End of Block interrupt enable */
N 
N#define  USART_CR1_M                         USART_CR1_M0 
N/******************  Bit definition for USART_CR2 register  *******************/
N#define  USART_CR2_ADDM7                     ((uint32_t)0x00000010)            /*!< 7-bit or 4-bit Address Detection */
N//#define  USART_CR2_LBDL                      ((uint32_t)0x00000020)            /*!< LIN Break Detection Length */
N//#define  USART_CR2_LBDIE                     ((uint32_t)0x00000040)            /*!< LIN Break Detection Interrupt Enable */
N#define  USART_CR2_LBCL                      ((uint32_t)0x00000100)            /*!< Last Bit Clock pulse */
N#define  USART_CR2_CPHA                      ((uint32_t)0x00000200)            /*!< Clock Phase */
N#define  USART_CR2_CPOL                      ((uint32_t)0x00000400)            /*!< Clock Polarity */
N#define  USART_CR2_CLKEN                     ((uint32_t)0x00000800)            /*!< Clock Enable */
N#define  USART_CR2_STOP                      ((uint32_t)0x00003000)            /*!< STOP[1:0] bits (STOP bits) */
N#define  USART_CR2_STOP_0                    ((uint32_t)0x00001000)            /*!< Bit 0 */
N#define  USART_CR2_STOP_1                    ((uint32_t)0x00002000)            /*!< Bit 1 */
N#define  USART_CR2_LINEN                     ((uint32_t)0x00004000)            /*!< LIN mode enable */
N#define  USART_CR2_SWAP                      ((uint32_t)0x00008000)            /*!< SWAP TX/RX pins */
N#define  USART_CR2_RXINV                     ((uint32_t)0x00010000)            /*!< RX pin active level inversion */
N#define  USART_CR2_TXINV                     ((uint32_t)0x00020000)            /*!< TX pin active level inversion */
N#define  USART_CR2_DATAINV                   ((uint32_t)0x00040000)            /*!< Binary data inversion */
N#define  USART_CR2_MSBFIRST                  ((uint32_t)0x00080000)            /*!< Most Significant Bit First */
N#define  USART_CR2_ABRE                      ((uint32_t)0x00100000)            /*!< Auto Baud-Rate Enable*/
N#define  USART_CR2_ABRMOD                    ((uint32_t)0x00600000)            /*!< ABRMOD[1:0] bits (Auto Baud-Rate Mode) */
N#define  USART_CR2_ABRMOD_0                  ((uint32_t)0x00200000)            /*!< Bit 0 */
N#define  USART_CR2_ABRMOD_1                  ((uint32_t)0x00400000)            /*!< Bit 1 */
N#define  USART_CR2_RTOEN                     ((uint32_t)0x00800000)            /*!< Receiver Time-Out enable */
N#define  USART_CR2_ADD                       ((uint32_t)0xFF000000)            /*!< Address of the USART node */
N
N#define  USART_CR2_ABRMODE									 USART_CR2_ABRMOD
N#define  USART_CR2_ABRMODE_0                 USART_CR2_ABRMOD_0
N#define  USART_CR2_ABRMODE_1                 USART_CR2_ABRMOD_1
N#define  USART_CR2_ABREN                     USART_CR2_ABRE
N/******************  Bit definition for USART_CR3 register  *******************/
N#define  USART_CR3_EIE                       ((uint32_t)0x00000001)            /*!< Error Interrupt Enable */
N//#define  USART_CR3_IREN                      ((uint32_t)0x00000002)            /*!< IrDA mode Enable */
N//#define  USART_CR3_IRLP                      ((uint32_t)0x00000004)            /*!< IrDA Low-Power */
N#define  USART_CR3_HDSEL                     ((uint32_t)0x00000008)            /*!< Half-Duplex Selection */
N//#define  USART_CR3_NACK                      ((uint32_t)0x00000010)            /*!< SmartCard NACK enable */
N//#define  USART_CR3_SCEN                      ((uint32_t)0x00000020)            /*!< SmartCard mode enable */
N#define  USART_CR3_DMAR                      ((uint32_t)0x00000040)            /*!< DMA Enable Receiver */
N#define  USART_CR3_DMAT                      ((uint32_t)0x00000080)            /*!< DMA Enable Transmitter */
N#define  USART_CR3_RTSE                      ((uint32_t)0x00000100)            /*!< RTS Enable */
N#define  USART_CR3_CTSE                      ((uint32_t)0x00000200)            /*!< CTS Enable */
N#define  USART_CR3_CTSIE                     ((uint32_t)0x00000400)            /*!< CTS Interrupt Enable */
N#define  USART_CR3_ONEBIT                    ((uint32_t)0x00000800)            /*!< One sample bit method enable */
N#define  USART_CR3_OVRDIS                    ((uint32_t)0x00001000)            /*!< Overrun Disable */
N#define  USART_CR3_DDRE                      ((uint32_t)0x00002000)            /*!< DMA Disable on Reception Error */
N#define  USART_CR3_DEM                       ((uint32_t)0x00004000)            /*!< Driver Enable Mode */
N#define  USART_CR3_DEP                       ((uint32_t)0x00008000)            /*!< Driver Enable Polarity Selection */
N//#define  USART_CR3_SCARCNT                   ((uint32_t)0x000E0000)            /*!< SCARCNT[2:0] bits (SmartCard Auto-Retry Count) */
N//#define  USART_CR3_SCARCNT_0                 ((uint32_t)0x00020000)            /*!< Bit 0 */
N//#define  USART_CR3_SCARCNT_1                 ((uint32_t)0x00040000)            /*!< Bit 1 */
N//#define  USART_CR3_SCARCNT_2                 ((uint32_t)0x00080000)            /*!< Bit 2 */
N//#define  USART_CR3_WUS                       ((uint32_t)0x00300000)            /*!< WUS[1:0] bits (Wake UP Interrupt Flag Selection) */
N//#define  USART_CR3_WUS_0                     ((uint32_t)0x00100000)            /*!< Bit 0 */
N//#define  USART_CR3_WUS_1                     ((uint32_t)0x00200000)            /*!< Bit 1 */
N//#define  USART_CR3_WUFIE                     ((uint32_t)0x00400000)            /*!< Wake Up Interrupt Enable */
N
N/******************  Bit definition for USART_BRR register  *******************/
N//#define  USART_BRR_DIV_FRACTION              ((uint16_t)0x000F)                /*!< Fraction of USARTDIV */
N//#define  USART_BRR_DIV_MANTISSA              ((uint16_t)0xFFF0)                /*!< Mantissa of USARTDIV */
N#define  USART_BRR_BRR                       ((uint16_t)0xFFFF)                /*!< Fraction of USARTDIV */
N
N/******************  Bit definition for USART_GTPR register  ******************/
N#define  USART_GTPR_PSC                      ((uint16_t)0x00FF)                /*!< PSC[7:0] bits (Prescaler value) */
N#define  USART_GTPR_GT                       ((uint16_t)0xFF00)                /*!< GT[7:0] bits (Guard time value) */
N
N
N/*******************  Bit definition for USART_RTOR register  *****************/
N#define  USART_RTOR_RTO                      ((uint32_t)0x00FFFFFF)            /*!< Receiver Time Out Value */
N//#define  USART_RTOR_BLEN                     ((uint32_t)0xFF000000)            /*!< Block Length */
N
N/*******************  Bit definition for USART_RQR register  ******************/
N#define  USART_RQR_ABRRQ                    ((uint16_t)0x0001)                /*!< Auto-Baud Rate Request */
N#define  USART_RQR_SBKRQ                    ((uint16_t)0x0002)                /*!< Send Break Request */
N#define  USART_RQR_MMRQ                     ((uint16_t)0x0004)                /*!< Mute Mode Request */
N#define  USART_RQR_RXFRQ                    ((uint16_t)0x0008)                /*!< Receive Data flush Request */
N#define  USART_RQR_TXFRQ                    ((uint16_t)0x0010)                /*!< Transmit data flush Request */
N
N/*******************  Bit definition for USART_ISR register  ******************/
N#define  USART_ISR_PE                        ((uint32_t)0x00000001)            /*!< Parity Error */
N#define  USART_ISR_FE                        ((uint32_t)0x00000002)            /*!< Framing Error */
N#define  USART_ISR_NE                        ((uint32_t)0x00000004)            /*!< Noise detected Flag */
N#define  USART_ISR_ORE                       ((uint32_t)0x00000008)            /*!< OverRun Error */
N#define  USART_ISR_IDLE                      ((uint32_t)0x00000010)            /*!< IDLE line detected */
N#define  USART_ISR_RXNE                      ((uint32_t)0x00000020)            /*!< Read Data Register Not Empty */
N#define  USART_ISR_TC                        ((uint32_t)0x00000040)            /*!< Transmission Complete */
N#define  USART_ISR_TXE                       ((uint32_t)0x00000080)            /*!< Transmit Data Register Empty */
N//#define  USART_ISR_LBD                       ((uint32_t)0x00000100)            /*!< LIN Break Detection Flag */
N#define  USART_ISR_CTSIF                     ((uint32_t)0x00000200)            /*!< CTS interrupt flag */
N#define  USART_ISR_CTS                       ((uint32_t)0x00000400)            /*!< CTS flag */
N#define  USART_ISR_RTOF                      ((uint32_t)0x00000800)            /*!< Receiver Time Out */
N//#define  USART_ISR_EOBF                      ((uint32_t)0x00001000)            /*!< End Of Block Flag */
N#define  USART_ISR_ABRE                      ((uint32_t)0x00004000)            /*!< Auto-Baud Rate Error */
N#define  USART_ISR_ABRF                      ((uint32_t)0x00008000)            /*!< Auto-Baud Rate Flag */
N#define  USART_ISR_BUSY                      ((uint32_t)0x00010000)            /*!< Busy Flag */
N#define  USART_ISR_CMF                       ((uint32_t)0x00020000)            /*!< Character Match Flag */
N#define  USART_ISR_SBKF                      ((uint32_t)0x00040000)            /*!< Send Break Flag */
N#define  USART_ISR_RWU                       ((uint32_t)0x00080000)            /*!< Receive Wake Up from mute mode Flag */
N//#define  USART_ISR_WUF                       ((uint32_t)0x00100000)            /*!< Wake Up from stop mode Flag */
N//#define  USART_ISR_TEACK                     ((uint32_t)0x00200000)            /*!< Transmit Enable Acknowledge Flag */
N//#define  USART_ISR_REACK                     ((uint32_t)0x00400000)            /*!< Receive Enable Acknowledge Flag */
N
N/*******************  Bit definition for USART_ICR register  ******************/
N#define  USART_ICR_PECF                      ((uint32_t)0x00000001)            /*!< Parity Error Clear Flag */
N#define  USART_ICR_FECF                      ((uint32_t)0x00000002)            /*!< Framing Error Clear Flag */
N#define  USART_ICR_NCF                      ((uint32_t)0x00000004)             /*!< Noise detected Clear Flag */
N#define  USART_ICR_ORECF                     ((uint32_t)0x00000008)            /*!< OverRun Error Clear Flag */
N#define  USART_ICR_IDLECF                    ((uint32_t)0x00000010)            /*!< IDLE line detected Clear Flag */
N#define  USART_ICR_TCCF                      ((uint32_t)0x00000040)            /*!< Transmission Complete Clear Flag */
N#define  USART_ICR_LBDCF                     ((uint32_t)0x00000100)            /*!< LIN Break Detection Clear Flag */
N#define  USART_ICR_CTSCF                     ((uint32_t)0x00000200)            /*!< CTS Interrupt Clear Flag */
N#define  USART_ICR_RTOCF                     ((uint32_t)0x00000800)            /*!< Receiver Time Out Clear Flag */
N//#define  USART_ICR_EOBCF                     ((uint32_t)0x00001000)            /*!< End Of Block Clear Flag */
N#define  USART_ICR_CMCF                      ((uint32_t)0x00020000)            /*!< Character Match Clear Flag */
N//#define  USART_ICR_WUCF                      ((uint32_t)0x00100000)            /*!< Wake Up from stop mode Clear Flag */
N
N/*******************  Bit definition for USART_RDR register  ******************/
N#define  USART_RDR_RDR                       ((uint16_t)0x01FF)                /*!< RDR[8:0] bits (Receive Data value) */
N
N/*******************  Bit definition for USART_TDR register  ******************/
N#define  USART_TDR_TDR                       ((uint16_t)0x01FF)                /*!< TDR[8:0] bits (Transmit Data value) */
N
N/******************************************************************************/
N/*                                                                            */
N/*                         Window WATCHDOG (WWDG)                             */
N/*                                                                            */
N/******************************************************************************/
N
N/*******************  Bit definition for WWDG_CR register  ********************/
N#define  WWDG_CR_T                           ((uint8_t)0x7F)               /*!< T[6:0] bits (7-Bit counter (MSB to LSB)) */
N#define  WWDG_CR_T0                          ((uint8_t)0x01)               /*!< Bit 0 */
N#define  WWDG_CR_T1                          ((uint8_t)0x02)               /*!< Bit 1 */
N#define  WWDG_CR_T2                          ((uint8_t)0x04)               /*!< Bit 2 */
N#define  WWDG_CR_T3                          ((uint8_t)0x08)               /*!< Bit 3 */
N#define  WWDG_CR_T4                          ((uint8_t)0x10)               /*!< Bit 4 */
N#define  WWDG_CR_T5                          ((uint8_t)0x20)               /*!< Bit 5 */
N#define  WWDG_CR_T6                          ((uint8_t)0x40)               /*!< Bit 6 */
N
N#define  WWDG_CR_WDGA                        ((uint8_t)0x80)               /*!< Activation bit */
N
N/*******************  Bit definition for WWDG_CFR register  *******************/
N#define  WWDG_CFR_W                          ((uint16_t)0x007F)            /*!< W[6:0] bits (7-bit window value) */
N#define  WWDG_CFR_W0                         ((uint16_t)0x0001)            /*!< Bit 0 */
N#define  WWDG_CFR_W1                         ((uint16_t)0x0002)            /*!< Bit 1 */
N#define  WWDG_CFR_W2                         ((uint16_t)0x0004)            /*!< Bit 2 */
N#define  WWDG_CFR_W3                         ((uint16_t)0x0008)            /*!< Bit 3 */
N#define  WWDG_CFR_W4                         ((uint16_t)0x0010)            /*!< Bit 4 */
N#define  WWDG_CFR_W5                         ((uint16_t)0x0020)            /*!< Bit 5 */
N#define  WWDG_CFR_W6                         ((uint16_t)0x0040)            /*!< Bit 6 */
N
N#define  WWDG_CFR_WDGTB                      ((uint16_t)0x0180)            /*!< WDGTB[1:0] bits (Timer Base) */
N#define  WWDG_CFR_WDGTB0                     ((uint16_t)0x0080)            /*!< Bit 0 */
N#define  WWDG_CFR_WDGTB1                     ((uint16_t)0x0100)            /*!< Bit 1 */
N
N#define  WWDG_CFR_EWI                        ((uint16_t)0x0200)            /*!< Early Wakeup Interrupt */
N
N/*******************  Bit definition for WWDG_SR register  ********************/
N#define  WWDG_SR_EWIF                        ((uint8_t)0x01)               /*!< Early Wakeup Interrupt Flag */
N
N
N
N/**
N  * @}
N  */
N
N /**
N  * @}
N  */ 
N
N//#ifdef USE_STDPERIPH_DRIVER
N//  #include "FT32f0xx_conf.h"
N//#endif
N
N/** @addtogroup Exported_macro
N  * @{
N  */
N/**
N  * @}
N  */
N  
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __FT32F072X8_H */
N
N/**
N  * @}
N  */
N
N  /**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT FMD *****END OF FILE****/
L 54 "..\FTLib\CMSIS\inc\ft32f0xx.h" 2
N#else
S #error "Please select first the target FT32F0xx device used in your application (in ft32f0xx.h file)"
N#endif
N
N/**
N  * @}
N  */
N
N
N
N/**
N  * @}
N  */
N
N
N/** @addtogroup Exported_macros
N  * @{
N  */
N#define SET_BIT(REG, BIT)     ((REG) |= (BIT))
N
N#define CLEAR_BIT(REG, BIT)   ((REG) &= ~(BIT))
N
N#define READ_BIT(REG, BIT)    ((REG) & (BIT))
N
N#define CLEAR_REG(REG)        ((REG) = (0x0))
N
N#define WRITE_REG(REG, VAL)   ((REG) = (VAL))
N
N#define READ_REG(REG)         ((REG))
N
N#define MODIFY_REG(REG, CLEARMASK, SETMASK)  WRITE_REG((REG), (((READ_REG(REG)) & (~(CLEARMASK))) | (SETMASK)))
N
N
N#ifdef __cplusplus
S}
N#endif /* __cplusplus */
N
N#endif /* __FT32F0xx_H */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N  
N
N
N
N/*****************************END OF FILE****/
L 23 "..\FTLib\Inc\ft32f0xx_tim.h" 2
N
N
N/** @addtogroup TIM
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief  TIM Time Base Init structure definition
N  * @note   This sturcture is used with all TIMx.
N  */
N
Ntypedef struct
N{
N  uint16_t TIM_Prescaler;         /*!< Specifies the prescaler value used to divide the TIM clock.
N                                       This parameter can be a number between 0x0000 and 0xFFFF */
N
N  uint16_t TIM_CounterMode;       /*!< Specifies the counter mode.
N                                       This parameter can be a value of @ref TIM_Counter_Mode */
N
N  uint32_t TIM_Period;            /*!< Specifies the period value to be loaded into the active
N                                       Auto-Reload Register at the next update event.
N                                       This parameter must be a number between 0x0000 and 0xFFFF.  */ 
N
N  uint16_t TIM_ClockDivision;     /*!< Specifies the clock division.
N                                      This parameter can be a value of @ref TIM_Clock_Division_CKD */
N
N  uint8_t TIM_RepetitionCounter;  /*!< Specifies the repetition counter value. Each time the RCR downcounter
N                                       reaches zero, an update event is generated and counting restarts
N                                       from the RCR value (N).
N                                       This means in PWM mode that (N+1) corresponds to:
N                                          - the number of PWM periods in edge-aligned mode
N                                          - the number of half PWM period in center-aligned mode
N                                       This parameter must be a number between 0x00 and 0xFF. 
N                                       @note This parameter is valid only for TIM1. */
N} TIM_TimeBaseInitTypeDef;       
N
N/** 
N  * @brief  TIM Output Compare Init structure definition  
N  */
N
Ntypedef struct
N{
N  uint16_t TIM_OCMode;        /*!< Specifies the TIM mode.
N                                   This parameter can be a value of @ref TIM_Output_Compare_and_PWM_modes */
N
N  uint16_t TIM_OutputState;   /*!< Specifies the TIM Output Compare state.
N                                   This parameter can be a value of @ref TIM_Output_Compare_state */
N
N  uint16_t TIM_OutputNState;  /*!< Specifies the TIM complementary Output Compare state.
N                                   This parameter can be a value of @ref TIM_Output_Compare_N_state
N                                   @note This parameter is valid only for TIM1. */
N
N  uint32_t TIM_Pulse;         /*!< Specifies the pulse value to be loaded into the Capture Compare Register. 
N                                   This parameter can be a number between 0x0000 and 0xFFFF ( or 0xFFFFFFFF 
N                                   for TIM2) */
N
N  uint16_t TIM_OCPolarity;    /*!< Specifies the output polarity.
N                                   This parameter can be a value of @ref TIM_Output_Compare_Polarity */
N
N  uint16_t TIM_OCNPolarity;   /*!< Specifies the complementary output polarity.
N                                   This parameter can be a value of @ref TIM_Output_Compare_N_Polarity
N                                   @note This parameter is valid only for TIM1. */
N
N  uint16_t TIM_OCIdleState;   /*!< Specifies the TIM Output Compare pin state during Idle state.
N                                   This parameter can be a value of @ref TIM_Output_Compare_Idle_State
N                                   @note This parameter is valid only for TIM1. */
N
N  uint16_t TIM_OCNIdleState;  /*!< Specifies the TIM Output Compare pin state during Idle state.
N                                   This parameter can be a value of @ref TIM_Output_Compare_N_Idle_State
N                                   @note This parameter is valid only for TIM1. */
N} TIM_OCInitTypeDef;
N
N/** 
N  * @brief  TIM Input Capture Init structure definition  
N  */
N
Ntypedef struct
N{
N
N  uint16_t TIM_Channel;      /*!< Specifies the TIM channel.
N                                  This parameter can be a value of @ref TIM_Channel */
N
N  uint16_t TIM_ICPolarity;   /*!< Specifies the active edge of the input signal.
N                                  This parameter can be a value of @ref TIM_Input_Capture_Polarity */
N
N  uint16_t TIM_ICSelection;  /*!< Specifies the input.
N                                  This parameter can be a value of @ref TIM_Input_Capture_Selection */
N
N  uint16_t TIM_ICPrescaler;  /*!< Specifies the Input Capture Prescaler.
N                                  This parameter can be a value of @ref TIM_Input_Capture_Prescaler */
N
N  uint16_t TIM_ICFilter;     /*!< Specifies the input capture filter.
N                                  This parameter can be a number between 0x0 and 0xF */
N} TIM_ICInitTypeDef;
N
N/** 
N  * @brief  TIM_BDTR structure definition 
N  * @note   This sturcture is used only with TIM1.    
N  */
N
Ntypedef struct
N{
N
N  uint16_t TIM_OSSRState;        /*!< Specifies the Off-State selection used in Run mode.
N                                      This parameter can be a value of @ref TIM_OSSR_Off_State_Selection_for_Run_mode_state */
N
N  uint16_t TIM_OSSIState;        /*!< Specifies the Off-State used in Idle state.
N                                      This parameter can be a value of @ref TIM_OSSI_Off_State_Selection_for_Idle_mode_state */
N
N  uint16_t TIM_LOCKLevel;        /*!< Specifies the LOCK level parameters.
N                                      This parameter can be a value of @ref TIM_Lock_level */ 
N
N  uint16_t TIM_DeadTime;         /*!< Specifies the delay time between the switching-off and the
N                                      switching-on of the outputs.
N                                      This parameter can be a number between 0x00 and 0xFF  */
N
N  uint16_t TIM_Break;            /*!< Specifies whether the TIM Break input is enabled or not. 
N                                      This parameter can be a value of @ref TIM_Break_Input_enable_disable */
N
N  uint16_t TIM_BreakPolarity;    /*!< Specifies the TIM Break Input pin polarity.
N                                      This parameter can be a value of @ref TIM_Break_Polarity */
N
N  uint16_t TIM_AutomaticOutput;  /*!< Specifies whether the TIM Automatic Output feature is enabled or not. 
N                                      This parameter can be a value of @ref TIM_AOE_Bit_Set_Reset */
N} TIM_BDTRInitTypeDef;
N
N/** 
N  * @brief  TIM Input Capture Init structure definition  
N  */
N
N/* Exported constants --------------------------------------------------------*/
N
N  
N/** @defgroup TIM_Exported_constants 
N  * @{
N  */
N
N#define IS_TIM_ALL_PERIPH(PERIPH) (((PERIPH) == TIM1) || \
N                                   ((PERIPH) == TIM2) || \
N                                   ((PERIPH) == TIM3) || \
N                                   ((PERIPH) == TIM6) || \
N                                   ((PERIPH) == TIM7) || \
N                                   ((PERIPH) == TIM14)|| \
N                                   ((PERIPH) == TIM15)|| \
N                                   ((PERIPH) == TIM16)|| \
N                                   ((PERIPH) == TIM17))
X#define IS_TIM_ALL_PERIPH(PERIPH) (((PERIPH) == TIM1) ||                                    ((PERIPH) == TIM2) ||                                    ((PERIPH) == TIM3) ||                                    ((PERIPH) == TIM6) ||                                    ((PERIPH) == TIM7) ||                                    ((PERIPH) == TIM14)||                                    ((PERIPH) == TIM15)||                                    ((PERIPH) == TIM16)||                                    ((PERIPH) == TIM17))
N
N/* LIST1: TIM 1 */
N#define IS_TIM_LIST1_PERIPH(PERIPH)  ((PERIPH) == TIM1)
N
N/* LIST2: TIM 1, 15, 16 and 17 */
N#define IS_TIM_LIST2_PERIPH(PERIPH) (((PERIPH) == TIM1) || \
N                                     ((PERIPH) == TIM15)|| \
N                                     ((PERIPH) == TIM16)|| \
N                                     ((PERIPH) == TIM17)) 
X#define IS_TIM_LIST2_PERIPH(PERIPH) (((PERIPH) == TIM1) ||                                      ((PERIPH) == TIM15)||                                      ((PERIPH) == TIM16)||                                      ((PERIPH) == TIM17)) 
N
N/* LIST3: TIM 1, 2 and 3 */
N#define IS_TIM_LIST3_PERIPH(PERIPH) (((PERIPH) == TIM1) || \
N                                     ((PERIPH) == TIM2) || \
N                                     ((PERIPH) == TIM3)) 
X#define IS_TIM_LIST3_PERIPH(PERIPH) (((PERIPH) == TIM1) ||                                      ((PERIPH) == TIM2) ||                                      ((PERIPH) == TIM3)) 
N
N/* LIST4: TIM 1, 2, 3, 14, 15, 16 and 17 */
N#define IS_TIM_LIST4_PERIPH(PERIPH) (((PERIPH) == TIM1) || \
N                                     ((PERIPH) == TIM2) || \
N                                     ((PERIPH) == TIM3) || \
N                                     ((PERIPH) == TIM14) || \
N                                     ((PERIPH) == TIM15)|| \
N                                     ((PERIPH) == TIM16)|| \
N                                     ((PERIPH) == TIM17))
X#define IS_TIM_LIST4_PERIPH(PERIPH) (((PERIPH) == TIM1) ||                                      ((PERIPH) == TIM2) ||                                      ((PERIPH) == TIM3) ||                                      ((PERIPH) == TIM14) ||                                      ((PERIPH) == TIM15)||                                      ((PERIPH) == TIM16)||                                      ((PERIPH) == TIM17))
N
N/* LIST5: TIM 1, 2, 3, 15, 16 and 17 */
N#define IS_TIM_LIST5_PERIPH(PERIPH) (((PERIPH) == TIM1) || \
N                                     ((PERIPH) == TIM2) || \
N                                     ((PERIPH) == TIM3) || \
N                                     ((PERIPH) == TIM15)|| \
N                                     ((PERIPH) == TIM16)|| \
N                                     ((PERIPH) == TIM17))
X#define IS_TIM_LIST5_PERIPH(PERIPH) (((PERIPH) == TIM1) ||                                      ((PERIPH) == TIM2) ||                                      ((PERIPH) == TIM3) ||                                      ((PERIPH) == TIM15)||                                      ((PERIPH) == TIM16)||                                      ((PERIPH) == TIM17))
N
N/* LIST6: TIM 1, 2, 3 and 15 */
N#define IS_TIM_LIST6_PERIPH(PERIPH) (((PERIPH) == TIM1) || \
N                                     ((PERIPH) == TIM2) || \
N                                     ((PERIPH) == TIM3) || \
N                                     ((PERIPH) == TIM15)) 
X#define IS_TIM_LIST6_PERIPH(PERIPH) (((PERIPH) == TIM1) ||                                      ((PERIPH) == TIM2) ||                                      ((PERIPH) == TIM3) ||                                      ((PERIPH) == TIM15)) 
N
N/* LIST7: TIM 1, 2, 3, 6, 7 and 14 */
N#define IS_TIM_LIST7_PERIPH(PERIPH)  (((PERIPH) == TIM1) || \
N                                      ((PERIPH) == TIM2) || \
N                                      ((PERIPH) == TIM3) || \
N                                      ((PERIPH) == TIM6) || \
N                                      ((PERIPH) == TIM7) || \
N                                      ((PERIPH) == TIM14))
X#define IS_TIM_LIST7_PERIPH(PERIPH)  (((PERIPH) == TIM1) ||                                       ((PERIPH) == TIM2) ||                                       ((PERIPH) == TIM3) ||                                       ((PERIPH) == TIM6) ||                                       ((PERIPH) == TIM7) ||                                       ((PERIPH) == TIM14))
N                                      
N/* LIST8: TIM 1, 2, 3 and 14 */
N#define IS_TIM_LIST8_PERIPH(PERIPH)  (((PERIPH) == TIM1) || \
N                                      ((PERIPH) == TIM2) || \
N                                      ((PERIPH) == TIM3) || \
N                                      ((PERIPH) == TIM14))
X#define IS_TIM_LIST8_PERIPH(PERIPH)  (((PERIPH) == TIM1) ||                                       ((PERIPH) == TIM2) ||                                       ((PERIPH) == TIM3) ||                                       ((PERIPH) == TIM14))
N
N/* LIST9: TIM 1, 2, 3, 6, 7 and 15 */
N#define IS_TIM_LIST9_PERIPH(PERIPH)  (((PERIPH) == TIM1) || \
N                                      ((PERIPH) == TIM2) || \
N                                      ((PERIPH) == TIM3) || \
N                                      ((PERIPH) == TIM6) || \
N                                      ((PERIPH) == TIM7) || \
N                                      ((PERIPH) == TIM15))
X#define IS_TIM_LIST9_PERIPH(PERIPH)  (((PERIPH) == TIM1) ||                                       ((PERIPH) == TIM2) ||                                       ((PERIPH) == TIM3) ||                                       ((PERIPH) == TIM6) ||                                       ((PERIPH) == TIM7) ||                                       ((PERIPH) == TIM15))
N
N/* LIST10: TIM 1, 2, 3, 6, 7, 15, 16 and 17 */
N#define IS_TIM_LIST10_PERIPH(PERIPH) (((PERIPH) == TIM1) || \
N                                     ((PERIPH) == TIM2) || \
N                                     ((PERIPH) == TIM3) || \
N                                     ((PERIPH) == TIM6) || \
N                                     ((PERIPH) == TIM7) || \
N                                     ((PERIPH) == TIM15)|| \
N                                     ((PERIPH) == TIM16)|| \
N                                     ((PERIPH) == TIM17))
X#define IS_TIM_LIST10_PERIPH(PERIPH) (((PERIPH) == TIM1) ||                                      ((PERIPH) == TIM2) ||                                      ((PERIPH) == TIM3) ||                                      ((PERIPH) == TIM6) ||                                      ((PERIPH) == TIM7) ||                                      ((PERIPH) == TIM15)||                                      ((PERIPH) == TIM16)||                                      ((PERIPH) == TIM17))
N
N/* LIST1: TIM 11 */
N#define IS_TIM_LIST11_PERIPH(PERIPH)  ((PERIPH) == TIM14)
N                                     
N
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Output_Compare_and_PWM_modes 
N  * @{
N  */
N
N#define TIM_OCMode_Timing                  ((uint16_t)0x0000)
N#define TIM_OCMode_Active                  ((uint16_t)0x0010)
N#define TIM_OCMode_Inactive                ((uint16_t)0x0020)
N#define TIM_OCMode_Toggle                  ((uint16_t)0x0030)
N#define TIM_OCMode_PWM1                    ((uint16_t)0x0060)
N#define TIM_OCMode_PWM2                    ((uint16_t)0x0070)
N#define IS_TIM_OC_MODE(MODE) (((MODE) == TIM_OCMode_Timing) || \
N                              ((MODE) == TIM_OCMode_Active) || \
N                              ((MODE) == TIM_OCMode_Inactive) || \
N                              ((MODE) == TIM_OCMode_Toggle)|| \
N                              ((MODE) == TIM_OCMode_PWM1) || \
N                              ((MODE) == TIM_OCMode_PWM2))
X#define IS_TIM_OC_MODE(MODE) (((MODE) == TIM_OCMode_Timing) ||                               ((MODE) == TIM_OCMode_Active) ||                               ((MODE) == TIM_OCMode_Inactive) ||                               ((MODE) == TIM_OCMode_Toggle)||                               ((MODE) == TIM_OCMode_PWM1) ||                               ((MODE) == TIM_OCMode_PWM2))
N#define IS_TIM_OCM(MODE) (((MODE) == TIM_OCMode_Timing) || \
N                          ((MODE) == TIM_OCMode_Active) || \
N                          ((MODE) == TIM_OCMode_Inactive) || \
N                          ((MODE) == TIM_OCMode_Toggle)|| \
N                          ((MODE) == TIM_OCMode_PWM1) || \
N                          ((MODE) == TIM_OCMode_PWM2) ||	\
N                          ((MODE) == TIM_ForcedAction_Active) || \
N                          ((MODE) == TIM_ForcedAction_InActive))
X#define IS_TIM_OCM(MODE) (((MODE) == TIM_OCMode_Timing) ||                           ((MODE) == TIM_OCMode_Active) ||                           ((MODE) == TIM_OCMode_Inactive) ||                           ((MODE) == TIM_OCMode_Toggle)||                           ((MODE) == TIM_OCMode_PWM1) ||                           ((MODE) == TIM_OCMode_PWM2) ||	                          ((MODE) == TIM_ForcedAction_Active) ||                           ((MODE) == TIM_ForcedAction_InActive))
N/**
N  * @}
N  */
N
N/** @defgroup TIM_One_Pulse_Mode 
N  * @{
N  */
N
N#define TIM_OPMode_Single                  ((uint16_t)0x0008)
N#define TIM_OPMode_Repetitive              ((uint16_t)0x0000)
N#define IS_TIM_OPM_MODE(MODE) (((MODE) == TIM_OPMode_Single) || \
N                               ((MODE) == TIM_OPMode_Repetitive))
X#define IS_TIM_OPM_MODE(MODE) (((MODE) == TIM_OPMode_Single) ||                                ((MODE) == TIM_OPMode_Repetitive))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Channel 
N  * @{
N  */
N
N#define TIM_Channel_1                      ((uint16_t)0x0000)
N#define TIM_Channel_2                      ((uint16_t)0x0004)
N#define TIM_Channel_3                      ((uint16_t)0x0008)
N#define TIM_Channel_4                      ((uint16_t)0x000C)
N
N#define IS_TIM_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) || \
N                                 ((CHANNEL) == TIM_Channel_2) || \
N                                 ((CHANNEL) == TIM_Channel_3) || \
N                                 ((CHANNEL) == TIM_Channel_4))
X#define IS_TIM_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) ||                                  ((CHANNEL) == TIM_Channel_2) ||                                  ((CHANNEL) == TIM_Channel_3) ||                                  ((CHANNEL) == TIM_Channel_4))
N#define IS_TIM_COMPLEMENTARY_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) || \
N                                               ((CHANNEL) == TIM_Channel_2) || \
N                                               ((CHANNEL) == TIM_Channel_3))
X#define IS_TIM_COMPLEMENTARY_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) ||                                                ((CHANNEL) == TIM_Channel_2) ||                                                ((CHANNEL) == TIM_Channel_3))
N#define IS_TIM_PWMI_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) || \
N                                      ((CHANNEL) == TIM_Channel_2))
X#define IS_TIM_PWMI_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) ||                                       ((CHANNEL) == TIM_Channel_2))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Clock_Division_CKD 
N  * @{
N  */
N
N#define TIM_CKD_DIV1                       ((uint16_t)0x0000)
N#define TIM_CKD_DIV2                       ((uint16_t)0x0100)
N#define TIM_CKD_DIV4                       ((uint16_t)0x0200)
N#define IS_TIM_CKD_DIV(DIV) (((DIV) == TIM_CKD_DIV1) || \
N                             ((DIV) == TIM_CKD_DIV2) || \
N                             ((DIV) == TIM_CKD_DIV4))
X#define IS_TIM_CKD_DIV(DIV) (((DIV) == TIM_CKD_DIV1) ||                              ((DIV) == TIM_CKD_DIV2) ||                              ((DIV) == TIM_CKD_DIV4))
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Counter_Mode 
N  * @{
N  */
N
N#define TIM_CounterMode_Up                 ((uint16_t)0x0000)
N#define TIM_CounterMode_Down               ((uint16_t)0x0010)
N#define TIM_CounterMode_CenterAligned1     ((uint16_t)0x0020)
N#define TIM_CounterMode_CenterAligned2     ((uint16_t)0x0040)
N#define TIM_CounterMode_CenterAligned3     ((uint16_t)0x0060)
N#define IS_TIM_COUNTER_MODE(MODE) (((MODE) == TIM_CounterMode_Up) ||  \
N                                   ((MODE) == TIM_CounterMode_Down) || \
N                                   ((MODE) == TIM_CounterMode_CenterAligned1) || \
N                                   ((MODE) == TIM_CounterMode_CenterAligned2) || \
N                                   ((MODE) == TIM_CounterMode_CenterAligned3))
X#define IS_TIM_COUNTER_MODE(MODE) (((MODE) == TIM_CounterMode_Up) ||                                     ((MODE) == TIM_CounterMode_Down) ||                                    ((MODE) == TIM_CounterMode_CenterAligned1) ||                                    ((MODE) == TIM_CounterMode_CenterAligned2) ||                                    ((MODE) == TIM_CounterMode_CenterAligned3))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Output_Compare_Polarity 
N  * @{
N  */
N
N#define TIM_OCPolarity_High                ((uint16_t)0x0000)
N#define TIM_OCPolarity_Low                 ((uint16_t)0x0002)
N#define IS_TIM_OC_POLARITY(POLARITY) (((POLARITY) == TIM_OCPolarity_High) || \
N                                      ((POLARITY) == TIM_OCPolarity_Low))
X#define IS_TIM_OC_POLARITY(POLARITY) (((POLARITY) == TIM_OCPolarity_High) ||                                       ((POLARITY) == TIM_OCPolarity_Low))
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Output_Compare_N_Polarity 
N  * @{
N  */
N  
N#define TIM_OCNPolarity_High               ((uint16_t)0x0000)
N#define TIM_OCNPolarity_Low                ((uint16_t)0x0008)
N#define IS_TIM_OCN_POLARITY(POLARITY) (((POLARITY) == TIM_OCNPolarity_High) || \
N                                       ((POLARITY) == TIM_OCNPolarity_Low))
X#define IS_TIM_OCN_POLARITY(POLARITY) (((POLARITY) == TIM_OCNPolarity_High) ||                                        ((POLARITY) == TIM_OCNPolarity_Low))
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Output_Compare_state
N  * @{
N  */
N
N#define TIM_OutputState_Disable            ((uint16_t)0x0000)
N#define TIM_OutputState_Enable             ((uint16_t)0x0001)
N#define IS_TIM_OUTPUT_STATE(STATE) (((STATE) == TIM_OutputState_Disable) || \
N                                    ((STATE) == TIM_OutputState_Enable))
X#define IS_TIM_OUTPUT_STATE(STATE) (((STATE) == TIM_OutputState_Disable) ||                                     ((STATE) == TIM_OutputState_Enable))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Output_Compare_N_state 
N  * @{
N  */
N
N#define TIM_OutputNState_Disable           ((uint16_t)0x0000)
N#define TIM_OutputNState_Enable            ((uint16_t)0x0004)
N#define IS_TIM_OUTPUTN_STATE(STATE) (((STATE) == TIM_OutputNState_Disable) || \
N                                     ((STATE) == TIM_OutputNState_Enable))
X#define IS_TIM_OUTPUTN_STATE(STATE) (((STATE) == TIM_OutputNState_Disable) ||                                      ((STATE) == TIM_OutputNState_Enable))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Capture_Compare_state 
N  * @{
N  */
N
N#define TIM_CCx_Enable                      ((uint16_t)0x0001)
N#define TIM_CCx_Disable                     ((uint16_t)0x0000)
N#define IS_TIM_CCX(CCX) (((CCX) == TIM_CCx_Enable) || \
N                         ((CCX) == TIM_CCx_Disable))
X#define IS_TIM_CCX(CCX) (((CCX) == TIM_CCx_Enable) ||                          ((CCX) == TIM_CCx_Disable))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Capture_Compare_N_state 
N  * @{
N  */
N
N#define TIM_CCxN_Enable                     ((uint16_t)0x0004)
N#define TIM_CCxN_Disable                    ((uint16_t)0x0000)
N#define IS_TIM_CCXN(CCXN) (((CCXN) == TIM_CCxN_Enable) || \
N                           ((CCXN) == TIM_CCxN_Disable))
X#define IS_TIM_CCXN(CCXN) (((CCXN) == TIM_CCxN_Enable) ||                            ((CCXN) == TIM_CCxN_Disable))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Break_Input_enable_disable 
N  * @{
N  */
N
N#define TIM_Break_Enable                   ((uint16_t)0x1000)
N#define TIM_Break_Disable                  ((uint16_t)0x0000)
N#define IS_TIM_BREAK_STATE(STATE) (((STATE) == TIM_Break_Enable) || \
N                                   ((STATE) == TIM_Break_Disable))
X#define IS_TIM_BREAK_STATE(STATE) (((STATE) == TIM_Break_Enable) ||                                    ((STATE) == TIM_Break_Disable))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Break_Polarity 
N  * @{
N  */
N
N#define TIM_BreakPolarity_Low              ((uint16_t)0x0000)
N#define TIM_BreakPolarity_High             ((uint16_t)0x2000)
N#define IS_TIM_BREAK_POLARITY(POLARITY) (((POLARITY) == TIM_BreakPolarity_Low) || \
N                                         ((POLARITY) == TIM_BreakPolarity_High))
X#define IS_TIM_BREAK_POLARITY(POLARITY) (((POLARITY) == TIM_BreakPolarity_Low) ||                                          ((POLARITY) == TIM_BreakPolarity_High))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_AOE_Bit_Set_Reset 
N  * @{
N  */
N
N#define TIM_AutomaticOutput_Enable         ((uint16_t)0x4000)
N#define TIM_AutomaticOutput_Disable        ((uint16_t)0x0000)
N#define IS_TIM_AUTOMATIC_OUTPUT_STATE(STATE) (((STATE) == TIM_AutomaticOutput_Enable) || \
N                                              ((STATE) == TIM_AutomaticOutput_Disable))
X#define IS_TIM_AUTOMATIC_OUTPUT_STATE(STATE) (((STATE) == TIM_AutomaticOutput_Enable) ||                                               ((STATE) == TIM_AutomaticOutput_Disable))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Lock_level 
N  * @{
N  */
N
N#define TIM_LOCKLevel_OFF                  ((uint16_t)0x0000)
N#define TIM_LOCKLevel_1                    ((uint16_t)0x0100)
N#define TIM_LOCKLevel_2                    ((uint16_t)0x0200)
N#define TIM_LOCKLevel_3                    ((uint16_t)0x0300)
N#define IS_TIM_LOCK_LEVEL(LEVEL) (((LEVEL) == TIM_LOCKLevel_OFF) || \
N                                  ((LEVEL) == TIM_LOCKLevel_1) || \
N                                  ((LEVEL) == TIM_LOCKLevel_2) || \
N                                  ((LEVEL) == TIM_LOCKLevel_3))
X#define IS_TIM_LOCK_LEVEL(LEVEL) (((LEVEL) == TIM_LOCKLevel_OFF) ||                                   ((LEVEL) == TIM_LOCKLevel_1) ||                                   ((LEVEL) == TIM_LOCKLevel_2) ||                                   ((LEVEL) == TIM_LOCKLevel_3))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_OSSI_Off_State_Selection_for_Idle_mode_state 
N  * @{
N  */
N
N#define TIM_OSSIState_Enable               ((uint16_t)0x0400)
N#define TIM_OSSIState_Disable              ((uint16_t)0x0000)
N#define IS_TIM_OSSI_STATE(STATE) (((STATE) == TIM_OSSIState_Enable) || \
N                                  ((STATE) == TIM_OSSIState_Disable))
X#define IS_TIM_OSSI_STATE(STATE) (((STATE) == TIM_OSSIState_Enable) ||                                   ((STATE) == TIM_OSSIState_Disable))
N/**
N  * @}
N  */
N
N/** @defgroup TIM_OSSR_Off_State_Selection_for_Run_mode_state 
N  * @{
N  */
N
N#define TIM_OSSRState_Enable               ((uint16_t)0x0800)
N#define TIM_OSSRState_Disable              ((uint16_t)0x0000)
N#define IS_TIM_OSSR_STATE(STATE) (((STATE) == TIM_OSSRState_Enable) || \
N                                  ((STATE) == TIM_OSSRState_Disable))
X#define IS_TIM_OSSR_STATE(STATE) (((STATE) == TIM_OSSRState_Enable) ||                                   ((STATE) == TIM_OSSRState_Disable))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Output_Compare_Idle_State 
N  * @{
N  */
N
N#define TIM_OCIdleState_Set                ((uint16_t)0x0100)
N#define TIM_OCIdleState_Reset              ((uint16_t)0x0000)
N#define IS_TIM_OCIDLE_STATE(STATE) (((STATE) == TIM_OCIdleState_Set) || \
N                                    ((STATE) == TIM_OCIdleState_Reset))
X#define IS_TIM_OCIDLE_STATE(STATE) (((STATE) == TIM_OCIdleState_Set) ||                                     ((STATE) == TIM_OCIdleState_Reset))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Output_Compare_N_Idle_State 
N  * @{
N  */
N
N#define TIM_OCNIdleState_Set               ((uint16_t)0x0200)
N#define TIM_OCNIdleState_Reset             ((uint16_t)0x0000)
N#define IS_TIM_OCNIDLE_STATE(STATE) (((STATE) == TIM_OCNIdleState_Set) || \
N                                     ((STATE) == TIM_OCNIdleState_Reset))
X#define IS_TIM_OCNIDLE_STATE(STATE) (((STATE) == TIM_OCNIdleState_Set) ||                                      ((STATE) == TIM_OCNIdleState_Reset))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Input_Capture_Polarity 
N  * @{
N  */
N
N#define  TIM_ICPolarity_Rising             ((uint16_t)0x0000)
N#define  TIM_ICPolarity_Falling            ((uint16_t)0x0002)
N#define  TIM_ICPolarity_BothEdge           ((uint16_t)0x000A)
N#define IS_TIM_IC_POLARITY(POLARITY) (((POLARITY) == TIM_ICPolarity_Rising) || \
N                                      ((POLARITY) == TIM_ICPolarity_Falling)|| \
N                                      ((POLARITY) == TIM_ICPolarity_BothEdge)) 
X#define IS_TIM_IC_POLARITY(POLARITY) (((POLARITY) == TIM_ICPolarity_Rising) ||                                       ((POLARITY) == TIM_ICPolarity_Falling)||                                       ((POLARITY) == TIM_ICPolarity_BothEdge)) 
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Input_Capture_Selection 
N  * @{
N  */
N
N#define TIM_ICSelection_DirectTI           ((uint16_t)0x0001) /*!< TIM Input 1, 2, 3 or 4 is selected to be 
N                                                                   connected to IC1, IC2, IC3 or IC4, respectively */
N#define TIM_ICSelection_IndirectTI         ((uint16_t)0x0002) /*!< TIM Input 1, 2, 3 or 4 is selected to be
N                                                                   connected to IC2, IC1, IC4 or IC3, respectively. */
N#define TIM_ICSelection_TRC                ((uint16_t)0x0003) /*!< TIM Input 1, 2, 3 or 4 is selected to be connected to TRC. */
N#define IS_TIM_IC_SELECTION(SELECTION) (((SELECTION) == TIM_ICSelection_DirectTI) || \
N                                        ((SELECTION) == TIM_ICSelection_IndirectTI) || \
N                                        ((SELECTION) == TIM_ICSelection_TRC))
X#define IS_TIM_IC_SELECTION(SELECTION) (((SELECTION) == TIM_ICSelection_DirectTI) ||                                         ((SELECTION) == TIM_ICSelection_IndirectTI) ||                                         ((SELECTION) == TIM_ICSelection_TRC))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Input_Capture_Prescaler 
N  * @{
N  */
N
N#define TIM_ICPSC_DIV1                     ((uint16_t)0x0000) /*!< Capture performed each time an edge is detected on the capture input. */
N#define TIM_ICPSC_DIV2                     ((uint16_t)0x0004) /*!< Capture performed once every 2 events. */
N#define TIM_ICPSC_DIV4                     ((uint16_t)0x0008) /*!< Capture performed once every 4 events. */
N#define TIM_ICPSC_DIV8                     ((uint16_t)0x000C) /*!< Capture performed once every 8 events. */
N#define IS_TIM_IC_PRESCALER(PRESCALER) (((PRESCALER) == TIM_ICPSC_DIV1) || \
N                                        ((PRESCALER) == TIM_ICPSC_DIV2) || \
N                                        ((PRESCALER) == TIM_ICPSC_DIV4) || \
N                                        ((PRESCALER) == TIM_ICPSC_DIV8))
X#define IS_TIM_IC_PRESCALER(PRESCALER) (((PRESCALER) == TIM_ICPSC_DIV1) ||                                         ((PRESCALER) == TIM_ICPSC_DIV2) ||                                         ((PRESCALER) == TIM_ICPSC_DIV4) ||                                         ((PRESCALER) == TIM_ICPSC_DIV8))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_interrupt_sources 
N  * @{
N  */
N
N#define TIM_IT_Update                      ((uint16_t)0x0001)
N#define TIM_IT_CC1                         ((uint16_t)0x0002)
N#define TIM_IT_CC2                         ((uint16_t)0x0004)
N#define TIM_IT_CC3                         ((uint16_t)0x0008)
N#define TIM_IT_CC4                         ((uint16_t)0x0010)
N#define TIM_IT_COM                         ((uint16_t)0x0020)
N#define TIM_IT_Trigger                     ((uint16_t)0x0040)
N#define TIM_IT_Break                       ((uint16_t)0x0080)
N#define IS_TIM_IT(IT) ((((IT) & (uint16_t)0xFF00) == 0x0000) && ((IT) != 0x0000))
N
N#define IS_TIM_GET_IT(IT) (((IT) == TIM_IT_Update) || \
N                           ((IT) == TIM_IT_CC1) || \
N                           ((IT) == TIM_IT_CC2) || \
N                           ((IT) == TIM_IT_CC3) || \
N                           ((IT) == TIM_IT_CC4) || \
N                           ((IT) == TIM_IT_COM) || \
N                           ((IT) == TIM_IT_Trigger) || \
N                           ((IT) == TIM_IT_Break))
X#define IS_TIM_GET_IT(IT) (((IT) == TIM_IT_Update) ||                            ((IT) == TIM_IT_CC1) ||                            ((IT) == TIM_IT_CC2) ||                            ((IT) == TIM_IT_CC3) ||                            ((IT) == TIM_IT_CC4) ||                            ((IT) == TIM_IT_COM) ||                            ((IT) == TIM_IT_Trigger) ||                            ((IT) == TIM_IT_Break))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_DMA_Base_address 
N  * @{
N  */
N
N#define TIM_DMABase_CR1                    ((uint16_t)0x0000)
N#define TIM_DMABase_CR2                    ((uint16_t)0x0001)
N#define TIM_DMABase_SMCR                   ((uint16_t)0x0002)
N#define TIM_DMABase_DIER                   ((uint16_t)0x0003)
N#define TIM_DMABase_SR                     ((uint16_t)0x0004)
N#define TIM_DMABase_EGR                    ((uint16_t)0x0005)
N#define TIM_DMABase_CCMR1                  ((uint16_t)0x0006)
N#define TIM_DMABase_CCMR2                  ((uint16_t)0x0007)
N#define TIM_DMABase_CCER                   ((uint16_t)0x0008)
N#define TIM_DMABase_CNT                    ((uint16_t)0x0009)
N#define TIM_DMABase_PSC                    ((uint16_t)0x000A)
N#define TIM_DMABase_ARR                    ((uint16_t)0x000B)
N#define TIM_DMABase_RCR                    ((uint16_t)0x000C)
N#define TIM_DMABase_CCR1                   ((uint16_t)0x000D)
N#define TIM_DMABase_CCR2                   ((uint16_t)0x000E)
N#define TIM_DMABase_CCR3                   ((uint16_t)0x000F)
N#define TIM_DMABase_CCR4                   ((uint16_t)0x0010)
N#define TIM_DMABase_BDTR                   ((uint16_t)0x0011)
N#define TIM_DMABase_DCR                    ((uint16_t)0x0012)
N#define TIM_DMABase_OR                     ((uint16_t)0x0013)
N#define IS_TIM_DMA_BASE(BASE) (((BASE) == TIM_DMABase_CR1) || \
N                               ((BASE) == TIM_DMABase_CR2) || \
N                               ((BASE) == TIM_DMABase_SMCR) || \
N                               ((BASE) == TIM_DMABase_DIER) || \
N                               ((BASE) == TIM_DMABase_SR) || \
N                               ((BASE) == TIM_DMABase_EGR) || \
N                               ((BASE) == TIM_DMABase_CCMR1) || \
N                               ((BASE) == TIM_DMABase_CCMR2) || \
N                               ((BASE) == TIM_DMABase_CCER) || \
N                               ((BASE) == TIM_DMABase_CNT) || \
N                               ((BASE) == TIM_DMABase_PSC) || \
N                               ((BASE) == TIM_DMABase_ARR) || \
N                               ((BASE) == TIM_DMABase_RCR) || \
N                               ((BASE) == TIM_DMABase_CCR1) || \
N                               ((BASE) == TIM_DMABase_CCR2) || \
N                               ((BASE) == TIM_DMABase_CCR3) || \
N                               ((BASE) == TIM_DMABase_CCR4) || \
N                               ((BASE) == TIM_DMABase_BDTR) || \
N							   ((BASE) == TIM_DMABase_DCR) || \
N                               ((BASE) == TIM_DMABase_OR))
X#define IS_TIM_DMA_BASE(BASE) (((BASE) == TIM_DMABase_CR1) ||                                ((BASE) == TIM_DMABase_CR2) ||                                ((BASE) == TIM_DMABase_SMCR) ||                                ((BASE) == TIM_DMABase_DIER) ||                                ((BASE) == TIM_DMABase_SR) ||                                ((BASE) == TIM_DMABase_EGR) ||                                ((BASE) == TIM_DMABase_CCMR1) ||                                ((BASE) == TIM_DMABase_CCMR2) ||                                ((BASE) == TIM_DMABase_CCER) ||                                ((BASE) == TIM_DMABase_CNT) ||                                ((BASE) == TIM_DMABase_PSC) ||                                ((BASE) == TIM_DMABase_ARR) ||                                ((BASE) == TIM_DMABase_RCR) ||                                ((BASE) == TIM_DMABase_CCR1) ||                                ((BASE) == TIM_DMABase_CCR2) ||                                ((BASE) == TIM_DMABase_CCR3) ||                                ((BASE) == TIM_DMABase_CCR4) ||                                ((BASE) == TIM_DMABase_BDTR) || 							   ((BASE) == TIM_DMABase_DCR) ||                                ((BASE) == TIM_DMABase_OR))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup TIM_DMA_Burst_Length 
N  * @{
N  */
N
N#define TIM_DMABurstLength_1Transfer           ((uint16_t)0x0000)
N#define TIM_DMABurstLength_2Transfers          ((uint16_t)0x0100)
N#define TIM_DMABurstLength_3Transfers          ((uint16_t)0x0200)
N#define TIM_DMABurstLength_4Transfers          ((uint16_t)0x0300)
N#define TIM_DMABurstLength_5Transfers          ((uint16_t)0x0400)
N#define TIM_DMABurstLength_6Transfers          ((uint16_t)0x0500)
N#define TIM_DMABurstLength_7Transfers          ((uint16_t)0x0600)
N#define TIM_DMABurstLength_8Transfers          ((uint16_t)0x0700)
N#define TIM_DMABurstLength_9Transfers          ((uint16_t)0x0800)
N#define TIM_DMABurstLength_10Transfers         ((uint16_t)0x0900)
N#define TIM_DMABurstLength_11Transfers         ((uint16_t)0x0A00)
N#define TIM_DMABurstLength_12Transfers         ((uint16_t)0x0B00)
N#define TIM_DMABurstLength_13Transfers         ((uint16_t)0x0C00)
N#define TIM_DMABurstLength_14Transfers         ((uint16_t)0x0D00)
N#define TIM_DMABurstLength_15Transfers         ((uint16_t)0x0E00)
N#define TIM_DMABurstLength_16Transfers         ((uint16_t)0x0F00)
N#define TIM_DMABurstLength_17Transfers         ((uint16_t)0x1000)
N#define TIM_DMABurstLength_18Transfers         ((uint16_t)0x1100)
N#define IS_TIM_DMA_LENGTH(LENGTH) (((LENGTH) == TIM_DMABurstLength_1Transfer) || \
N                                   ((LENGTH) == TIM_DMABurstLength_2Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_3Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_4Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_5Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_6Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_7Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_8Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_9Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_10Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_11Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_12Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_13Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_14Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_15Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_16Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_17Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_18Transfers))
X#define IS_TIM_DMA_LENGTH(LENGTH) (((LENGTH) == TIM_DMABurstLength_1Transfer) ||                                    ((LENGTH) == TIM_DMABurstLength_2Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_3Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_4Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_5Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_6Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_7Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_8Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_9Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_10Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_11Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_12Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_13Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_14Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_15Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_16Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_17Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_18Transfers))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_DMA_sources 
N  * @{
N  */
N
N#define TIM_DMA_Update                     ((uint16_t)0x0100)
N#define TIM_DMA_CC1                        ((uint16_t)0x0200)
N#define TIM_DMA_CC2                        ((uint16_t)0x0400)
N#define TIM_DMA_CC3                        ((uint16_t)0x0800)
N#define TIM_DMA_CC4                        ((uint16_t)0x1000)
N#define TIM_DMA_COM                        ((uint16_t)0x2000)
N#define TIM_DMA_Trigger                    ((uint16_t)0x4000)
N#define IS_TIM_DMA_SOURCE(SOURCE) ((((SOURCE) & (uint16_t)0x80FF) == 0x0000) && ((SOURCE) != 0x0000))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_External_Trigger_Prescaler 
N  * @{
N  */
N
N#define TIM_ExtTRGPSC_OFF                  ((uint16_t)0x0000)
N#define TIM_ExtTRGPSC_DIV2                 ((uint16_t)0x1000)
N#define TIM_ExtTRGPSC_DIV4                 ((uint16_t)0x2000)
N#define TIM_ExtTRGPSC_DIV8                 ((uint16_t)0x3000)
N#define IS_TIM_EXT_PRESCALER(PRESCALER) (((PRESCALER) == TIM_ExtTRGPSC_OFF) || \
N                                         ((PRESCALER) == TIM_ExtTRGPSC_DIV2) || \
N                                         ((PRESCALER) == TIM_ExtTRGPSC_DIV4) || \
N                                         ((PRESCALER) == TIM_ExtTRGPSC_DIV8))
X#define IS_TIM_EXT_PRESCALER(PRESCALER) (((PRESCALER) == TIM_ExtTRGPSC_OFF) ||                                          ((PRESCALER) == TIM_ExtTRGPSC_DIV2) ||                                          ((PRESCALER) == TIM_ExtTRGPSC_DIV4) ||                                          ((PRESCALER) == TIM_ExtTRGPSC_DIV8))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Internal_Trigger_Selection 
N  * @{
N  */
N
N#define TIM_TS_ITR0                        ((uint16_t)0x0000)
N#define TIM_TS_ITR1                        ((uint16_t)0x0010)
N#define TIM_TS_ITR2                        ((uint16_t)0x0020)
N#define TIM_TS_ITR3                        ((uint16_t)0x0030)
N#define TIM_TS_TI1F_ED                     ((uint16_t)0x0040)
N#define TIM_TS_TI1FP1                      ((uint16_t)0x0050)
N#define TIM_TS_TI2FP2                      ((uint16_t)0x0060)
N#define TIM_TS_ETRF                        ((uint16_t)0x0070)
N#define IS_TIM_TRIGGER_SELECTION(SELECTION) (((SELECTION) == TIM_TS_ITR0) || \
N                                             ((SELECTION) == TIM_TS_ITR1) || \
N                                             ((SELECTION) == TIM_TS_ITR2) || \
N                                             ((SELECTION) == TIM_TS_ITR3) || \
N                                             ((SELECTION) == TIM_TS_TI1F_ED) || \
N                                             ((SELECTION) == TIM_TS_TI1FP1) || \
N                                             ((SELECTION) == TIM_TS_TI2FP2) || \
N                                             ((SELECTION) == TIM_TS_ETRF))
X#define IS_TIM_TRIGGER_SELECTION(SELECTION) (((SELECTION) == TIM_TS_ITR0) ||                                              ((SELECTION) == TIM_TS_ITR1) ||                                              ((SELECTION) == TIM_TS_ITR2) ||                                              ((SELECTION) == TIM_TS_ITR3) ||                                              ((SELECTION) == TIM_TS_TI1F_ED) ||                                              ((SELECTION) == TIM_TS_TI1FP1) ||                                              ((SELECTION) == TIM_TS_TI2FP2) ||                                              ((SELECTION) == TIM_TS_ETRF))
N#define IS_TIM_INTERNAL_TRIGGER_SELECTION(SELECTION) (((SELECTION) == TIM_TS_ITR0) || \
N                                                      ((SELECTION) == TIM_TS_ITR1) || \
N                                                      ((SELECTION) == TIM_TS_ITR2) || \
N                                                      ((SELECTION) == TIM_TS_ITR3))
X#define IS_TIM_INTERNAL_TRIGGER_SELECTION(SELECTION) (((SELECTION) == TIM_TS_ITR0) ||                                                       ((SELECTION) == TIM_TS_ITR1) ||                                                       ((SELECTION) == TIM_TS_ITR2) ||                                                       ((SELECTION) == TIM_TS_ITR3))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_TIx_External_Clock_Source 
N  * @{
N  */
N
N#define TIM_TIxExternalCLK1Source_TI1      ((uint16_t)0x0050)
N#define TIM_TIxExternalCLK1Source_TI2      ((uint16_t)0x0060)
N#define TIM_TIxExternalCLK1Source_TI1ED    ((uint16_t)0x0040)
N
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_External_Trigger_Polarity 
N  * @{
N  */ 
N#define TIM_ExtTRGPolarity_Inverted        ((uint16_t)0x8000)
N#define TIM_ExtTRGPolarity_NonInverted     ((uint16_t)0x0000)
N#define IS_TIM_EXT_POLARITY(POLARITY) (((POLARITY) == TIM_ExtTRGPolarity_Inverted) || \
N                                       ((POLARITY) == TIM_ExtTRGPolarity_NonInverted))
X#define IS_TIM_EXT_POLARITY(POLARITY) (((POLARITY) == TIM_ExtTRGPolarity_Inverted) ||                                        ((POLARITY) == TIM_ExtTRGPolarity_NonInverted))
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Prescaler_Reload_Mode 
N  * @{
N  */
N
N#define TIM_PSCReloadMode_Update           ((uint16_t)0x0000)
N#define TIM_PSCReloadMode_Immediate        ((uint16_t)0x0001)
N#define IS_TIM_PRESCALER_RELOAD(RELOAD) (((RELOAD) == TIM_PSCReloadMode_Update) || \
N                                         ((RELOAD) == TIM_PSCReloadMode_Immediate))
X#define IS_TIM_PRESCALER_RELOAD(RELOAD) (((RELOAD) == TIM_PSCReloadMode_Update) ||                                          ((RELOAD) == TIM_PSCReloadMode_Immediate))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Forced_Action 
N  * @{
N  */
N
N#define TIM_ForcedAction_Active            ((uint16_t)0x0050)
N#define TIM_ForcedAction_InActive          ((uint16_t)0x0040)
N#define IS_TIM_FORCED_ACTION(ACTION) (((ACTION) == TIM_ForcedAction_Active) || \
N                                      ((ACTION) == TIM_ForcedAction_InActive))
X#define IS_TIM_FORCED_ACTION(ACTION) (((ACTION) == TIM_ForcedAction_Active) ||                                       ((ACTION) == TIM_ForcedAction_InActive))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Encoder_Mode 
N  * @{
N  */
N
N#define TIM_EncoderMode_TI1                ((uint16_t)0x0001)
N#define TIM_EncoderMode_TI2                ((uint16_t)0x0002)
N#define TIM_EncoderMode_TI12               ((uint16_t)0x0003)
N#define IS_TIM_ENCODER_MODE(MODE) (((MODE) == TIM_EncoderMode_TI1) || \
N                                   ((MODE) == TIM_EncoderMode_TI2) || \
N                                   ((MODE) == TIM_EncoderMode_TI12))
X#define IS_TIM_ENCODER_MODE(MODE) (((MODE) == TIM_EncoderMode_TI1) ||                                    ((MODE) == TIM_EncoderMode_TI2) ||                                    ((MODE) == TIM_EncoderMode_TI12))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup TIM_Event_Source 
N  * @{
N  */
N
N#define TIM_EventSource_Update             ((uint16_t)0x0001)
N#define TIM_EventSource_CC1                ((uint16_t)0x0002)
N#define TIM_EventSource_CC2                ((uint16_t)0x0004)
N#define TIM_EventSource_CC3                ((uint16_t)0x0008)
N#define TIM_EventSource_CC4                ((uint16_t)0x0010)
N#define TIM_EventSource_COM                ((uint16_t)0x0020)
N#define TIM_EventSource_Trigger            ((uint16_t)0x0040)
N#define TIM_EventSource_Break              ((uint16_t)0x0080)
N#define IS_TIM_EVENT_SOURCE(SOURCE) ((((SOURCE) & (uint16_t)0xFF00) == 0x0000) && ((SOURCE) != 0x0000))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Update_Source 
N  * @{
N  */
N
N#define TIM_UpdateSource_Global            ((uint16_t)0x0000) /*!< Source of update is the counter overflow/underflow
N                                                                   or the setting of UG bit, or an update generation
N                                                                   through the slave mode controller. */
N#define TIM_UpdateSource_Regular           ((uint16_t)0x0001) /*!< Source of update is counter overflow/underflow. */
N#define IS_TIM_UPDATE_SOURCE(SOURCE) (((SOURCE) == TIM_UpdateSource_Global) || \
N                                      ((SOURCE) == TIM_UpdateSource_Regular))
X#define IS_TIM_UPDATE_SOURCE(SOURCE) (((SOURCE) == TIM_UpdateSource_Global) ||                                       ((SOURCE) == TIM_UpdateSource_Regular))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Output_Compare_Preload_State 
N  * @{
N  */
N
N#define TIM_OCPreload_Enable               ((uint16_t)0x0008)
N#define TIM_OCPreload_Disable              ((uint16_t)0x0000)
N#define IS_TIM_OCPRELOAD_STATE(STATE) (((STATE) == TIM_OCPreload_Enable) || \
N                                       ((STATE) == TIM_OCPreload_Disable))
X#define IS_TIM_OCPRELOAD_STATE(STATE) (((STATE) == TIM_OCPreload_Enable) ||                                        ((STATE) == TIM_OCPreload_Disable))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Output_Compare_Fast_State 
N  * @{
N  */
N
N#define TIM_OCFast_Enable                  ((uint16_t)0x0004)
N#define TIM_OCFast_Disable                 ((uint16_t)0x0000)
N#define IS_TIM_OCFAST_STATE(STATE) (((STATE) == TIM_OCFast_Enable) || \
N                                    ((STATE) == TIM_OCFast_Disable))
X#define IS_TIM_OCFAST_STATE(STATE) (((STATE) == TIM_OCFast_Enable) ||                                     ((STATE) == TIM_OCFast_Disable))
N                                     
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Output_Compare_Clear_State 
N  * @{
N  */
N
N#define TIM_OCClear_Enable                 ((uint16_t)0x0080)
N#define TIM_OCClear_Disable                ((uint16_t)0x0000)
N#define IS_TIM_OCCLEAR_STATE(STATE) (((STATE) == TIM_OCClear_Enable) || \
N                                     ((STATE) == TIM_OCClear_Disable))
X#define IS_TIM_OCCLEAR_STATE(STATE) (((STATE) == TIM_OCClear_Enable) ||                                      ((STATE) == TIM_OCClear_Disable))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Trigger_Output_Source 
N  * @{
N  */
N
N#define TIM_TRGOSource_Reset               ((uint16_t)0x0000)
N#define TIM_TRGOSource_Enable              ((uint16_t)0x0010)
N#define TIM_TRGOSource_Update              ((uint16_t)0x0020)
N#define TIM_TRGOSource_OC1                 ((uint16_t)0x0030)
N#define TIM_TRGOSource_OC1Ref              ((uint16_t)0x0040)
N#define TIM_TRGOSource_OC2Ref              ((uint16_t)0x0050)
N#define TIM_TRGOSource_OC3Ref              ((uint16_t)0x0060)
N#define TIM_TRGOSource_OC4Ref              ((uint16_t)0x0070)
N#define IS_TIM_TRGO_SOURCE(SOURCE) (((SOURCE) == TIM_TRGOSource_Reset) || \
N                                    ((SOURCE) == TIM_TRGOSource_Enable) || \
N                                    ((SOURCE) == TIM_TRGOSource_Update) || \
N                                    ((SOURCE) == TIM_TRGOSource_OC1) || \
N                                    ((SOURCE) == TIM_TRGOSource_OC1Ref) || \
N                                    ((SOURCE) == TIM_TRGOSource_OC2Ref) || \
N                                    ((SOURCE) == TIM_TRGOSource_OC3Ref) || \
N                                    ((SOURCE) == TIM_TRGOSource_OC4Ref))
X#define IS_TIM_TRGO_SOURCE(SOURCE) (((SOURCE) == TIM_TRGOSource_Reset) ||                                     ((SOURCE) == TIM_TRGOSource_Enable) ||                                     ((SOURCE) == TIM_TRGOSource_Update) ||                                     ((SOURCE) == TIM_TRGOSource_OC1) ||                                     ((SOURCE) == TIM_TRGOSource_OC1Ref) ||                                     ((SOURCE) == TIM_TRGOSource_OC2Ref) ||                                     ((SOURCE) == TIM_TRGOSource_OC3Ref) ||                                     ((SOURCE) == TIM_TRGOSource_OC4Ref))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Slave_Mode 
N  * @{
N  */
N
N#define TIM_SlaveMode_Reset                ((uint16_t)0x0004)
N#define TIM_SlaveMode_Gated                ((uint16_t)0x0005)
N#define TIM_SlaveMode_Trigger              ((uint16_t)0x0006)
N#define TIM_SlaveMode_External1            ((uint16_t)0x0007)
N#define IS_TIM_SLAVE_MODE(MODE) (((MODE) == TIM_SlaveMode_Reset) || \
N                                 ((MODE) == TIM_SlaveMode_Gated) || \
N                                 ((MODE) == TIM_SlaveMode_Trigger) || \
N                                 ((MODE) == TIM_SlaveMode_External1))
X#define IS_TIM_SLAVE_MODE(MODE) (((MODE) == TIM_SlaveMode_Reset) ||                                  ((MODE) == TIM_SlaveMode_Gated) ||                                  ((MODE) == TIM_SlaveMode_Trigger) ||                                  ((MODE) == TIM_SlaveMode_External1))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Master_Slave_Mode 
N  * @{
N  */
N
N#define TIM_MasterSlaveMode_Enable         ((uint16_t)0x0080)
N#define TIM_MasterSlaveMode_Disable        ((uint16_t)0x0000)
N#define IS_TIM_MSM_STATE(STATE) (((STATE) == TIM_MasterSlaveMode_Enable) || \
N                                 ((STATE) == TIM_MasterSlaveMode_Disable))
X#define IS_TIM_MSM_STATE(STATE) (((STATE) == TIM_MasterSlaveMode_Enable) ||                                  ((STATE) == TIM_MasterSlaveMode_Disable))
N/**
N  * @}
N  */ 
N  
N/** @defgroup TIM_Flags 
N  * @{
N  */
N
N#define TIM_FLAG_Update                    ((uint16_t)0x0001)
N#define TIM_FLAG_CC1                       ((uint16_t)0x0002)
N#define TIM_FLAG_CC2                       ((uint16_t)0x0004)
N#define TIM_FLAG_CC3                       ((uint16_t)0x0008)
N#define TIM_FLAG_CC4                       ((uint16_t)0x0010)
N#define TIM_FLAG_COM                       ((uint16_t)0x0020)
N#define TIM_FLAG_Trigger                   ((uint16_t)0x0040)
N#define TIM_FLAG_Break                     ((uint16_t)0x0080)
N#define TIM_FLAG_CC1OF                     ((uint16_t)0x0200)
N#define TIM_FLAG_CC2OF                     ((uint16_t)0x0400)
N#define TIM_FLAG_CC3OF                     ((uint16_t)0x0800)
N#define TIM_FLAG_CC4OF                     ((uint16_t)0x1000)
N#define IS_TIM_GET_FLAG(FLAG) (((FLAG) == TIM_FLAG_Update) || \
N                               ((FLAG) == TIM_FLAG_CC1) || \
N                               ((FLAG) == TIM_FLAG_CC2) || \
N                               ((FLAG) == TIM_FLAG_CC3) || \
N                               ((FLAG) == TIM_FLAG_CC4) || \
N                               ((FLAG) == TIM_FLAG_COM) || \
N                               ((FLAG) == TIM_FLAG_Trigger) || \
N                               ((FLAG) == TIM_FLAG_Break) || \
N                               ((FLAG) == TIM_FLAG_CC1OF) || \
N                               ((FLAG) == TIM_FLAG_CC2OF) || \
N                               ((FLAG) == TIM_FLAG_CC3OF) || \
N                               ((FLAG) == TIM_FLAG_CC4OF))
X#define IS_TIM_GET_FLAG(FLAG) (((FLAG) == TIM_FLAG_Update) ||                                ((FLAG) == TIM_FLAG_CC1) ||                                ((FLAG) == TIM_FLAG_CC2) ||                                ((FLAG) == TIM_FLAG_CC3) ||                                ((FLAG) == TIM_FLAG_CC4) ||                                ((FLAG) == TIM_FLAG_COM) ||                                ((FLAG) == TIM_FLAG_Trigger) ||                                ((FLAG) == TIM_FLAG_Break) ||                                ((FLAG) == TIM_FLAG_CC1OF) ||                                ((FLAG) == TIM_FLAG_CC2OF) ||                                ((FLAG) == TIM_FLAG_CC3OF) ||                                ((FLAG) == TIM_FLAG_CC4OF))
N                               
N                               
N#define IS_TIM_CLEAR_FLAG(TIM_FLAG) ((((TIM_FLAG) & (uint16_t)0xE100) == 0x0000) && ((TIM_FLAG) != 0x0000))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup TIM_Input_Capture_Filer_Value 
N  * @{
N  */
N
N#define IS_TIM_IC_FILTER(ICFILTER) ((ICFILTER) <= 0xF) 
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_External_Trigger_Filter 
N  * @{
N  */
N
N#define IS_TIM_EXT_FILTER(EXTFILTER) ((EXTFILTER) <= 0xF)
N/**
N  * @}
N  */
N
N/** @defgroup TIM_OCReferenceClear 
N  * @{
N  */
N#define TIM_OCReferenceClear_ETRF          ((uint16_t)0x0008)
N#define TIM_OCReferenceClear_OCREFCLR      ((uint16_t)0x0000)
N#define TIM_OCREFERENCECECLEAR_SOURCE(SOURCE) (((SOURCE) == TIM_OCReferenceClear_ETRF) || \
N                                              ((SOURCE) == TIM_OCReferenceClear_OCREFCLR)) 
X#define TIM_OCREFERENCECECLEAR_SOURCE(SOURCE) (((SOURCE) == TIM_OCReferenceClear_ETRF) ||                                               ((SOURCE) == TIM_OCReferenceClear_OCREFCLR)) 
N
N/**
N  * @}
N  */
N/** @defgroup TIM_Remap 
N  * @{
N  */
N#define TIM14_GPIO                      ((uint16_t)0x0000)
N#define TIM14_RTC_CLK                   ((uint16_t)0x0001)
N#define TIM14_HSEDiv32                  ((uint16_t)0x0002)
N#define TIM14_MCO                       ((uint16_t)0x0003)
N
N#define IS_TIM_REMAP(TIM_REMAP)  (((TIM_REMAP) == TIM14_GPIO)|| \
N                                  ((TIM_REMAP) == TIM14_RTC_CLK) || \
N                                  ((TIM_REMAP) == TIM14_HSEDiv32) || \
N                                  ((TIM_REMAP) == TIM14_MCO))
X#define IS_TIM_REMAP(TIM_REMAP)  (((TIM_REMAP) == TIM14_GPIO)||                                   ((TIM_REMAP) == TIM14_RTC_CLK) ||                                   ((TIM_REMAP) == TIM14_HSEDiv32) ||                                   ((TIM_REMAP) == TIM14_MCO))
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Legacy 
N  * @{
N  */
N
N#define TIM_DMABurstLength_1Byte           TIM_DMABurstLength_1Transfer
N#define TIM_DMABurstLength_2Bytes          TIM_DMABurstLength_2Transfers
N#define TIM_DMABurstLength_3Bytes          TIM_DMABurstLength_3Transfers
N#define TIM_DMABurstLength_4Bytes          TIM_DMABurstLength_4Transfers
N#define TIM_DMABurstLength_5Bytes          TIM_DMABurstLength_5Transfers
N#define TIM_DMABurstLength_6Bytes          TIM_DMABurstLength_6Transfers
N#define TIM_DMABurstLength_7Bytes          TIM_DMABurstLength_7Transfers
N#define TIM_DMABurstLength_8Bytes          TIM_DMABurstLength_8Transfers
N#define TIM_DMABurstLength_9Bytes          TIM_DMABurstLength_9Transfers
N#define TIM_DMABurstLength_10Bytes         TIM_DMABurstLength_10Transfers
N#define TIM_DMABurstLength_11Bytes         TIM_DMABurstLength_11Transfers
N#define TIM_DMABurstLength_12Bytes         TIM_DMABurstLength_12Transfers
N#define TIM_DMABurstLength_13Bytes         TIM_DMABurstLength_13Transfers
N#define TIM_DMABurstLength_14Bytes         TIM_DMABurstLength_14Transfers
N#define TIM_DMABurstLength_15Bytes         TIM_DMABurstLength_15Transfers
N#define TIM_DMABurstLength_16Bytes         TIM_DMABurstLength_16Transfers
N#define TIM_DMABurstLength_17Bytes         TIM_DMABurstLength_17Transfers
N#define TIM_DMABurstLength_18Bytes         TIM_DMABurstLength_18Transfers
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N  
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */ 
N
N/* TimeBase management ********************************************************/
Nvoid TIM_DeInit(TIM_TypeDef* TIMx);
Nvoid TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct);
Nvoid TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct);
Nvoid TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode);
Nvoid TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode);
Nvoid TIM_SetCounter(TIM_TypeDef* TIMx, uint32_t Counter);
Nvoid TIM_SetAutoreload(TIM_TypeDef* TIMx, uint32_t Autoreload);
Nuint32_t TIM_GetCounter(TIM_TypeDef* TIMx);
Nuint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx);
Nvoid TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState);
Nvoid TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource);
Nvoid TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState);
Nvoid TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode);
Nvoid TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD);
Nvoid TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState);
N
N/* Advanced-control timers (TIM1) specific features*******************/
Nvoid TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct);
Nvoid TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct);
Nvoid TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState);
N
N/* Output Compare management **************************************************/
Nvoid TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
Nvoid TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
Nvoid TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
Nvoid TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
Nvoid TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct);
Nvoid TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode);
Nvoid TIM_SetCompare1(TIM_TypeDef* TIMx, uint32_t Compare1);
Nvoid TIM_SetCompare2(TIM_TypeDef* TIMx, uint32_t Compare2);
Nvoid TIM_SetCompare3(TIM_TypeDef* TIMx, uint32_t Compare3);
Nvoid TIM_SetCompare4(TIM_TypeDef* TIMx, uint32_t Compare4);
Nvoid TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);
Nvoid TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);
Nvoid TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);
Nvoid TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);
Nvoid TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState);
Nvoid TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);
Nvoid TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);
Nvoid TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);
Nvoid TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);
Nvoid TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);
Nvoid TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);
Nvoid TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);
Nvoid TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);
Nvoid TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);
Nvoid TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);
Nvoid TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);
Nvoid TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);
Nvoid TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);
Nvoid TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity);
Nvoid TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);
Nvoid TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity);
Nvoid TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);
Nvoid TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity);
Nvoid TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);
Nvoid TIM_SelectOCREFClear(TIM_TypeDef* TIMx, uint16_t TIM_OCReferenceClear);
Nvoid TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx);
Nvoid TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN);
Nvoid TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState);
N
N/* Input Capture management ***************************************************/
Nvoid TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct);
Nvoid TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct);
Nvoid TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct);
Nuint32_t TIM_GetCapture1(TIM_TypeDef* TIMx);
Nuint32_t TIM_GetCapture2(TIM_TypeDef* TIMx);
Nuint32_t TIM_GetCapture3(TIM_TypeDef* TIMx);
Nuint32_t TIM_GetCapture4(TIM_TypeDef* TIMx);
Nvoid TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);
Nvoid TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);
Nvoid TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);
Nvoid TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);
N
N/* Interrupts, DMA and flags management ***************************************/
Nvoid TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState);
Nvoid TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource);
NFlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG);
Nvoid TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG);
NITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT);
Nvoid TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT);
Nvoid TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength);
Nvoid TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState);
Nvoid TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState);
N
N/* Clocks management **********************************************************/
Nvoid TIM_InternalClockConfig(TIM_TypeDef* TIMx);
Nvoid TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);
Nvoid TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
N                                uint16_t TIM_ICPolarity, uint16_t ICFilter);
Nvoid TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
N                             uint16_t ExtTRGFilter);
Nvoid TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
N                             uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter);
N
N
N/* Synchronization management *************************************************/
Nvoid TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);
Nvoid TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource);
Nvoid TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode);
Nvoid TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode);
Nvoid TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
N                   uint16_t ExtTRGFilter);
N
N/* Specific interface management **********************************************/                   
Nvoid TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
N                                uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity);
Nvoid TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState);
N
N/* Specific remapping management **********************************************/
Nvoid TIM_RemapConfig(TIM_TypeDef* TIMx, uint16_t TIM_Remap);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__FT32F0XX_TIM_H */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT FMD *****END OF FILE****/
L 22 "..\FTLib\Src\ft32f0xx_tim.c" 2
N#include "ft32f0xx_rcc.h"
L 1 "..\FTLib\Inc\ft32f0xx_rcc.h" 1
N/**
N  ******************************************************************************
N  * @file    			ft32f0xx_rcc.h
N  * @author  			FMD AE
N  * @brief   			This file contains all the functions prototypes for the RCC 
N  *          			firmware library.
N  * @version 			V1.0.0           
N  * @data		 			2021-07-01
N  ******************************************************************************
N  */
N
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __FT32F0XX_RCC_H
N#define __FT32F0XX_RCC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "ft32f0xx.h"
N
N
N/** @addtogroup RCC
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
Ntypedef struct
N{
N  uint32_t SYSCLK_Frequency;
N  uint32_t HCLK_Frequency;
N  uint32_t PCLK_Frequency;
N  uint32_t ADCCLK_Frequency;
N  uint32_t CECCLK_Frequency;
N  uint32_t I2C1CLK_Frequency;
N  uint32_t USART1CLK_Frequency;
N  uint32_t USART2CLK_Frequency; 
N  uint32_t USART3CLK_Frequency; 
N  uint32_t USBCLK_Frequency;  
N}RCC_ClocksTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup RCC_Exported_Constants
N  * @{
N  */
N
N/** @defgroup RCC_HSE_configuration 
N  * @{
N  */
N
N#define RCC_HSE_OFF                      ((uint8_t)0x00)
N#define RCC_HSE_ON                       ((uint8_t)0x01)
N#define RCC_HSE_Bypass                   ((uint8_t)0x05)
N#define IS_RCC_HSE(HSE) (((HSE) == RCC_HSE_OFF) || ((HSE) == RCC_HSE_ON) || \
N                         ((HSE) == RCC_HSE_Bypass))
X#define IS_RCC_HSE(HSE) (((HSE) == RCC_HSE_OFF) || ((HSE) == RCC_HSE_ON) ||                          ((HSE) == RCC_HSE_Bypass))
N
N/**
N  * @}
N  */ 
N 
N/** @defgroup RCC_PLL_Clock_Source 
N  * @{
N  */
N
N#define RCC_PLLSource_HSI_Div2           RCC_CFGR_PLLSRC_HSI_Div2
N#define RCC_PLLSource_PREDIV1            RCC_CFGR_PLLSRC_HSE_PREDIV /* Old HSEPREDIV1 bit definition, maintained for legacy purpose */
N#define RCC_PLLSource_HSE                RCC_CFGR_PLLSRC_HSE_PREDIV 
N#define RCC_PLLSource_HSI48              RCC_CFGR_PLLSRC_HSI48_PREDIV 
N#define RCC_PLLSource_HSI                RCC_CFGR_PLLSRC_HSI_PREDIV
N
N#define IS_RCC_PLL_SOURCE(SOURCE) (((SOURCE) == RCC_PLLSource_HSI_Div2) || \
N                                   ((SOURCE) == RCC_PLLSource_HSI48)    || \
N                                   ((SOURCE) == RCC_PLLSource_HSI)      || \
N                                   ((SOURCE) == RCC_PLLSource_HSE)      || \
N                                   ((SOURCE) == RCC_PLLSource_PREDIV1))
X#define IS_RCC_PLL_SOURCE(SOURCE) (((SOURCE) == RCC_PLLSource_HSI_Div2) ||                                    ((SOURCE) == RCC_PLLSource_HSI48)    ||                                    ((SOURCE) == RCC_PLLSource_HSI)      ||                                    ((SOURCE) == RCC_PLLSource_HSE)      ||                                    ((SOURCE) == RCC_PLLSource_PREDIV1))
N/**
N  * @}
N  */ 
N
N/** @defgroup RCC_PLL_Multiplication_Factor 
N  * @{
N  */
N
N#define RCC_PLLMul_2                    RCC_CFGR_PLLMULL2
N#define RCC_PLLMul_3                    RCC_CFGR_PLLMULL3
N#define RCC_PLLMul_4                    RCC_CFGR_PLLMULL4
N#define RCC_PLLMul_5                    RCC_CFGR_PLLMULL5
N#define RCC_PLLMul_6                    RCC_CFGR_PLLMULL6
N#define RCC_PLLMul_7                    RCC_CFGR_PLLMULL7
N#define RCC_PLLMul_8                    RCC_CFGR_PLLMULL8
N#define RCC_PLLMul_9                    RCC_CFGR_PLLMULL9
N#define RCC_PLLMul_10                   RCC_CFGR_PLLMULL10
N#define RCC_PLLMul_11                   RCC_CFGR_PLLMULL11
N#define RCC_PLLMul_12                   RCC_CFGR_PLLMULL12
N#define RCC_PLLMul_13                   RCC_CFGR_PLLMULL13
N#define RCC_PLLMul_14                   RCC_CFGR_PLLMULL14
N#define RCC_PLLMul_15                   RCC_CFGR_PLLMULL15
N#define RCC_PLLMul_16                   RCC_CFGR_PLLMULL16
N#define IS_RCC_PLL_MUL(MUL) (((MUL) == RCC_PLLMul_2) || ((MUL) == RCC_PLLMul_3)   || \
N                             ((MUL) == RCC_PLLMul_4) || ((MUL) == RCC_PLLMul_5)   || \
N                             ((MUL) == RCC_PLLMul_6) || ((MUL) == RCC_PLLMul_7)   || \
N                             ((MUL) == RCC_PLLMul_8) || ((MUL) == RCC_PLLMul_9)   || \
N                             ((MUL) == RCC_PLLMul_10) || ((MUL) == RCC_PLLMul_11) || \
N                             ((MUL) == RCC_PLLMul_12) || ((MUL) == RCC_PLLMul_13) || \
N                             ((MUL) == RCC_PLLMul_14) || ((MUL) == RCC_PLLMul_15) || \
N                             ((MUL) == RCC_PLLMul_16))
X#define IS_RCC_PLL_MUL(MUL) (((MUL) == RCC_PLLMul_2) || ((MUL) == RCC_PLLMul_3)   ||                              ((MUL) == RCC_PLLMul_4) || ((MUL) == RCC_PLLMul_5)   ||                              ((MUL) == RCC_PLLMul_6) || ((MUL) == RCC_PLLMul_7)   ||                              ((MUL) == RCC_PLLMul_8) || ((MUL) == RCC_PLLMul_9)   ||                              ((MUL) == RCC_PLLMul_10) || ((MUL) == RCC_PLLMul_11) ||                              ((MUL) == RCC_PLLMul_12) || ((MUL) == RCC_PLLMul_13) ||                              ((MUL) == RCC_PLLMul_14) || ((MUL) == RCC_PLLMul_15) ||                              ((MUL) == RCC_PLLMul_16))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_PREDIV1_division_factor
N  * @{
N  */
N#define  RCC_PREDIV1_Div1               RCC_CFGR2_PREDIV1_DIV1
N#define  RCC_PREDIV1_Div2               RCC_CFGR2_PREDIV1_DIV2
N#define  RCC_PREDIV1_Div3               RCC_CFGR2_PREDIV1_DIV3
N#define  RCC_PREDIV1_Div4               RCC_CFGR2_PREDIV1_DIV4
N#define  RCC_PREDIV1_Div5               RCC_CFGR2_PREDIV1_DIV5
N#define  RCC_PREDIV1_Div6               RCC_CFGR2_PREDIV1_DIV6
N#define  RCC_PREDIV1_Div7               RCC_CFGR2_PREDIV1_DIV7
N#define  RCC_PREDIV1_Div8               RCC_CFGR2_PREDIV1_DIV8
N#define  RCC_PREDIV1_Div9               RCC_CFGR2_PREDIV1_DIV9
N#define  RCC_PREDIV1_Div10              RCC_CFGR2_PREDIV1_DIV10
N#define  RCC_PREDIV1_Div11              RCC_CFGR2_PREDIV1_DIV11
N#define  RCC_PREDIV1_Div12              RCC_CFGR2_PREDIV1_DIV12
N#define  RCC_PREDIV1_Div13              RCC_CFGR2_PREDIV1_DIV13
N#define  RCC_PREDIV1_Div14              RCC_CFGR2_PREDIV1_DIV14
N#define  RCC_PREDIV1_Div15              RCC_CFGR2_PREDIV1_DIV15
N#define  RCC_PREDIV1_Div16              RCC_CFGR2_PREDIV1_DIV16
N
N#define IS_RCC_PREDIV1(PREDIV1) (((PREDIV1) == RCC_PREDIV1_Div1) || ((PREDIV1) == RCC_PREDIV1_Div2) || \
N                                 ((PREDIV1) == RCC_PREDIV1_Div3) || ((PREDIV1) == RCC_PREDIV1_Div4) || \
N                                 ((PREDIV1) == RCC_PREDIV1_Div5) || ((PREDIV1) == RCC_PREDIV1_Div6) || \
N                                 ((PREDIV1) == RCC_PREDIV1_Div7) || ((PREDIV1) == RCC_PREDIV1_Div8) || \
N                                 ((PREDIV1) == RCC_PREDIV1_Div9) || ((PREDIV1) == RCC_PREDIV1_Div10) || \
N                                 ((PREDIV1) == RCC_PREDIV1_Div11) || ((PREDIV1) == RCC_PREDIV1_Div12) || \
N                                 ((PREDIV1) == RCC_PREDIV1_Div13) || ((PREDIV1) == RCC_PREDIV1_Div14) || \
N                                 ((PREDIV1) == RCC_PREDIV1_Div15) || ((PREDIV1) == RCC_PREDIV1_Div16))
X#define IS_RCC_PREDIV1(PREDIV1) (((PREDIV1) == RCC_PREDIV1_Div1) || ((PREDIV1) == RCC_PREDIV1_Div2) ||                                  ((PREDIV1) == RCC_PREDIV1_Div3) || ((PREDIV1) == RCC_PREDIV1_Div4) ||                                  ((PREDIV1) == RCC_PREDIV1_Div5) || ((PREDIV1) == RCC_PREDIV1_Div6) ||                                  ((PREDIV1) == RCC_PREDIV1_Div7) || ((PREDIV1) == RCC_PREDIV1_Div8) ||                                  ((PREDIV1) == RCC_PREDIV1_Div9) || ((PREDIV1) == RCC_PREDIV1_Div10) ||                                  ((PREDIV1) == RCC_PREDIV1_Div11) || ((PREDIV1) == RCC_PREDIV1_Div12) ||                                  ((PREDIV1) == RCC_PREDIV1_Div13) || ((PREDIV1) == RCC_PREDIV1_Div14) ||                                  ((PREDIV1) == RCC_PREDIV1_Div15) || ((PREDIV1) == RCC_PREDIV1_Div16))
N/**
N  * @}
N  */
N 
N/** @defgroup RCC_System_Clock_Source 
N  * @{
N  */
N
N#define RCC_SYSCLKSource_HSI             RCC_CFGR_SW_HSI
N#define RCC_SYSCLKSource_HSE             RCC_CFGR_SW_HSE
N#define RCC_SYSCLKSource_PLLCLK          RCC_CFGR_SW_PLL
N#define RCC_SYSCLKSource_HSI48           RCC_CFGR_SW_HSI48 
N
N#define IS_RCC_SYSCLK_SOURCE(SOURCE) (((SOURCE) == RCC_SYSCLKSource_HSI)   || \
N                                      ((SOURCE) == RCC_SYSCLKSource_HSE)   || \
N                                      ((SOURCE) == RCC_SYSCLKSource_HSI48) || \
N                                      ((SOURCE) == RCC_SYSCLKSource_PLLCLK))
X#define IS_RCC_SYSCLK_SOURCE(SOURCE) (((SOURCE) == RCC_SYSCLKSource_HSI)   ||                                       ((SOURCE) == RCC_SYSCLKSource_HSE)   ||                                       ((SOURCE) == RCC_SYSCLKSource_HSI48) ||                                       ((SOURCE) == RCC_SYSCLKSource_PLLCLK))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_AHB_Clock_Source
N  * @{
N  */
N
N#define RCC_SYSCLK_Div1                  RCC_CFGR_HPRE_DIV1
N#define RCC_SYSCLK_Div2                  RCC_CFGR_HPRE_DIV2
N#define RCC_SYSCLK_Div4                  RCC_CFGR_HPRE_DIV4
N#define RCC_SYSCLK_Div8                  RCC_CFGR_HPRE_DIV8
N#define RCC_SYSCLK_Div16                 RCC_CFGR_HPRE_DIV16
N#define RCC_SYSCLK_Div64                 RCC_CFGR_HPRE_DIV64
N#define RCC_SYSCLK_Div128                RCC_CFGR_HPRE_DIV128
N#define RCC_SYSCLK_Div256                RCC_CFGR_HPRE_DIV256
N#define RCC_SYSCLK_Div512                RCC_CFGR_HPRE_DIV512
N#define IS_RCC_HCLK(HCLK) (((HCLK) == RCC_SYSCLK_Div1) || ((HCLK) == RCC_SYSCLK_Div2) || \
N                           ((HCLK) == RCC_SYSCLK_Div4) || ((HCLK) == RCC_SYSCLK_Div8) || \
N                           ((HCLK) == RCC_SYSCLK_Div16) || ((HCLK) == RCC_SYSCLK_Div64) || \
N                           ((HCLK) == RCC_SYSCLK_Div128) || ((HCLK) == RCC_SYSCLK_Div256) || \
N                           ((HCLK) == RCC_SYSCLK_Div512))
X#define IS_RCC_HCLK(HCLK) (((HCLK) == RCC_SYSCLK_Div1) || ((HCLK) == RCC_SYSCLK_Div2) ||                            ((HCLK) == RCC_SYSCLK_Div4) || ((HCLK) == RCC_SYSCLK_Div8) ||                            ((HCLK) == RCC_SYSCLK_Div16) || ((HCLK) == RCC_SYSCLK_Div64) ||                            ((HCLK) == RCC_SYSCLK_Div128) || ((HCLK) == RCC_SYSCLK_Div256) ||                            ((HCLK) == RCC_SYSCLK_Div512))
N/**
N  * @}
N  */ 
N
N/** @defgroup RCC_APB_Clock_Source
N  * @{
N  */
N
N#define RCC_HCLK_Div1                    RCC_CFGR_PPRE_DIV1
N#define RCC_HCLK_Div2                    RCC_CFGR_PPRE_DIV2
N#define RCC_HCLK_Div4                    RCC_CFGR_PPRE_DIV4
N#define RCC_HCLK_Div8                    RCC_CFGR_PPRE_DIV8
N#define RCC_HCLK_Div16                   RCC_CFGR_PPRE_DIV16
N#define IS_RCC_PCLK(PCLK) (((PCLK) == RCC_HCLK_Div1) || ((PCLK) == RCC_HCLK_Div2) || \
N                           ((PCLK) == RCC_HCLK_Div4) || ((PCLK) == RCC_HCLK_Div8) || \
N                           ((PCLK) == RCC_HCLK_Div16))
X#define IS_RCC_PCLK(PCLK) (((PCLK) == RCC_HCLK_Div1) || ((PCLK) == RCC_HCLK_Div2) ||                            ((PCLK) == RCC_HCLK_Div4) || ((PCLK) == RCC_HCLK_Div8) ||                            ((PCLK) == RCC_HCLK_Div16))
N/**
N  * @}
N  */
N  
N/** @defgroup RCC_ADC_clock_source 
N  * @{
N  */
N/* These defines are obsolete and kept for legacy purpose only.
NProper ADC clock selection is done within ADC driver by mean of the ADC_ClockModeConfig() function */
N#define RCC_ADCCLK_HSI14                 ((uint32_t)0x00000000)
N#define RCC_ADCCLK_PCLK_Div2             ((uint32_t)0x01000000)
N#define RCC_ADCCLK_PCLK_Div4             ((uint32_t)0x01004000)
N
N#define IS_RCC_ADCCLK(ADCCLK) (((ADCCLK) == RCC_ADCCLK_HSI14) || ((ADCCLK) == RCC_ADCCLK_PCLK_Div2) || \
N                               ((ADCCLK) == RCC_ADCCLK_PCLK_Div4))
X#define IS_RCC_ADCCLK(ADCCLK) (((ADCCLK) == RCC_ADCCLK_HSI14) || ((ADCCLK) == RCC_ADCCLK_PCLK_Div2) ||                                ((ADCCLK) == RCC_ADCCLK_PCLK_Div4))
N
N/**
N  * @}
N  */
N
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_I2C_clock_source 
N  * @{
N  */
N
N#define RCC_I2C1CLK_HSI                   ((uint32_t)0x00000000)
N#define RCC_I2C1CLK_SYSCLK                RCC_CFGR3_I2C1SW
N
N#define IS_RCC_I2CCLK(I2CCLK) (((I2CCLK) == RCC_I2C1CLK_HSI) || ((I2CCLK) == RCC_I2C1CLK_SYSCLK))
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_USB_clock_source
N  * @brief    
N  * @{
N  */
N
N#define RCC_USBCLK_HSI48                 ((uint32_t)0x00000000)
N#define RCC_USBCLK_PLLCLK                RCC_CFGR3_USBSW
N
N#define IS_RCC_USBCLK(USBCLK) (((USBCLK) == RCC_USBCLK_HSI48) || ((USBCLK) == RCC_USBCLK_PLLCLK))
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_USART_clock_source 
N  * @{
N  */
N
N#define RCC_USART1CLK_PCLK                  ((uint32_t)0x10000000)
N#define RCC_USART1CLK_SYSCLK                ((uint32_t)0x10000001)
N#define RCC_USART1CLK_LSE                   ((uint32_t)0x10000002)
N#define RCC_USART1CLK_HSI                   ((uint32_t)0x10000003)
N
N#define RCC_USART2CLK_PCLK                  ((uint32_t)0x20000000) 
N#define RCC_USART2CLK_SYSCLK                ((uint32_t)0x20010000) 
N#define RCC_USART2CLK_LSE                   ((uint32_t)0x20020000) 
N#define RCC_USART2CLK_HSI                   ((uint32_t)0x20030000) 
N
N#define RCC_USART3CLK_PCLK                  ((uint32_t)0x30000000)
N#define RCC_USART3CLK_SYSCLK                ((uint32_t)0x30040000) 
N#define RCC_USART3CLK_LSE                   ((uint32_t)0x30080000)
N#define RCC_USART3CLK_HSI                   ((uint32_t)0x300C0000)
N
N
N#define IS_RCC_USARTCLK(USARTCLK) (((USARTCLK) == RCC_USART1CLK_PCLK)   || \
N                                   ((USARTCLK) == RCC_USART1CLK_SYSCLK) || \
N                                   ((USARTCLK) == RCC_USART1CLK_LSE)    || \
N                                   ((USARTCLK) == RCC_USART1CLK_HSI)    || \
N                                   ((USARTCLK) == RCC_USART2CLK_PCLK)   || \
N                                   ((USARTCLK) == RCC_USART2CLK_SYSCLK) || \
N                                   ((USARTCLK) == RCC_USART2CLK_LSE)    || \
N                                   ((USARTCLK) == RCC_USART2CLK_HSI)|| \
N                                   ((USARTCLK) == RCC_USART3CLK_PCLK)   || \
N                                   ((USARTCLK) == RCC_USART3CLK_SYSCLK) || \
N                                   ((USARTCLK) == RCC_USART3CLK_LSE)    || \
N                                   ((USARTCLK) == RCC_USART3CLK_HSI))
X#define IS_RCC_USARTCLK(USARTCLK) (((USARTCLK) == RCC_USART1CLK_PCLK)   ||                                    ((USARTCLK) == RCC_USART1CLK_SYSCLK) ||                                    ((USARTCLK) == RCC_USART1CLK_LSE)    ||                                    ((USARTCLK) == RCC_USART1CLK_HSI)    ||                                    ((USARTCLK) == RCC_USART2CLK_PCLK)   ||                                    ((USARTCLK) == RCC_USART2CLK_SYSCLK) ||                                    ((USARTCLK) == RCC_USART2CLK_LSE)    ||                                    ((USARTCLK) == RCC_USART2CLK_HSI)||                                    ((USARTCLK) == RCC_USART3CLK_PCLK)   ||                                    ((USARTCLK) == RCC_USART3CLK_SYSCLK) ||                                    ((USARTCLK) == RCC_USART3CLK_LSE)    ||                                    ((USARTCLK) == RCC_USART3CLK_HSI))
N
N/**
N  * @}
N  */
N         
N/** @defgroup RCC_Interrupt_Source 
N  * @{
N  */
N
N#define RCC_IT_LSIRDY                    ((uint8_t)0x01)
N#define RCC_IT_LSERDY                    ((uint8_t)0x02)
N#define RCC_IT_HSIRDY                    ((uint8_t)0x04)
N#define RCC_IT_HSERDY                    ((uint8_t)0x08)
N#define RCC_IT_PLLRDY                    ((uint8_t)0x10)
N#define RCC_IT_HSI14RDY                  ((uint8_t)0x20)
N#define RCC_IT_HSI48RDY                  ((uint8_t)0x40)
N#define RCC_IT_CSS                       ((uint8_t)0x80)
N
N#define IS_RCC_IT(IT) ((((IT) & (uint8_t)0x80) == 0x00) && ((IT) != 0x00))
N
N#define IS_RCC_GET_IT(IT) (((IT) == RCC_IT_LSIRDY) || ((IT) == RCC_IT_LSERDY) || \
N                           ((IT) == RCC_IT_HSIRDY) || ((IT) == RCC_IT_HSERDY) || \
N                           ((IT) == RCC_IT_PLLRDY) || ((IT) == RCC_IT_HSI14RDY) || \
N                           ((IT) == RCC_IT_CSS)    || ((IT) == RCC_IT_HSI48RDY))
X#define IS_RCC_GET_IT(IT) (((IT) == RCC_IT_LSIRDY) || ((IT) == RCC_IT_LSERDY) ||                            ((IT) == RCC_IT_HSIRDY) || ((IT) == RCC_IT_HSERDY) ||                            ((IT) == RCC_IT_PLLRDY) || ((IT) == RCC_IT_HSI14RDY) ||                            ((IT) == RCC_IT_CSS)    || ((IT) == RCC_IT_HSI48RDY))
N
N#define IS_RCC_CLEAR_IT(IT) ((IT) != 0x00)
N
N/**
N  * @}
N  */
N  
N/** @defgroup RCC_LSE_Configuration 
N  * @{
N  */
N
N#define RCC_LSE_OFF                      ((uint32_t)0x00000000)
N#define RCC_LSE_ON                       RCC_BDCR_LSEON
N#define RCC_LSE_Bypass                   ((uint32_t)(RCC_BDCR_LSEON | RCC_BDCR_LSEBYP))
N#define IS_RCC_LSE(LSE) (((LSE) == RCC_LSE_OFF) || ((LSE) == RCC_LSE_ON) || \
N                         ((LSE) == RCC_LSE_Bypass))
X#define IS_RCC_LSE(LSE) (((LSE) == RCC_LSE_OFF) || ((LSE) == RCC_LSE_ON) ||                          ((LSE) == RCC_LSE_Bypass))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_RTC_Clock_Source
N  * @{
N  */
N
N#define RCC_RTCCLKSource_LSE             RCC_BDCR_RTCSEL_LSE
N#define RCC_RTCCLKSource_LSI             RCC_BDCR_RTCSEL_LSI
N#define RCC_RTCCLKSource_HSE_Div32       RCC_BDCR_RTCSEL_HSE
N
N#define IS_RCC_RTCCLK_SOURCE(SOURCE) (((SOURCE) == RCC_RTCCLKSource_LSE) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_LSI) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div32))
X#define IS_RCC_RTCCLK_SOURCE(SOURCE) (((SOURCE) == RCC_RTCCLKSource_LSE) ||                                       ((SOURCE) == RCC_RTCCLKSource_LSI) ||                                       ((SOURCE) == RCC_RTCCLKSource_HSE_Div32))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LSE_Drive_Configuration 
N  * @{
N  */
N
N#define RCC_LSEDrive_Low                 ((uint32_t)0x00000000)
N#define RCC_LSEDrive_MediumLow           RCC_BDCR_LSEDRV_0
N#define RCC_LSEDrive_MediumHigh          RCC_BDCR_LSEDRV_1
N#define RCC_LSEDrive_High                RCC_BDCR_LSEDRV
N#define IS_RCC_LSE_DRIVE(DRIVE) (((DRIVE) == RCC_LSEDrive_Low) || ((DRIVE) == RCC_LSEDrive_MediumLow) || \
N                                 ((DRIVE) == RCC_LSEDrive_MediumHigh) || ((DRIVE) == RCC_LSEDrive_High))
X#define IS_RCC_LSE_DRIVE(DRIVE) (((DRIVE) == RCC_LSEDrive_Low) || ((DRIVE) == RCC_LSEDrive_MediumLow) ||                                  ((DRIVE) == RCC_LSEDrive_MediumHigh) || ((DRIVE) == RCC_LSEDrive_High))
N/**
N  * @}
N  */
N  
N/** @defgroup RCC_AHB_Peripherals 
N  * @{
N  */
N
N#define RCC_AHBPeriph_GPIOA               RCC_AHBENR_GPIOAEN
N#define RCC_AHBPeriph_GPIOB               RCC_AHBENR_GPIOBEN
N#define RCC_AHBPeriph_GPIOC               RCC_AHBENR_GPIOCEN
N#define RCC_AHBPeriph_GPIOD               RCC_AHBENR_GPIODEN
N#define RCC_AHBPeriph_GPIOE               RCC_AHBENR_GPIOEEN
N#define RCC_AHBPeriph_GPIOF               RCC_AHBENR_GPIOFEN
N#define RCC_AHBPeriph_TS                  RCC_AHBENR_TSEN
N#define RCC_AHBPeriph_CRC                 RCC_AHBENR_CRCEN
N#define RCC_AHBPeriph_FLITF               RCC_AHBENR_FLITFEN
N#define RCC_AHBPeriph_SRAM                RCC_AHBENR_SRAMEN
N#define RCC_AHBPeriph_DMA1                RCC_AHBENR_DMA1EN
N#define RCC_AHBPeriph_DMA2                RCC_AHBENR_DMA2EN
N
N#define IS_RCC_AHB_PERIPH(PERIPH) ((((PERIPH) & 0xFE81FFA8) == 0x00) && ((PERIPH) != 0x00))
N#define IS_RCC_AHB_RST_PERIPH(PERIPH) ((((PERIPH) & 0xFE81FFA8) == 0x00) && ((PERIPH) != 0x00))
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_APB2_Peripherals 
N  * @{
N  */
N
N#define RCC_APB2Periph_SYSCFG            RCC_APB2ENR_SYSCFGEN
N#define RCC_APB2Periph_USART6            RCC_APB2ENR_USART6EN
N#define RCC_APB2Periph_USART7            RCC_APB2ENR_USART7EN
N#define RCC_APB2Periph_USART8            RCC_APB2ENR_USART8EN
N#define RCC_APB2Periph_ADC1              RCC_APB2ENR_ADC1EN
N#define RCC_APB2Periph_TIM1              RCC_APB2ENR_TIM1EN
N#define RCC_APB2Periph_SPI1              RCC_APB2ENR_SPI1EN
N#define RCC_APB2Periph_USART1            RCC_APB2ENR_USART1EN
N#define RCC_APB2Periph_TIM15             RCC_APB2ENR_TIM15EN
N#define RCC_APB2Periph_TIM16             RCC_APB2ENR_TIM16EN
N#define RCC_APB2Periph_TIM17             RCC_APB2ENR_TIM17EN
N#define RCC_APB2Periph_DBGMCU            RCC_APB2ENR_DBGMCUEN
N
N#define IS_RCC_APB2_PERIPH(PERIPH) ((((PERIPH) & 0xFFB8A51E) == 0x00) && ((PERIPH) != 0x00))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RCC_APB1_Peripherals 
N  * @{
N  */
N
N#define RCC_APB1Periph_TIM2              RCC_APB1ENR_TIM2EN   
N#define RCC_APB1Periph_TIM3              RCC_APB1ENR_TIM3EN
N#define RCC_APB1Periph_TIM6              RCC_APB1ENR_TIM6EN
N#define RCC_APB1Periph_TIM7              RCC_APB1ENR_TIM7EN   
N#define RCC_APB1Periph_TIM14             RCC_APB1ENR_TIM14EN
N#define RCC_APB1Periph_WWDG              RCC_APB1ENR_WWDGEN
N#define RCC_APB1Periph_SPI2              RCC_APB1ENR_SPI2EN
N#define RCC_APB1Periph_USART2            RCC_APB1ENR_USART2EN
N#define RCC_APB1Periph_USART3            RCC_APB1ENR_USART3EN  
N#define RCC_APB1Periph_USART4            RCC_APB1ENR_USART4EN 
N#define RCC_APB1Periph_USART5            RCC_APB1ENR_USART5EN 
N#define RCC_APB1Periph_I2C1              RCC_APB1ENR_I2C1EN
N#define RCC_APB1Periph_I2C2              RCC_APB1ENR_I2C2EN
N#define RCC_APB1Periph_USB               RCC_APB1ENR_USBEN    
N#define RCC_APB1Periph_CAN               RCC_APB1ENR_CANEN    
N#define RCC_APB1Periph_CRS               RCC_APB1ENR_CRSEN    
N#define RCC_APB1Periph_PWR               RCC_APB1ENR_PWREN
N#define RCC_APB1Periph_DAC               RCC_APB1ENR_DACEN     
N#define RCC_APB1Periph_CEC               RCC_APB1ENR_CECEN     
N
N#define IS_RCC_APB1_PERIPH(PERIPH) ((((PERIPH) & 0x8581B6CC) == 0x00) && ((PERIPH) != 0x00))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_MCO_Clock_Source
N  * @{
N  */
N
N#define RCC_MCOSource_NoClock            ((uint8_t)0x00)
N#define RCC_MCOSource_HSI14              ((uint8_t)0x01)
N#define RCC_MCOSource_LSI                ((uint8_t)0x02)
N#define RCC_MCOSource_LSE                ((uint8_t)0x03)
N#define RCC_MCOSource_SYSCLK             ((uint8_t)0x04)
N#define RCC_MCOSource_HSI                ((uint8_t)0x05)
N#define RCC_MCOSource_HSE                ((uint8_t)0x06)
N#define RCC_MCOSource_PLLCLK_Div2        ((uint8_t)0x07)
N#define RCC_MCOSource_HSI48              ((uint8_t)0x08)  
N#define RCC_MCOSource_PLLCLK             ((uint8_t)0x87)
N
N#define IS_RCC_MCO_SOURCE(SOURCE) (((SOURCE) == RCC_MCOSource_NoClock) || ((SOURCE) == RCC_MCOSource_HSI14)      || \
N                                   ((SOURCE) == RCC_MCOSource_SYSCLK)  || ((SOURCE) == RCC_MCOSource_HSI)        || \
N                                   ((SOURCE) == RCC_MCOSource_HSE)     || ((SOURCE) == RCC_MCOSource_PLLCLK_Div2)|| \
N                                   ((SOURCE) == RCC_MCOSource_LSI)     || ((SOURCE) == RCC_MCOSource_HSI48)      || \
N                                   ((SOURCE) == RCC_MCOSource_PLLCLK)  || ((SOURCE) == RCC_MCOSource_LSE))
X#define IS_RCC_MCO_SOURCE(SOURCE) (((SOURCE) == RCC_MCOSource_NoClock) || ((SOURCE) == RCC_MCOSource_HSI14)      ||                                    ((SOURCE) == RCC_MCOSource_SYSCLK)  || ((SOURCE) == RCC_MCOSource_HSI)        ||                                    ((SOURCE) == RCC_MCOSource_HSE)     || ((SOURCE) == RCC_MCOSource_PLLCLK_Div2)||                                    ((SOURCE) == RCC_MCOSource_LSI)     || ((SOURCE) == RCC_MCOSource_HSI48)      ||                                    ((SOURCE) == RCC_MCOSource_PLLCLK)  || ((SOURCE) == RCC_MCOSource_LSE))
N/**
N  * @}
N  */ 
N
N/** @defgroup RCC_MCOPrescaler
N  * @{
N  */
N#if !defined (FT32F051)
X#if !0L
N#define RCC_MCOPrescaler_1            RCC_CFGR_MCO_PRE_1
N#define RCC_MCOPrescaler_2            RCC_CFGR_MCO_PRE_2
N#define RCC_MCOPrescaler_4            RCC_CFGR_MCO_PRE_4
N#define RCC_MCOPrescaler_8            RCC_CFGR_MCO_PRE_8
N#define RCC_MCOPrescaler_16           RCC_CFGR_MCO_PRE_16
N#define RCC_MCOPrescaler_32           RCC_CFGR_MCO_PRE_32
N#define RCC_MCOPrescaler_64           RCC_CFGR_MCO_PRE_64
N#define RCC_MCOPrescaler_128          RCC_CFGR_MCO_PRE_128
N
N#define IS_RCC_MCO_PRESCALER(PRESCALER) (((PRESCALER) == RCC_MCOPrescaler_1)  || \
N                                         ((PRESCALER) == RCC_MCOPrescaler_2)  || \
N                                         ((PRESCALER) == RCC_MCOPrescaler_4)  || \
N                                         ((PRESCALER) == RCC_MCOPrescaler_8)  || \
N                                         ((PRESCALER) == RCC_MCOPrescaler_16) || \
N                                         ((PRESCALER) == RCC_MCOPrescaler_32) || \
N                                         ((PRESCALER) == RCC_MCOPrescaler_64) || \
N                                         ((PRESCALER) == RCC_MCOPrescaler_128))
X#define IS_RCC_MCO_PRESCALER(PRESCALER) (((PRESCALER) == RCC_MCOPrescaler_1)  ||                                          ((PRESCALER) == RCC_MCOPrescaler_2)  ||                                          ((PRESCALER) == RCC_MCOPrescaler_4)  ||                                          ((PRESCALER) == RCC_MCOPrescaler_8)  ||                                          ((PRESCALER) == RCC_MCOPrescaler_16) ||                                          ((PRESCALER) == RCC_MCOPrescaler_32) ||                                          ((PRESCALER) == RCC_MCOPrescaler_64) ||                                          ((PRESCALER) == RCC_MCOPrescaler_128))
N#endif /* FT32F051 */                                         
N/**
N  * @}
N  */ 
N
N/** @defgroup RCC_Flag 
N  * @{
N  */
N#define RCC_FLAG_HSIRDY                  ((uint8_t)0x01)
N#define RCC_FLAG_HSERDY                  ((uint8_t)0x11)
N#define RCC_FLAG_PLLRDY                  ((uint8_t)0x19)
N#define RCC_FLAG_LSERDY                  ((uint8_t)0x21)
N#define RCC_FLAG_LSIRDY                  ((uint8_t)0x41)
N#define RCC_FLAG_V18PWRRSTF              ((uint8_t)0x57)
N#define RCC_FLAG_OBLRST                  ((uint8_t)0x59)
N#define RCC_FLAG_PINRST                  ((uint8_t)0x5A)
N#define RCC_FLAG_PORRST                  ((uint8_t)0x5B)
N#define RCC_FLAG_SFTRST                  ((uint8_t)0x5C)
N#define RCC_FLAG_IWDGRST                 ((uint8_t)0x5D)
N#define RCC_FLAG_WWDGRST                 ((uint8_t)0x5E)
N#define RCC_FLAG_LPWRRST                 ((uint8_t)0x5F)
N#define RCC_FLAG_HSI14RDY                ((uint8_t)0x61)
N#define RCC_FLAG_HSI48RDY                ((uint8_t)0x71)
N
N#define IS_RCC_FLAG(FLAG) (((FLAG) == RCC_FLAG_HSIRDY)  || ((FLAG) == RCC_FLAG_HSERDY)  || \
N                           ((FLAG) == RCC_FLAG_PLLRDY)  || ((FLAG) == RCC_FLAG_LSERDY)  || \
N                           ((FLAG) == RCC_FLAG_LSIRDY)  || ((FLAG) == RCC_FLAG_OBLRST)  || \
N                           ((FLAG) == RCC_FLAG_PINRST)  || ((FLAG) == RCC_FLAG_PORRST)  || \
N                           ((FLAG) == RCC_FLAG_SFTRST)  || ((FLAG) == RCC_FLAG_IWDGRST) || \
N                           ((FLAG) == RCC_FLAG_WWDGRST) || ((FLAG) == RCC_FLAG_LPWRRST) || \
N                           ((FLAG) == RCC_FLAG_HSI14RDY)|| ((FLAG) == RCC_FLAG_HSI48RDY)|| \
N                           ((FLAG) == RCC_FLAG_V18PWRRSTF))
X#define IS_RCC_FLAG(FLAG) (((FLAG) == RCC_FLAG_HSIRDY)  || ((FLAG) == RCC_FLAG_HSERDY)  ||                            ((FLAG) == RCC_FLAG_PLLRDY)  || ((FLAG) == RCC_FLAG_LSERDY)  ||                            ((FLAG) == RCC_FLAG_LSIRDY)  || ((FLAG) == RCC_FLAG_OBLRST)  ||                            ((FLAG) == RCC_FLAG_PINRST)  || ((FLAG) == RCC_FLAG_PORRST)  ||                            ((FLAG) == RCC_FLAG_SFTRST)  || ((FLAG) == RCC_FLAG_IWDGRST) ||                            ((FLAG) == RCC_FLAG_WWDGRST) || ((FLAG) == RCC_FLAG_LPWRRST) ||                            ((FLAG) == RCC_FLAG_HSI14RDY)|| ((FLAG) == RCC_FLAG_HSI48RDY)||                            ((FLAG) == RCC_FLAG_V18PWRRSTF))
N
N#define IS_RCC_HSI_CALIBRATION_VALUE(VALUE) ((VALUE) <= 0x1F)
N#define IS_RCC_HSI14_CALIBRATION_VALUE(VALUE) ((VALUE) <= 0x1F)
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
N/* Function used to set the RCC clock configuration to the default reset state */
Nvoid RCC_DeInit(void);
N
N/* Internal/external clocks, PLL, CSS and MCO configuration functions *********/
Nvoid RCC_HSEConfig(uint8_t RCC_HSE);
NErrorStatus RCC_WaitForHSEStartUp(void);
Nvoid RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue);
Nvoid RCC_HSICmd(FunctionalState NewState);
Nvoid RCC_AdjustHSI14CalibrationValue(uint8_t HSI14CalibrationValue);
Nvoid RCC_HSI14Cmd(FunctionalState NewState);
Nvoid RCC_HSI14ADCRequestCmd(FunctionalState NewState);
Nvoid RCC_LSEConfig(uint32_t RCC_LSE);
Nvoid RCC_LSEDriveConfig(uint32_t RCC_LSEDrive);
Nvoid RCC_LSICmd(FunctionalState NewState);
Nvoid RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t RCC_PLLMul);
Nvoid RCC_PLLCmd(FunctionalState NewState);
Nvoid RCC_HSI48Cmd(FunctionalState NewState);
Nuint32_t RCC_GetHSI48CalibrationValue(void); 
Nvoid RCC_PREDIV1Config(uint32_t RCC_PREDIV1_Div);
Nvoid RCC_ClockSecuritySystemCmd(FunctionalState NewState);
N#ifdef FT32F051
Svoid RCC_MCOConfig(uint8_t RCC_MCOSource);
N#else
Nvoid RCC_MCOConfig(uint8_t RCC_MCOSource,uint32_t RCC_MCOPrescaler);
N#endif /* FT32F051 */
N
N/* System, AHB and APB busses clocks configuration functions ******************/
Nvoid RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource);
Nuint8_t RCC_GetSYSCLKSource(void);
Nvoid RCC_HCLKConfig(uint32_t RCC_SYSCLK);
Nvoid RCC_PCLKConfig(uint32_t RCC_HCLK);
Nvoid RCC_ADCCLKConfig(uint32_t RCC_ADCCLK); /* This function is obsolete.
N                                               For proper ADC clock selection, refer to
N                                               ADC_ClockModeConfig() in the ADC driver */
Nvoid RCC_CECCLKConfig(uint32_t RCC_CECCLK);
Nvoid RCC_I2CCLKConfig(uint32_t RCC_I2CCLK);
Nvoid RCC_USARTCLKConfig(uint32_t RCC_USARTCLK);
Nvoid RCC_USBCLKConfig(uint32_t RCC_USBCLK); 
Nvoid RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks);
N
N/* Peripheral clocks configuration functions **********************************/
Nvoid RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource);
Nvoid RCC_RTCCLKCmd(FunctionalState NewState);
Nvoid RCC_BackupResetCmd(FunctionalState NewState);
N
Nvoid RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState);
Nvoid RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState);
Nvoid RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState);
N
Nvoid RCC_AHBPeriphResetCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState);
Nvoid RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState);
Nvoid RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState);
N
N/* Interrupts and flags management functions **********************************/
Nvoid RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState);
NFlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG);
Nvoid RCC_ClearFlag(void);
NITStatus RCC_GetITStatus(uint8_t RCC_IT);
Nvoid RCC_ClearITPendingBit(uint8_t RCC_IT);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __FT32F0XX_RCC_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/************************ (C) COPYRIGHT FMD *****END OF FILE****/
L 23 "..\FTLib\Src\ft32f0xx_tim.c" 2
N
N
N/* ---------------------- TIM registers bit mask ------------------------ */
N#define SMCR_ETR_MASK               ((uint16_t)0x00FF) 
N#define CCMR_OFFSET                 ((uint16_t)0x0018)
N#define CCER_CCE_SET                ((uint16_t)0x0001)
N#define CCER_CCNE_SET               ((uint16_t)0x0004) 
N  
N
Nstatic void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
N                       uint16_t TIM_ICFilter);
Nstatic void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
N                       uint16_t TIM_ICFilter);
Nstatic void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
N                       uint16_t TIM_ICFilter);
Nstatic void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
N                       uint16_t TIM_ICFilter);
N
N/**
N  * @brief  Deinitializes the TIMx peripheral registers to their default reset values.
N  * @param  TIMx: where x can be 1, 2, 3, 6, 7, 14, 15, 16 and 17 to select the TIM peripheral.  
N  * @retval None
N  *   
N  */
Nvoid TIM_DeInit(TIM_TypeDef* TIMx)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
X  ((void)0); 
N
N  if (TIMx == TIM1)
X  if (TIMx == ((TIM_TypeDef *) (((uint32_t)0x40000000) + 0x00012C00)))
N  {
N    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
X    RCC_APB2PeriphResetCmd(((uint32_t)0x00000800), ENABLE);
N    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
X    RCC_APB2PeriphResetCmd(((uint32_t)0x00000800), DISABLE);  
N  }     
N//  else if (TIMx == TIM2)
N//  {
N//    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
N//    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
N//  }
N  else if (TIMx == TIM3)
X  else if (TIMx == ((TIM_TypeDef *) (((uint32_t)0x40000000) + 0x00000400)))
N  {
N    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
X    RCC_APB1PeriphResetCmd(((uint32_t)0x00000002), ENABLE);
N    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
X    RCC_APB1PeriphResetCmd(((uint32_t)0x00000002), DISABLE);
N  }
N  else if (TIMx == TIM6)
X  else if (TIMx == ((TIM_TypeDef *) (((uint32_t)0x40000000) + 0x00001000)))
N  {
N    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
X    RCC_APB1PeriphResetCmd(((uint32_t)0x00000010), ENABLE);
N    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
X    RCC_APB1PeriphResetCmd(((uint32_t)0x00000010), DISABLE);
N  } 
N//  else if (TIMx == TIM7)
N//  {
N//    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
N//    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
N//  }
N  else if (TIMx == TIM14) 
X  else if (TIMx == ((TIM_TypeDef *) (((uint32_t)0x40000000) + 0x00002000))) 
N  {       
N    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
X    RCC_APB1PeriphResetCmd(((uint32_t)0x00000100), ENABLE);
N    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE);  
X    RCC_APB1PeriphResetCmd(((uint32_t)0x00000100), DISABLE);  
N  }        
N  else if (TIMx == TIM15)
X  else if (TIMx == ((TIM_TypeDef *) (((uint32_t)0x40000000) + 0x00014000)))
N  {
N    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM15, ENABLE);
X    RCC_APB2PeriphResetCmd(((uint32_t)0x00010000), ENABLE);
N    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM15, DISABLE);
X    RCC_APB2PeriphResetCmd(((uint32_t)0x00010000), DISABLE);
N  } 
N  else if (TIMx == TIM16)
X  else if (TIMx == ((TIM_TypeDef *) (((uint32_t)0x40000000) + 0x00014400)))
N  {
N    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM16, ENABLE);
X    RCC_APB2PeriphResetCmd(((uint32_t)0x00020000), ENABLE);
N    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM16, DISABLE);
X    RCC_APB2PeriphResetCmd(((uint32_t)0x00020000), DISABLE);
N  } 
N  else
N  {
N    if (TIMx == TIM17)
X    if (TIMx == ((TIM_TypeDef *) (((uint32_t)0x40000000) + 0x00014800)))
N    {
N      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, ENABLE);
X      RCC_APB2PeriphResetCmd(((uint32_t)0x00040000), ENABLE);
N      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, DISABLE);
X      RCC_APB2PeriphResetCmd(((uint32_t)0x00040000), DISABLE);
N    }  
N  }
N     
N}
N
N/**
N  * @brief  Initializes the TIMx Time Base Unit peripheral according to 
N  *         the specified parameters in the TIM_TimeBaseInitStruct.
N  * @param  TIMx: where x can be 1, 2, 3, 6, 7, 14, 15, 16 and 17 to select the TIM 
N  *         peripheral. 
N  * @param  TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef
N  *         structure that contains the configuration information for
N  *         the specified TIM peripheral.
N  * @retval None
N  */
Nvoid TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
N{
N  uint16_t tmpcr1 = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
X  ((void)0); 
N  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
X  ((void)0);
N  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
X  ((void)0);
N
N  tmpcr1 = TIMx->CR1;  
N
N  if((TIMx == TIM1) || (TIMx == TIM2) || (TIMx == TIM3))
X  if((TIMx == ((TIM_TypeDef *) (((uint32_t)0x40000000) + 0x00012C00))) || (TIMx == ((TIM_TypeDef *) (((uint32_t)0x40000000) + 0x00000000))) || (TIMx == ((TIM_TypeDef *) (((uint32_t)0x40000000) + 0x00000400))))
N  {
N    /* Select the Counter Mode */
N    tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
X    tmpcr1 &= (uint16_t)(~((uint16_t)(((uint16_t)0x0010) | ((uint16_t)0x0060))));
N    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
N  }
N 
N  if(TIMx != TIM6)
X  if(TIMx != ((TIM_TypeDef *) (((uint32_t)0x40000000) + 0x00001000)))
N  {
N    /* Set the clock division */
N    tmpcr1 &= (uint16_t)(~((uint16_t)TIM_CR1_CKD));
X    tmpcr1 &= (uint16_t)(~((uint16_t)((uint16_t)0x0300)));
N    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
N  }
N
N  TIMx->CR1 = tmpcr1;
N
N  /* Set the Autoreload value */
N  TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
N 
N  /* Set the Prescaler value */
N  TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
N    
N  if ((TIMx == TIM1) || (TIMx == TIM15)|| (TIMx == TIM16) || (TIMx == TIM17))  
X  if ((TIMx == ((TIM_TypeDef *) (((uint32_t)0x40000000) + 0x00012C00))) || (TIMx == ((TIM_TypeDef *) (((uint32_t)0x40000000) + 0x00014000)))|| (TIMx == ((TIM_TypeDef *) (((uint32_t)0x40000000) + 0x00014400))) || (TIMx == ((TIM_TypeDef *) (((uint32_t)0x40000000) + 0x00014800))))  
N  {
N    /* Set the Repetition Counter value */
N    TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
N  }
N
N  /* Generate an update event to reload the Prescaler and the Repetition counter
N     values immediately */
N  TIMx->EGR = TIM_PSCReloadMode_Immediate;           
X  TIMx->EGR = ((uint16_t)0x0001);           
N}
N
N/**
N  * @brief  Fills each TIM_TimeBaseInitStruct member with its default value.
N  * @param  TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef structure
N  *         which will be initialized.
N  * @retval None
N  */
Nvoid TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
N{
N  /* Set the default configuration */
N  TIM_TimeBaseInitStruct->TIM_Period = 0xFFFFFFFF;
N  TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
N  TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
X  TIM_TimeBaseInitStruct->TIM_ClockDivision = ((uint16_t)0x0000);
N  TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
X  TIM_TimeBaseInitStruct->TIM_CounterMode = ((uint16_t)0x0000);
N  TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
N}
N
N/**
N  * @brief  Configures the TIMx Prescaler.
N  * @param  TIMx: where x can be 1, 2, 3, 6, 7, 14, 15, 16 and 17 to select the TIM peripheral.    
N  * @param  Prescaler: specifies the Prescaler Register value
N  * @param  TIM_PSCReloadMode: specifies the TIM Prescaler Reload mode
N  *          This parameter can be one of the following values:
N  *            @arg TIM_PSCReloadMode_Update: The Prescaler is loaded at the update event.
N  *            @arg TIM_PSCReloadMode_Immediate: The Prescaler is loaded immediatly.
N  * @retval None
N  */
Nvoid TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_ALL_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
X  ((void)0);
N  
N  /* Set the Prescaler value */
N  TIMx->PSC = Prescaler;
N  /* Set or reset the UG Bit */
N  TIMx->EGR = TIM_PSCReloadMode;
N}
N
N/**
N  * @brief  Specifies the TIMx Counter Mode to be used.
N  * @param  TIMx: where x can be 1, 2, or 3 to select the TIM peripheral.
N  * @param  TIM_CounterMode: specifies the Counter Mode to be used
N  *          This parameter can be one of the following values:
N  *            @arg TIM_CounterMode_Up: TIM Up Counting Mode
N  *            @arg TIM_CounterMode_Down: TIM Down Counting Mode
N  *            @arg TIM_CounterMode_CenterAligned1: TIM Center Aligned Mode1
N  *            @arg TIM_CounterMode_CenterAligned2: TIM Center Aligned Mode2
N  *            @arg TIM_CounterMode_CenterAligned3: TIM Center Aligned Mode3
N  * @retval None
N  */
Nvoid TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode)
N{
N  uint16_t tmpcr1 = 0;
N  
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
X  ((void)0);
N  
N  tmpcr1 = TIMx->CR1;
N  /* Reset the CMS and DIR Bits */
N  tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
X  tmpcr1 &= (uint16_t)(~((uint16_t)(((uint16_t)0x0010) | ((uint16_t)0x0060))));
N  /* Set the Counter Mode */
N  tmpcr1 |= TIM_CounterMode;
N  /* Write to TIMx CR1 register */
N  TIMx->CR1 = tmpcr1;
N}
N
N/**
N  * @brief  Sets the TIMx Counter Register value
N  * @param  TIMx: where x can be 1, 2, 3, 6, 7, 14, 15, 16 and 17 to select the TIM 
N  *          peripheral.   
N  * @param  Counter: specifies the Counter register new value.
N  * @retval None
N  */
Nvoid TIM_SetCounter(TIM_TypeDef* TIMx, uint32_t Counter)
N{
N  /* Check the parameters */
N   assert_param(IS_TIM_ALL_PERIPH(TIMx));
X   ((void)0);
N   
N  /* Set the Counter Register value */
N  TIMx->CNT = Counter;
N}
N
N/**
N  * @brief  Sets the TIMx Autoreload Register value
N  * @param  TIMx: where x can be 1, 2, 3, 6, 7, 14, 15, 16 and 17 to select the TIM peripheral.   
N  * @param  Autoreload: specifies the Autoreload register new value.
N  * @retval None
N  */
Nvoid TIM_SetAutoreload(TIM_TypeDef* TIMx, uint32_t Autoreload)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_ALL_PERIPH(TIMx));
X  ((void)0);
N  
N  /* Set the Autoreload Register value */
N  TIMx->ARR = Autoreload;
N}
N
N/**
N  * @brief  Gets the TIMx Counter value.
N  * @param  TIMx: where x can be 1, 2, 3, 6, 7, 14, 15, 16 and 17 to select the TIM 
N  *         peripheral.  
N  * @retval Counter Register value.
N  */
Nuint32_t TIM_GetCounter(TIM_TypeDef* TIMx)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_ALL_PERIPH(TIMx));
X  ((void)0);
N  
N  /* Get the Counter Register value */
N  return TIMx->CNT;
N}
N
N/**
N  * @brief  Gets the TIMx Prescaler value.
N  * @param  TIMx: where x can be 1, 2, 3, 6, 7, 14, 15, 16 and 17 to select the TIM 
N  *         peripheral.  
N  * @retval Prescaler Register value.
N  */
Nuint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_ALL_PERIPH(TIMx));
X  ((void)0);
N  
N  /* Get the Prescaler Register value */
N  return TIMx->PSC;
N}
N
N/**
N  * @brief  Enables or Disables the TIMx Update event.
N  * @param  TIMx: where x can be 1, 2, 3, 6, 7, 14, 15, 16 and 17 to select the TIM 
N  *         peripheral.   
N  * @param  NewState: new state of the TIMx UDIS bit
N  *          This parameter can be: ENABLE or DISABLE.
N  * @retval None
N  */
Nvoid TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_ALL_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N  
N  if (NewState != DISABLE)
N  {
N    /* Set the Update Disable Bit */
N    TIMx->CR1 |= TIM_CR1_UDIS;
X    TIMx->CR1 |= ((uint16_t)0x0002);
N  }
N  else
N  {
N    /* Reset the Update Disable Bit */
N    TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_UDIS);
X    TIMx->CR1 &= (uint16_t)~((uint16_t)((uint16_t)0x0002));
N  }
N}
N
N/**
N  * @brief  Configures the TIMx Update Request Interrupt source.
N  * @param  TIMx: where x can be 1, 2, 3, 6, 7, 14, 15, 16 and 17 to select the TIM 
N  *         peripheral.  
N  * @param  TIM_UpdateSource: specifies the Update source.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_UpdateSource_Regular: Source of update is the counter
N  *                 overflow/underflow or the setting of UG bit, or an update
N  *                 generation through the slave mode controller.
N  *            @arg TIM_UpdateSource_Global: Source of update is counter overflow/underflow.
N  * @retval None
N  */
Nvoid TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_ALL_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
X  ((void)0);
N  
N  if (TIM_UpdateSource != TIM_UpdateSource_Global)
X  if (TIM_UpdateSource != ((uint16_t)0x0000))
N  {
N    /* Set the URS Bit */
N    TIMx->CR1 |= TIM_CR1_URS;
X    TIMx->CR1 |= ((uint16_t)0x0004);
N  }
N  else
N  {
N    /* Reset the URS Bit */
N    TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_URS);
X    TIMx->CR1 &= (uint16_t)~((uint16_t)((uint16_t)0x0004));
N  }
N}
N
N/**
N  * @brief  Enables or disables TIMx peripheral Preload register on ARR.
N  * @param  TIMx: where x can be  1, 2, 3, 6, 7, 14, 15, 16 and 17 to select the TIM 
N  *         peripheral. 
N  * @param  NewState: new state of the TIMx peripheral Preload register
N  *          This parameter can be: ENABLE or DISABLE.
N  * @retval None
N  */
Nvoid TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_ALL_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N  
N  if (NewState != DISABLE)
N  {
N    /* Set the ARR Preload Bit */
N    TIMx->CR1 |= TIM_CR1_ARPE;
X    TIMx->CR1 |= ((uint16_t)0x0080);
N  }
N  else
N  {
N    /* Reset the ARR Preload Bit */
N    TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_ARPE);
X    TIMx->CR1 &= (uint16_t)~((uint16_t)((uint16_t)0x0080));
N  }
N}
N
N/**
N  * @brief  Selects the TIMx's One Pulse Mode.
N  * @param  TIMx: where x can be 1, 2, 3, 6, 7, 14, 15, 16 and 17 to select the TIM 
N  *         peripheral.    
N  * @param  TIM_OPMode: specifies the OPM Mode to be used.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_OPMode_Single
N  *            @arg TIM_OPMode_Repetitive
N  * @retval None
N  */
Nvoid TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_ALL_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
X  ((void)0);
N  
N  /* Reset the OPM Bit */
N  TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_OPM);
X  TIMx->CR1 &= (uint16_t)~((uint16_t)((uint16_t)0x0008));
N  /* Configure the OPM Mode */
N  TIMx->CR1 |= TIM_OPMode;
N}
N
N/**
N  * @brief  Sets the TIMx Clock Division value.
N  * @param  TIMx: where x can be  1, 2, 3, 14, 15, 16 and 17 to select the TIM peripheral.
N  * @param  TIM_CKD: specifies the clock division value.
N  *          This parameter can be one of the following value:
N  *            @arg TIM_CKD_DIV1: TDTS = Tck_tim
N  *            @arg TIM_CKD_DIV2: TDTS = 2*Tck_tim
N  *            @arg TIM_CKD_DIV4: TDTS = 4*Tck_tim
N  * @retval None
N  */
Nvoid TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_CKD_DIV(TIM_CKD));
X  ((void)0);
N  
N  /* Reset the CKD Bits */
N  TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_CKD);
X  TIMx->CR1 &= (uint16_t)~((uint16_t)((uint16_t)0x0300));
N  /* Set the CKD value */
N  TIMx->CR1 |= TIM_CKD;
N}
N
N/**
N  * @brief  Enables or disables the specified TIM peripheral.
N  * @param  TIMx: where x can be 1, 2, 3, 6, 7, 14, 15, 16 and 17to select the TIMx
N  *         peripheral.   
N  * @param  NewState: new state of the TIMx peripheral.
N  *          This parameter can be: ENABLE or DISABLE.
N  * @retval None
N  */
Nvoid TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
X  ((void)0); 
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N  
N  if (NewState != DISABLE)
N  {
N    /* Enable the TIM Counter */
N    TIMx->CR1 |= TIM_CR1_CEN;
X    TIMx->CR1 |= ((uint16_t)0x0001);
N  }
N  else
N  {
N    /* Disable the TIM Counter */
N    TIMx->CR1 &= (uint16_t)(~((uint16_t)TIM_CR1_CEN));
X    TIMx->CR1 &= (uint16_t)(~((uint16_t)((uint16_t)0x0001)));
N  }
N}
N
N/**
N  * @}
N  */
N/**
N  * @brief  Configures the: Break feature, dead time, Lock level, OSSI/OSSR State
N  *         and the AOE(automatic output enable).
N  * @param  TIMx: where x can be  1, 15, 16 or 17 to select the TIM 
N  * @param  TIM_BDTRInitStruct: pointer to a TIM_BDTRInitTypeDef structure that
N  *         contains the BDTR Register configuration  information for the TIM peripheral.
N  * @retval None
N  */
Nvoid TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct->TIM_OSSRState));
X  ((void)0);
N  assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct->TIM_OSSIState));
X  ((void)0);
N  assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->TIM_LOCKLevel));
X  ((void)0);
N  assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
X  ((void)0);
N  assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
X  ((void)0);
N  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
X  ((void)0);
N  /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSR State,
N     the OSSI State, the dead time value and the Automatic Output Enable Bit */
N  TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
N             TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
N             TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
N             TIM_BDTRInitStruct->TIM_AutomaticOutput;
N}
N
N/**
N  * @brief  Fills each TIM_BDTRInitStruct member with its default value.
N  * @param  TIM_BDTRInitStruct: pointer to a TIM_BDTRInitTypeDef structure which
N  *         will be initialized.
N  * @retval None
N  */
Nvoid TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
N{
N  /* Set the default configuration */
N  TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
X  TIM_BDTRInitStruct->TIM_OSSRState = ((uint16_t)0x0000);
N  TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
X  TIM_BDTRInitStruct->TIM_OSSIState = ((uint16_t)0x0000);
N  TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
X  TIM_BDTRInitStruct->TIM_LOCKLevel = ((uint16_t)0x0000);
N  TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
N  TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
X  TIM_BDTRInitStruct->TIM_Break = ((uint16_t)0x0000);
N  TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
X  TIM_BDTRInitStruct->TIM_BreakPolarity = ((uint16_t)0x0000);
N  TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
X  TIM_BDTRInitStruct->TIM_AutomaticOutput = ((uint16_t)0x0000);
N}
N
N/**
N  * @brief  Enables or disables the TIM peripheral Main Outputs.
N  * @param  TIMx: where x can be 1, 15, 16 or 17 to select the TIMx peripheral.
N  * @param  NewState: new state of the TIM peripheral Main Outputs.
N  *          This parameter can be: ENABLE or DISABLE.
N  * @retval None
N  */
Nvoid TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N  if (NewState != DISABLE)
N  {
N    /* Enable the TIM Main Output */
N    TIMx->BDTR |= TIM_BDTR_MOE;
X    TIMx->BDTR |= ((uint16_t)0x8000);
N  }
N  else
N  {
N    /* Disable the TIM Main Output */
N    TIMx->BDTR &= (uint16_t)(~((uint16_t)TIM_BDTR_MOE));
X    TIMx->BDTR &= (uint16_t)(~((uint16_t)((uint16_t)0x8000)));
N  }  
N}
N
N/**
N  * @}
N  */
N
N/**
N  * @brief  Initializes the TIMx Channel1 according to the specified
N  *         parameters in the TIM_OCInitStruct.
N  * @param  TIMx: where x can be 1, 2, 3, 14, 15, 16 and 17 to select the TIM peripheral.  
N  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
N  *         that contains the configuration information for the specified TIM 
N  *         peripheral.
N  * @retval None
N  */
Nvoid TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
N{
N  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
N   
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
X  ((void)0);
N  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
X  ((void)0);
N  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
X  ((void)0);   
N /* Disable the Channel 1: Reset the CC1E Bit */
N  TIMx->CCER &= (uint16_t)(~(uint16_t)TIM_CCER_CC1E);
X  TIMx->CCER &= (uint16_t)(~(uint16_t)((uint16_t)0x0001));
N  /* Get the TIMx CCER register value */
N  tmpccer = TIMx->CCER;
N  /* Get the TIMx CR2 register value */
N  tmpcr2 =  TIMx->CR2;
N  
N  /* Get the TIMx CCMR1 register value */
N  tmpccmrx = TIMx->CCMR1;
N    
N  /* Reset the Output Compare Mode Bits */
N  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC1M));
X  tmpccmrx &= (uint16_t)(~((uint16_t)((uint16_t)0x0070)));
N  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC1S));
X  tmpccmrx &= (uint16_t)(~((uint16_t)((uint16_t)0x0003)));
N
N  /* Select the Output Compare Mode */
N  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
N  
N  /* Reset the Output Polarity level */
N  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1P));
X  tmpccer &= (uint16_t)(~((uint16_t)((uint16_t)0x0002)));
N  /* Set the Output Compare Polarity */
N  tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
N  
N  /* Set the Output State */
N  tmpccer |= TIM_OCInitStruct->TIM_OutputState;
N    
N  if((TIMx == TIM1) || (TIMx == TIM15) || (TIMx == TIM16) || (TIMx == TIM17))
X  if((TIMx == ((TIM_TypeDef *) (((uint32_t)0x40000000) + 0x00012C00))) || (TIMx == ((TIM_TypeDef *) (((uint32_t)0x40000000) + 0x00014000))) || (TIMx == ((TIM_TypeDef *) (((uint32_t)0x40000000) + 0x00014400))) || (TIMx == ((TIM_TypeDef *) (((uint32_t)0x40000000) + 0x00014800))))
N  {
N    assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
X    ((void)0);
N    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
X    ((void)0);
N    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
X    ((void)0);
N    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
X    ((void)0);
N    
N    /* Reset the Output N Polarity level */
N    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1NP));
X    tmpccer &= (uint16_t)(~((uint16_t)((uint16_t)0x0008)));
N    /* Set the Output N Polarity */
N    tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
N    
N    /* Reset the Output N State */
N    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1NE));    
X    tmpccer &= (uint16_t)(~((uint16_t)((uint16_t)0x0004)));    
N    /* Set the Output N State */
N    tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
N    
N    /* Reset the Ouput Compare and Output Compare N IDLE State */
N    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS1));
X    tmpcr2 &= (uint16_t)(~((uint16_t)((uint16_t)0x0100)));
N    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS1N));
X    tmpcr2 &= (uint16_t)(~((uint16_t)((uint16_t)0x0200)));
N    
N    /* Set the Output Idle state */
N    tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
N    /* Set the Output N Idle state */
N    tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
N  }
N  /* Write to TIMx CR2 */
N  TIMx->CR2 = tmpcr2;
N  
N  /* Write to TIMx CCMR1 */
N  TIMx->CCMR1 = tmpccmrx;
N
N  /* Set the Capture Compare Register value */
N  TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse; 
N 
N  /* Write to TIMx CCER */
N  TIMx->CCER = tmpccer;
N}
N
N/**
N  * @brief  Initializes the TIMx Channel2 according to the specified
N  *         parameters in the TIM_OCInitStruct.
N  * @param  TIMx: where x can be 1, 2, 3 or 15 to select the TIM peripheral. 
N  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
N  *         that contains the configuration information for the specified TIM 
N  *         peripheral.
N  * @retval None
N  */
Nvoid TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
N{
N  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
N   
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST6_PERIPH(TIMx)); 
X  ((void)0); 
N  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
X  ((void)0);
N  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
X  ((void)0);
N  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
X  ((void)0);   
N   /* Disable the Channel 2: Reset the CC2E Bit */
N  TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC2E));
X  TIMx->CCER &= (uint16_t)(~((uint16_t)((uint16_t)0x0010)));
N  
N  /* Get the TIMx CCER register value */  
N  tmpccer = TIMx->CCER;
N  /* Get the TIMx CR2 register value */
N  tmpcr2 =  TIMx->CR2;
N  
N  /* Get the TIMx CCMR1 register value */
N  tmpccmrx = TIMx->CCMR1;
N    
N  /* Reset the Output Compare mode and Capture/Compare selection Bits */
N  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC2M));
X  tmpccmrx &= (uint16_t)(~((uint16_t)((uint16_t)0x7000)));
N  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S));
X  tmpccmrx &= (uint16_t)(~((uint16_t)((uint16_t)0x0300)));
N  
N  /* Select the Output Compare Mode */
N  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
N  
N  /* Reset the Output Polarity level */
N  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2P));
X  tmpccer &= (uint16_t)(~((uint16_t)((uint16_t)0x0020)));
N  /* Set the Output Compare Polarity */
N  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
N  
N  /* Set the Output State */
N  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
N    
N  if((TIMx == TIM1) || (TIMx == TIM15))
X  if((TIMx == ((TIM_TypeDef *) (((uint32_t)0x40000000) + 0x00012C00))) || (TIMx == ((TIM_TypeDef *) (((uint32_t)0x40000000) + 0x00014000))))
N  {
N    /* Check the parameters */
N    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
X    ((void)0);
N    
N    /* Reset the Ouput Compare State */
N    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS2));
X    tmpcr2 &= (uint16_t)(~((uint16_t)((uint16_t)0x0400)));
N    
N    /* Set the Output Idle state */
N    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
N    
N    if (TIMx == TIM1)
X    if (TIMx == ((TIM_TypeDef *) (((uint32_t)0x40000000) + 0x00012C00)))
N    {    
N      /* Check the parameters */
N      assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
X      ((void)0);
N      assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
X      ((void)0);
N      assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
X      ((void)0);
N      
N      /* Reset the Output N Polarity level */
N      tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2NP));
X      tmpccer &= (uint16_t)(~((uint16_t)((uint16_t)0x0080)));
N      /* Set the Output N Polarity */
N      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
N      
N      /* Reset the Output N State */
N      tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2NE));    
X      tmpccer &= (uint16_t)(~((uint16_t)((uint16_t)0x0040)));    
N      /* Set the Output N State */
N      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
N      
N      /* Reset the Output Compare N IDLE State */
N      tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS2N));
X      tmpcr2 &= (uint16_t)(~((uint16_t)((uint16_t)0x0800)));
N      
N      /* Set the Output N Idle state */
N      tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
N    }
N  }
N  /* Write to TIMx CR2 */
N  TIMx->CR2 = tmpcr2;
N  
N  /* Write to TIMx CCMR1 */
N  TIMx->CCMR1 = tmpccmrx;
N
N  /* Set the Capture Compare Register value */
N  TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
N  
N  /* Write to TIMx CCER */
N  TIMx->CCER = tmpccer;
N}
N
N/**
N  * @brief  Initializes the TIMx Channel3 according to the specified
N  *         parameters in the TIM_OCInitStruct.
N  * @param  TIMx: where x can be 1, 2 or 3 to select the TIM peripheral.
N  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
N  *         that contains the configuration information for the specified TIM 
N  *         peripheral.
N  * @retval None
N  */
Nvoid TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
N{
N  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
N   
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
X  ((void)0); 
N  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
X  ((void)0);
N  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
X  ((void)0);
N  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
X  ((void)0);   
N  /* Disable the Channel 2: Reset the CC2E Bit */
N  TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC3E));
X  TIMx->CCER &= (uint16_t)(~((uint16_t)((uint16_t)0x0100)));
N  
N  /* Get the TIMx CCER register value */
N  tmpccer = TIMx->CCER;
N  /* Get the TIMx CR2 register value */
N  tmpcr2 =  TIMx->CR2;
N  
N  /* Get the TIMx CCMR2 register value */
N  tmpccmrx = TIMx->CCMR2;
N    
N  /* Reset the Output Compare mode and Capture/Compare selection Bits */
N  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC3M));
X  tmpccmrx &= (uint16_t)(~((uint16_t)((uint16_t)0x0070)));
N  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC3S));  
X  tmpccmrx &= (uint16_t)(~((uint16_t)((uint16_t)0x0003)));  
N  /* Select the Output Compare Mode */
N  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
N  
N  /* Reset the Output Polarity level */
N  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3P));
X  tmpccer &= (uint16_t)(~((uint16_t)((uint16_t)0x0200)));
N  /* Set the Output Compare Polarity */
N  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
N  
N  /* Set the Output State */
N  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
N    
N  if(TIMx == TIM1)
X  if(TIMx == ((TIM_TypeDef *) (((uint32_t)0x40000000) + 0x00012C00)))
N  {
N    assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
X    ((void)0);
N    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
X    ((void)0);
N    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
X    ((void)0);
N    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
X    ((void)0);
N    
N    /* Reset the Output N Polarity level */
N    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3NP));
X    tmpccer &= (uint16_t)(~((uint16_t)((uint16_t)0x0800)));
N    /* Set the Output N Polarity */
N    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
N    /* Reset the Output N State */
N    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3NE));
X    tmpccer &= (uint16_t)(~((uint16_t)((uint16_t)0x0400)));
N    
N    /* Set the Output N State */
N    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
N    /* Reset the Ouput Compare and Output Compare N IDLE State */
N    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS3));
X    tmpcr2 &= (uint16_t)(~((uint16_t)((uint16_t)0x1000)));
N    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS3N));
X    tmpcr2 &= (uint16_t)(~((uint16_t)((uint16_t)0x2000)));
N    /* Set the Output Idle state */
N    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
N    /* Set the Output N Idle state */
N    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
N  }
N  /* Write to TIMx CR2 */
N  TIMx->CR2 = tmpcr2;
N  
N  /* Write to TIMx CCMR2 */
N  TIMx->CCMR2 = tmpccmrx;
N
N  /* Set the Capture Compare Register value */
N  TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
N  
N  /* Write to TIMx CCER */
N  TIMx->CCER = tmpccer;
N}
N
N/**
N  * @brief  Initializes the TIMx Channel4 according to the specified
N  *         parameters in the TIM_OCInitStruct.
N  * @param  TIMx: where x can be 1, 2 or 3 to select the TIM peripheral.
N  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
N  *         that contains the configuration information for the specified TIM 
N  *         peripheral.
N  * @retval None
N  */
Nvoid TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
N{
N  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
N   
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
X  ((void)0); 
N  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
X  ((void)0);
N  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
X  ((void)0);
N  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
X  ((void)0);   
N  /* Disable the Channel 2: Reset the CC4E Bit */
N  TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC4E));
X  TIMx->CCER &= (uint16_t)(~((uint16_t)((uint16_t)0x1000)));
N  
N  /* Get the TIMx CCER register value */
N  tmpccer = TIMx->CCER;
N  /* Get the TIMx CR2 register value */
N  tmpcr2 =  TIMx->CR2;
N  
N  /* Get the TIMx CCMR2 register value */
N  tmpccmrx = TIMx->CCMR2;
N    
N  /* Reset the Output Compare mode and Capture/Compare selection Bits */
N  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC4M));
X  tmpccmrx &= (uint16_t)(~((uint16_t)((uint16_t)0x7000)));
N  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC4S));
X  tmpccmrx &= (uint16_t)(~((uint16_t)((uint16_t)0x0300)));
N  
N  /* Select the Output Compare Mode */
N  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
N  
N  /* Reset the Output Polarity level */
N  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC4P));
X  tmpccer &= (uint16_t)(~((uint16_t)((uint16_t)0x2000)));
N  /* Set the Output Compare Polarity */
N  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
N  
N  /* Set the Output State */
N  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
N    
N  if(TIMx == TIM1)
X  if(TIMx == ((TIM_TypeDef *) (((uint32_t)0x40000000) + 0x00012C00)))
N  {
N    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
X    ((void)0);
N    /* Reset the Ouput Compare IDLE State */
N    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS4));
X    tmpcr2 &= (uint16_t)(~((uint16_t)((uint16_t)0x4000)));
N    /* Set the Output Idle state */
N    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
N  }
N  /* Write to TIMx CR2 */
N  TIMx->CR2 = tmpcr2;
N  
N  /* Write to TIMx CCMR2 */  
N  TIMx->CCMR2 = tmpccmrx;
N
N  /* Set the Capture Compare Register value */
N  TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
N  
N  /* Write to TIMx CCER */
N  TIMx->CCER = tmpccer;
N}
N
N/**
N  * @brief  Fills each TIM_OCInitStruct member with its default value.
N  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure which will
N  *         be initialized.
N  * @retval None
N  */
Nvoid TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
N{
N  /* Set the default configuration */
N  TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
X  TIM_OCInitStruct->TIM_OCMode = ((uint16_t)0x0000);
N  TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
X  TIM_OCInitStruct->TIM_OutputState = ((uint16_t)0x0000);
N  TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
X  TIM_OCInitStruct->TIM_OutputNState = ((uint16_t)0x0000);
N  TIM_OCInitStruct->TIM_Pulse = 0x0000000;
N  TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
X  TIM_OCInitStruct->TIM_OCPolarity = ((uint16_t)0x0000);
N  TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
X  TIM_OCInitStruct->TIM_OCNPolarity = ((uint16_t)0x0000);
N  TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
X  TIM_OCInitStruct->TIM_OCIdleState = ((uint16_t)0x0000);
N  TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
X  TIM_OCInitStruct->TIM_OCNIdleState = ((uint16_t)0x0000);
N}
N
N/**
N  * @brief  Selects the TIM Output Compare Mode.
N  * @note   This function disables the selected channel before changing the Output
N  *         Compare Mode.
N  *         User has to enable this channel using TIM_CCxCmd and TIM_CCxNCmd functions.
N  * @param  TIMx: where x can be 1, 2, 3, 14, 15, 16 or 17 to select the TIM peripheral.
N  * @param  TIM_Channel: specifies the TIM Channel
N  *          This parameter can be one of the following values:
N  *            @arg TIM_Channel_1: TIM Channel 1
N  *            @arg TIM_Channel_2: TIM Channel 2
N  *            @arg TIM_Channel_3: TIM Channel 3
N  *            @arg TIM_Channel_4: TIM Channel 4
N  * @param  TIM_OCMode: specifies the TIM Output Compare Mode.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_OCMode_Timing
N  *            @arg TIM_OCMode_Active
N  *            @arg TIM_OCMode_Toggle
N  *            @arg TIM_OCMode_PWM1
N  *            @arg TIM_OCMode_PWM2
N  *            @arg TIM_ForcedAction_Active
N  *            @arg TIM_ForcedAction_InActive
N  * @retval None
N  */
Nvoid TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode)
N{
N  uint32_t tmp = 0;
N  uint16_t tmp1 = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST4_PERIPH(TIMx));  
X  ((void)0);  
N  assert_param(IS_TIM_OCM(TIM_OCMode));
X  ((void)0);
N  
N  tmp = (uint32_t) TIMx;
N  tmp += CCMR_OFFSET;
X  tmp += ((uint16_t)0x0018);
N
N  tmp1 = CCER_CCE_SET << (uint16_t)TIM_Channel;
X  tmp1 = ((uint16_t)0x0001) << (uint16_t)TIM_Channel;
N
N  /* Disable the Channel: Reset the CCxE Bit */
N  TIMx->CCER &= (uint16_t) ~tmp1;
N
N  if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
X  if((TIM_Channel == ((uint16_t)0x0000)) ||(TIM_Channel == ((uint16_t)0x0008)))
N  {
N    tmp += (TIM_Channel>>1);
N
N    /* Reset the OCxM bits in the CCMRx register */
N    *(__IO uint32_t *) tmp &= (uint32_t)~((uint32_t)TIM_CCMR1_OC1M);
X    *(volatile uint32_t *) tmp &= (uint32_t)~((uint32_t)((uint16_t)0x0070));
N   
N    /* Configure the OCxM bits in the CCMRx register */
N    *(__IO uint32_t *) tmp |= TIM_OCMode;
X    *(volatile uint32_t *) tmp |= TIM_OCMode;
N  }
N  else
N  {
N    tmp += (uint16_t)(TIM_Channel - (uint16_t)4)>> (uint16_t)1;
N
N    /* Reset the OCxM bits in the CCMRx register */
N    *(__IO uint32_t *) tmp &= (uint32_t)~((uint32_t)TIM_CCMR1_OC2M);
X    *(volatile uint32_t *) tmp &= (uint32_t)~((uint32_t)((uint16_t)0x7000));
N    
N    /* Configure the OCxM bits in the CCMRx register */
N    *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
X    *(volatile uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
N  }
N}
N
N/**
N  * @brief  Sets the TIMx Capture Compare1 Register value
N  * @param  TIMx: where x can be 1, 2, 3, 14, 15, 16 or 17 to select the TIM peripheral.  
N  * @param  Compare1: specifies the Capture Compare1 register new value.
N  * @retval None
N  */
Nvoid TIM_SetCompare1(TIM_TypeDef* TIMx, uint32_t Compare1)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
X  ((void)0);
N  
N  /* Set the Capture Compare1 Register value */
N  TIMx->CCR1 = Compare1;
N}
N
N/**
N  * @brief  Sets the TIMx Capture Compare2 Register value
N  * @param  TIMx: where x can be 1, 2, 3 or 15 to select the TIM peripheral.
N  * @param  Compare2: specifies the Capture Compare2 register new value.
N  * @retval None
N  */
Nvoid TIM_SetCompare2(TIM_TypeDef* TIMx, uint32_t Compare2)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
X  ((void)0);
N  
N  /* Set the Capture Compare2 Register value */
N  TIMx->CCR2 = Compare2;
N}
N
N/**
N  * @brief  Sets the TIMx Capture Compare3 Register value
N  * @param  TIMx: where x can be 1, 2 or 3 to select the TIM peripheral.
N  * @param  Compare3: specifies the Capture Compare3 register new value.
N  * @retval None
N  */
Nvoid TIM_SetCompare3(TIM_TypeDef* TIMx, uint32_t Compare3)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
X  ((void)0);
N  
N  /* Set the Capture Compare3 Register value */
N  TIMx->CCR3 = Compare3;
N}
N
N/**
N  * @brief  Sets the TIMx Capture Compare4 Register value
N  * @param  TIMx: where x can be 1, 2 or 3 to select the TIM peripheral.  
N  * @param  Compare4: specifies the Capture Compare4 register new value.
N  * @retval None
N  */
Nvoid TIM_SetCompare4(TIM_TypeDef* TIMx, uint32_t Compare4)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
X  ((void)0);
N  
N  /* Set the Capture Compare4 Register value */
N  TIMx->CCR4 = Compare4;
N}
N
N/**
N  * @brief  Forces the TIMx output 1 waveform to active or inactive level.
N  * @param  TIMx: where x can be 1, 2, 3, 14, 15, 16 or 17 to select the TIM peripheral.
N  * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_ForcedAction_Active: Force active level on OC1REF
N  *            @arg TIM_ForcedAction_InActive: Force inactive level on OC1REF.
N  * @retval None
N  */
Nvoid TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
N{
N  uint16_t tmpccmr1 = 0;
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
X  ((void)0);
N  tmpccmr1 = TIMx->CCMR1;
N  /* Reset the OC1M Bits */
N  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1M);
X  tmpccmr1 &= (uint16_t)~((uint16_t)((uint16_t)0x0070));
N  /* Configure The Forced output Mode */
N  tmpccmr1 |= TIM_ForcedAction;
N  /* Write to TIMx CCMR1 register */
N  TIMx->CCMR1 = tmpccmr1;
N}
N 
N/**
N  * @brief  Forces the TIMx output 2 waveform to active or inactive level.
N  * @param  TIMx: where x can be 1, 2, 3, or 15 to select the TIM peripheral. 
N  * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_ForcedAction_Active: Force active level on OC2REF
N  *            @arg TIM_ForcedAction_InActive: Force inactive level on OC2REF.
N  * @retval None
N  */
Nvoid TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
N{
N  uint16_t tmpccmr1 = 0;
N  
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
X  ((void)0);
N  
N  tmpccmr1 = TIMx->CCMR1;
N  /* Reset the OC2M Bits */
N  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2M);
X  tmpccmr1 &= (uint16_t)~((uint16_t)((uint16_t)0x7000));
N  /* Configure The Forced output Mode */
N  tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);
N  /* Write to TIMx CCMR1 register */
N  TIMx->CCMR1 = tmpccmr1;
N}
N
N/**
N  * @brief  Forces the TIMx output 3 waveform to active or inactive level.
N  * @param  TIMx: where x can be 1, 2 or 3 to select the TIM peripheral.
N  * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_ForcedAction_Active: Force active level on OC3REF
N  *            @arg TIM_ForcedAction_InActive: Force inactive level on OC3REF.
N  * @retval None
N  */
Nvoid TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
N{
N  uint16_t tmpccmr2 = 0;
N  
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
X  ((void)0);
N  
N  tmpccmr2 = TIMx->CCMR2;
N  /* Reset the OC1M Bits */
N  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3M);
X  tmpccmr2 &= (uint16_t)~((uint16_t)((uint16_t)0x0070));
N  /* Configure The Forced output Mode */
N  tmpccmr2 |= TIM_ForcedAction;
N  /* Write to TIMx CCMR2 register */
N  TIMx->CCMR2 = tmpccmr2;
N}
N
N/**
N  * @brief  Forces the TIMx output 4 waveform to active or inactive level.
N  * @param  TIMx: where x can be 1, 2 or 3 to select the TIM peripheral. 
N  * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_ForcedAction_Active: Force active level on OC4REF
N  *            @arg TIM_ForcedAction_InActive: Force inactive level on OC4REF.
N  * @retval None
N  */
Nvoid TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
N{
N  uint16_t tmpccmr2 = 0;
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
X  ((void)0);
N  
N  tmpccmr2 = TIMx->CCMR2;
N  /* Reset the OC2M Bits */
N  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4M);
X  tmpccmr2 &= (uint16_t)~((uint16_t)((uint16_t)0x7000));
N  /* Configure The Forced output Mode */
N  tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);
N  /* Write to TIMx CCMR2 register */
N  TIMx->CCMR2 = tmpccmr2;
N}
N
N/**
N  * @brief  Sets or Resets the TIM peripheral Capture Compare Preload Control bit.
N  * @param  TIMx: where x can be 1, 2, 3 or 15 to select the TIMx peripheral 
N  * @param  NewState: new state of the Capture Compare Preload Control bit
N  *          This parameter can be: ENABLE or DISABLE.
N  * @retval None
N  */
Nvoid TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
N{ 
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N  if (NewState != DISABLE)
N  {
N    /* Set the CCPC Bit */
N    TIMx->CR2 |= TIM_CR2_CCPC;
X    TIMx->CR2 |= ((uint16_t)0x0001);
N  }
N  else
N  {
N    /* Reset the CCPC Bit */
N    TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCPC);
X    TIMx->CR2 &= (uint16_t)~((uint16_t)((uint16_t)0x0001));
N  }
N}
N
N
N/**
N  * @brief  Enables or disables the TIMx peripheral Preload register on CCR1.
N  * @param  TIMx: where x can be 1, 2, 3, 14, 15, 16 and 17 to select the TIM peripheral.
N  * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
N  *          This parameter can be one of the following values:
N  *            @arg TIM_OCPreload_Enable
N  *            @arg TIM_OCPreload_Disable
N  * @retval None
N  */
Nvoid TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
N{
N  uint16_t tmpccmr1 = 0;
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
X  ((void)0);
N  
N  tmpccmr1 = TIMx->CCMR1;
N  /* Reset the OC1PE Bit */
N  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1PE);
X  tmpccmr1 &= (uint16_t)~((uint16_t)((uint16_t)0x0008));
N  /* Enable or Disable the Output Compare Preload feature */
N  tmpccmr1 |= TIM_OCPreload;
N  /* Write to TIMx CCMR1 register */
N  TIMx->CCMR1 = tmpccmr1;
N}
N
N/**
N  * @brief  Enables or disables the TIMx peripheral Preload register on CCR2.
N  * @param  TIMx: where x can be 1, 2, 3 and 15 to select the TIM peripheral. 
N  * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
N  *          This parameter can be one of the following values:
N  *            @arg TIM_OCPreload_Enable
N  *            @arg TIM_OCPreload_Disable
N  * @retval None
N  */
Nvoid TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
N{
N  uint16_t tmpccmr1 = 0;
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
X  ((void)0);
N  
N  tmpccmr1 = TIMx->CCMR1;
N  /* Reset the OC2PE Bit */
N  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2PE);
X  tmpccmr1 &= (uint16_t)~((uint16_t)((uint16_t)0x0800));
N  /* Enable or Disable the Output Compare Preload feature */
N  tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
N  /* Write to TIMx CCMR1 register */
N  TIMx->CCMR1 = tmpccmr1;
N}
N
N/**
N  * @brief  Enables or disables the TIMx peripheral Preload register on CCR3.
N  * @param  TIMx: where x can be 1, 2 or 3 to select the TIM peripheral.
N  * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
N  *          This parameter can be one of the following values:
N  *            @arg TIM_OCPreload_Enable
N  *            @arg TIM_OCPreload_Disable
N  * @retval None
N  */
Nvoid TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
N{
N  uint16_t tmpccmr2 = 0;
N  
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
X  ((void)0);
N  
N  tmpccmr2 = TIMx->CCMR2;
N  /* Reset the OC3PE Bit */
N  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3PE);
X  tmpccmr2 &= (uint16_t)~((uint16_t)((uint16_t)0x0008));
N  /* Enable or Disable the Output Compare Preload feature */
N  tmpccmr2 |= TIM_OCPreload;
N  /* Write to TIMx CCMR2 register */
N  TIMx->CCMR2 = tmpccmr2;
N}
N
N/**
N  * @brief  Enables or disables the TIMx peripheral Preload register on CCR4.
N  * @param  TIMx: where x can be 1, 2 or 3 to select the TIM peripheral. 
N  * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register
N  *          This parameter can be one of the following values:
N  *            @arg TIM_OCPreload_Enable
N  *            @arg TIM_OCPreload_Disable
N  * @retval None
N  */
Nvoid TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
N{
N  uint16_t tmpccmr2 = 0;
N  
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
X  ((void)0);
N  
N  tmpccmr2 = TIMx->CCMR2;
N  /* Reset the OC4PE Bit */
N  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4PE);
X  tmpccmr2 &= (uint16_t)~((uint16_t)((uint16_t)0x0800));
N  /* Enable or Disable the Output Compare Preload feature */
N  tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);
N  /* Write to TIMx CCMR2 register */
N  TIMx->CCMR2 = tmpccmr2;
N}
N
N/**
N  * @brief  Configures the TIMx Output Compare 1 Fast feature.
N  * @param  TIMx: where x can be 1, 2, 3, 14, 15, 16 or 17 to select the TIM peripheral.
N  * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_OCFast_Enable: TIM output compare fast enable
N  *            @arg TIM_OCFast_Disable: TIM output compare fast disable
N  * @retval None
N  */
Nvoid TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
N{
N  uint16_t tmpccmr1 = 0;
N  
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
X  ((void)0);
N  
N  /* Get the TIMx CCMR1 register value */
N  tmpccmr1 = TIMx->CCMR1;
N  /* Reset the OC1FE Bit */
N  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1FE);
X  tmpccmr1 &= (uint16_t)~((uint16_t)((uint16_t)0x0004));
N  /* Enable or Disable the Output Compare Fast Bit */
N  tmpccmr1 |= TIM_OCFast;
N  /* Write to TIMx CCMR1 */
N  TIMx->CCMR1 = tmpccmr1;
N}
N
N/**
N  * @brief  Configures the TIMx Output Compare 2 Fast feature.
N  * @param  TIMx: where x can be 1, 2, 3 or 15 to select the TIM peripheral.
N  * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_OCFast_Enable: TIM output compare fast enable
N  *            @arg TIM_OCFast_Disable: TIM output compare fast disable
N  * @retval None
N  */
Nvoid TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
N{
N  uint16_t tmpccmr1 = 0;
N  
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
X  ((void)0);
N  
N  /* Get the TIMx CCMR1 register value */
N  tmpccmr1 = TIMx->CCMR1;
N  /* Reset the OC2FE Bit */
N  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2FE);
X  tmpccmr1 &= (uint16_t)~((uint16_t)((uint16_t)0x0400));
N  /* Enable or Disable the Output Compare Fast Bit */
N  tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);
N  /* Write to TIMx CCMR1 */
N  TIMx->CCMR1 = tmpccmr1;
N}
N
N/**
N  * @brief  Configures the TIMx Output Compare 3 Fast feature.
N  * @param  TIMx: where x can be 1, 2 or 3 to select the TIM peripheral.
N  * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_OCFast_Enable: TIM output compare fast enable
N  *            @arg TIM_OCFast_Disable: TIM output compare fast disable
N  * @retval None
N  */
Nvoid TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
N{
N  uint16_t tmpccmr2 = 0;
N  
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
X  ((void)0);
N  
N  /* Get the TIMx CCMR2 register value */
N  tmpccmr2 = TIMx->CCMR2;
N  /* Reset the OC3FE Bit */
N  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3FE);
X  tmpccmr2 &= (uint16_t)~((uint16_t)((uint16_t)0x0004));
N  /* Enable or Disable the Output Compare Fast Bit */
N  tmpccmr2 |= TIM_OCFast;
N  /* Write to TIMx CCMR2 */
N  TIMx->CCMR2 = tmpccmr2;
N}
N
N/**
N  * @brief  Configures the TIMx Output Compare 4 Fast feature.
N  * @param  TIMx: where x can be 1, 2 or 3 to select the TIM peripheral. 
N  * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_OCFast_Enable: TIM output compare fast enable
N  *            @arg TIM_OCFast_Disable: TIM output compare fast disable
N  * @retval None
N  */
Nvoid TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
N{
N  uint16_t tmpccmr2 = 0;
N  
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
X  ((void)0);
N  
N  /* Get the TIMx CCMR2 register value */
N  tmpccmr2 = TIMx->CCMR2;
N  /* Reset the OC4FE Bit */
N  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4FE);
X  tmpccmr2 &= (uint16_t)~((uint16_t)((uint16_t)0x0400));
N  /* Enable or Disable the Output Compare Fast Bit */
N  tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);
N  /* Write to TIMx CCMR2 */
N  TIMx->CCMR2 = tmpccmr2;
N}
N
N/**
N  * @brief  Clears or safeguards the OCREF1 signal on an external event
N  * @param  TIMx: where x can be 1, 2, 3, 14, 15, 16 or 17 to select the TIM peripheral.
N  * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_OCClear_Enable: TIM Output clear enable
N  *            @arg TIM_OCClear_Disable: TIM Output clear disable
N  * @retval None
N  */
Nvoid TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
N{
N  uint16_t tmpccmr1 = 0;
N  
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
X  ((void)0);
N  
N  tmpccmr1 = TIMx->CCMR1;
N  /* Reset the OC1CE Bit */
N  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1CE);
X  tmpccmr1 &= (uint16_t)~((uint16_t)((uint16_t)0x0080));
N  /* Enable or Disable the Output Compare Clear Bit */
N  tmpccmr1 |= TIM_OCClear;
N  /* Write to TIMx CCMR1 register */
N  TIMx->CCMR1 = tmpccmr1;
N}
N
N/**
N  * @brief  Clears or safeguards the OCREF2 signal on an external event
N  * @param  TIMx: where x can be 1, 2, 3 or 15 to select the TIM peripheral.
N  * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_OCClear_Enable: TIM Output clear enable
N  *            @arg TIM_OCClear_Disable: TIM Output clear disable
N  * @retval None
N  */
Nvoid TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
N{
N  uint16_t tmpccmr1 = 0;
N  
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
X  ((void)0);
N  
N  tmpccmr1 = TIMx->CCMR1;
N  /* Reset the OC2CE Bit */
N  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2CE);
X  tmpccmr1 &= (uint16_t)~((uint16_t)((uint16_t)0x8000));
N  /* Enable or Disable the Output Compare Clear Bit */
N  tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
N  /* Write to TIMx CCMR1 register */
N  TIMx->CCMR1 = tmpccmr1;
N}
N
N/**
N  * @brief  Clears or safeguards the OCREF3 signal on an external event
N  * @param  TIMx: where x can be 1, 2 or 3 to select the TIM peripheral.
N  * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_OCClear_Enable: TIM Output clear enable
N  *            @arg TIM_OCClear_Disable: TIM Output clear disable
N  * @retval None
N  */
Nvoid TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
N{
N  uint16_t tmpccmr2 = 0;
N  
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
X  ((void)0);
N  
N  tmpccmr2 = TIMx->CCMR2;
N  /* Reset the OC3CE Bit */
N  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3CE);
X  tmpccmr2 &= (uint16_t)~((uint16_t)((uint16_t)0x0080));
N  /* Enable or Disable the Output Compare Clear Bit */
N  tmpccmr2 |= TIM_OCClear;
N  /* Write to TIMx CCMR2 register */
N  TIMx->CCMR2 = tmpccmr2;
N}
N
N/**
N  * @brief  Clears or safeguards the OCREF4 signal on an external event
N  * @param  TIMx: where x can be 1, 2 or 3 to select the TIM peripheral.
N  * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_OCClear_Enable: TIM Output clear enable
N  *            @arg TIM_OCClear_Disable: TIM Output clear disable
N  * @retval None
N  */
Nvoid TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
N{
N  uint16_t tmpccmr2 = 0;
N  
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
X  ((void)0);
N  
N  tmpccmr2 = TIMx->CCMR2;
N  /* Reset the OC4CE Bit */
N  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4CE);
X  tmpccmr2 &= (uint16_t)~((uint16_t)((uint16_t)0x8000));
N  /* Enable or Disable the Output Compare Clear Bit */
N  tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
N  /* Write to TIMx CCMR2 register */
N  TIMx->CCMR2 = tmpccmr2;
N}
N
N/**
N  * @brief  Configures the TIMx channel 1 polarity.
N  * @param  TIMx: where x can be 1, 2, 3, 14, 15, 16 or 17 to select the TIM peripheral. 
N  * @param  TIM_OCPolarity: specifies the OC1 Polarity
N  *          This parmeter can be one of the following values:
N  *            @arg TIM_OCPolarity_High: Output Compare active high
N  *            @arg TIM_OCPolarity_Low: Output Compare active low
N  * @retval None
N  */
Nvoid TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
N{
N  uint16_t tmpccer = 0;
N  
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
X  ((void)0);
N  
N  tmpccer = TIMx->CCER;
N  /* Set or Reset the CC1P Bit */
N  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC1P);
X  tmpccer &= (uint16_t)~((uint16_t)((uint16_t)0x0002));
N  tmpccer |= TIM_OCPolarity;
N  /* Write to TIMx CCER register */
N  TIMx->CCER = tmpccer;
N}
N
N/**
N  * @brief  Configures the TIMx Channel 1N polarity.
N  * @param  TIMx: where x can be 1, 15, 16 or 17 to select the TIM peripheral.
N  * @param  TIM_OCNPolarity: specifies the OC1N Polarity
N  *          This parmeter can be one of the following values:
N  *            @arg TIM_OCNPolarity_High: Output Compare active high
N  *            @arg TIM_OCNPolarity_Low: Output Compare active low
N  * @retval None
N  */
Nvoid TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
N{
N  uint16_t tmpccer = 0;
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
X  ((void)0);
N   
N  tmpccer = TIMx->CCER;
N  /* Set or Reset the CC1NP Bit */
N  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC1NP);
X  tmpccer &= (uint16_t)~((uint16_t)((uint16_t)0x0008));
N  tmpccer |= TIM_OCNPolarity;
N  /* Write to TIMx CCER register */
N  TIMx->CCER = tmpccer;
N}
N
N/**
N  * @brief  Configures the TIMx channel 2 polarity.
N  * @param  TIMx: where x can be 1, 2, 3, or 15 to select the TIM peripheral. 
N  * @param  TIM_OCPolarity: specifies the OC2 Polarity
N  *          This parmeter can be one of the following values:
N  *            @arg TIM_OCPolarity_High: Output Compare active high
N  *            @arg TIM_OCPolarity_Low: Output Compare active low
N  * @retval None
N  */
Nvoid TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
N{
N  uint16_t tmpccer = 0;
N  
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
X  ((void)0);
N  
N  tmpccer = TIMx->CCER;
N  /* Set or Reset the CC2P Bit */
N  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC2P);
X  tmpccer &= (uint16_t)~((uint16_t)((uint16_t)0x0020));
N  tmpccer |= (uint16_t)(TIM_OCPolarity << 4);
N  /* Write to TIMx CCER register */
N  TIMx->CCER = tmpccer;
N}
N
N/**
N  * @brief  Configures the TIMx Channel 2N polarity.
N  * @param  TIMx: where x can be 1 to select the TIM peripheral.
N  * @param  TIM_OCNPolarity: specifies the OC2N Polarity
N  *          This parmeter can be one of the following values:
N  *            @arg TIM_OCNPolarity_High: Output Compare active high
N  *            @arg TIM_OCNPolarity_Low: Output Compare active low
N  * @retval None
N  */
Nvoid TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
N{
N  uint16_t tmpccer = 0;
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
X  ((void)0);
N  
N  tmpccer = TIMx->CCER;
N  /* Set or Reset the CC2NP Bit */
N  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC2NP);
X  tmpccer &= (uint16_t)~((uint16_t)((uint16_t)0x0080));
N  tmpccer |= (uint16_t)(TIM_OCNPolarity << 4);
N  /* Write to TIMx CCER register */
N  TIMx->CCER = tmpccer;
N}
N
N/**
N  * @brief  Configures the TIMx channel 3 polarity.
N  * @param  TIMx: where x can be 1, 2 or 3 to select the TIM peripheral.
N  * @param  TIM_OCPolarity: specifies the OC3 Polarity
N  *          This parmeter can be one of the following values:
N  *            @arg TIM_OCPolarity_High: Output Compare active high
N  *            @arg TIM_OCPolarity_Low: Output Compare active low
N  * @retval None
N  */
Nvoid TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
N{
N  uint16_t tmpccer = 0;
N  
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
X  ((void)0);
N  
N  tmpccer = TIMx->CCER;
N  /* Set or Reset the CC3P Bit */
N  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC3P);
X  tmpccer &= (uint16_t)~((uint16_t)((uint16_t)0x0200));
N  tmpccer |= (uint16_t)(TIM_OCPolarity << 8);
N  /* Write to TIMx CCER register */
N  TIMx->CCER = tmpccer;
N}
N
N/**
N  * @brief  Configures the TIMx Channel 3N polarity.
N  * @param  TIMx: where x can be 1 to select the TIM peripheral.
N  * @param  TIM_OCNPolarity: specifies the OC3N Polarity
N  *          This parmeter can be one of the following values:
N  *            @arg TIM_OCNPolarity_High: Output Compare active high
N  *            @arg TIM_OCNPolarity_Low: Output Compare active low
N  * @retval None
N  */
Nvoid TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
N{
N  uint16_t tmpccer = 0;
N 
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
X  ((void)0);
N    
N  tmpccer = TIMx->CCER;
N  /* Set or Reset the CC3NP Bit */
N  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC3NP);
X  tmpccer &= (uint16_t)~((uint16_t)((uint16_t)0x0800));
N  tmpccer |= (uint16_t)(TIM_OCNPolarity << 8);
N  /* Write to TIMx CCER register */
N  TIMx->CCER = tmpccer;
N}
N
N/**
N  * @brief  Configures the TIMx channel 4 polarity.
N  * @param  TIMx: where x can be 1, 2 or 3 to select the TIM peripheral. 
N  * @param  TIM_OCPolarity: specifies the OC4 Polarity
N  *          This parmeter can be one of the following values:
N  *            @arg TIM_OCPolarity_High: Output Compare active high
N  *            @arg TIM_OCPolarity_Low: Output Compare active low
N  * @retval None
N  */
Nvoid TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
N{
N  uint16_t tmpccer = 0;
N  
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
X  ((void)0);
N  
N  tmpccer = TIMx->CCER;
N  /* Set or Reset the CC4P Bit */
N  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC4P);
X  tmpccer &= (uint16_t)~((uint16_t)((uint16_t)0x2000));
N  tmpccer |= (uint16_t)(TIM_OCPolarity << 12);
N  /* Write to TIMx CCER register */
N  TIMx->CCER = tmpccer;
N}
N
N/**
N  * @brief  Selects the OCReference Clear source.
N  * @param  TIMx: where x can be 1, 2 or 3 to select the TIM peripheral.  
N  * @param  TIM_OCReferenceClear: specifies the OCReference Clear source.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_OCReferenceClear_ETRF: The internal OCreference clear input is connected to ETRF.
N  *            @arg TIM_OCReferenceClear_OCREFCLR: The internal OCreference clear input is connected to OCREF_CLR input.  
N  * @retval None
N  */
Nvoid TIM_SelectOCREFClear(TIM_TypeDef* TIMx, uint16_t TIM_OCReferenceClear)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
X  ((void)0);
N  assert_param(TIM_OCREFERENCECECLEAR_SOURCE(TIM_OCReferenceClear));
X  ((void)0);
N
N  /* Set the TIM_OCReferenceClear source */
N  TIMx->SMCR &=  (uint16_t)~((uint16_t)TIM_SMCR_OCCS);
X  TIMx->SMCR &=  (uint16_t)~((uint16_t)((uint16_t)0x0008));
N  TIMx->SMCR |=  TIM_OCReferenceClear;
N}
N
N/**
N  * @brief  Enables or disables the TIM Capture Compare Channel x.
N  * @param  TIMx: where x can be 1, 2, 3, 14, 15, 16 or 17 to select the TIM peripheral.
N  * @param  TIM_Channel: specifies the TIM Channel
N  *          This parameter can be one of the following values:
N  *            @arg TIM_Channel_1: TIM Channel 1
N  *            @arg TIM_Channel_2: TIM Channel 2
N  *            @arg TIM_Channel_3: TIM Channel 3
N  *            @arg TIM_Channel_4: TIM Channel 4
N  * @param  TIM_CCx: specifies the TIM Channel CCxE bit new state.
N  *          This parameter can be: TIM_CCx_Enable or TIM_CCx_Disable. 
N  * @retval None
N  */
Nvoid TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
N{
N  uint16_t tmp = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST4_PERIPH(TIMx)); 
X  ((void)0); 
N  assert_param(IS_TIM_CCX(TIM_CCx));
X  ((void)0);
N
N  tmp = CCER_CCE_SET << TIM_Channel;
X  tmp = ((uint16_t)0x0001) << TIM_Channel;
N
N  /* Reset the CCxE Bit */
N  TIMx->CCER &= (uint16_t)~ tmp;
N
N  /* Set or reset the CCxE Bit */ 
N  TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
N}
N
N/**
N  * @brief  Enables or disables the TIM Capture Compare Channel xN.
N  * @param  TIMx: where x can be 1, 15, 16 or 17 to select the TIM peripheral.
N  * @param  TIM_Channel: specifies the TIM Channel
N  *          This parmeter can be one of the following values:
N  *            @arg TIM_Channel_1: TIM Channel 1
N  *            @arg TIM_Channel_2: TIM Channel 2
N  *            @arg TIM_Channel_3: TIM Channel 3
N  * @param  TIM_CCxN: specifies the TIM Channel CCxNE bit new state.
N  *          This parameter can be: TIM_CCxN_Enable or TIM_CCxN_Disable. 
N  * @retval None
N  */
Nvoid TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN)
N{
N  uint16_t tmp = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
X  ((void)0);
N  assert_param(IS_TIM_CCXN(TIM_CCxN));
X  ((void)0);
N
N  tmp = CCER_CCNE_SET << TIM_Channel;
X  tmp = ((uint16_t)0x0004) << TIM_Channel;
N
N  /* Reset the CCxNE Bit */
N  TIMx->CCER &= (uint16_t) ~tmp;
N
N  /* Set or reset the CCxNE Bit */ 
N  TIMx->CCER |=  (uint16_t)(TIM_CCxN << TIM_Channel);
N}
N
N/**
N  * @brief  Selects the TIM peripheral Commutation event.
N  * @param  TIMx: where x can be  1, 15, 16 or 17 to select the TIMx peripheral
N  * @param  NewState: new state of the Commutation event.
N  *          This parameter can be: ENABLE or DISABLE.
N  * @retval None
N  */
Nvoid TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N  if (NewState != DISABLE)
N  {
N    /* Set the COM Bit */
N    TIMx->CR2 |= TIM_CR2_CCUS;
X    TIMx->CR2 |= ((uint16_t)0x0004);
N  }
N  else
N  {
N    /* Reset the COM Bit */
N    TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCUS);
X    TIMx->CR2 &= (uint16_t)~((uint16_t)((uint16_t)0x0004));
N  }
N}
N
N/**
N  * @}
N  */
N/**
N  * @brief  Initializes the TIM peripheral according to the specified
N  *         parameters in the TIM_ICInitStruct.
N  * @param  TIMx: where x can be 1, 2, 3, 14, 15, 16 or 17 to select the TIM peripheral.
N  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
N  *         that contains the configuration information for the specified TIM 
N  *         peripheral.
N  * @retval None
N  */
Nvoid TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_CHANNEL(TIM_ICInitStruct->TIM_Channel));  
X  ((void)0);  
N  assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
X  ((void)0);
N  assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
X  ((void)0);
N  assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
X  ((void)0);
N  assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
X  ((void)0);
N
N  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
X  if (TIM_ICInitStruct->TIM_Channel == ((uint16_t)0x0000))
N  {
N    assert_param(IS_TIM_LIST4_PERIPH(TIMx));
X    ((void)0);
N    /* TI1 Configuration */
N    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
N               TIM_ICInitStruct->TIM_ICSelection,
N               TIM_ICInitStruct->TIM_ICFilter);
N    /* Set the Input Capture Prescaler value */
N    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
N  }
N  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
X  else if (TIM_ICInitStruct->TIM_Channel == ((uint16_t)0x0004))
N  {
N    assert_param(IS_TIM_LIST6_PERIPH(TIMx));
X    ((void)0);
N    /* TI2 Configuration */
N    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
N               TIM_ICInitStruct->TIM_ICSelection,
N               TIM_ICInitStruct->TIM_ICFilter);
N    /* Set the Input Capture Prescaler value */
N    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
N  }
N  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
X  else if (TIM_ICInitStruct->TIM_Channel == ((uint16_t)0x0008))
N  {
N    assert_param(IS_TIM_LIST3_PERIPH(TIMx));
X    ((void)0);
N    /* TI3 Configuration */
N    TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
N               TIM_ICInitStruct->TIM_ICSelection,
N               TIM_ICInitStruct->TIM_ICFilter);
N    /* Set the Input Capture Prescaler value */
N    TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
N  }
N  else
N  {
N    assert_param(IS_TIM_LIST3_PERIPH(TIMx));
X    ((void)0);
N    /* TI4 Configuration */
N    TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
N               TIM_ICInitStruct->TIM_ICSelection,
N               TIM_ICInitStruct->TIM_ICFilter);
N    /* Set the Input Capture Prescaler value */
N    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
N  }
N}
N
N/**
N  * @brief  Fills each TIM_ICInitStruct member with its default value.
N  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure which will
N  *         be initialized.
N  * @retval None
N  */
Nvoid TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
N{
N  /* Set the default configuration */
N  TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
X  TIM_ICInitStruct->TIM_Channel = ((uint16_t)0x0000);
N  TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
X  TIM_ICInitStruct->TIM_ICPolarity = ((uint16_t)0x0000);
N  TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
X  TIM_ICInitStruct->TIM_ICSelection = ((uint16_t)0x0001);
N  TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
X  TIM_ICInitStruct->TIM_ICPrescaler = ((uint16_t)0x0000);
N  TIM_ICInitStruct->TIM_ICFilter = 0x00;
N}
N
N/**
N  * @brief  Configures the TIM peripheral according to the specified
N  *         parameters in the TIM_ICInitStruct to measure an external PWM signal.
N  * @param  TIMx: where x can be 1, 2, 3 or 15 to select the TIM peripheral. 
N  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
N  *         that contains the configuration information for the specified TIM 
N  *         peripheral.
N  * @retval None
N  */
Nvoid TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
N{
N  uint16_t icoppositepolarity = TIM_ICPolarity_Rising;
X  uint16_t icoppositepolarity = ((uint16_t)0x0000);
N  uint16_t icoppositeselection = TIM_ICSelection_DirectTI;
X  uint16_t icoppositeselection = ((uint16_t)0x0001);
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
X  ((void)0);
N  /* Select the Opposite Input Polarity */
N  if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
X  if (TIM_ICInitStruct->TIM_ICPolarity == ((uint16_t)0x0000))
N  {
N    icoppositepolarity = TIM_ICPolarity_Falling;
X    icoppositepolarity = ((uint16_t)0x0002);
N  }
N  else
N  {
N    icoppositepolarity = TIM_ICPolarity_Rising;
X    icoppositepolarity = ((uint16_t)0x0000);
N  }
N  /* Select the Opposite Input */
N  if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
X  if (TIM_ICInitStruct->TIM_ICSelection == ((uint16_t)0x0001))
N  {
N    icoppositeselection = TIM_ICSelection_IndirectTI;
X    icoppositeselection = ((uint16_t)0x0002);
N  }
N  else
N  {
N    icoppositeselection = TIM_ICSelection_DirectTI;
X    icoppositeselection = ((uint16_t)0x0001);
N  }
N  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
X  if (TIM_ICInitStruct->TIM_Channel == ((uint16_t)0x0000))
N  {
N    /* TI1 Configuration */
N    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
N               TIM_ICInitStruct->TIM_ICFilter);
N    /* Set the Input Capture Prescaler value */
N    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
N    /* TI2 Configuration */
N    TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
N    /* Set the Input Capture Prescaler value */
N    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
N  }
N  else
N  { 
N    /* TI2 Configuration */
N    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
N               TIM_ICInitStruct->TIM_ICFilter);
N    /* Set the Input Capture Prescaler value */
N    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
N    /* TI1 Configuration */
N    TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
N    /* Set the Input Capture Prescaler value */
N    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
N  }
N}
N
N/**
N  * @brief  Gets the TIMx Input Capture 1 value.
N  * @param  TIMx: where x can be 1, 2, 3, 14, 15, 16 or 17 to select the TIM peripheral.
N  * @retval Capture Compare 1 Register value.
N  */
Nuint32_t TIM_GetCapture1(TIM_TypeDef* TIMx)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
X  ((void)0);
N  
N  /* Get the Capture 1 Register value */
N  return TIMx->CCR1;
N}
N
N/**
N  * @brief  Gets the TIMx Input Capture 2 value.
N  * @param  TIMx: where x can be 1, 2, 3 or 15 to select the TIM peripheral.
N  * @retval Capture Compare 2 Register value.
N  */
Nuint32_t TIM_GetCapture2(TIM_TypeDef* TIMx)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
X  ((void)0);
N  
N  /* Get the Capture 2 Register value */
N  return TIMx->CCR2;
N}
N
N/**
N  * @brief  Gets the TIMx Input Capture 3 value.
N  * @param  TIMx: where x can be 1, 2 or 3 to select the TIM peripheral. 
N  * @retval Capture Compare 3 Register value.
N  */
Nuint32_t TIM_GetCapture3(TIM_TypeDef* TIMx)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
X  ((void)0); 
N  
N  /* Get the Capture 3 Register value */
N  return TIMx->CCR3;
N}
N
N/**
N  * @brief  Gets the TIMx Input Capture 4 value.
N  * @param  TIMx: where x can be 1, 2 or 3 to select the TIM peripheral.
N  * @retval Capture Compare 4 Register value.
N  */
Nuint32_t TIM_GetCapture4(TIM_TypeDef* TIMx)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
X  ((void)0);
N  
N  /* Get the Capture 4 Register value */
N  return TIMx->CCR4;
N}
N
N/**
N  * @brief  Sets the TIMx Input Capture 1 prescaler.
N  * @param  TIMx: where x can be 1, 2, 3, 14, 15, 16 or 17 to select the TIM peripheral.
N  * @param  TIM_ICPSC: specifies the Input Capture1 prescaler new value.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_ICPSC_DIV1: no prescaler
N  *            @arg TIM_ICPSC_DIV2: capture is done once every 2 events
N  *            @arg TIM_ICPSC_DIV4: capture is done once every 4 events
N  *            @arg TIM_ICPSC_DIV8: capture is done once every 8 events
N  * @retval None
N  */
Nvoid TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
X  ((void)0);
N  
N  /* Reset the IC1PSC Bits */
N  TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC1PSC);
X  TIMx->CCMR1 &= (uint16_t)~((uint16_t)((uint16_t)0x000C));
N  /* Set the IC1PSC value */
N  TIMx->CCMR1 |= TIM_ICPSC;
N}
N
N/**
N  * @brief  Sets the TIMx Input Capture 2 prescaler.
N  * @param  TIMx: where x can be 1, 2, 3 or 15 to select the TIM peripheral.
N  * @param  TIM_ICPSC: specifies the Input Capture2 prescaler new value.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_ICPSC_DIV1: no prescaler
N  *            @arg TIM_ICPSC_DIV2: capture is done once every 2 events
N  *            @arg TIM_ICPSC_DIV4: capture is done once every 4 events
N  *            @arg TIM_ICPSC_DIV8: capture is done once every 8 events
N  * @retval None
N  */
Nvoid TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
X  ((void)0);
N  
N  /* Reset the IC2PSC Bits */
N  TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC2PSC);
X  TIMx->CCMR1 &= (uint16_t)~((uint16_t)((uint16_t)0x0C00));
N  /* Set the IC2PSC value */
N  TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
N}
N
N/**
N  * @brief  Sets the TIMx Input Capture 3 prescaler.
N  * @param  TIMx: where x can be 1, 2 or 3 to select the TIM peripheral.
N  * @param  TIM_ICPSC: specifies the Input Capture3 prescaler new value.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_ICPSC_DIV1: no prescaler
N  *            @arg TIM_ICPSC_DIV2: capture is done once every 2 events
N  *            @arg TIM_ICPSC_DIV4: capture is done once every 4 events
N  *            @arg TIM_ICPSC_DIV8: capture is done once every 8 events
N  * @retval None
N  */
Nvoid TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
X  ((void)0);
N  
N  /* Reset the IC3PSC Bits */
N  TIMx->CCMR2 &= (uint16_t)~((uint16_t)TIM_CCMR2_IC3PSC);
X  TIMx->CCMR2 &= (uint16_t)~((uint16_t)((uint16_t)0x000C));
N  /* Set the IC3PSC value */
N  TIMx->CCMR2 |= TIM_ICPSC;
N}
N
N/**
N  * @brief  Sets the TIMx Input Capture 4 prescaler.
N  * @param  TIMx: where x can be 1, 2 or 3 to select the TIM peripheral. 
N  * @param  TIM_ICPSC: specifies the Input Capture4 prescaler new value.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_ICPSC_DIV1: no prescaler
N  *            @arg TIM_ICPSC_DIV2: capture is done once every 2 events
N  *            @arg TIM_ICPSC_DIV4: capture is done once every 4 events
N  *            @arg TIM_ICPSC_DIV8: capture is done once every 8 events
N  * @retval None
N  */
Nvoid TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
N{  
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
X  ((void)0);
N  
N  /* Reset the IC4PSC Bits */
N  TIMx->CCMR2 &= (uint16_t)~((uint16_t)TIM_CCMR2_IC4PSC);
X  TIMx->CCMR2 &= (uint16_t)~((uint16_t)((uint16_t)0x0C00));
N  /* Set the IC4PSC value */
N  TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
N}
N
N/**
N  * @}
N  */
N/**
N  * @brief  Enables or disables the specified TIM interrupts.
N  * @param  TIMx: where x can be 1, 2, 3, 6, 7, 14, 15, 16 or 17 to select the TIMx peripheral.
N  * @param  TIM_IT: specifies the TIM interrupts sources to be enabled or disabled.
N  *          This parameter can be any combination of the following values:
N  *            @arg TIM_IT_Update: TIM update Interrupt source
N  *            @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
N  *            @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
N  *            @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
N  *            @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
N  *            @arg TIM_IT_COM: TIM Commutation Interrupt source
N  *            @arg TIM_IT_Trigger: TIM Trigger Interrupt source
N  *            @arg TIM_IT_Break: TIM Break Interrupt source
N  * 
N  * @note   TIM6 and TIM7 can only generate an update interrupt.
N  * @note   TIM15 can have only TIM_IT_Update, TIM_IT_CC1,TIM_IT_CC2 or TIM_IT_Trigger. 
N  * @note   TIM14, TIM16 and TIM17 can have TIM_IT_Update or TIM_IT_CC1.   
N  * @note   TIM_IT_Break is used only with TIM1 and TIM15. 
N  * @note   TIM_IT_COM is used only with TIM1, TIM15, TIM16 and TIM17.
N  *       
N  * @param  NewState: new state of the TIM interrupts.
N  *          This parameter can be: ENABLE or DISABLE.
N  * @retval None
N  */
Nvoid TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
N{  
N  /* Check the parameters */
N  assert_param(IS_TIM_ALL_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_IT(TIM_IT));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N  
N  if (NewState != DISABLE)
N  {
N    /* Enable the Interrupt sources */
N    TIMx->DIER |= TIM_IT;
N  }
N  else
N  {
N    /* Disable the Interrupt sources */
N    TIMx->DIER &= (uint16_t)~TIM_IT;
N  }
N}
N
N/**
N  * @brief  Configures the TIMx event to be generate by software.
N  * @param  TIMx: where x can be 1, 2, 3, 6, 7, 14, 15, 16 or 17 to select the 
N  *         TIM peripheral.
N  * @param  TIM_EventSource: specifies the event source.
N  *          This parameter can be one or more of the following values:  
N  *            @arg TIM_EventSource_Update: Timer update Event source
N  *            @arg TIM_EventSource_CC1: Timer Capture Compare 1 Event source
N  *            @arg TIM_EventSource_CC2: Timer Capture Compare 2 Event source
N  *            @arg TIM_EventSource_CC3: Timer Capture Compare 3 Event source
N  *            @arg TIM_EventSource_CC4: Timer Capture Compare 4 Event source
N  *            @arg TIM_EventSource_COM: Timer COM event source  
N  *            @arg TIM_EventSource_Trigger: Timer Trigger Event source
N  *            @arg TIM_EventSource_Break: Timer Break event source
N  *
N  * @note   TIM6 and TIM7 can only generate an update event.  
N  * @note   TIM_EventSource_COM and TIM_EventSource_Break are used only with TIM1.
N  *             
N  * @retval None
N  */
Nvoid TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource)
N{ 
N  /* Check the parameters */
N  assert_param(IS_TIM_ALL_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource)); 
X  ((void)0); 
N  /* Set the event sources */
N  TIMx->EGR = TIM_EventSource;
N}
N
N/**
N  * @brief  Checks whether the specified TIM flag is set or not.
N  * @param  TIMx: where x can be 1, 2, 3, 6, 7, 14, 15, 16 or 17 to select the TIM peripheral.
N  * @param  TIM_FLAG: specifies the flag to check.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_FLAG_Update: TIM update Flag
N  *            @arg TIM_FLAG_CC1: TIM Capture Compare 1 Flag
N  *            @arg TIM_FLAG_CC2: TIM Capture Compare 2 Flag
N  *            @arg TIM_FLAG_CC3: TIM Capture Compare 3 Flag
N  *            @arg TIM_FLAG_CC4: TIM Capture Compare 4 Flag
N  *            @arg TIM_FLAG_COM: TIM Commutation Flag
N  *            @arg TIM_FLAG_Trigger: TIM Trigger Flag
N  *            @arg TIM_FLAG_Break: TIM Break Flag
N  *            @arg TIM_FLAG_CC1OF: TIM Capture Compare 1 overcapture Flag
N  *            @arg TIM_FLAG_CC2OF: TIM Capture Compare 2 overcapture Flag
N  *            @arg TIM_FLAG_CC3OF: TIM Capture Compare 3 overcapture Flag
N  *            @arg TIM_FLAG_CC4OF: TIM Capture Compare 4 overcapture Flag
N  *
N  * @note   TIM6 and TIM7 can have only one update flag. 
N  * @note   TIM15 can have only TIM_FLAG_Update, TIM_FLAG_CC1, TIM_FLAG_CC2 or TIM_FLAG_Trigger.
N  * @note   TIM14, TIM16 and TIM17 can have TIM_FLAG_Update or TIM_FLAG_CC1.   
N  * @note   TIM_FLAG_Break is used only with TIM1 and TIM15. 
N  * @note   TIM_FLAG_COM is used only with TIM1 TIM15, TIM16 and TIM17.
N  *
N  * @retval The new state of TIM_FLAG (SET or RESET).
N  */
NFlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
N{ 
N  ITStatus bitstatus = RESET; 
N   
N  /* Check the parameters */
N  assert_param(IS_TIM_ALL_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
X  ((void)0);
N  
N  if ((TIMx->SR & TIM_FLAG) != (uint16_t)RESET)
N  {
N    bitstatus = SET;
N  }
N  else
N  {
N    bitstatus = RESET;
N  }
N  return bitstatus;
N}
N
N/**
N  * @brief  Clears the TIMx's pending flags.
N  * @param  TIMx: where x can be 1, 2, 3, 6, 7, 14, 15, 16 or 17 to select the TIM peripheral.
N  * @param  TIM_FLAG: specifies the flag bit to clear.
N  *          This parameter can be any combination of the following values:
N  *            @arg TIM_FLAG_Update: TIM update Flag
N  *            @arg TIM_FLAG_CC1: TIM Capture Compare 1 Flag
N  *            @arg TIM_FLAG_CC2: TIM Capture Compare 2 Flag
N  *            @arg TIM_FLAG_CC3: TIM Capture Compare 3 Flag
N  *            @arg TIM_FLAG_CC4: TIM Capture Compare 4 Flag
N  *            @arg TIM_FLAG_COM: TIM Commutation Flag
N  *            @arg TIM_FLAG_Trigger: TIM Trigger Flag
N  *            @arg TIM_FLAG_Break: TIM Break Flag
N  *            @arg TIM_FLAG_CC1OF: TIM Capture Compare 1 overcapture Flag
N  *            @arg TIM_FLAG_CC2OF: TIM Capture Compare 2 overcapture Flag
N  *            @arg TIM_FLAG_CC3OF: TIM Capture Compare 3 overcapture Flag
N  *            @arg TIM_FLAG_CC4OF: TIM Capture Compare 4 overcapture Flag
N  *
N  * @note   TIM6 and TIM7 can have only one update flag. 
N  * @note   TIM15 can have only TIM_FLAG_Update, TIM_FLAG_CC1,TIM_FLAG_CC2 or 
N  *         TIM_FLAG_Trigger. 
N  * @note   TIM14, TIM16 and TIM17 can have TIM_FLAG_Update or TIM_FLAG_CC1.   
N  * @note   TIM_FLAG_Break is used only with TIM1 and TIM15. 
N  * @note   TIM_FLAG_COM is used only with TIM1, TIM15, TIM16 and TIM17.
N  *
N  * @retval None
N  */
Nvoid TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
N{  
N  /* Check the parameters */
N  assert_param(IS_TIM_ALL_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_CLEAR_FLAG(TIM_FLAG));
X  ((void)0);
N   
N  /* Clear the flags */
N  TIMx->SR = (uint16_t)~TIM_FLAG;
N}
N
N/**
N  * @brief  Checks whether the TIM interrupt has occurred or not.
N  * @param  TIMx: where x can be 1, 2, 3, 6, 7, 14, 15, 16 or 17 to select the TIM peripheral.
N  * @param  TIM_IT: specifies the TIM interrupt source to check.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_IT_Update: TIM update Interrupt source
N  *            @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
N  *            @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
N  *            @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
N  *            @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
N  *            @arg TIM_IT_COM: TIM Commutation Interrupt source
N  *            @arg TIM_IT_Trigger: TIM Trigger Interrupt source
N  *            @arg TIM_IT_Break: TIM Break Interrupt source
N  *
N  * @note   TIM6 and TIM7 can generate only an update interrupt.
N  * @note   TIM15 can have only TIM_IT_Update, TIM_IT_CC1, TIM_IT_CC2 or TIM_IT_Trigger. 
N  * @note   TIM14, TIM16 and TIM17 can have TIM_IT_Update or TIM_IT_CC1.   
N  * @note   TIM_IT_Break is used only with TIM1 and TIM15. 
N  * @note   TIM_IT_COM is used only with TIM1, TIM15, TIM16 and TIM17.
N  *
N  * @retval The new state of the TIM_IT(SET or RESET).
N  */
NITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)
N{
N  ITStatus bitstatus = RESET;  
N  uint16_t itstatus = 0x0, itenable = 0x0;
N  
N  /* Check the parameters */
N  assert_param(IS_TIM_ALL_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_GET_IT(TIM_IT));
X  ((void)0);
N   
N  itstatus = TIMx->SR & TIM_IT;
N  
N  itenable = TIMx->DIER & TIM_IT;
N  if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
N  {
N    bitstatus = SET;
N  }
N  else
N  {
N    bitstatus = RESET;
N  }
N  return bitstatus;
N}
N
N/**
N  * @brief  Clears the TIMx's interrupt pending bits.
N  * @param  TIMx: where x can be 1, 2, 3, 6, 7, 14, 15, 16 or 17 to select the TIM peripheral.
N  * @param  TIM_IT: specifies the pending bit to clear.
N  *          This parameter can be any combination of the following values:
N  *            @arg TIM_IT_Update: TIM1 update Interrupt source
N  *            @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
N  *            @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
N  *            @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
N  *            @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
N  *            @arg TIM_IT_COM: TIM Commutation Interrupt source
N  *            @arg TIM_IT_Trigger: TIM Trigger Interrupt source
N  *            @arg TIM_IT_Break: TIM Break Interrupt source
N  *
N  * @note   TIM6 and TIM7 can generate only an update interrupt.
N  * @note   TIM15 can have only TIM_IT_Update, TIM_IT_CC1, TIM_IT_CC2 or TIM_IT_Trigger. 
N  * @note   TIM14, TIM16 and TIM17 can have TIM_IT_Update or TIM_IT_CC1.   
N  * @note   TIM_IT_Break is used only with TIM1 and TIM15. 
N  * @note   TIM_IT_COM is used only with TIM1, TIM15, TIM16 and TIM17.
N  *
N  * @retval None
N  */
Nvoid TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_ALL_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_IT(TIM_IT));
X  ((void)0);
N   
N  /* Clear the IT pending Bit */
N  TIMx->SR = (uint16_t)~TIM_IT;
N}
N
N/**
N  * @brief  Configures the TIMx's DMA interface.
N  * @param  TIMx: where x can be 1, 2, 3, 15, 16 or 17  to select the TIM peripheral.
N  * @param  TIM_DMABase: DMA Base address.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_DMABase_CR1
N  *            @arg TIM_DMABase_CR2
N  *            @arg TIM_DMABase_SMCR
N  *            @arg TIM_DMABase_DIER
N  *            @arg TIM_DMABase_SR
N  *            @arg TIM_DMABase_EGR
N  *            @arg TIM_DMABase_CCMR1
N  *            @arg TIM_DMABase_CCMR2
N  *            @arg TIM_DMABase_CCER
N  *            @arg TIM_DMABase_CNT
N  *            @arg TIM_DMABase_PSC
N  *            @arg TIM_DMABase_ARR
N  *            @arg TIM_DMABase_CCR1
N  *            @arg TIM_DMABase_CCR2
N  *            @arg TIM_DMABase_CCR3 
N  *            @arg TIM_DMABase_CCR4
N  *            @arg TIM_DMABase_DCR
N  *            @arg TIM_DMABase_OR
N  * @param  TIM_DMABurstLength: DMA Burst length. This parameter can be one value
N  *         between: TIM_DMABurstLength_1Transfer and TIM_DMABurstLength_18Transfers.
N  * @retval None
N  */
Nvoid TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_DMA_BASE(TIM_DMABase)); 
X  ((void)0); 
N  assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
X  ((void)0);
N  /* Set the DMA Base and the DMA Burst Length */
N  TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
N}
N
N/**
N  * @brief  Enables or disables the TIMx's DMA Requests.
N  * @param  TIMx: where x can be 1, 2, 3, 6, 7, 15, 16 or 17 to select the TIM peripheral. 
N  * @param  TIM_DMASource: specifies the DMA Request sources.
N  *          This parameter can be any combination of the following values:
N  *            @arg TIM_DMA_Update: TIM update Interrupt source
N  *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
N  *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
N  *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
N  *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
N  *            @arg TIM_DMA_COM: TIM Commutation DMA source
N  *            @arg TIM_DMA_Trigger: TIM Trigger DMA source
N  * @param  NewState: new state of the DMA Request sources.
N  *          This parameter can be: ENABLE or DISABLE.
N  * @retval None
N  */
Nvoid TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState)
N{ 
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST10_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N  
N  if (NewState != DISABLE)
N  {
N    /* Enable the DMA sources */
N    TIMx->DIER |= TIM_DMASource; 
N  }
N  else
N  {
N    /* Disable the DMA sources */
N    TIMx->DIER &= (uint16_t)~TIM_DMASource;
N  }
N}
N
N/**
N  * @brief  Selects the TIMx peripheral Capture Compare DMA source.
N  * @param  TIMx: where x can be 1, 2, 3, 15, 16 or 17  to select the TIM peripheral.
N  * @param  NewState: new state of the Capture Compare DMA source
N  *          This parameter can be: ENABLE or DISABLE.
N  * @retval None
N  */
Nvoid TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST5_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N  
N  if (NewState != DISABLE)
N  {
N    /* Set the CCDS Bit */
N    TIMx->CR2 |= TIM_CR2_CCDS;
X    TIMx->CR2 |= ((uint16_t)0x0008);
N  }
N  else
N  {
N    /* Reset the CCDS Bit */
N    TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCDS);
X    TIMx->CR2 &= (uint16_t)~((uint16_t)((uint16_t)0x0008));
N  }
N}
N
N/**
N  * @}
N  */
N/**
N  * @brief  Configures the TIMx internal Clock
N  * @param  TIMx: where x can be 1, 2, 3, or 15 to select the TIM peripheral. 
N  * @retval None
N  */
Nvoid TIM_InternalClockConfig(TIM_TypeDef* TIMx)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
X  ((void)0);
N  /* Disable slave mode to clock the prescaler directly with the internal clock */
N  TIMx->SMCR &=  (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
X  TIMx->SMCR &=  (uint16_t)(~((uint16_t)((uint16_t)0x0007)));
N}
N
N/**
N  * @brief  Configures the TIMx Internal Trigger as External Clock
N  * @param  TIMx: where x can be 1, 2, 3, or 15 to select the TIM peripheral.
N  * @param  TIM_ITRSource: Trigger source.
N  *          This parameter can be one of the following values:
N  *            @arg  TIM_TS_ITR0: Internal Trigger 0
N  *            @arg  TIM_TS_ITR1: Internal Trigger 1
N  *            @arg  TIM_TS_ITR2: Internal Trigger 2
N  *            @arg  TIM_TS_ITR3: Internal Trigger 3
N  * @retval None
N  */
Nvoid TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
X  ((void)0);
N  /* Select the Internal Trigger */
N  TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
N  /* Select the External clock mode1 */
N  TIMx->SMCR |= TIM_SlaveMode_External1;
X  TIMx->SMCR |= ((uint16_t)0x0007);
N}
N
N/**
N  * @brief  Configures the TIMx Trigger as External Clock
N  * @param  TIMx: where x can be 1, 2, 3, or 15 to select the TIM peripheral. 
N  * @param  TIM_TIxExternalCLKSource: Trigger source.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_TIxExternalCLK1Source_TI1ED: TI1 Edge Detector
N  *            @arg TIM_TIxExternalCLK1Source_TI1: Filtered Timer Input 1
N  *            @arg TIM_TIxExternalCLK1Source_TI2: Filtered Timer Input 2
N  * @param  TIM_ICPolarity: specifies the TIx Polarity.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_ICPolarity_Rising
N  *            @arg TIM_ICPolarity_Falling
N  * @param  ICFilter: specifies the filter value.
N  *          This parameter must be a value between 0x0 and 0xF.
N  * @retval None
N  */
Nvoid TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
N                                uint16_t TIM_ICPolarity, uint16_t ICFilter)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
X  ((void)0);
N  assert_param(IS_TIM_IC_FILTER(ICFilter));
X  ((void)0);
N  
N  /* Configure the Timer Input Clock Source */
N  if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
X  if (TIM_TIxExternalCLKSource == ((uint16_t)0x0060))
N  {
N    TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
X    TI2_Config(TIMx, TIM_ICPolarity, ((uint16_t)0x0001), ICFilter);
N  }
N  else
N  {
N    TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
X    TI1_Config(TIMx, TIM_ICPolarity, ((uint16_t)0x0001), ICFilter);
N  }
N  /* Select the Trigger source */
N  TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
N  /* Select the External clock mode1 */
N  TIMx->SMCR |= TIM_SlaveMode_External1;
X  TIMx->SMCR |= ((uint16_t)0x0007);
N}
N
N/**
N  * @brief  Configures the External clock Mode1
N  * @param  TIMx: where x can be 1, 2 or 3 to select the TIM peripheral.
N  * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
N  *            @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
N  *            @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
N  *            @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
N  * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
N  *            @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
N  * @param  ExtTRGFilter: External Trigger Filter.
N  *          This parameter must be a value between 0x00 and 0x0F
N  * @retval None
N  */
Nvoid TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
N                             uint16_t ExtTRGFilter)
N{
N  uint16_t tmpsmcr = 0;
N  
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
X  ((void)0);
N  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
X  ((void)0);
N  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
X  ((void)0);
N  
N  /* Configure the ETR Clock source */
N  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
N  
N  /* Get the TIMx SMCR register value */
N  tmpsmcr = TIMx->SMCR;
N  /* Reset the SMS Bits */
N  tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
X  tmpsmcr &= (uint16_t)(~((uint16_t)((uint16_t)0x0007)));
N  /* Select the External clock mode1 */
N  tmpsmcr |= TIM_SlaveMode_External1;
X  tmpsmcr |= ((uint16_t)0x0007);
N  /* Select the Trigger selection : ETRF */
N  tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
X  tmpsmcr &= (uint16_t)(~((uint16_t)((uint16_t)0x0070)));
N  tmpsmcr |= TIM_TS_ETRF;
X  tmpsmcr |= ((uint16_t)0x0070);
N  /* Write to TIMx SMCR */
N  TIMx->SMCR = tmpsmcr;
N}
N
N/**
N  * @brief  Configures the External clock Mode2
N  * @param  TIMx: where x can be 1, 2 or 3 to select the TIM peripheral.
N  * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
N  *            @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
N  *            @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
N  *            @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
N  * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
N  *            @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
N  * @param  ExtTRGFilter: External Trigger Filter.
N  *          This parameter must be a value between 0x00 and 0x0F
N  * @retval None
N  */
Nvoid TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
N                             uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
X  ((void)0);
N  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
X  ((void)0);
N  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
X  ((void)0);
N  
N  /* Configure the ETR Clock source */
N  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
N  /* Enable the External clock mode2 */
N  TIMx->SMCR |= TIM_SMCR_ECE;
X  TIMx->SMCR |= ((uint16_t)0x4000);
N}
N
N/**
N  * @}
N  */
N/**
N  * @brief  Selects the Input Trigger source
N  * @param  TIMx: where x can be 1, 2, 3 or 15 to select the TIM peripheral.  
N  * @param  TIM_InputTriggerSource: The Input Trigger source.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_TS_ITR0: Internal Trigger 0
N  *            @arg TIM_TS_ITR1: Internal Trigger 1
N  *            @arg TIM_TS_ITR2: Internal Trigger 2
N  *            @arg TIM_TS_ITR3: Internal Trigger 3
N  *            @arg TIM_TS_TI1F_ED: TI1 Edge Detector
N  *            @arg TIM_TS_TI1FP1: Filtered Timer Input 1
N  *            @arg TIM_TS_TI2FP2: Filtered Timer Input 2
N  *            @arg TIM_TS_ETRF: External Trigger input
N  * @retval None
N  */
Nvoid TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
N{
N  uint16_t tmpsmcr = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST6_PERIPH(TIMx)); 
X  ((void)0); 
N  assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
X  ((void)0);
N
N  /* Get the TIMx SMCR register value */
N  tmpsmcr = TIMx->SMCR;
N  /* Reset the TS Bits */
N  tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
X  tmpsmcr &= (uint16_t)(~((uint16_t)((uint16_t)0x0070)));
N  /* Set the Input Trigger source */
N  tmpsmcr |= TIM_InputTriggerSource;
N  /* Write to TIMx SMCR */
N  TIMx->SMCR = tmpsmcr;
N}
N
N/**
N  * @brief  Selects the TIMx Trigger Output Mode.
N  * @param  TIMx: where x can be 1, 2, 3, 6, 7, or 15 to select the TIM peripheral. 
N  * @param  TIM_TRGOSource: specifies the Trigger Output source.
N  *          This parameter can be one of the following values:
N  *
N  *   - For all TIMx
N  *            @arg TIM_TRGOSource_Reset:  The UG bit in the TIM_EGR register is used as the trigger output (TRGO).
N  *            @arg TIM_TRGOSource_Enable: The Counter Enable CEN is used as the trigger output (TRGO).
N  *            @arg TIM_TRGOSource_Update: The update event is selected as the trigger output (TRGO).
N  *
N  *   - For all TIMx except TIM6 and TIM7
N  *            @arg TIM_TRGOSource_OC1: The trigger output sends a positive pulse when the CC1IF flag
N  *                                     is to be set, as soon as a capture or compare match occurs (TRGO).
N  *            @arg TIM_TRGOSource_OC1Ref: OC1REF signal is used as the trigger output (TRGO).
N  *            @arg TIM_TRGOSource_OC2Ref: OC2REF signal is used as the trigger output (TRGO).
N  *            @arg TIM_TRGOSource_OC3Ref: OC3REF signal is used as the trigger output (TRGO).
N  *            @arg TIM_TRGOSource_OC4Ref: OC4REF signal is used as the trigger output (TRGO).
N  *
N  * @retval None
N  */
Nvoid TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST9_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
X  ((void)0);
N
N  /* Reset the MMS Bits */
N  TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_MMS);
X  TIMx->CR2 &= (uint16_t)~((uint16_t)((uint16_t)0x0070));
N  /* Select the TRGO source */
N  TIMx->CR2 |=  TIM_TRGOSource;
N}
N
N/**
N  * @brief  Selects the TIMx Slave Mode.
N  * @param  TIMx: where x can be 1, 2, 3 or 15 to select the TIM peripheral.  
N  * @param  TIM_SlaveMode: specifies the Timer Slave Mode.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_SlaveMode_Reset: Rising edge of the selected trigger signal (TRGI) re-initializes
N  *                                      the counter and triggers an update of the registers.
N  *            @arg TIM_SlaveMode_Gated:     The counter clock is enabled when the trigger signal (TRGI) is high.
N  *            @arg TIM_SlaveMode_Trigger:   The counter starts at a rising edge of the trigger TRGI.
N  *            @arg TIM_SlaveMode_External1: Rising edges of the selected trigger (TRGI) clock the counter.
N  * @retval None
N  */
Nvoid TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST6_PERIPH(TIMx)); 
X  ((void)0); 
N  assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
X  ((void)0);
N  
N  /* Reset the SMS Bits */
N  TIMx->SMCR &= (uint16_t)~((uint16_t)TIM_SMCR_SMS);
X  TIMx->SMCR &= (uint16_t)~((uint16_t)((uint16_t)0x0007));
N  /* Select the Slave Mode */
N  TIMx->SMCR |= TIM_SlaveMode;
N}
N
N/**
N  * @brief  Sets or Resets the TIMx Master/Slave Mode.
N  * @param  TIMx: where x can be 1, 2, 3, or 15 to select the TIM peripheral. 
N  * @param  TIM_MasterSlaveMode: specifies the Timer Master Slave Mode.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_MasterSlaveMode_Enable: synchronization between the current timer
N  *                                             and its slaves (through TRGO).
N  *            @arg TIM_MasterSlaveMode_Disable: No action
N  * @retval None
N  */
Nvoid TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
X  ((void)0);
N  
N  /* Reset the MSM Bit */
N  TIMx->SMCR &= (uint16_t)~((uint16_t)TIM_SMCR_MSM);
X  TIMx->SMCR &= (uint16_t)~((uint16_t)((uint16_t)0x0080));
N  
N  /* Set or Reset the MSM Bit */
N  TIMx->SMCR |= TIM_MasterSlaveMode;
N}
N
N/**
N  * @brief  Configures the TIMx External Trigger (ETR).
N  * @param  TIMx: where x can be 1, 2 or 3 to select the TIM peripheral.   
N  * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.
N  *            @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.
N  *            @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.
N  *            @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.
N  * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.
N  *            @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.
N  * @param  ExtTRGFilter: External Trigger Filter.
N  *          This parameter must be a value between 0x00 and 0x0F
N  * @retval None
N  */
Nvoid TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
N                   uint16_t ExtTRGFilter)
N{
N  uint16_t tmpsmcr = 0;
N  
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
X  ((void)0);
N  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
X  ((void)0);
N  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
X  ((void)0);
N  
N  tmpsmcr = TIMx->SMCR;
N  /* Reset the ETR Bits */
N  tmpsmcr &= SMCR_ETR_MASK;
X  tmpsmcr &= ((uint16_t)0x00FF);
N  /* Set the Prescaler, the Filter value and the Polarity */
N  tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
N  /* Write to TIMx SMCR */
N  TIMx->SMCR = tmpsmcr;
N}
N
N/**
N  * @}
N  */
N/**
N  * @brief  Configures the TIMx Encoder Interface.
N  * @param  TIMx: where x can be  1, 2 or 3 to select the TIM peripheral. 
N  * @param  TIM_EncoderMode: specifies the TIMx Encoder Mode.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_EncoderMode_TI1: Counter counts on TI1FP1 edge depending on TI2FP2 level.
N  *            @arg TIM_EncoderMode_TI2: Counter counts on TI2FP2 edge depending on TI1FP1 level.
N  *            @arg TIM_EncoderMode_TI12: Counter counts on both TI1FP1 and TI2FP2 edges depending
N  *                                       on the level of the other input.
N  * @param  TIM_IC1Polarity: specifies the IC1 Polarity
N  *          This parmeter can be one of the following values:
N  *            @arg TIM_ICPolarity_Falling: IC Falling edge.
N  *            @arg TIM_ICPolarity_Rising: IC Rising edge.
N  * @param  TIM_IC2Polarity: specifies the IC2 Polarity
N  *          This parmeter can be one of the following values:
N  *            @arg TIM_ICPolarity_Falling: IC Falling edge.
N  *            @arg TIM_ICPolarity_Rising: IC Rising edge.
N  * @retval None
N  */
Nvoid TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
N                                uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
N{
N  uint16_t tmpsmcr = 0;
N  uint16_t tmpccmr1 = 0;
N  uint16_t tmpccer = 0;
N    
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
X  ((void)0);
N  assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
X  ((void)0);
N  assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
X  ((void)0);
N  
N  /* Get the TIMx SMCR register value */
N  tmpsmcr = TIMx->SMCR;
N  /* Get the TIMx CCMR1 register value */
N  tmpccmr1 = TIMx->CCMR1;
N  /* Get the TIMx CCER register value */
N  tmpccer = TIMx->CCER;
N  /* Set the encoder Mode */
N  tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
X  tmpsmcr &= (uint16_t)(~((uint16_t)((uint16_t)0x0007)));
N  tmpsmcr |= TIM_EncoderMode;
N  /* Select the Capture Compare 1 and the Capture Compare 2 as input */
N  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S)));
X  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)((uint16_t)0x0003))) & (uint16_t)(~((uint16_t)((uint16_t)0x0300))));
N  tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
X  tmpccmr1 |= ((uint16_t)0x0001) | ((uint16_t)0x0100);
N  /* Set the TI1 and the TI2 Polarities */
N  tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC1P | TIM_CCER_CC1NP)) & (uint16_t)~((uint16_t)(TIM_CCER_CC2P | TIM_CCER_CC2NP));
X  tmpccer &= (uint16_t)~((uint16_t)(((uint16_t)0x0002) | ((uint16_t)0x0008))) & (uint16_t)~((uint16_t)(((uint16_t)0x0020) | ((uint16_t)0x0080)));
N  tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
N  /* Write to TIMx SMCR */
N  TIMx->SMCR = tmpsmcr;
N  /* Write to TIMx CCMR1 */
N  TIMx->CCMR1 = tmpccmr1;
N  /* Write to TIMx CCER */
N  TIMx->CCER = tmpccer;
N}
N
N/**
N  * @brief  Enables or disables the TIMx's Hall sensor interface.
N  * @param  TIMx: where x can be 1, 2 or 3 to select the TIM peripheral. 
N  * @param  NewState: new state of the TIMx Hall sensor interface.
N  *          This parameter can be: ENABLE or DISABLE.
N  * @retval None
N  */
Nvoid TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N  
N  if (NewState != DISABLE)
N  {
N    /* Set the TI1S Bit */
N    TIMx->CR2 |= TIM_CR2_TI1S;
X    TIMx->CR2 |= ((uint16_t)0x0080);
N  }
N  else
N  {
N    /* Reset the TI1S Bit */
N    TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_TI1S);
X    TIMx->CR2 &= (uint16_t)~((uint16_t)((uint16_t)0x0080));
N  }
N}
N
N/**
N  * @}
N  */
N/**
N  * @brief  Configures the TIM14 Remapping input Capabilities.
N  * @param  TIMx: where x can be 14 to select the TIM peripheral.
N  * @param  TIM_Remap: specifies the TIM input reampping source.
N  *          This parameter can be one of the following values:
N  *            @arg TIM14_GPIO: TIM14 Channel 1 is connected to GPIO.
N  *            @arg TIM14_RTC_CLK: TIM14 Channel 1 is connected to RTC input clock.
N  *                                RTC input clock can be LSE, LSI or HSE/div128.
N  *            @arg TIM14_HSE_DIV32: TIM14 Channel 1 is connected to HSE/32 clock.  
N  *            @arg TIM14_MCO: TIM14 Channel 1 is connected to MCO clock.  
N  *                            MCO clock can be HSI14, SYSCLK, HSI, HSE or PLL/2.  
N  * @retval None
N  */
Nvoid TIM_RemapConfig(TIM_TypeDef* TIMx, uint16_t TIM_Remap)
N{
N /* Check the parameters */
N  assert_param(IS_TIM_LIST11_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_REMAP(TIM_Remap));
X  ((void)0);
N
N  /* Set the Timer remapping configuration */
N  TIMx->OR =  TIM_Remap;
N}
N
N/**
N  * @}
N  */
N
N/**
N  * @brief  Configure the TI1 as Input.
N  * @param  TIMx: where x can be 1, 2, 3, 14, 15, 16 or 17 to select the TIM peripheral.  
N  * @param  TIM_ICPolarity: The Input Polarity.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_ICPolarity_Rising
N  *            @arg TIM_ICPolarity_Falling
N  * @param  TIM_ICSelection: specifies the input to be used.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_ICSelection_DirectTI: TIM Input 1 is selected to be connected to IC1.
N  *            @arg TIM_ICSelection_IndirectTI: TIM Input 1 is selected to be connected to IC2.
N  *            @arg TIM_ICSelection_TRC: TIM Input 1 is selected to be connected to TRC.
N  * @param  TIM_ICFilter: Specifies the Input Capture Filter.
N  *          This parameter must be a value between 0x00 and 0x0F.
N  * @retval None
N  */
Nstatic void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
N                       uint16_t TIM_ICFilter)
N{
N  uint16_t tmpccmr1 = 0, tmpccer = 0;
N  /* Disable the Channel 1: Reset the CC1E Bit */
N  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC1E);
X  TIMx->CCER &= (uint16_t)~((uint16_t)((uint16_t)0x0001));
N  tmpccmr1 = TIMx->CCMR1;
N  tmpccer = TIMx->CCER;
N  /* Select the Input and set the filter */
N  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC1F)));
X  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)((uint16_t)0x0003))) & ((uint16_t)~((uint16_t)((uint16_t)0x00F0))));
N  tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
N 
N  /* Select the Polarity and set the CC1E Bit */
N  tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC1P | TIM_CCER_CC1NP));
X  tmpccer &= (uint16_t)~((uint16_t)(((uint16_t)0x0002) | ((uint16_t)0x0008)));
N  tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
X  tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)((uint16_t)0x0001));
N  /* Write to TIMx CCMR1 and CCER registers */
N  TIMx->CCMR1 = tmpccmr1;
N  TIMx->CCER = tmpccer;
N}
N
N/**
N  * @brief  Configure the TI2 as Input.
N  * @param  TIMx: where x can be 1, 2, 3, or 15 to select the TIM peripheral.
N  * @param  TIM_ICPolarity: The Input Polarity.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_ICPolarity_Rising
N  *            @arg TIM_ICPolarity_Falling
N  * @param  TIM_ICSelection: specifies the input to be used.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_ICSelection_DirectTI: TIM Input 2 is selected to be connected to IC2.
N  *            @arg TIM_ICSelection_IndirectTI: TIM Input 2 is selected to be connected to IC1.
N  *            @arg TIM_ICSelection_TRC: TIM Input 2 is selected to be connected to TRC.
N  * @param  TIM_ICFilter: Specifies the Input Capture Filter.
N  *          This parameter must be a value between 0x00 and 0x0F.
N  * @retval None
N  */
Nstatic void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
N                       uint16_t TIM_ICFilter)
N{
N  uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
N  /* Disable the Channel 2: Reset the CC2E Bit */
N  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC2E);
X  TIMx->CCER &= (uint16_t)~((uint16_t)((uint16_t)0x0010));
N  tmpccmr1 = TIMx->CCMR1;
N  tmpccer = TIMx->CCER;
N  tmp = (uint16_t)(TIM_ICPolarity << 4);
N  /* Select the Input and set the filter */
N  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC2S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC2F)));
X  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)((uint16_t)0x0300))) & ((uint16_t)~((uint16_t)((uint16_t)0xF000))));
N  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
N  tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8); 
N  /* Select the Polarity and set the CC2E Bit */
N  tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC2P | TIM_CCER_CC2NP));
X  tmpccer &= (uint16_t)~((uint16_t)(((uint16_t)0x0020) | ((uint16_t)0x0080)));
N  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);  
X  tmpccer |= (uint16_t)(tmp | (uint16_t)((uint16_t)0x0010));  
N  /* Write to TIMx CCMR1 and CCER registers */
N  TIMx->CCMR1 = tmpccmr1 ;
N  TIMx->CCER = tmpccer;
N}
N
N/**
N  * @brief  Configure the TI3 as Input.
N  * @param  TIMx: where x can be 1, 2 or 3 to select the TIM peripheral.  
N  * @param  TIM_ICPolarity: The Input Polarity.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_ICPolarity_Rising
N  *            @arg TIM_ICPolarity_Falling
N  * @param  TIM_ICSelection: specifies the input to be used.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_ICSelection_DirectTI: TIM Input 3 is selected to be connected to IC3.
N  *            @arg TIM_ICSelection_IndirectTI: TIM Input 3 is selected to be connected to IC4.
N  *            @arg TIM_ICSelection_TRC: TIM Input 3 is selected to be connected to TRC.
N  * @param  TIM_ICFilter: Specifies the Input Capture Filter.
N  *          This parameter must be a value between 0x00 and 0x0F.
N  * @retval None
N  */
Nstatic void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
N                       uint16_t TIM_ICFilter)
N{
N  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
N  /* Disable the Channel 3: Reset the CC3E Bit */
N  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC3E);
X  TIMx->CCER &= (uint16_t)~((uint16_t)((uint16_t)0x0100));
N  tmpccmr2 = TIMx->CCMR2;
N  tmpccer = TIMx->CCER;
N  tmp = (uint16_t)(TIM_ICPolarity << 8);
N  /* Select the Input and set the filter */
N  tmpccmr2 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR2_CC3S)) & ((uint16_t)~((uint16_t)TIM_CCMR2_IC3F)));
X  tmpccmr2 &= (uint16_t)(((uint16_t)~((uint16_t)((uint16_t)0x0003))) & ((uint16_t)~((uint16_t)((uint16_t)0x00F0))));
N  tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
N  /* Select the Polarity and set the CC3E Bit */
N  tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC3P | TIM_CCER_CC3NP));
X  tmpccer &= (uint16_t)~((uint16_t)(((uint16_t)0x0200) | ((uint16_t)0x0800)));
N  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);  
X  tmpccer |= (uint16_t)(tmp | (uint16_t)((uint16_t)0x0100));  
N  /* Write to TIMx CCMR2 and CCER registers */
N  TIMx->CCMR2 = tmpccmr2;
N  TIMx->CCER = tmpccer;
N}
N
N/**
N  * @brief  Configure the TI4 as Input.
N  * @param  TIMx: where x can be 1, 2 or 3 to select the TIM peripheral.
N  * @param  TIM_ICPolarity: The Input Polarity.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_ICPolarity_Rising
N  *            @arg TIM_ICPolarity_Falling
N  * @param  TIM_ICSelection: specifies the input to be used.
N  *          This parameter can be one of the following values:
N  *            @arg TIM_ICSelection_DirectTI: TIM Input 4 is selected to be connected to IC4.
N  *            @arg TIM_ICSelection_IndirectTI: TIM Input 4 is selected to be connected to IC3.
N  *            @arg TIM_ICSelection_TRC: TIM Input 4 is selected to be connected to TRC.
N  * @param  TIM_ICFilter: Specifies the Input Capture Filter.
N  *          This parameter must be a value between 0x00 and 0x0F.
N  * @retval None
N  */
Nstatic void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
N                       uint16_t TIM_ICFilter)
N{
N  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;
N
N   /* Disable the Channel 4: Reset the CC4E Bit */
N  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC4E);
X  TIMx->CCER &= (uint16_t)~((uint16_t)((uint16_t)0x1000));
N  tmpccmr2 = TIMx->CCMR2;
N  tmpccer = TIMx->CCER;
N  tmp = (uint16_t)(TIM_ICPolarity << 12);
N  /* Select the Input and set the filter */
N  tmpccmr2 &= (uint16_t)((uint16_t)(~(uint16_t)TIM_CCMR2_CC4S) & ((uint16_t)~((uint16_t)TIM_CCMR2_IC4F)));
X  tmpccmr2 &= (uint16_t)((uint16_t)(~(uint16_t)((uint16_t)0x0300)) & ((uint16_t)~((uint16_t)((uint16_t)0xF000))));
N  tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
N  tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);  
N  /* Select the Polarity and set the CC4E Bit */
N  tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC4P));
X  tmpccer &= (uint16_t)~((uint16_t)(((uint16_t)0x2000)));
N  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);
X  tmpccer |= (uint16_t)(tmp | (uint16_t)((uint16_t)0x1000));
N  /* Write to TIMx CCMR2 and CCER registers */
N  TIMx->CCMR2 = tmpccmr2;
N  TIMx->CCER = tmpccer;
N}
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT FMD *****END OF FILE****/
