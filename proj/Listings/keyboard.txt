; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\keyboard.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\keyboard.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\FTLib\CMSIS\inc -I..\FTLib\Inc -I..\FTLib\Lib -I..\usb\inc -I..\user -I..\RTT -IC:\Users\Tom\AppData\Local\Arm\Packs\FMD\FT32F0xx_DFP\1.0.2\Drivers\CMSIS\FT32F0xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=533 -DFT32F072x8 -DFT32F072x8 --omf_browse=.\objects\keyboard.crf ..\user\keyboard.c]
                          THUMB

                          AREA ||i.USB_Receive_VendorData||, CODE, READONLY, ALIGN=1

                  USB_Receive_VendorData PROC
;;;144    */
;;;145    void USB_Receive_VendorData(uint8_t* dat, uint8_t len)
000000  b570              PUSH     {r4-r6,lr}
;;;146    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;147    	USB_EP_Rx(ep_hid_vendor_rx, dat, len);
000006  462a              MOV      r2,r5
000008  4621              MOV      r1,r4
00000a  2005              MOVS     r0,#5
00000c  f7fffffe          BL       USB_EP_Rx
;;;148    	
;;;149    //	if(USB_Receive_Buffer[0] ==0x05)
;;;150    //	{ 
;;;151    //		__disable_irq();
;;;152    //		
;;;153    //		/*Unlock FLASH*/
;;;154    //		FLASH_Unlock();  
;;;155    //		 
;;;156    //		/* Clear All pending flags */
;;;157    //		FLASH_ClearFlag(FLASH_FLAG_BSY | FLASH_FLAG_EOP | FLASH_FLAG_PGERR | FLASH_FLAG_WRPERR);  
;;;158    //		FLASH_ErasePage(ApplicaflagAddress);
;;;159    //		Delay_Nus(100);
;;;160    //		FLASH_Lock();
;;;161    
;;;162    //		__NOP();
;;;163    //		__NOP();
;;;164    //		SYSCFG_MemoryRemapConfig(SYSCFG_MemoryRemap_Flash);
;;;165    //		NVIC_SystemReset();
;;;166    //	}
;;;167    }
000010  bd70              POP      {r4-r6,pc}
;;;168    
                          ENDP


                          AREA ||i.USB_Transmit_VendorData||, CODE, READONLY, ALIGN=1

                  USB_Transmit_VendorData PROC
;;;131    */
;;;132    void USB_Transmit_VendorData(uint8_t* dat, uint8_t len)
000000  b570              PUSH     {r4-r6,lr}
;;;133    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;134    	USB_EP_Tx(ep_hid_vendor_tx, dat, len);
000006  462a              MOV      r2,r5
000008  4621              MOV      r1,r4
00000a  2004              MOVS     r0,#4
00000c  f7fffffe          BL       USB_EP_Tx
;;;135    }
000010  bd70              POP      {r4-r6,pc}
;;;136    
                          ENDP


                          AREA ||i.ep2_send_data||, CODE, READONLY, ALIGN=2

                  ep2_send_data PROC
;;;74     */
;;;75     void ep2_send_data(uint8_t rpt_type, uint8_t* dat, uint8_t len)
000000  b570              PUSH     {r4-r6,lr}
;;;76     {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
000006  4614              MOV      r4,r2
;;;77     	switch(rpt_type)
000008  2e01              CMP      r6,#1
00000a  d006              BEQ      |L3.26|
00000c  2e02              CMP      r6,#2
00000e  d025              BEQ      |L3.92|
000010  2e03              CMP      r6,#3
000012  d013              BEQ      |L3.60|
000014  2e06              CMP      r6,#6
000016  d142              BNE      |L3.158|
000018  e030              B        |L3.124|
                  |L3.26|
;;;78     	{
;;;79     		case RPT_TOUCHPAD:
;;;80     			if( LEN_TOUCHPAD_DATA == len)  // 如果此行影响发送速度，可注释掉以提高执行速度
00001a  2c05              CMP      r4,#5
00001c  d10d              BNE      |L3.58|
;;;81     			{
;;;82     				ep2_send_buf[0] = RPT_TOUCHPAD;
00001e  2001              MOVS     r0,#1
000020  4920              LDR      r1,|L3.164|
000022  7008              STRB     r0,[r1,#0]
;;;83     				memcpy(&ep2_send_buf[1], dat, LEN_TOUCHPAD_DATA);
000024  2205              MOVS     r2,#5
000026  4629              MOV      r1,r5
000028  481e              LDR      r0,|L3.164|
00002a  1c40              ADDS     r0,r0,#1
00002c  f7fffffe          BL       __aeabi_memcpy
;;;84     				
;;;85     				USB_EP_Tx(ep_touchpad, ep2_send_buf, len);
000030  4622              MOV      r2,r4
000032  491c              LDR      r1,|L3.164|
000034  2002              MOVS     r0,#2
000036  f7fffffe          BL       USB_EP_Tx
                  |L3.58|
;;;86     			}
;;;87     		break;
00003a  e031              B        |L3.160|
                  |L3.60|
;;;88     		
;;;89     		case RPT_CONSUMER:
;;;90     			if( LEN_CONSUMER_DATA == len)
00003c  2c02              CMP      r4,#2
00003e  d10c              BNE      |L3.90|
;;;91     			{
;;;92     				ep2_send_buf[0] = RPT_CONSUMER;
000040  2003              MOVS     r0,#3
000042  4918              LDR      r1,|L3.164|
000044  7008              STRB     r0,[r1,#0]
;;;93     				memcpy(&ep2_send_buf[1], dat, LEN_CONSUMER_DATA);
000046  4608              MOV      r0,r1
000048  7829              LDRB     r1,[r5,#0]
00004a  7041              STRB     r1,[r0,#1]
00004c  7869              LDRB     r1,[r5,#1]
00004e  7081              STRB     r1,[r0,#2]
;;;94     				
;;;95     				USB_EP_Tx(ep_consumer, ep2_send_buf, len);
000050  4622              MOV      r2,r4
000052  4601              MOV      r1,r0
000054  2002              MOVS     r0,#2
000056  f7fffffe          BL       USB_EP_Tx
                  |L3.90|
;;;96     			}
;;;97     		break;
00005a  e021              B        |L3.160|
                  |L3.92|
;;;98     		
;;;99     		case RPT_SYSCTRL:
;;;100    			if( LEN_SYSCTRL_DATA == len)
00005c  2c02              CMP      r4,#2
00005e  d10c              BNE      |L3.122|
;;;101    			{
;;;102    				ep2_send_buf[0] = RPT_SYSCTRL;
000060  2002              MOVS     r0,#2
000062  4910              LDR      r1,|L3.164|
000064  7008              STRB     r0,[r1,#0]
;;;103    				memcpy(&ep2_send_buf[1], dat, LEN_SYSCTRL_DATA);
000066  4608              MOV      r0,r1
000068  7829              LDRB     r1,[r5,#0]
00006a  7041              STRB     r1,[r0,#1]
00006c  7869              LDRB     r1,[r5,#1]
00006e  7081              STRB     r1,[r0,#2]
;;;104    				
;;;105    				USB_EP_Tx(ep_sysctrl, ep2_send_buf, len);
000070  4622              MOV      r2,r4
000072  4601              MOV      r1,r0
000074  2002              MOVS     r0,#2
000076  f7fffffe          BL       USB_EP_Tx
                  |L3.122|
;;;106    			}
;;;107    		break;
00007a  e011              B        |L3.160|
                  |L3.124|
;;;108    		
;;;109    		case RPT_HID_KEYBOARD:
;;;110    			if( LEN_HID_KEYBOARD_DATA == len)
00007c  2c0f              CMP      r4,#0xf
00007e  d10d              BNE      |L3.156|
;;;111    			{
;;;112    				ep2_send_buf[0] = RPT_HID_KEYBOARD;
000080  2006              MOVS     r0,#6
000082  4908              LDR      r1,|L3.164|
000084  7008              STRB     r0,[r1,#0]
;;;113    				memcpy(&ep2_send_buf[1], dat, LEN_HID_KEYBOARD_DATA);
000086  220f              MOVS     r2,#0xf
000088  4629              MOV      r1,r5
00008a  4806              LDR      r0,|L3.164|
00008c  1c40              ADDS     r0,r0,#1
00008e  f7fffffe          BL       __aeabi_memcpy
;;;114    				
;;;115    				USB_EP_Tx(ep_hid_keyboard, ep2_send_buf, len);
000092  4622              MOV      r2,r4
000094  4903              LDR      r1,|L3.164|
000096  2002              MOVS     r0,#2
000098  f7fffffe          BL       USB_EP_Tx
                  |L3.156|
;;;116    			}
;;;117    		break;
00009c  e000              B        |L3.160|
                  |L3.158|
;;;118    		
;;;119    		default:
;;;120    			
;;;121    		break;
00009e  bf00              NOP      
                  |L3.160|
0000a0  bf00              NOP                            ;87
;;;122    	}
;;;123    }
0000a2  bd70              POP      {r4-r6,pc}
;;;124    
                          ENDP

                  |L3.164|
                          DCD      ep2_send_buf

                          AREA ||i.send_boot_keyboard_code||, CODE, READONLY, ALIGN=1

                  send_boot_keyboard_code PROC
;;;18     
;;;19     void send_boot_keyboard_code(uint8_t* dat, uint8_t len)
000000  b570              PUSH     {r4-r6,lr}
;;;20     {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;21     	if( LEN_BOOT_KEYBOARD_DATA == len)
000006  2c08              CMP      r4,#8
000008  d104              BNE      |L4.20|
;;;22     	{
;;;23     		USB_EP_Tx(ep_boot_keyboard, dat, len);
00000a  4622              MOV      r2,r4
00000c  4629              MOV      r1,r5
00000e  2001              MOVS     r0,#1
000010  f7fffffe          BL       USB_EP_Tx
                  |L4.20|
;;;24     	}
;;;25     }
000014  bd70              POP      {r4-r6,pc}
;;;26     
                          ENDP


                          AREA ||i.send_hid_keyboard_code||, CODE, READONLY, ALIGN=1

                  send_hid_keyboard_code PROC
;;;58     
;;;59     void send_hid_keyboard_code(uint8_t* dat, uint8_t len)
000000  b570              PUSH     {r4-r6,lr}
;;;60     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;61     //	if( LEN_HID_KEYBOARD_DATA == len)
;;;62     	{
;;;63     		USB_EP_Tx(3, dat, len);
000006  462a              MOV      r2,r5
000008  4621              MOV      r1,r4
00000a  2003              MOVS     r0,#3
00000c  f7fffffe          BL       USB_EP_Tx
;;;64     	}
;;;65     }
000010  bd70              POP      {r4-r6,pc}
;;;66     
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  Vendor_data_Buffer
                          %        64
                  ep2_send_buf
                          %        64

;*** Start embedded assembler ***

#line 1 "..\\user\\keyboard.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_keyboard_c_d802fdc2____REV16|
#line 129 "..\\FTLib\\CMSIS\\inc\\core_cmInstr.h"
|__asm___10_keyboard_c_d802fdc2____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_keyboard_c_d802fdc2____REVSH|
#line 144
|__asm___10_keyboard_c_d802fdc2____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
