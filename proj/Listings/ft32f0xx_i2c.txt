; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\ft32f0xx_i2c.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\ft32f0xx_i2c.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\FTLib\CMSIS\inc -I..\FTLib\Inc -I..\FTLib\Lib -I..\usb\inc -I..\user -I..\RTT -I..\iap2 -IC:\Users\dell1\AppData\Local\Arm\Packs\FMD\FT32F0xx_DFP\1.0.6\Drivers\CMSIS\FT32F0xx\Include -D__UVISION_VERSION=534 -DFT32F072x8 -DFT32F072x8 --omf_browse=.\objects\ft32f0xx_i2c.crf ..\FTLib\Src\ft32f0xx_i2c.c]
                          THUMB

                          AREA ||i.I2C_10BitAddressHeaderCmd||, CODE, READONLY, ALIGN=1

                  I2C_10BitAddressHeaderCmd PROC
;;;607      */
;;;608    void I2C_10BitAddressHeaderCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;609    {
;;;610      /* Check the parameters */
;;;611      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;612      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;613      
;;;614      if (NewState != DISABLE)
000002  d005              BEQ      |L1.16|
;;;615      {
;;;616        /* Enable 10-bit header only mode */
;;;617        I2Cx->CR2 |= I2C_CR2_HEAD10R;
000004  6842              LDR      r2,[r0,#4]
000006  2301              MOVS     r3,#1
000008  031b              LSLS     r3,r3,#12
00000a  431a              ORRS     r2,r2,r3
00000c  6042              STR      r2,[r0,#4]
00000e  e004              B        |L1.26|
                  |L1.16|
;;;618      }
;;;619      else
;;;620      {
;;;621        /* Disable 10-bit header only mode */
;;;622        I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_HEAD10R);
000010  6842              LDR      r2,[r0,#4]
000012  2301              MOVS     r3,#1
000014  031b              LSLS     r3,r3,#12
000016  439a              BICS     r2,r2,r3
000018  6042              STR      r2,[r0,#4]
                  |L1.26|
;;;623      }
;;;624    }    
00001a  4770              BX       lr
;;;625    
                          ENDP


                          AREA ||i.I2C_10BitAddressingModeCmd||, CODE, READONLY, ALIGN=1

                  I2C_10BitAddressingModeCmd PROC
;;;419      */
;;;420    void I2C_10BitAddressingModeCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;421    {
;;;422      /* Check the parameters */
;;;423      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;424      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;425      
;;;426      if (NewState != DISABLE)
000002  d005              BEQ      |L2.16|
;;;427      {
;;;428        /* Enable 10-bit addressing mode */
;;;429        I2Cx->CR2 |= I2C_CR2_ADD10;
000004  6842              LDR      r2,[r0,#4]
000006  2301              MOVS     r3,#1
000008  02db              LSLS     r3,r3,#11
00000a  431a              ORRS     r2,r2,r3
00000c  6042              STR      r2,[r0,#4]
00000e  e004              B        |L2.26|
                  |L2.16|
;;;430      }
;;;431      else
;;;432      {
;;;433        /* Disable 10-bit addressing mode */
;;;434        I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_ADD10);
000010  6842              LDR      r2,[r0,#4]
000012  2301              MOVS     r3,#1
000014  02db              LSLS     r3,r3,#11
000016  439a              BICS     r2,r2,r3
000018  6042              STR      r2,[r0,#4]
                  |L2.26|
;;;435      }
;;;436    } 
00001a  4770              BX       lr
;;;437    
                          ENDP


                          AREA ||i.I2C_AcknowledgeConfig||, CODE, READONLY, ALIGN=1

                  I2C_AcknowledgeConfig PROC
;;;632      */
;;;633    void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;634    {
;;;635      /* Check the parameters */
;;;636      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;637      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;638      
;;;639      if (NewState != DISABLE)
000002  d005              BEQ      |L3.16|
;;;640      {
;;;641        /* Enable ACK generation */
;;;642        I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_NACK);    
000004  6842              LDR      r2,[r0,#4]
000006  2301              MOVS     r3,#1
000008  03db              LSLS     r3,r3,#15
00000a  439a              BICS     r2,r2,r3
00000c  6042              STR      r2,[r0,#4]
00000e  e004              B        |L3.26|
                  |L3.16|
;;;643      }
;;;644      else
;;;645      {
;;;646        /* Enable NACK generation */
;;;647        I2Cx->CR2 |= I2C_CR2_NACK;
000010  6842              LDR      r2,[r0,#4]
000012  2301              MOVS     r3,#1
000014  03db              LSLS     r3,r3,#15
000016  431a              ORRS     r2,r2,r3
000018  6042              STR      r2,[r0,#4]
                  |L3.26|
;;;648      }
;;;649    }
00001a  4770              BX       lr
;;;650    
                          ENDP


                          AREA ||i.I2C_AutoEndCmd||, CODE, READONLY, ALIGN=1

                  I2C_AutoEndCmd PROC
;;;451      */
;;;452    void I2C_AutoEndCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;453    {
;;;454      /* Check the parameters */
;;;455      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;456      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;457      
;;;458      if (NewState != DISABLE)
000002  d005              BEQ      |L4.16|
;;;459      {
;;;460        /* Enable Auto end mode */
;;;461        I2Cx->CR2 |= I2C_CR2_AUTOEND;
000004  6842              LDR      r2,[r0,#4]
000006  2301              MOVS     r3,#1
000008  065b              LSLS     r3,r3,#25
00000a  431a              ORRS     r2,r2,r3
00000c  6042              STR      r2,[r0,#4]
00000e  e004              B        |L4.26|
                  |L4.16|
;;;462      }
;;;463      else
;;;464      {
;;;465        /* Disable Auto end mode */
;;;466        I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_AUTOEND);
000010  6842              LDR      r2,[r0,#4]
000012  2301              MOVS     r3,#1
000014  065b              LSLS     r3,r3,#25
000016  439a              BICS     r2,r2,r3
000018  6042              STR      r2,[r0,#4]
                  |L4.26|
;;;467      }
;;;468    } 
00001a  4770              BX       lr
;;;469    
                          ENDP


                          AREA ||i.I2C_CalculatePEC||, CODE, READONLY, ALIGN=1

                  I2C_CalculatePEC PROC
;;;904      */
;;;905    void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;906    {
;;;907      /* Check the parameters */
;;;908      assert_param(IS_I2C_1_PERIPH(I2Cx));
;;;909      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;910      
;;;911      if (NewState != DISABLE)
000002  d005              BEQ      |L5.16|
;;;912      {
;;;913        /* Enable PEC calculation */
;;;914        I2Cx->CR1 |= I2C_CR1_PECEN;   
000004  6802              LDR      r2,[r0,#0]
000006  2301              MOVS     r3,#1
000008  05db              LSLS     r3,r3,#23
00000a  431a              ORRS     r2,r2,r3
00000c  6002              STR      r2,[r0,#0]
00000e  e004              B        |L5.26|
                  |L5.16|
;;;915      }
;;;916      else
;;;917      {
;;;918        /* Disable PEC calculation */    
;;;919        I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_PECEN); 
000010  6802              LDR      r2,[r0,#0]
000012  2301              MOVS     r3,#1
000014  05db              LSLS     r3,r3,#23
000016  439a              BICS     r2,r2,r3
000018  6002              STR      r2,[r0,#0]
                  |L5.26|
;;;920      }
;;;921    }
00001a  4770              BX       lr
;;;922    
                          ENDP


                          AREA ||i.I2C_ClearFlag||, CODE, READONLY, ALIGN=1

                  I2C_ClearFlag PROC
;;;1135     */
;;;1136   void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
000000  61c1              STR      r1,[r0,#0x1c]
;;;1137   { 
;;;1138     /* Check the parameters */
;;;1139     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1140     assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
;;;1141   
;;;1142     /* Clear the selected flag */
;;;1143     I2Cx->ICR = I2C_FLAG;
;;;1144   }
000002  4770              BX       lr
;;;1145   
                          ENDP


                          AREA ||i.I2C_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  I2C_ClearITPendingBit PROC
;;;1229     */
;;;1230   void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
000000  61c1              STR      r1,[r0,#0x1c]
;;;1231   {
;;;1232     /* Check the parameters */
;;;1233     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1234     assert_param(IS_I2C_CLEAR_IT(I2C_IT));
;;;1235   
;;;1236     /* Clear the selected flag */
;;;1237     I2Cx->ICR = I2C_IT;
;;;1238   }
000002  4770              BX       lr
;;;1239   
                          ENDP


                          AREA ||i.I2C_ClockTimeoutCmd||, CODE, READONLY, ALIGN=1

                  I2C_ClockTimeoutCmd PROC
;;;773      */
;;;774    void I2C_ClockTimeoutCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;775    {
;;;776      /* Check the parameters */
;;;777      assert_param(IS_I2C_1_PERIPH(I2Cx));
;;;778      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;779      
;;;780      if (NewState != DISABLE)
000002  d005              BEQ      |L8.16|
;;;781      {
;;;782        /* Enable Clock Timeout */
;;;783        I2Cx->TIMEOUTR |= I2C_TIMEOUTR_TIMOUTEN;   
000004  6942              LDR      r2,[r0,#0x14]
000006  2301              MOVS     r3,#1
000008  03db              LSLS     r3,r3,#15
00000a  431a              ORRS     r2,r2,r3
00000c  6142              STR      r2,[r0,#0x14]
00000e  e004              B        |L8.26|
                  |L8.16|
;;;784      }
;;;785      else
;;;786      {
;;;787        /* Disable Clock Timeout */    
;;;788        I2Cx->TIMEOUTR &= (uint32_t)~((uint32_t)I2C_TIMEOUTR_TIMOUTEN); 
000010  6942              LDR      r2,[r0,#0x14]
000012  2301              MOVS     r3,#1
000014  03db              LSLS     r3,r3,#15
000016  439a              BICS     r2,r2,r3
000018  6142              STR      r2,[r0,#0x14]
                  |L8.26|
;;;789      }
;;;790    }
00001a  4770              BX       lr
;;;791    
                          ENDP


                          AREA ||i.I2C_Cmd||, CODE, READONLY, ALIGN=1

                  I2C_Cmd PROC
;;;171      */
;;;172    void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;173    {
;;;174      /* Check the parameters */
;;;175      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;176      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;177      if (NewState != DISABLE)
000002  d004              BEQ      |L9.14|
;;;178      {
;;;179        /* Enable the selected I2C peripheral */
;;;180        I2Cx->CR1 |= I2C_CR1_PE;
000004  6802              LDR      r2,[r0,#0]
000006  2301              MOVS     r3,#1
000008  431a              ORRS     r2,r2,r3
00000a  6002              STR      r2,[r0,#0]
00000c  e003              B        |L9.22|
                  |L9.14|
;;;181      }
;;;182      else
;;;183      {
;;;184        /* Disable the selected I2C peripheral */
;;;185        I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_PE);
00000e  6802              LDR      r2,[r0,#0]
000010  0852              LSRS     r2,r2,#1
000012  0052              LSLS     r2,r2,#1
000014  6002              STR      r2,[r0,#0]
                  |L9.22|
;;;186      }
;;;187    }
000016  4770              BX       lr
;;;188    
                          ENDP


                          AREA ||i.I2C_DMACmd||, CODE, READONLY, ALIGN=1

                  I2C_DMACmd PROC
;;;1048     */
;;;1049   void I2C_DMACmd(I2C_TypeDef* I2Cx, uint32_t I2C_DMAReq, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;1050   {
;;;1051     /* Check the parameters */
;;;1052     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1053     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1054     assert_param(IS_I2C_DMA_REQ(I2C_DMAReq));
;;;1055   
;;;1056     if (NewState != DISABLE)
000002  d003              BEQ      |L10.12|
;;;1057     {
;;;1058       /* Enable the selected I2C DMA requests */
;;;1059       I2Cx->CR1 |= I2C_DMAReq;
000004  6803              LDR      r3,[r0,#0]
000006  430b              ORRS     r3,r3,r1
000008  6003              STR      r3,[r0,#0]
00000a  e002              B        |L10.18|
                  |L10.12|
;;;1060     }
;;;1061     else
;;;1062     {
;;;1063       /* Disable the selected I2C DMA requests */
;;;1064       I2Cx->CR1 &= (uint32_t)~I2C_DMAReq;
00000c  6803              LDR      r3,[r0,#0]
00000e  438b              BICS     r3,r3,r1
000010  6003              STR      r3,[r0,#0]
                  |L10.18|
;;;1065     }
;;;1066   }
000012  4770              BX       lr
;;;1067   /**
                          ENDP


                          AREA ||i.I2C_DeInit||, CODE, READONLY, ALIGN=2

                  I2C_DeInit PROC
;;;37       */
;;;38     void I2C_DeInit(I2C_TypeDef* I2Cx)
000000  b510              PUSH     {r4,lr}
;;;39     {
000002  4604              MOV      r4,r0
;;;40       /* Check the parameters */
;;;41       assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;42     
;;;43       if (I2Cx == I2C1)
000004  480b              LDR      r0,|L11.52|
000006  4284              CMP      r4,r0
000008  d109              BNE      |L11.30|
;;;44       {
;;;45         /* Enable I2C1 reset state */
;;;46         RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  0548              LSLS     r0,r1,#21
00000e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;47         /* Release I2C1 from reset state */
;;;48         RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);
000012  2100              MOVS     r1,#0
000014  2001              MOVS     r0,#1
000016  0540              LSLS     r0,r0,#21
000018  f7fffffe          BL       RCC_APB1PeriphResetCmd
00001c  e008              B        |L11.48|
                  |L11.30|
;;;49       }
;;;50       else
;;;51       {
;;;52         /* Enable I2C2 reset state */
;;;53         RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
00001e  2101              MOVS     r1,#1
000020  0588              LSLS     r0,r1,#22
000022  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;54         /* Release I2C2 from reset state */
;;;55         RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);
000026  2100              MOVS     r1,#0
000028  2001              MOVS     r0,#1
00002a  0580              LSLS     r0,r0,#22
00002c  f7fffffe          BL       RCC_APB1PeriphResetCmd
                  |L11.48|
;;;56       }
;;;57     }
000030  bd10              POP      {r4,pc}
;;;58     
                          ENDP

000032  0000              DCW      0x0000
                  |L11.52|
                          DCD      0x40005400

                          AREA ||i.I2C_DualAddressCmd||, CODE, READONLY, ALIGN=1

                  I2C_DualAddressCmd PROC
;;;276      */
;;;277    void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;278    {
;;;279      /* Check the parameters */
;;;280      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;281      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;282      
;;;283      if (NewState != DISABLE)
000002  d005              BEQ      |L12.16|
;;;284      {
;;;285        /* Enable own address 2 */
;;;286        I2Cx->OAR2 |= I2C_OAR2_OA2EN;
000004  68c2              LDR      r2,[r0,#0xc]
000006  2301              MOVS     r3,#1
000008  03db              LSLS     r3,r3,#15
00000a  431a              ORRS     r2,r2,r3
00000c  60c2              STR      r2,[r0,#0xc]
00000e  e004              B        |L12.26|
                  |L12.16|
;;;287      }
;;;288      else
;;;289      {
;;;290        /* Disable own address 2 */
;;;291        I2Cx->OAR2 &= (uint32_t)~((uint32_t)I2C_OAR2_OA2EN);
000010  68c2              LDR      r2,[r0,#0xc]
000012  2301              MOVS     r3,#1
000014  03db              LSLS     r3,r3,#15
000016  439a              BICS     r2,r2,r3
000018  60c2              STR      r2,[r0,#0xc]
                  |L12.26|
;;;292      }
;;;293    }    
00001a  4770              BX       lr
;;;294    
                          ENDP


                          AREA ||i.I2C_ExtendedClockTimeoutCmd||, CODE, READONLY, ALIGN=1

                  I2C_ExtendedClockTimeoutCmd PROC
;;;798      */
;;;799    void I2C_ExtendedClockTimeoutCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;800    {
;;;801      /* Check the parameters */
;;;802      assert_param(IS_I2C_1_PERIPH(I2Cx));
;;;803      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;804      
;;;805      if (NewState != DISABLE)
000002  d005              BEQ      |L13.16|
;;;806      {
;;;807        /* Enable Clock Timeout */
;;;808        I2Cx->TIMEOUTR |= I2C_TIMEOUTR_TEXTEN;   
000004  6942              LDR      r2,[r0,#0x14]
000006  2301              MOVS     r3,#1
000008  07db              LSLS     r3,r3,#31
00000a  431a              ORRS     r2,r2,r3
00000c  6142              STR      r2,[r0,#0x14]
00000e  e003              B        |L13.24|
                  |L13.16|
;;;809      }
;;;810      else
;;;811      {
;;;812        /* Disable Clock Timeout */    
;;;813        I2Cx->TIMEOUTR &= (uint32_t)~((uint32_t)I2C_TIMEOUTR_TEXTEN); 
000010  6942              LDR      r2,[r0,#0x14]
000012  0052              LSLS     r2,r2,#1
000014  0852              LSRS     r2,r2,#1
000016  6142              STR      r2,[r0,#0x14]
                  |L13.24|
;;;814      }
;;;815    }
000018  4770              BX       lr
;;;816    
                          ENDP


                          AREA ||i.I2C_GeneralCallCmd||, CODE, READONLY, ALIGN=1

                  I2C_GeneralCallCmd PROC
;;;340      */
;;;341    void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;342    {
;;;343      /* Check the parameters */
;;;344      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;345      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;346      
;;;347      if (NewState != DISABLE)
000002  d005              BEQ      |L14.16|
;;;348      {
;;;349        /* Enable general call mode */
;;;350        I2Cx->CR1 |= I2C_CR1_GCEN;
000004  6802              LDR      r2,[r0,#0]
000006  2301              MOVS     r3,#1
000008  04db              LSLS     r3,r3,#19
00000a  431a              ORRS     r2,r2,r3
00000c  6002              STR      r2,[r0,#0]
00000e  e004              B        |L14.26|
                  |L14.16|
;;;351      }
;;;352      else
;;;353      {
;;;354        /* Disable general call mode */
;;;355        I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_GCEN);
000010  6802              LDR      r2,[r0,#0]
000012  2301              MOVS     r3,#1
000014  04db              LSLS     r3,r3,#19
000016  439a              BICS     r2,r2,r3
000018  6002              STR      r2,[r0,#0]
                  |L14.26|
;;;356      }
;;;357    } 
00001a  4770              BX       lr
;;;358    
                          ENDP


                          AREA ||i.I2C_GenerateSTART||, CODE, READONLY, ALIGN=1

                  I2C_GenerateSTART PROC
;;;555      */
;;;556    void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;557    {
;;;558      /* Check the parameters */
;;;559      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;560      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;561      
;;;562      if (NewState != DISABLE)
000002  d005              BEQ      |L15.16|
;;;563      {
;;;564        /* Generate a START condition */
;;;565        I2Cx->CR2 |= I2C_CR2_START;
000004  6842              LDR      r2,[r0,#4]
000006  2301              MOVS     r3,#1
000008  035b              LSLS     r3,r3,#13
00000a  431a              ORRS     r2,r2,r3
00000c  6042              STR      r2,[r0,#4]
00000e  e004              B        |L15.26|
                  |L15.16|
;;;566      }
;;;567      else
;;;568      {
;;;569        /* Disable the START condition generation */
;;;570        I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_START);
000010  6842              LDR      r2,[r0,#4]
000012  2301              MOVS     r3,#1
000014  035b              LSLS     r3,r3,#13
000016  439a              BICS     r2,r2,r3
000018  6042              STR      r2,[r0,#4]
                  |L15.26|
;;;571      }
;;;572    }  
00001a  4770              BX       lr
;;;573      
                          ENDP


                          AREA ||i.I2C_GenerateSTOP||, CODE, READONLY, ALIGN=1

                  I2C_GenerateSTOP PROC
;;;580      */
;;;581    void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;582    {
;;;583      /* Check the parameters */
;;;584      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;585      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;586      
;;;587      if (NewState != DISABLE)
000002  d005              BEQ      |L16.16|
;;;588      {
;;;589        /* Generate a STOP condition */
;;;590        I2Cx->CR2 |= I2C_CR2_STOP;
000004  6842              LDR      r2,[r0,#4]
000006  2301              MOVS     r3,#1
000008  039b              LSLS     r3,r3,#14
00000a  431a              ORRS     r2,r2,r3
00000c  6042              STR      r2,[r0,#4]
00000e  e004              B        |L16.26|
                  |L16.16|
;;;591      }
;;;592      else
;;;593      {
;;;594        /* Disable the STOP condition generation */
;;;595        I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_STOP);
000010  6842              LDR      r2,[r0,#4]
000012  2301              MOVS     r3,#1
000014  039b              LSLS     r3,r3,#14
000016  439a              BICS     r2,r2,r3
000018  6042              STR      r2,[r0,#4]
                  |L16.26|
;;;596      }
;;;597    }  
00001a  4770              BX       lr
;;;598    
                          ENDP


                          AREA ||i.I2C_GetAddressMatched||, CODE, READONLY, ALIGN=1

                  I2C_GetAddressMatched PROC
;;;655      */
;;;656    uint8_t I2C_GetAddressMatched(I2C_TypeDef* I2Cx)
000000  4601              MOV      r1,r0
;;;657    {
;;;658      /* Check the parameters */
;;;659      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;660      
;;;661      /* Return the slave matched address in the SR1 register */
;;;662      return (uint8_t)(((uint32_t)I2Cx->ISR & I2C_ISR_ADDCODE) >> 16) ;
000002  6988              LDR      r0,[r1,#0x18]
000004  227f              MOVS     r2,#0x7f
000006  0452              LSLS     r2,r2,#17
000008  4010              ANDS     r0,r0,r2
00000a  0c00              LSRS     r0,r0,#16
;;;663    }
00000c  4770              BX       lr
;;;664    
                          ENDP


                          AREA ||i.I2C_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetFlagStatus PROC
;;;1091     */
;;;1092   FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
000000  b510              PUSH     {r4,lr}
;;;1093   {
000002  4602              MOV      r2,r0
;;;1094     uint32_t tmpreg = 0;
000004  2300              MOVS     r3,#0
;;;1095     FlagStatus bitstatus = RESET;
000006  2000              MOVS     r0,#0
;;;1096     
;;;1097     /* Check the parameters */
;;;1098     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1099     assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
;;;1100     
;;;1101     /* Get the ISR register value */
;;;1102     tmpreg = I2Cx->ISR;
000008  6993              LDR      r3,[r2,#0x18]
;;;1103     
;;;1104     /* Get flag status */
;;;1105     tmpreg &= I2C_FLAG;
00000a  461c              MOV      r4,r3
00000c  400c              ANDS     r4,r4,r1
00000e  4623              MOV      r3,r4
;;;1106     
;;;1107     if(tmpreg != 0)
000010  2b00              CMP      r3,#0
000012  d001              BEQ      |L18.24|
;;;1108     {
;;;1109       /* I2C_FLAG is set */
;;;1110       bitstatus = SET;
000014  2001              MOVS     r0,#1
000016  e000              B        |L18.26|
                  |L18.24|
;;;1111     }
;;;1112     else
;;;1113     {
;;;1114       /* I2C_FLAG is reset */
;;;1115       bitstatus = RESET;
000018  2000              MOVS     r0,#0
                  |L18.26|
;;;1116     }
;;;1117     return bitstatus;
;;;1118   } 
00001a  bd10              POP      {r4,pc}
;;;1119   
                          ENDP


                          AREA ||i.I2C_GetITStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetITStatus PROC
;;;1165     */
;;;1166   ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
000000  b570              PUSH     {r4-r6,lr}
;;;1167   {
000002  4602              MOV      r2,r0
;;;1168     uint32_t tmpreg = 0;
000004  2300              MOVS     r3,#0
;;;1169     ITStatus bitstatus = RESET;
000006  2000              MOVS     r0,#0
;;;1170     uint32_t enablestatus = 0;
000008  2400              MOVS     r4,#0
;;;1171   
;;;1172     /* Check the parameters */
;;;1173     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1174     assert_param(IS_I2C_GET_IT(I2C_IT));
;;;1175   
;;;1176     /* Check if the interrupt source is enabled or not */
;;;1177     /* If Error interrupt */
;;;1178     if ((uint32_t)(I2C_IT & ERROR_IT_MASK))
00000a  253f              MOVS     r5,#0x3f
00000c  022d              LSLS     r5,r5,#8
00000e  400d              ANDS     r5,r5,r1
000010  2d00              CMP      r5,#0
000012  d004              BEQ      |L19.30|
;;;1179     {
;;;1180       enablestatus = (uint32_t)((I2C_CR1_ERRIE) & (I2Cx->CR1));
000014  6815              LDR      r5,[r2,#0]
000016  2680              MOVS     r6,#0x80
000018  4035              ANDS     r5,r5,r6
00001a  462c              MOV      r4,r5
00001c  e00b              B        |L19.54|
                  |L19.30|
;;;1181     }
;;;1182     /* If TC interrupt */
;;;1183     else if ((uint32_t)(I2C_IT & TC_IT_MASK))
00001e  25c0              MOVS     r5,#0xc0
000020  400d              ANDS     r5,r5,r1
000022  2d00              CMP      r5,#0
000024  d004              BEQ      |L19.48|
;;;1184     {
;;;1185       enablestatus = (uint32_t)((I2C_CR1_TCIE) & (I2Cx->CR1));
000026  6815              LDR      r5,[r2,#0]
000028  2640              MOVS     r6,#0x40
00002a  4035              ANDS     r5,r5,r6
00002c  462c              MOV      r4,r5
00002e  e002              B        |L19.54|
                  |L19.48|
;;;1186     }
;;;1187     else
;;;1188     {
;;;1189       enablestatus = (uint32_t)((I2C_IT) & (I2Cx->CR1));
000030  6815              LDR      r5,[r2,#0]
000032  400d              ANDS     r5,r5,r1
000034  462c              MOV      r4,r5
                  |L19.54|
;;;1190     }
;;;1191     
;;;1192     /* Get the ISR register value */
;;;1193     tmpreg = I2Cx->ISR;
000036  6993              LDR      r3,[r2,#0x18]
;;;1194   
;;;1195     /* Get flag status */
;;;1196     tmpreg &= I2C_IT;
000038  461d              MOV      r5,r3
00003a  400d              ANDS     r5,r5,r1
00003c  462b              MOV      r3,r5
;;;1197   
;;;1198     /* Check the status of the specified I2C flag */
;;;1199     if((tmpreg != RESET) && enablestatus)
00003e  2b00              CMP      r3,#0
000040  d003              BEQ      |L19.74|
000042  2c00              CMP      r4,#0
000044  d001              BEQ      |L19.74|
;;;1200     {
;;;1201       /* I2C_IT is set */
;;;1202       bitstatus = SET;
000046  2001              MOVS     r0,#1
000048  e000              B        |L19.76|
                  |L19.74|
;;;1203     }
;;;1204     else
;;;1205     {
;;;1206       /* I2C_IT is reset */
;;;1207       bitstatus = RESET;
00004a  2000              MOVS     r0,#0
                  |L19.76|
;;;1208     }
;;;1209   
;;;1210     /* Return the I2C_IT status */
;;;1211     return bitstatus;
;;;1212   }
00004c  bd70              POP      {r4-r6,pc}
;;;1213   
                          ENDP


                          AREA ||i.I2C_GetPEC||, CODE, READONLY, ALIGN=1

                  I2C_GetPEC PROC
;;;952      */
;;;953    uint8_t I2C_GetPEC(I2C_TypeDef* I2Cx)
000000  4601              MOV      r1,r0
;;;954    {
;;;955      /* Check the parameters */
;;;956      assert_param(IS_I2C_1_PERIPH(I2Cx));
;;;957      
;;;958      /* Return the slave matched address in the SR1 register */
;;;959      return (uint8_t)((uint32_t)I2Cx->PECR & I2C_PECR_PEC);
000002  6a08              LDR      r0,[r1,#0x20]
000004  b2c0              UXTB     r0,r0
;;;960    }
000006  4770              BX       lr
;;;961    
                          ENDP


                          AREA ||i.I2C_GetTransferDirection||, CODE, READONLY, ALIGN=1

                  I2C_GetTransferDirection PROC
;;;669      */
;;;670    uint16_t I2C_GetTransferDirection(I2C_TypeDef* I2Cx)
000000  b510              PUSH     {r4,lr}
;;;671    {
000002  4601              MOV      r1,r0
;;;672      uint32_t tmpreg = 0;
000004  2200              MOVS     r2,#0
;;;673      uint16_t direction = 0;
000006  2000              MOVS     r0,#0
;;;674      
;;;675      /* Check the parameters */
;;;676      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;677      
;;;678      /* Return the slave matched address in the SR1 register */
;;;679      tmpreg = (uint32_t)(I2Cx->ISR & I2C_ISR_DIR);
000008  698b              LDR      r3,[r1,#0x18]
00000a  2401              MOVS     r4,#1
00000c  0424              LSLS     r4,r4,#16
00000e  4023              ANDS     r3,r3,r4
000010  461a              MOV      r2,r3
;;;680      
;;;681      /* If write transfer is requested */
;;;682      if (tmpreg == 0)
000012  2a00              CMP      r2,#0
000014  d100              BNE      |L21.24|
;;;683      {
;;;684        /* write transfer is requested */
;;;685        direction = I2C_Direction_Transmitter;
000016  e001              B        |L21.28|
                  |L21.24|
;;;686      }
;;;687      else
;;;688      {
;;;689        /* Read transfer is requested */
;;;690        direction = I2C_Direction_Receiver;
000018  2001              MOVS     r0,#1
00001a  0280              LSLS     r0,r0,#10
                  |L21.28|
;;;691      }  
;;;692      return direction;
;;;693    }
00001c  bd10              POP      {r4,pc}
;;;694    
                          ENDP


                          AREA ||i.I2C_ITConfig||, CODE, READONLY, ALIGN=1

                  I2C_ITConfig PROC
;;;225      */
;;;226    void I2C_ITConfig(I2C_TypeDef* I2Cx, uint32_t I2C_IT, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;227    {
;;;228      /* Check the parameters */
;;;229      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;230      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;231      assert_param(IS_I2C_CONFIG_IT(I2C_IT));
;;;232      
;;;233      if (NewState != DISABLE)
000002  d003              BEQ      |L22.12|
;;;234      {
;;;235        /* Enable the selected I2C interrupts */
;;;236        I2Cx->CR1 |= I2C_IT;
000004  6803              LDR      r3,[r0,#0]
000006  430b              ORRS     r3,r3,r1
000008  6003              STR      r3,[r0,#0]
00000a  e002              B        |L22.18|
                  |L22.12|
;;;237      }
;;;238      else
;;;239      {
;;;240        /* Disable the selected I2C interrupts */
;;;241        I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_IT);
00000c  6803              LDR      r3,[r0,#0]
00000e  438b              BICS     r3,r3,r1
000010  6003              STR      r3,[r0,#0]
                  |L22.18|
;;;242      }
;;;243    }
000012  4770              BX       lr
;;;244    
                          ENDP


                          AREA ||i.I2C_IdleClockTimeoutCmd||, CODE, READONLY, ALIGN=1

                  I2C_IdleClockTimeoutCmd PROC
;;;824      */
;;;825    void I2C_IdleClockTimeoutCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;826    {
;;;827      /* Check the parameters */
;;;828      assert_param(IS_I2C_1_PERIPH(I2Cx));
;;;829      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;830      
;;;831      if (NewState != DISABLE)
000002  d005              BEQ      |L23.16|
;;;832      {
;;;833        /* Enable Clock Timeout */
;;;834        I2Cx->TIMEOUTR |= I2C_TIMEOUTR_TIDLE;   
000004  6942              LDR      r2,[r0,#0x14]
000006  2301              MOVS     r3,#1
000008  031b              LSLS     r3,r3,#12
00000a  431a              ORRS     r2,r2,r3
00000c  6142              STR      r2,[r0,#0x14]
00000e  e004              B        |L23.26|
                  |L23.16|
;;;835      }
;;;836      else
;;;837      {
;;;838        /* Disable Clock Timeout */    
;;;839        I2Cx->TIMEOUTR &= (uint32_t)~((uint32_t)I2C_TIMEOUTR_TIDLE); 
000010  6942              LDR      r2,[r0,#0x14]
000012  2301              MOVS     r3,#1
000014  031b              LSLS     r3,r3,#12
000016  439a              BICS     r2,r2,r3
000018  6142              STR      r2,[r0,#0x14]
                  |L23.26|
;;;840      }
;;;841    }
00001a  4770              BX       lr
;;;842    
                          ENDP


                          AREA ||i.I2C_Init||, CODE, READONLY, ALIGN=2

                  I2C_Init PROC
;;;66       */
;;;67     void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
000000  b510              PUSH     {r4,lr}
;;;68     {
000002  460a              MOV      r2,r1
;;;69       uint32_t tmpreg = 0;
000004  2100              MOVS     r1,#0
;;;70     
;;;71       /* Check the parameters */
;;;72       assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;73       assert_param(IS_I2C_ANALOG_FILTER(I2C_InitStruct->I2C_AnalogFilter));
;;;74       assert_param(IS_I2C_DIGITAL_FILTER(I2C_InitStruct->I2C_DigitalFilter));
;;;75       assert_param(IS_I2C_MODE(I2C_InitStruct->I2C_Mode));
;;;76       assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct->I2C_OwnAddress1));
;;;77       assert_param(IS_I2C_ACK(I2C_InitStruct->I2C_Ack));
;;;78       assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));
;;;79     
;;;80       /* Disable I2Cx Peripheral */
;;;81       I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_PE);
000006  6803              LDR      r3,[r0,#0]
000008  085b              LSRS     r3,r3,#1
00000a  005b              LSLS     r3,r3,#1
00000c  6003              STR      r3,[r0,#0]
;;;82     
;;;83       /*---------------------------- I2Cx FILTERS Configuration ------------------*/
;;;84       /* Get the I2Cx CR1 value */
;;;85       tmpreg = I2Cx->CR1;
00000e  6801              LDR      r1,[r0,#0]
;;;86       /* Clear I2Cx CR1 register */
;;;87       tmpreg &= CR1_CLEAR_MASK;
000010  4b14              LDR      r3,|L24.100|
000012  4019              ANDS     r1,r1,r3
;;;88       /* Configure I2Cx: analog and digital filter */
;;;89       /* Set ANFOFF bit according to I2C_AnalogFilter value */
;;;90       /* Set DFN bits according to I2C_DigitalFilter value */
;;;91       tmpreg |= (uint32_t)I2C_InitStruct->I2C_AnalogFilter |(I2C_InitStruct->I2C_DigitalFilter << 8);
000014  6894              LDR      r4,[r2,#8]
000016  0224              LSLS     r4,r4,#8
000018  6853              LDR      r3,[r2,#4]
00001a  4323              ORRS     r3,r3,r4
00001c  4319              ORRS     r1,r1,r3
;;;92     
;;;93       /* Write to I2Cx CR1 */
;;;94       I2Cx->CR1 = tmpreg;
00001e  6001              STR      r1,[r0,#0]
;;;95     
;;;96       /*---------------------------- I2Cx TIMING Configuration -------------------*/
;;;97       /* Configure I2Cx: Timing */
;;;98       /* Set TIMINGR bits according to I2C_Timing */
;;;99       /* Write to I2Cx TIMING */
;;;100      I2Cx->TIMINGR = I2C_InitStruct->I2C_Timing & TIMING_CLEAR_MASK;
000020  240f              MOVS     r4,#0xf
000022  0624              LSLS     r4,r4,#24
000024  6813              LDR      r3,[r2,#0]
000026  43a3              BICS     r3,r3,r4
000028  6103              STR      r3,[r0,#0x10]
;;;101    
;;;102      /* Enable I2Cx Peripheral */
;;;103      I2Cx->CR1 |= I2C_CR1_PE;
00002a  6803              LDR      r3,[r0,#0]
00002c  2401              MOVS     r4,#1
00002e  4323              ORRS     r3,r3,r4
000030  6003              STR      r3,[r0,#0]
;;;104    
;;;105      /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
;;;106      /* Clear tmpreg local variable */
;;;107      tmpreg = 0;
000032  2100              MOVS     r1,#0
;;;108      /* Clear OAR1 register */
;;;109      I2Cx->OAR1 = (uint32_t)tmpreg;
000034  6081              STR      r1,[r0,#8]
;;;110      /* Clear OAR2 register */
;;;111      I2Cx->OAR2 = (uint32_t)tmpreg;
000036  60c1              STR      r1,[r0,#0xc]
;;;112      /* Configure I2Cx: Own Address1 and acknowledged address */
;;;113      /* Set OA1MODE bit according to I2C_AcknowledgedAddress value */
;;;114      /* Set OA1 bits according to I2C_OwnAddress1 value */
;;;115      tmpreg = (uint32_t)((uint32_t)I2C_InitStruct->I2C_AcknowledgedAddress | \
000038  6914              LDR      r4,[r2,#0x10]
00003a  6993              LDR      r3,[r2,#0x18]
00003c  4323              ORRS     r3,r3,r4
00003e  4619              MOV      r1,r3
;;;116                          (uint32_t)I2C_InitStruct->I2C_OwnAddress1);
;;;117      /* Write to I2Cx OAR1 */
;;;118      I2Cx->OAR1 = tmpreg;
000040  6081              STR      r1,[r0,#8]
;;;119      /* Enable Own Address1 acknowledgement */
;;;120      I2Cx->OAR1 |= I2C_OAR1_OA1EN;
000042  6883              LDR      r3,[r0,#8]
000044  2401              MOVS     r4,#1
000046  03e4              LSLS     r4,r4,#15
000048  4323              ORRS     r3,r3,r4
00004a  6083              STR      r3,[r0,#8]
;;;121    
;;;122      /*---------------------------- I2Cx MODE Configuration ---------------------*/
;;;123      /* Configure I2Cx: mode */
;;;124      /* Set SMBDEN and SMBHEN bits according to I2C_Mode value */
;;;125      tmpreg = I2C_InitStruct->I2C_Mode;
00004c  68d1              LDR      r1,[r2,#0xc]
;;;126      /* Write to I2Cx CR1 */
;;;127      I2Cx->CR1 |= tmpreg;
00004e  6803              LDR      r3,[r0,#0]
000050  430b              ORRS     r3,r3,r1
000052  6003              STR      r3,[r0,#0]
;;;128    
;;;129      /*---------------------------- I2Cx ACK Configuration ----------------------*/
;;;130      /* Get the I2Cx CR2 value */
;;;131      tmpreg = I2Cx->CR2;
000054  6841              LDR      r1,[r0,#4]
;;;132      /* Clear I2Cx CR2 register */
;;;133      tmpreg &= CR2_CLEAR_MASK;
000056  4b04              LDR      r3,|L24.104|
000058  4019              ANDS     r1,r1,r3
;;;134      /* Configure I2Cx: acknowledgement */
;;;135      /* Set NACK bit according to I2C_Ack value */
;;;136      tmpreg |= I2C_InitStruct->I2C_Ack;
00005a  6953              LDR      r3,[r2,#0x14]
00005c  4319              ORRS     r1,r1,r3
;;;137      /* Write to I2Cx CR2 */
;;;138      I2Cx->CR2 = tmpreg;
00005e  6041              STR      r1,[r0,#4]
;;;139    }
000060  bd10              POP      {r4,pc}
;;;140    
                          ENDP

000062  0000              DCW      0x0000
                  |L24.100|
                          DCD      0x00cfe0ff
                  |L24.104|
                          DCD      0x07ff7fff

                          AREA ||i.I2C_MasterRequestConfig||, CODE, READONLY, ALIGN=1

                  I2C_MasterRequestConfig PROC
;;;529      */
;;;530    void I2C_MasterRequestConfig(I2C_TypeDef* I2Cx, uint16_t I2C_Direction)
000000  2900              CMP      r1,#0
;;;531    {
;;;532    /* Check the parameters */
;;;533      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;534      assert_param(IS_I2C_DIRECTION(I2C_Direction));
;;;535      
;;;536      /* Test on the direction to set/reset the read/write bit */
;;;537      if (I2C_Direction == I2C_Direction_Transmitter)
000002  d105              BNE      |L25.16|
;;;538      {
;;;539        /* Request a write Transfer */
;;;540        I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_RD_WRN);
000004  6842              LDR      r2,[r0,#4]
000006  2301              MOVS     r3,#1
000008  029b              LSLS     r3,r3,#10
00000a  439a              BICS     r2,r2,r3
00000c  6042              STR      r2,[r0,#4]
00000e  e004              B        |L25.26|
                  |L25.16|
;;;541      }
;;;542      else
;;;543      {
;;;544        /* Request a read Transfer */
;;;545        I2Cx->CR2 |= I2C_CR2_RD_WRN;
000010  6842              LDR      r2,[r0,#4]
000012  2301              MOVS     r3,#1
000014  029b              LSLS     r3,r3,#10
000016  431a              ORRS     r2,r2,r3
000018  6042              STR      r2,[r0,#4]
                  |L25.26|
;;;546      }
;;;547    }  
00001a  4770              BX       lr
;;;548      
                          ENDP


                          AREA ||i.I2C_NumberOfBytesConfig||, CODE, READONLY, ALIGN=1

                  I2C_NumberOfBytesConfig PROC
;;;500      */
;;;501    void I2C_NumberOfBytesConfig(I2C_TypeDef* I2Cx, uint8_t Number_Bytes)
000000  b510              PUSH     {r4,lr}
;;;502    {
000002  460a              MOV      r2,r1
;;;503      uint32_t tmpreg = 0;
000004  2100              MOVS     r1,#0
;;;504    
;;;505      /* Check the parameters */
;;;506      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;507    
;;;508      /* Get the old register value */
;;;509      tmpreg = I2Cx->CR2;
000006  6841              LDR      r1,[r0,#4]
;;;510    
;;;511      /* Reset I2Cx Nbytes bit [7:0] */
;;;512      tmpreg &= (uint32_t)~((uint32_t)I2C_CR2_NBYTES);
000008  24ff              MOVS     r4,#0xff
00000a  0424              LSLS     r4,r4,#16
00000c  460b              MOV      r3,r1
00000e  43a3              BICS     r3,r3,r4
000010  4619              MOV      r1,r3
;;;513    
;;;514      /* Set I2Cx Nbytes */
;;;515      tmpreg |= (uint32_t)(((uint32_t)Number_Bytes << 16 ) & I2C_CR2_NBYTES);
000012  0413              LSLS     r3,r2,#16
000014  4023              ANDS     r3,r3,r4
000016  4319              ORRS     r1,r1,r3
;;;516    
;;;517      /* Store the new register value */
;;;518      I2Cx->CR2 = tmpreg;
000018  6041              STR      r1,[r0,#4]
;;;519    }  
00001a  bd10              POP      {r4,pc}
;;;520      
                          ENDP


                          AREA ||i.I2C_OwnAddress2Config||, CODE, READONLY, ALIGN=2

                  I2C_OwnAddress2Config PROC
;;;310      */
;;;311    void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, uint16_t Address, uint8_t Mask)
000000  b570              PUSH     {r4-r6,lr}
;;;312    {
000002  460b              MOV      r3,r1
;;;313      uint32_t tmpreg = 0;
000004  2100              MOVS     r1,#0
;;;314    
;;;315      /* Check the parameters */
;;;316      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;317      assert_param(IS_I2C_OWN_ADDRESS2(Address));
;;;318      assert_param(IS_I2C_OWN_ADDRESS2_MASK(Mask));
;;;319      
;;;320      /* Get the old register value */
;;;321      tmpreg = I2Cx->OAR2;
000006  68c1              LDR      r1,[r0,#0xc]
;;;322    
;;;323      /* Reset I2Cx OA2 bit [7:1] and OA2MSK bit [1:0]  */
;;;324      tmpreg &= (uint32_t)~((uint32_t)(I2C_OAR2_OA2 | I2C_OAR2_OA2MSK));
000008  4c05              LDR      r4,|L27.32|
00000a  4021              ANDS     r1,r1,r4
;;;325    
;;;326      /* Set I2Cx SADD */
;;;327      tmpreg |= (uint32_t)(((uint32_t)Address & I2C_OAR2_OA2) | \
00000c  24fe              MOVS     r4,#0xfe
00000e  401c              ANDS     r4,r4,r3
000010  0215              LSLS     r5,r2,#8
000012  2607              MOVS     r6,#7
000014  0236              LSLS     r6,r6,#8
000016  4035              ANDS     r5,r5,r6
000018  432c              ORRS     r4,r4,r5
00001a  4321              ORRS     r1,r1,r4
;;;328                (((uint32_t)Mask << 8) & I2C_OAR2_OA2MSK)) ;
;;;329    
;;;330      /* Store the new register value */
;;;331      I2Cx->OAR2 = tmpreg;
00001c  60c1              STR      r1,[r0,#0xc]
;;;332    }
00001e  bd70              POP      {r4-r6,pc}
;;;333    
                          ENDP

                  |L27.32|
                          DCD      0xfffff801

                          AREA ||i.I2C_PECRequestCmd||, CODE, READONLY, ALIGN=1

                  I2C_PECRequestCmd PROC
;;;929      */
;;;930    void I2C_PECRequestCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;931    {
;;;932      /* Check the parameters */
;;;933      assert_param(IS_I2C_1_PERIPH(I2Cx));
;;;934      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;935      
;;;936      if (NewState != DISABLE)
000002  d005              BEQ      |L28.16|
;;;937      {
;;;938        /* Enable PEC transmission/reception request */
;;;939        I2Cx->CR2 |= I2C_CR2_PECBYTE;   
000004  6842              LDR      r2,[r0,#4]
000006  2301              MOVS     r3,#1
000008  069b              LSLS     r3,r3,#26
00000a  431a              ORRS     r2,r2,r3
00000c  6042              STR      r2,[r0,#4]
00000e  e004              B        |L28.26|
                  |L28.16|
;;;940      }
;;;941      else
;;;942      {
;;;943        /* Disable PEC transmission/reception request */    
;;;944        I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_PECBYTE); 
000010  6842              LDR      r2,[r0,#4]
000012  2301              MOVS     r3,#1
000014  069b              LSLS     r3,r3,#26
000016  439a              BICS     r2,r2,r3
000018  6042              STR      r2,[r0,#4]
                  |L28.26|
;;;945      }
;;;946    }
00001a  4770              BX       lr
;;;947    
                          ENDP


                          AREA ||i.I2C_ReadRegister||, CODE, READONLY, ALIGN=1

                  I2C_ReadRegister PROC
;;;985      */
;;;986    uint32_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register)
000000  b508              PUSH     {r3,lr}
;;;987    {
000002  4602              MOV      r2,r0
;;;988      __IO uint32_t tmp = 0;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;989    
;;;990      /* Check the parameters */
;;;991      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;992      assert_param(IS_I2C_REGISTER(I2C_Register));
;;;993    
;;;994      tmp = (uint32_t)I2Cx;
000008  9200              STR      r2,[sp,#0]
;;;995      tmp += I2C_Register;
00000a  9800              LDR      r0,[sp,#0]
00000c  1840              ADDS     r0,r0,r1
00000e  9000              STR      r0,[sp,#0]
;;;996    
;;;997      /* Return the selected register value */
;;;998      return (*(__IO uint32_t *) tmp);
000010  9800              LDR      r0,[sp,#0]
000012  6800              LDR      r0,[r0,#0]
;;;999    }
000014  bd08              POP      {r3,pc}
;;;1000   
                          ENDP


                          AREA ||i.I2C_ReceiveData||, CODE, READONLY, ALIGN=1

                  I2C_ReceiveData PROC
;;;1024     */
;;;1025   uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
000000  4601              MOV      r1,r0
;;;1026   {
;;;1027     /* Check the parameters */
;;;1028     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1029     
;;;1030     /* Return the data in the DR register */
;;;1031     return (uint8_t)I2Cx->RXDR;
000002  6a48              LDR      r0,[r1,#0x24]
000004  b2c0              UXTB     r0,r0
;;;1032   }  
000006  4770              BX       lr
;;;1033   
                          ENDP


                          AREA ||i.I2C_ReloadCmd||, CODE, READONLY, ALIGN=1

                  I2C_ReloadCmd PROC
;;;476      */
;;;477    void I2C_ReloadCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;478    {
;;;479      /* Check the parameters */
;;;480      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;481      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;482      
;;;483      if (NewState != DISABLE)
000002  d005              BEQ      |L31.16|
;;;484      {
;;;485        /* Enable Auto Reload mode */
;;;486        I2Cx->CR2 |= I2C_CR2_RELOAD;
000004  6842              LDR      r2,[r0,#4]
000006  2301              MOVS     r3,#1
000008  061b              LSLS     r3,r3,#24
00000a  431a              ORRS     r2,r2,r3
00000c  6042              STR      r2,[r0,#4]
00000e  e004              B        |L31.26|
                  |L31.16|
;;;487      }
;;;488      else
;;;489      {
;;;490        /* Disable Auto Reload mode */
;;;491        I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_RELOAD);
000010  6842              LDR      r2,[r0,#4]
000012  2301              MOVS     r3,#1
000014  061b              LSLS     r3,r3,#24
000016  439a              BICS     r2,r2,r3
000018  6042              STR      r2,[r0,#4]
                  |L31.26|
;;;492      }
;;;493    }
00001a  4770              BX       lr
;;;494    
                          ENDP


                          AREA ||i.I2C_SMBusAlertCmd||, CODE, READONLY, ALIGN=1

                  I2C_SMBusAlertCmd PROC
;;;748      */
;;;749    void I2C_SMBusAlertCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;750    {
;;;751      /* Check the parameters */
;;;752      assert_param(IS_I2C_1_PERIPH(I2Cx));
;;;753      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;754      
;;;755      if (NewState != DISABLE)
000002  d005              BEQ      |L32.16|
;;;756      {
;;;757        /* Enable SMBus alert */
;;;758        I2Cx->CR1 |= I2C_CR1_ALERTEN;   
000004  6802              LDR      r2,[r0,#0]
000006  2301              MOVS     r3,#1
000008  059b              LSLS     r3,r3,#22
00000a  431a              ORRS     r2,r2,r3
00000c  6002              STR      r2,[r0,#0]
00000e  e004              B        |L32.26|
                  |L32.16|
;;;759      }
;;;760      else
;;;761      {
;;;762        /* Disable SMBus alert */    
;;;763        I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_ALERTEN); 
000010  6802              LDR      r2,[r0,#0]
000012  2301              MOVS     r3,#1
000014  059b              LSLS     r3,r3,#22
000016  439a              BICS     r2,r2,r3
000018  6002              STR      r2,[r0,#0]
                  |L32.26|
;;;764      }
;;;765    }
00001a  4770              BX       lr
;;;766    
                          ENDP


                          AREA ||i.I2C_SendData||, CODE, READONLY, ALIGN=1

                  I2C_SendData PROC
;;;1010     */
;;;1011   void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
000000  6281              STR      r1,[r0,#0x28]
;;;1012   {
;;;1013     /* Check the parameters */
;;;1014     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1015     
;;;1016     /* Write in the DR register the data to be sent */
;;;1017     I2Cx->TXDR = (uint8_t)Data;
;;;1018   }
000002  4770              BX       lr
;;;1019   
                          ENDP


                          AREA ||i.I2C_SlaveAddressConfig||, CODE, READONLY, ALIGN=1

                  I2C_SlaveAddressConfig PROC
;;;390      */
;;;391    void I2C_SlaveAddressConfig(I2C_TypeDef* I2Cx, uint16_t Address)
000000  460a              MOV      r2,r1
;;;392    {
;;;393      uint32_t tmpreg = 0;
000002  2100              MOVS     r1,#0
;;;394    
;;;395      /* Check the parameters */
;;;396      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;397      assert_param(IS_I2C_SLAVE_ADDRESS(Address));
;;;398                   
;;;399      /* Get the old register value */
;;;400      tmpreg = I2Cx->CR2;
000004  6841              LDR      r1,[r0,#4]
;;;401    
;;;402      /* Reset I2Cx SADD bit [9:0] */
;;;403      tmpreg &= (uint32_t)~((uint32_t)I2C_CR2_SADD);
000006  0a89              LSRS     r1,r1,#10
000008  0289              LSLS     r1,r1,#10
;;;404    
;;;405      /* Set I2Cx SADD */
;;;406      tmpreg |= (uint32_t)((uint32_t)Address & I2C_CR2_SADD);
00000a  0593              LSLS     r3,r2,#22
00000c  0d9b              LSRS     r3,r3,#22
00000e  4319              ORRS     r1,r1,r3
;;;407    
;;;408      /* Store the new register value */
;;;409      I2Cx->CR2 = tmpreg;
000010  6041              STR      r1,[r0,#4]
;;;410    }
000012  4770              BX       lr
;;;411      
                          ENDP


                          AREA ||i.I2C_SlaveByteControlCmd||, CODE, READONLY, ALIGN=1

                  I2C_SlaveByteControlCmd PROC
;;;365      */
;;;366    void I2C_SlaveByteControlCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;367    {
;;;368      /* Check the parameters */
;;;369      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;370      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;371      
;;;372      if (NewState != DISABLE)
000002  d005              BEQ      |L35.16|
;;;373      {
;;;374        /* Enable slave byte control */
;;;375        I2Cx->CR1 |= I2C_CR1_SBC;
000004  6802              LDR      r2,[r0,#0]
000006  2301              MOVS     r3,#1
000008  041b              LSLS     r3,r3,#16
00000a  431a              ORRS     r2,r2,r3
00000c  6002              STR      r2,[r0,#0]
00000e  e004              B        |L35.26|
                  |L35.16|
;;;376      }
;;;377      else
;;;378      {
;;;379        /* Disable slave byte control */
;;;380        I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_SBC);
000010  6802              LDR      r2,[r0,#0]
000012  2301              MOVS     r3,#1
000014  041b              LSLS     r3,r3,#16
000016  439a              BICS     r2,r2,r3
000018  6002              STR      r2,[r0,#0]
                  |L35.26|
;;;381      }
;;;382    }
00001a  4770              BX       lr
;;;383    
                          ENDP


                          AREA ||i.I2C_SoftwareResetCmd||, CODE, READONLY, ALIGN=1

                  I2C_SoftwareResetCmd PROC
;;;193      */
;;;194    void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx)
000000  6801              LDR      r1,[r0,#0]
;;;195    {
;;;196      /* Check the parameters */
;;;197      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;198    
;;;199      /* Disable peripheral */
;;;200      I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_PE);
000002  0849              LSRS     r1,r1,#1
000004  0049              LSLS     r1,r1,#1
000006  6001              STR      r1,[r0,#0]
;;;201    
;;;202      /* Perform a dummy read to delay the disable of peripheral for minimum
;;;203         3 APB clock cycles to perform the software reset functionality */
;;;204      *(__IO uint32_t *)(uint32_t)I2Cx; 
000008  6801              LDR      r1,[r0,#0]
;;;205    
;;;206      /* Enable peripheral */
;;;207      I2Cx->CR1 |= I2C_CR1_PE;
00000a  6801              LDR      r1,[r0,#0]
00000c  2201              MOVS     r2,#1
00000e  4311              ORRS     r1,r1,r2
000010  6001              STR      r1,[r0,#0]
;;;208    }
000012  4770              BX       lr
;;;209    
                          ENDP


                          AREA ||i.I2C_StretchClockCmd||, CODE, READONLY, ALIGN=1

                  I2C_StretchClockCmd PROC
;;;251      */
;;;252    void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;253    {
;;;254      /* Check the parameters */
;;;255      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;256      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;257      
;;;258      if (NewState != DISABLE)
000002  d005              BEQ      |L37.16|
;;;259      {
;;;260        /* Enable clock stretching */
;;;261        I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_NOSTRETCH);    
000004  6802              LDR      r2,[r0,#0]
000006  2301              MOVS     r3,#1
000008  045b              LSLS     r3,r3,#17
00000a  439a              BICS     r2,r2,r3
00000c  6002              STR      r2,[r0,#0]
00000e  e004              B        |L37.26|
                  |L37.16|
;;;262      }
;;;263      else
;;;264      {
;;;265        /* Disable clock stretching  */
;;;266        I2Cx->CR1 |= I2C_CR1_NOSTRETCH;
000010  6802              LDR      r2,[r0,#0]
000012  2301              MOVS     r3,#1
000014  045b              LSLS     r3,r3,#17
000016  431a              ORRS     r2,r2,r3
000018  6002              STR      r2,[r0,#0]
                  |L37.26|
;;;267      }
;;;268    }
00001a  4770              BX       lr
;;;269    
                          ENDP


                          AREA ||i.I2C_StructInit||, CODE, READONLY, ALIGN=1

                  I2C_StructInit PROC
;;;145      */
;;;146    void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
000000  2100              MOVS     r1,#0
;;;147    {
;;;148      /*---------------- Reset I2C init structure parameters values --------------*/
;;;149      /* Initialize the I2C_Timing member */
;;;150      I2C_InitStruct->I2C_Timing = 0;
000002  6001              STR      r1,[r0,#0]
;;;151      /* Initialize the I2C_AnalogFilter member */
;;;152      I2C_InitStruct->I2C_AnalogFilter = I2C_AnalogFilter_Enable;
000004  6041              STR      r1,[r0,#4]
;;;153      /* Initialize the I2C_DigitalFilter member */
;;;154      I2C_InitStruct->I2C_DigitalFilter = 0;
000006  6081              STR      r1,[r0,#8]
;;;155      /* Initialize the I2C_Mode member */
;;;156      I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
000008  60c1              STR      r1,[r0,#0xc]
;;;157      /* Initialize the I2C_OwnAddress1 member */
;;;158      I2C_InitStruct->I2C_OwnAddress1 = 0;
00000a  6101              STR      r1,[r0,#0x10]
;;;159      /* Initialize the I2C_Ack member */
;;;160      I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
00000c  2101              MOVS     r1,#1
00000e  03c9              LSLS     r1,r1,#15
000010  6141              STR      r1,[r0,#0x14]
;;;161      /* Initialize the I2C_AcknowledgedAddress member */
;;;162      I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
000012  2100              MOVS     r1,#0
000014  6181              STR      r1,[r0,#0x18]
;;;163    }
000016  4770              BX       lr
;;;164    
                          ENDP


                          AREA ||i.I2C_TimeoutAConfig||, CODE, READONLY, ALIGN=1

                  I2C_TimeoutAConfig PROC
;;;849      */
;;;850    void I2C_TimeoutAConfig(I2C_TypeDef* I2Cx, uint16_t Timeout)
000000  460a              MOV      r2,r1
;;;851    {
;;;852      uint32_t tmpreg = 0;
000002  2100              MOVS     r1,#0
;;;853    
;;;854      /* Check the parameters */
;;;855      assert_param(IS_I2C_1_PERIPH(I2Cx));
;;;856      assert_param(IS_I2C_TIMEOUT(Timeout));
;;;857        
;;;858      /* Get the old register value */
;;;859      tmpreg = I2Cx->TIMEOUTR;
000004  6941              LDR      r1,[r0,#0x14]
;;;860    
;;;861      /* Reset I2Cx TIMEOUTA bit [11:0] */
;;;862      tmpreg &= (uint32_t)~((uint32_t)I2C_TIMEOUTR_TIMEOUTA);
000006  0b09              LSRS     r1,r1,#12
000008  0309              LSLS     r1,r1,#12
;;;863    
;;;864      /* Set I2Cx TIMEOUTA */
;;;865      tmpreg |= (uint32_t)((uint32_t)Timeout & I2C_TIMEOUTR_TIMEOUTA) ;
00000a  0513              LSLS     r3,r2,#20
00000c  0d1b              LSRS     r3,r3,#20
00000e  4319              ORRS     r1,r1,r3
;;;866    
;;;867      /* Store the new register value */
;;;868      I2Cx->TIMEOUTR = tmpreg;
000010  6141              STR      r1,[r0,#0x14]
;;;869    }
000012  4770              BX       lr
;;;870    
                          ENDP


                          AREA ||i.I2C_TimeoutBConfig||, CODE, READONLY, ALIGN=2

                  I2C_TimeoutBConfig PROC
;;;876      */
;;;877    void I2C_TimeoutBConfig(I2C_TypeDef* I2Cx, uint16_t Timeout)
000000  b510              PUSH     {r4,lr}
;;;878    {
000002  460a              MOV      r2,r1
;;;879      uint32_t tmpreg = 0;
000004  2100              MOVS     r1,#0
;;;880    
;;;881      /* Check the parameters */
;;;882      assert_param(IS_I2C_1_PERIPH(I2Cx));
;;;883      assert_param(IS_I2C_TIMEOUT(Timeout));
;;;884    
;;;885      /* Get the old register value */
;;;886      tmpreg = I2Cx->TIMEOUTR;
000006  6941              LDR      r1,[r0,#0x14]
;;;887    
;;;888      /* Reset I2Cx TIMEOUTB bit [11:0] */
;;;889      tmpreg &= (uint32_t)~((uint32_t)I2C_TIMEOUTR_TIMEOUTB);
000008  4b04              LDR      r3,|L40.28|
00000a  4019              ANDS     r1,r1,r3
;;;890    
;;;891      /* Set I2Cx TIMEOUTB */
;;;892      tmpreg |= (uint32_t)(((uint32_t)Timeout << 16) & I2C_TIMEOUTR_TIMEOUTB) ;
00000c  0413              LSLS     r3,r2,#16
00000e  4c03              LDR      r4,|L40.28|
000010  43e4              MVNS     r4,r4
000012  4023              ANDS     r3,r3,r4
000014  4319              ORRS     r1,r1,r3
;;;893    
;;;894      /* Store the new register value */
;;;895      I2Cx->TIMEOUTR = tmpreg;
000016  6141              STR      r1,[r0,#0x14]
;;;896    }
000018  bd10              POP      {r4,pc}
;;;897    
                          ENDP

00001a  0000              DCW      0x0000
                  |L40.28|
                          DCD      0xf000ffff

                          AREA ||i.I2C_TransferHandling||, CODE, READONLY, ALIGN=2

                  I2C_TransferHandling PROC
;;;713      */
;;;714    void I2C_TransferHandling(I2C_TypeDef* I2Cx, uint16_t Address, uint8_t Number_Bytes, uint32_t ReloadEndMode, uint32_t StartStopMode)
000000  b5f0              PUSH     {r4-r7,lr}
;;;715    {
000002  460c              MOV      r4,r1
;;;716      uint32_t tmpreg = 0;
000004  2100              MOVS     r1,#0
;;;717      
;;;718      /* Check the parameters */
;;;719      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;720      assert_param(IS_I2C_SLAVE_ADDRESS(Address));  
;;;721      assert_param(IS_RELOAD_END_MODE(ReloadEndMode));
;;;722      assert_param(IS_START_STOP_MODE(StartStopMode));
;;;723        
;;;724      /* Get the CR2 register value */
;;;725      tmpreg = I2Cx->CR2;
000006  6841              LDR      r1,[r0,#4]
;;;726      
;;;727      /* clear tmpreg specific bits */
;;;728      tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
000008  4d07              LDR      r5,|L41.40|
00000a  4029              ANDS     r1,r1,r5
;;;729      
;;;730      /* update tmpreg */
;;;731      tmpreg |= (uint32_t)(((uint32_t)Address & I2C_CR2_SADD) | (((uint32_t)Number_Bytes << 16 ) & I2C_CR2_NBYTES) | \
00000c  05a5              LSLS     r5,r4,#22
00000e  0dad              LSRS     r5,r5,#22
000010  0416              LSLS     r6,r2,#16
000012  27ff              MOVS     r7,#0xff
000014  043f              LSLS     r7,r7,#16
000016  403e              ANDS     r6,r6,r7
000018  4335              ORRS     r5,r5,r6
00001a  431d              ORRS     r5,r5,r3
00001c  9e05              LDR      r6,[sp,#0x14]
00001e  4335              ORRS     r5,r5,r6
000020  4329              ORRS     r1,r1,r5
;;;732                (uint32_t)ReloadEndMode | (uint32_t)StartStopMode);
;;;733      
;;;734      /* update CR2 register */
;;;735      I2Cx->CR2 = tmpreg;  
000022  6041              STR      r1,[r0,#4]
;;;736    }
000024  bdf0              POP      {r4-r7,pc}
;;;737    
                          ENDP

000026  0000              DCW      0x0000
                  |L41.40|
                          DCD      0xfc009800

                          AREA ||i.i2c_readdata||, CODE, READONLY, ALIGN=2

                  i2c_readdata PROC
;;;1240   
;;;1241   int i2c_readdata(I2C_TypeDef * i2c,uint8_t slave_addr,uint8_t addr, uint8_t *pBuffer, uint32_t bufferSize)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1242   {
000002  460f              MOV      r7,r1
000004  4616              MOV      r6,r2
000006  461c              MOV      r4,r3
000008  9d05              LDR      r5,[sp,#0x14]
;;;1243   	  I2C_GenerateSTART(I2C1,ENABLE);
00000a  2101              MOVS     r1,#1
00000c  481a              LDR      r0,|L42.120|
00000e  f7fffffe          BL       I2C_GenerateSTART
;;;1244     //  while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT));
;;;1245       //??????-?
;;;1246   	I2C_MasterRequestConfig(I2C1,I2C_Direction_Transmitter);
000012  2100              MOVS     r1,#0
000014  4818              LDR      r0,|L42.120|
000016  f7fffffe          BL       I2C_MasterRequestConfig
;;;1247   	I2C_SlaveAddressConfig(I2C1,slave_addr); 
00001a  4639              MOV      r1,r7
00001c  4816              LDR      r0,|L42.120|
00001e  f7fffffe          BL       I2C_SlaveAddressConfig
;;;1248    
;;;1249       //????????
;;;1250       I2C_SendData(I2C1,addr);
000022  4631              MOV      r1,r6
000024  4814              LDR      r0,|L42.120|
000026  f7fffffe          BL       I2C_SendData
;;;1251   
;;;1252       //????????
;;;1253       I2C_GenerateSTART(I2C1,ENABLE);
00002a  2101              MOVS     r1,#1
00002c  4812              LDR      r0,|L42.120|
00002e  f7fffffe          BL       I2C_GenerateSTART
;;;1254   	    //??????-?
;;;1255   	I2C_MasterRequestConfig(I2C1,I2C_Direction_Receiver);
000032  2101              MOVS     r1,#1
000034  0289              LSLS     r1,r1,#10
000036  4810              LDR      r0,|L42.120|
000038  f7fffffe          BL       I2C_MasterRequestConfig
;;;1256   	I2C_SlaveAddressConfig(I2C1,slave_addr); 
00003c  4639              MOV      r1,r7
00003e  480e              LDR      r0,|L42.120|
000040  f7fffffe          BL       I2C_SlaveAddressConfig
;;;1257   	
;;;1258       while(bufferSize)
000044  e00b              B        |L42.94|
                  |L42.70|
;;;1259       {
;;;1260           bufferSize--;
000046  1e6d              SUBS     r5,r5,#1
;;;1261           if(bufferSize == 0)
000048  2d00              CMP      r5,#0
00004a  d103              BNE      |L42.84|
;;;1262           {
;;;1263           	//??????
;;;1264               I2C_AcknowledgeConfig(I2C1, DISABLE);
00004c  2100              MOVS     r1,#0
00004e  480a              LDR      r0,|L42.120|
000050  f7fffffe          BL       I2C_AcknowledgeConfig
                  |L42.84|
;;;1265           }
;;;1266           
;;;1267          
;;;1268           *pBuffer = I2C_ReceiveData(I2C1);
000054  4808              LDR      r0,|L42.120|
000056  f7fffffe          BL       I2C_ReceiveData
00005a  7020              STRB     r0,[r4,#0]
;;;1269           pBuffer++;
00005c  1c64              ADDS     r4,r4,#1
                  |L42.94|
00005e  2d00              CMP      r5,#0                 ;1258
000060  d1f1              BNE      |L42.70|
;;;1270       }
;;;1271   	//??????
;;;1272       I2C_GenerateSTOP(I2C1,ENABLE);
000062  2101              MOVS     r1,#1
000064  4804              LDR      r0,|L42.120|
000066  f7fffffe          BL       I2C_GenerateSTOP
;;;1273       //????????
;;;1274       I2C_AcknowledgeConfig(I2C1, ENABLE);
00006a  2101              MOVS     r1,#1
00006c  4802              LDR      r0,|L42.120|
00006e  f7fffffe          BL       I2C_AcknowledgeConfig
;;;1275   		
;;;1276   	  return 0;
000072  2000              MOVS     r0,#0
;;;1277   }
000074  bdf0              POP      {r4-r7,pc}
;;;1278   int i2c_senddata(I2C_TypeDef * i2c,uint8_t slave_addr,uint8_t addr, uint8_t *pBuffer, uint32_t bufferSize)
                          ENDP

000076  0000              DCW      0x0000
                  |L42.120|
                          DCD      0x40005400

                          AREA ||i.i2c_senddata||, CODE, READONLY, ALIGN=2

                  i2c_senddata PROC
;;;1277   }
;;;1278   int i2c_senddata(I2C_TypeDef * i2c,uint8_t slave_addr,uint8_t addr, uint8_t *pBuffer, uint32_t bufferSize)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1279   {
000002  460e              MOV      r6,r1
000004  4615              MOV      r5,r2
000006  461c              MOV      r4,r3
000008  9f05              LDR      r7,[sp,#0x14]
;;;1280   	I2C_GenerateSTART(I2C1,ENABLE);
00000a  2101              MOVS     r1,#1
00000c  480f              LDR      r0,|L43.76|
00000e  f7fffffe          BL       I2C_GenerateSTART
;;;1281     //  while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT));
;;;1282       //??????-?
;;;1283   	I2C_MasterRequestConfig(I2C1,I2C_Direction_Transmitter);
000012  2100              MOVS     r1,#0
000014  480d              LDR      r0,|L43.76|
000016  f7fffffe          BL       I2C_MasterRequestConfig
;;;1284   	I2C_SlaveAddressConfig(I2C1,slave_addr); 
00001a  4631              MOV      r1,r6
00001c  480b              LDR      r0,|L43.76|
00001e  f7fffffe          BL       I2C_SlaveAddressConfig
;;;1285    
;;;1286       //????????
;;;1287       I2C_SendData(I2C1,addr);
000022  4629              MOV      r1,r5
000024  4809              LDR      r0,|L43.76|
000026  f7fffffe          BL       I2C_SendData
;;;1288   
;;;1289       //??????
;;;1290       while(bufferSize--)
00002a  e004              B        |L43.54|
                  |L43.44|
;;;1291       {
;;;1292           I2C_SendData(I2C1,*pBuffer);
00002c  7821              LDRB     r1,[r4,#0]
00002e  4807              LDR      r0,|L43.76|
000030  f7fffffe          BL       I2C_SendData
;;;1293           pBuffer++;
000034  1c64              ADDS     r4,r4,#1
                  |L43.54|
000036  4638              MOV      r0,r7                 ;1290
000038  1e7f              SUBS     r7,r7,#1              ;1290
00003a  2800              CMP      r0,#0                 ;1290
00003c  d1f6              BNE      |L43.44|
;;;1294          // while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTING);
;;;1295       }
;;;1296       //??????
;;;1297       I2C_GenerateSTOP(I2C1,ENABLE);
00003e  2101              MOVS     r1,#1
000040  4802              LDR      r0,|L43.76|
000042  f7fffffe          BL       I2C_GenerateSTOP
;;;1298   		return 0;
000046  2000              MOVS     r0,#0
;;;1299   }
000048  bdf0              POP      {r4-r7,pc}
;;;1300   
                          ENDP

00004a  0000              DCW      0x0000
                  |L43.76|
                          DCD      0x40005400

;*** Start embedded assembler ***

#line 1 "..\\FTLib\\Src\\ft32f0xx_i2c.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_ft32f0xx_i2c_c_7174d409____REV16|
#line 129 "..\\FTLib\\CMSIS\\inc\\core_cmInstr.h"
|__asm___14_ft32f0xx_i2c_c_7174d409____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_ft32f0xx_i2c_c_7174d409____REVSH|
#line 144
|__asm___14_ft32f0xx_i2c_c_7174d409____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
