; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\virtual_eeprom.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\virtual_eeprom.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\FTLib\CMSIS\inc -I..\FTLib\Inc -I..\FTLib\Lib -I..\usb\inc -I..\user -I..\RTT -IC:\Users\Tom\AppData\Local\Arm\Packs\FMD\FT32F0xx_DFP\1.0.2\Drivers\CMSIS\FT32F0xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=533 -DFT32F072x8 -DFT32F072x8 --omf_browse=.\objects\virtual_eeprom.crf ..\user\virtual_eeprom.c]
                          THUMB

                          AREA ||i.eeprom_config||, CODE, READONLY, ALIGN=1

                  eeprom_config PROC
;;;221    
;;;222    void eeprom_config(eeprom_t* eeprom, size_t start, size_t size, size_t flash_start)
000000  b5f8              PUSH     {r3-r7,lr}
;;;223    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
;;;224    	if(eeprom != NULL && eeprom->init == 0xAA)
00000a  2c00              CMP      r4,#0
00000c  d012              BEQ      |L1.52|
00000e  7d20              LDRB     r0,[r4,#0x14]
000010  28aa              CMP      r0,#0xaa
000012  d10f              BNE      |L1.52|
;;;225    	{
;;;226    		eeprom->size = size;
000014  4621              MOV      r1,r4
000016  3108              ADDS     r1,r1,#8
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       __aeabi_uwrite4
;;;227    		eeprom->start = start;
00001e  1d21              ADDS     r1,r4,#4
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       __aeabi_uwrite4
;;;228    		eeprom->flash_start = flash_start;
000026  4621              MOV      r1,r4
000028  310c              ADDS     r1,r1,#0xc
00002a  4638              MOV      r0,r7
00002c  f7fffffe          BL       __aeabi_uwrite4
;;;229    		eeprom->init = 0xBB;
000030  20bb              MOVS     r0,#0xbb
000032  7520              STRB     r0,[r4,#0x14]
                  |L1.52|
;;;230    	}
;;;231    }
000034  bdf8              POP      {r3-r7,pc}
;;;232    
                          ENDP


                          AREA ||i.eeprom_free||, CODE, READONLY, ALIGN=1

                  eeprom_free PROC
;;;304    
;;;305    void eeprom_free(eeprom_t* eeprom)
000000  4770              BX       lr
;;;306    {
;;;307    	
;;;308    }
;;;309    
                          ENDP


                          AREA ||i.eeprom_init||, CODE, READONLY, ALIGN=1

                  eeprom_init PROC
;;;205    
;;;206    void eeprom_init(eeprom_t* eeprom, uint8_t* buffer, size_t len)
000000  b570              PUSH     {r4-r6,lr}
;;;207    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;208    	if(eeprom != NULL)
000008  2c00              CMP      r4,#0
00000a  d00c              BEQ      |L3.38|
;;;209    	{
;;;210    		if(buffer != NULL)
00000c  2d00              CMP      r5,#0
00000e  d00a              BEQ      |L3.38|
;;;211    		{
;;;212    			eeprom->buffer = buffer;
000010  4621              MOV      r1,r4
000012  3110              ADDS     r1,r1,#0x10
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       __aeabi_uwrite4
;;;213    			eeprom->page_size = len;
00001a  4621              MOV      r1,r4
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       __aeabi_uwrite4
;;;214    			eeprom->init = 0xAA;
000022  20aa              MOVS     r0,#0xaa
000024  7520              STRB     r0,[r4,#0x14]
                  |L3.38|
;;;215    		}
;;;216    	}
;;;217    }
000026  bd70              POP      {r4-r6,pc}
;;;218    
                          ENDP


                          AREA ||i.eeprom_read||, CODE, READONLY, ALIGN=1

                  eeprom_read PROC
;;;259    
;;;260    void eeprom_read(eeprom_t* eeprom, size_t addr, uint8_t* data, size_t len)
000000  4770              BX       lr
;;;261    {
;;;262    	
;;;263    	//计算出开始地址
;;;264    	//计算出4字节数量
;;;265    	//
;;;266    	
;;;267    	
;;;268    	
;;;269    	
;;;270    	
;;;271    	return *(uint32_t*)(EEPROM_START_ADDR + (addr * 4));
;;;272    }
;;;273    
                          ENDP


                          AREA ||i.eeprom_read_byte||, CODE, READONLY, ALIGN=1

                  eeprom_read_byte PROC
;;;238    
;;;239    uint8_t eeprom_read_byte(eeprom_t* eeprom, size_t addr)
000000  b5f8              PUSH     {r3-r7,lr}
;;;240    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;241    	uint8_t byte;
;;;242    	uint32_t byte4;
;;;243    	
;;;244    	if(eeprom == NULL || eeprom->init != 0xBB)
000006  2c00              CMP      r4,#0
000008  d002              BEQ      |L5.16|
00000a  7d20              LDRB     r0,[r4,#0x14]
00000c  28bb              CMP      r0,#0xbb
00000e  d001              BEQ      |L5.20|
                  |L5.16|
;;;245    	{
;;;246    		return 0xFF;
000010  20ff              MOVS     r0,#0xff
                  |L5.18|
;;;247    	}
;;;248    	
;;;249    	byte = addr % 4;
;;;250    	byte4 = addr / 4;
;;;251    	
;;;252    	return ( *(uint32_t*)(eeprom->start + (byte4 * 4 * 4)) & ( 0xFF << (byte * 8) ) ) >> ( byte * 8 );
;;;253    }
000012  bdf8              POP      {r3-r7,pc}
                  |L5.20|
000014  07ae              LSLS     r6,r5,#30             ;249
000016  0fb6              LSRS     r6,r6,#30             ;249
000018  08af              LSRS     r7,r5,#2              ;250
00001a  1d20              ADDS     r0,r4,#4              ;252
00001c  f7fffffe          BL       __aeabi_uread4
000020  0139              LSLS     r1,r7,#4              ;252
000022  5840              LDR      r0,[r0,r1]            ;252
000024  00f2              LSLS     r2,r6,#3              ;252
000026  21ff              MOVS     r1,#0xff              ;252
000028  4091              LSLS     r1,r1,r2              ;252
00002a  4008              ANDS     r0,r0,r1              ;252
00002c  00f1              LSLS     r1,r6,#3              ;252
00002e  40c8              LSRS     r0,r0,r1              ;252
000030  b2c0              UXTB     r0,r0                 ;252
000032  e7ee              B        |L5.18|
;;;254    
                          ENDP


                          AREA ||i.eeprom_write||, CODE, READONLY, ALIGN=1

                  eeprom_write PROC
;;;278    
;;;279    void eeprom_write(eeprom_t* eeprom, size_t addr, const uint8_t* data, size_t len)
000000  b5ff              PUSH     {r0-r7,lr}
;;;280    {
000002  b0e1              SUB      sp,sp,#0x184
000004  4606              MOV      r6,r0
;;;281    	int i, page_num = 0;
000006  2500              MOVS     r5,#0
;;;282    	page_data_t pdata[32];
;;;283    	
;;;284    	page_num = verify_data(eeprom, addr, data, len, pdata);
000008  a801              ADD      r0,sp,#4
00000a  9000              STR      r0,[sp,#0]
00000c  4630              MOV      r0,r6
00000e  a962              ADD      r1,sp,#0x188
000010  c90e              LDM      r1,{r1-r3}
000012  f7fffffe          BL       verify_data
000016  4605              MOV      r5,r0
;;;285    	if(page_num > 1)
000018  2d01              CMP      r5,#1
00001a  dd14              BLE      |L6.70|
;;;286    	{
;;;287    		/*需要跨页*/
;;;288    		for(i = 0; i < page_num; ++i)
00001c  2400              MOVS     r4,#0
00001e  e00f              B        |L6.64|
                  |L6.32|
;;;289    		{
;;;290    			eeprom_write_nverify(eeprom, pdata[i].addr, pdata[i].data, pdata[i].len);
000020  200c              MOVS     r0,#0xc
000022  4360              MULS     r0,r4,r0
000024  af01              ADD      r7,sp,#4
000026  19c0              ADDS     r0,r0,r7
000028  6843              LDR      r3,[r0,#4]
00002a  200c              MOVS     r0,#0xc
00002c  4360              MULS     r0,r4,r0
00002e  19c0              ADDS     r0,r0,r7
000030  6882              LDR      r2,[r0,#8]
000032  200c              MOVS     r0,#0xc
000034  4360              MULS     r0,r4,r0
000036  5839              LDR      r1,[r7,r0]
000038  4630              MOV      r0,r6
00003a  f7fffffe          BL       eeprom_write_nverify
00003e  1c64              ADDS     r4,r4,#1              ;288
                  |L6.64|
000040  42ac              CMP      r4,r5                 ;288
000042  dbed              BLT      |L6.32|
000044  e004              B        |L6.80|
                  |L6.70|
;;;291    		}
;;;292    	}
;;;293    	else
;;;294    	{
;;;295    		/*不需要跨页*/
;;;296    		eeprom_write_nverify(eeprom, addr, data, len);
000046  4630              MOV      r0,r6
000048  a962              ADD      r1,sp,#0x188
00004a  c90e              LDM      r1,{r1-r3}
00004c  f7fffffe          BL       eeprom_write_nverify
                  |L6.80|
;;;297    	}
;;;298    }
000050  b065              ADD      sp,sp,#0x194
000052  bdf0              POP      {r4-r7,pc}
;;;299    
                          ENDP


                          AREA ||i.eeprom_write_nverify||, CODE, READONLY, ALIGN=1

                  eeprom_write_nverify PROC
;;;109    
;;;110    static void eeprom_write_nverify(eeprom_t* eeprom, uint32_t addr, const uint8_t* data, size_t len)
000000  b5ff              PUSH     {r0-r7,lr}
;;;111    {
000002  b087              SUB      sp,sp,#0x1c
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;112    	int i;
;;;113    	uint32_t tdata;
;;;114    	size_t start_page;
;;;115    	size_t offset;
;;;116    	size_t page;
;;;117    	size_t page_addr;
;;;118    	
;;;119    	/*计算出EEPROM从第多少页开始*/
;;;120    	start_page = (eeprom->start - eeprom->flash_start) / eeprom->page_size;
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       __aeabi_uread4
00000e  9001              STR      r0,[sp,#4]
000010  1d20              ADDS     r0,r4,#4
000012  f7fffffe          BL       __aeabi_uread4
000016  4607              MOV      r7,r0
000018  4620              MOV      r0,r4
00001a  300c              ADDS     r0,r0,#0xc
00001c  f7fffffe          BL       __aeabi_uread4
000020  1a38              SUBS     r0,r7,r0
000022  9000              STR      r0,[sp,#0]
000024  9901              LDR      r1,[sp,#4]
000026  f7fffffe          BL       __aeabi_uidivmod
00002a  9005              STR      r0,[sp,#0x14]
;;;121    	
;;;122    	/*计算当前地址所处页*/
;;;123    	page = start_page + addr / eeprom->page_size;
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       __aeabi_uread4
000032  4607              MOV      r7,r0
000034  4639              MOV      r1,r7
000036  4630              MOV      r0,r6
000038  f7fffffe          BL       __aeabi_uidivmod
00003c  9905              LDR      r1,[sp,#0x14]
00003e  1840              ADDS     r0,r0,r1
000040  9003              STR      r0,[sp,#0xc]
;;;124    	
;;;125    	/*计算出addr,在所属页中的偏移地址*/
;;;126    	offset = addr % eeprom->page_size;
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       __aeabi_uread4
000048  4607              MOV      r7,r0
00004a  4639              MOV      r1,r7
00004c  4630              MOV      r0,r6
00004e  f7fffffe          BL       __aeabi_uidivmod
000052  9104              STR      r1,[sp,#0x10]
;;;127    	
;;;128    	/*计算出所在页位于Flash的开始地址*/
;;;129    	page_addr = eeprom->flash_start + (page * eeprom->page_size);
000054  4620              MOV      r0,r4
000056  300c              ADDS     r0,r0,#0xc
000058  f7fffffe          BL       __aeabi_uread4
00005c  4607              MOV      r7,r0
00005e  4620              MOV      r0,r4
000060  f7fffffe          BL       __aeabi_uread4
000064  9903              LDR      r1,[sp,#0xc]
000066  4348              MULS     r0,r1,r0
000068  1838              ADDS     r0,r7,r0
00006a  9002              STR      r0,[sp,#8]
;;;130    	
;;;131    	/*将整页数据从Flash中读到操作页缓存中*/
;;;132    	read_bytes(page_addr, eeprom->buffer, eeprom->page_size);
00006c  4620              MOV      r0,r4
00006e  f7fffffe          BL       __aeabi_uread4
000072  b2c7              UXTB     r7,r0
000074  4620              MOV      r0,r4
000076  3010              ADDS     r0,r0,#0x10
000078  f7fffffe          BL       __aeabi_uread4
00007c  463a              MOV      r2,r7
00007e  4601              MOV      r1,r0
000080  9001              STR      r0,[sp,#4]
000082  9802              LDR      r0,[sp,#8]
000084  f7fffffe          BL       read_bytes
;;;133    	
;;;134    	/*将数据写入算好的操作页缓冲区偏移地址中*/
;;;135    	memcpy(eeprom->buffer + offset, data, len);
000088  4620              MOV      r0,r4
00008a  3010              ADDS     r0,r0,#0x10
00008c  f7fffffe          BL       __aeabi_uread4
000090  9904              LDR      r1,[sp,#0x10]
000092  1847              ADDS     r7,r0,r1
000094  4638              MOV      r0,r7
000096  9a0a              LDR      r2,[sp,#0x28]
000098  9909              LDR      r1,[sp,#0x24]
00009a  f7fffffe          BL       __aeabi_memcpy
;;;136    	
;;;137    	/*擦除整个页*/
;;;138    	erase_page(page_addr);
00009e  9802              LDR      r0,[sp,#8]
0000a0  f7fffffe          BL       erase_page
;;;139    	
;;;140    	/*将缓冲区写回Flash*/
;;;141    	for(i = 0; i < eeprom->page_size / 4; i += 4)
0000a4  2500              MOVS     r5,#0
0000a6  e00d              B        |L7.196|
                  |L7.168|
;;;142    	{
;;;143    		tdata = *(uint32_t*)(eeprom->buffer + (i * 4));
0000a8  4620              MOV      r0,r4
0000aa  3010              ADDS     r0,r0,#0x10
0000ac  f7fffffe          BL       __aeabi_uread4
0000b0  00a9              LSLS     r1,r5,#2
0000b2  5840              LDR      r0,[r0,r1]
0000b4  9006              STR      r0,[sp,#0x18]
;;;144    		write_word(page_addr + (i * 4), tdata);
0000b6  00aa              LSLS     r2,r5,#2
0000b8  9902              LDR      r1,[sp,#8]
0000ba  1850              ADDS     r0,r2,r1
0000bc  9906              LDR      r1,[sp,#0x18]
0000be  f7fffffe          BL       write_word
0000c2  1d2d              ADDS     r5,r5,#4              ;141
                  |L7.196|
0000c4  4620              MOV      r0,r4                 ;141
0000c6  f7fffffe          BL       __aeabi_uread4
0000ca  0880              LSRS     r0,r0,#2              ;141
0000cc  42a8              CMP      r0,r5                 ;141
0000ce  d8eb              BHI      |L7.168|
;;;145    	}
;;;146    }
0000d0  b00b              ADD      sp,sp,#0x2c
0000d2  bdf0              POP      {r4-r7,pc}
;;;147    
                          ENDP


                          AREA ||i.erase_page||, CODE, READONLY, ALIGN=1

                  erase_page PROC
;;;82     
;;;83     static void erase_page(uint32_t addr)
000000  b510              PUSH     {r4,lr}
;;;84     {
000002  4604              MOV      r4,r0
;;;85     	FLASH_Unlock();
000004  f7fffffe          BL       FLASH_Unlock
;;;86     	FLASH_ClearFlag(FLASH_FLAG_EOP | FLASH_FLAG_PGERR | FLASH_FLAG_WRPERR);
000008  2034              MOVS     r0,#0x34
00000a  f7fffffe          BL       FLASH_ClearFlag
;;;87     	while(FLASH_ErasePage(addr) != FLASH_COMPLETE);
00000e  bf00              NOP      
                  |L8.16|
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       FLASH_ErasePage
000016  2804              CMP      r0,#4
000018  d1fa              BNE      |L8.16|
;;;88     	FLASH_Lock();
00001a  f7fffffe          BL       FLASH_Lock
;;;89     }
00001e  bd10              POP      {r4,pc}
;;;90     
                          ENDP


                          AREA ||i.read_byte||, CODE, READONLY, ALIGN=2

                  read_byte PROC
;;;49     
;;;50     static uint8_t read_byte(uint32_t addr)
000000  b530              PUSH     {r4,r5,lr}
;;;51     {
000002  4601              MOV      r1,r0
;;;52     
;;;53     	uint8_t byte = addr % 4;
000004  078a              LSLS     r2,r1,#30
000006  0f92              LSRS     r2,r2,#30
;;;54     	uint32_t byte4 = addr / 4;
000008  088b              LSRS     r3,r1,#2
;;;55     	
;;;56     	return ( *(uint32_t*)(EEPROM_START_ADDR + (byte4 * 4 * 4)) & ( 0xFF << (byte * 8) ) ) >> ( byte * 8 );
00000a  0118              LSLS     r0,r3,#4
00000c  4c05              LDR      r4,|L9.36|
00000e  1900              ADDS     r0,r0,r4
000010  6800              LDR      r0,[r0,#0]
000012  00d5              LSLS     r5,r2,#3
000014  24ff              MOVS     r4,#0xff
000016  40ac              LSLS     r4,r4,r5
000018  4020              ANDS     r0,r0,r4
00001a  00d4              LSLS     r4,r2,#3
00001c  40e0              LSRS     r0,r0,r4
00001e  b2c0              UXTB     r0,r0
;;;57     }
000020  bd30              POP      {r4,r5,pc}
;;;58     
                          ENDP

000022  0000              DCW      0x0000
                  |L9.36|
                          DCD      0x0800b000

                          AREA ||i.read_bytes||, CODE, READONLY, ALIGN=1

                  read_bytes PROC
;;;61     
;;;62     static uint8_t read_bytes(uint32_t addr, uint8_t* recv, uint8_t num)
000000  b5f8              PUSH     {r3-r7,lr}
;;;63     {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
;;;64     	uint8_t i;
;;;65     	uint8_t conut = 0;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;66     	
;;;67     	if(recv == NULL || addr + num > EEPROM_MAX_LEN)
00000c  2e00              CMP      r6,#0
00000e  d004              BEQ      |L10.26|
000010  19e0              ADDS     r0,r4,r7
000012  2105              MOVS     r1,#5
000014  0309              LSLS     r1,r1,#12
000016  4288              CMP      r0,r1
000018  d901              BLS      |L10.30|
                  |L10.26|
;;;68     	{
;;;69     		return 0;
00001a  2000              MOVS     r0,#0
                  |L10.28|
;;;70     	}
;;;71     	
;;;72     	for(i = addr; i < addr + num; ++i)
;;;73     	{
;;;74     		recv[conut++] = read_byte(i);
;;;75     	}
;;;76     	return conut;
;;;77     }
00001c  bdf8              POP      {r3-r7,pc}
                  |L10.30|
00001e  b2e5              UXTB     r5,r4                 ;72
000020  e00a              B        |L10.56|
                  |L10.34|
000022  4628              MOV      r0,r5                 ;74
000024  f7fffffe          BL       read_byte
000028  4601              MOV      r1,r0                 ;74
00002a  9800              LDR      r0,[sp,#0]            ;74
00002c  1c42              ADDS     r2,r0,#1              ;74
00002e  b2d2              UXTB     r2,r2                 ;74
000030  9200              STR      r2,[sp,#0]            ;74
000032  5431              STRB     r1,[r6,r0]            ;74
000034  1c68              ADDS     r0,r5,#1              ;72
000036  b2c5              UXTB     r5,r0                 ;72
                  |L10.56|
000038  19e0              ADDS     r0,r4,r7              ;72
00003a  42a8              CMP      r0,r5                 ;72
00003c  d8f1              BHI      |L10.34|
00003e  9800              LDR      r0,[sp,#0]            ;76
000040  e7ec              B        |L10.28|
;;;78     
                          ENDP


                          AREA ||i.read_word||, CODE, READONLY, ALIGN=2

                  read_word PROC
;;;37     
;;;38     uint32_t read_word(uint32_t addr)
000000  4601              MOV      r1,r0
;;;39     {
;;;40     	return *(uint32_t*)(EEPROM_START_ADDR + (addr * 4));
000002  0088              LSLS     r0,r1,#2
000004  4a01              LDR      r2,|L11.12|
000006  1880              ADDS     r0,r0,r2
000008  6800              LDR      r0,[r0,#0]
;;;41     }
00000a  4770              BX       lr
;;;42     
                          ENDP

                  |L11.12|
                          DCD      0x0800b000

                          AREA ||i.verify_data||, CODE, READONLY, ALIGN=1

                  verify_data PROC
;;;162    
;;;163    static int verify_data(eeprom_t* eeprom, size_t addr, const uint8_t* data, size_t len, page_data_t* pdata)
000000  b5fe              PUSH     {r1-r7,lr}
;;;164    {
000002  4607              MOV      r7,r0
000004  460c              MOV      r4,r1
000006  461d              MOV      r5,r3
;;;165    	size_t page_offset;
;;;166    	size_t page_count = 0;
000008  2600              MOVS     r6,#0
;;;167    	
;;;168    	/*计算页内偏移*/
;;;169    	page_offset = addr % eeprom->page_size;
00000a  4638              MOV      r0,r7
00000c  f7fffffe          BL       __aeabi_uread4
000010  4601              MOV      r1,r0
000012  9000              STR      r0,[sp,#0]
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       __aeabi_uidivmod
00001a  9101              STR      r1,[sp,#4]
;;;170    	
;;;171    	if( len > eeprom->page_size - page_offset )
00001c  4638              MOV      r0,r7
00001e  f7fffffe          BL       __aeabi_uread4
000022  9901              LDR      r1,[sp,#4]
000024  1a40              SUBS     r0,r0,r1
000026  42a8              CMP      r0,r5
000028  d300              BCC      |L12.44|
;;;172    	{
;;;173    		/*跨页*/
;;;174    		
;;;175    			//确定每个页的写地址
;;;176    			//确定每个页的长度
;;;177    			//确定每个页的数据指针
;;;178    		
;;;179    		
;;;180    	
;;;181    	}
;;;182    	else
;;;183    	{
;;;184    		/*不需要跨页*/
;;;185    		page_count++;
00002a  1c76              ADDS     r6,r6,#1
                  |L12.44|
;;;186    	}
;;;187    	
;;;188    	return page_count;
00002c  4630              MOV      r0,r6
;;;189    }
00002e  bdfe              POP      {r1-r7,pc}
;;;190    
                          ENDP


                          AREA ||i.write_word||, CODE, READONLY, ALIGN=2

                  write_word PROC
;;;94     
;;;95     static FLASH_Status write_word(uint32_t addr, uint32_t data)
000000  b570              PUSH     {r4-r6,lr}
;;;96     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;97     	FLASH_Status status;
;;;98     	FLASH_Unlock();
000006  f7fffffe          BL       FLASH_Unlock
;;;99     	FLASH_ClearFlag(FLASH_FLAG_EOP | FLASH_FLAG_PGERR | FLASH_FLAG_WRPERR);
00000a  2034              MOVS     r0,#0x34
00000c  f7fffffe          BL       FLASH_ClearFlag
;;;100    	status = FLASH_ProgramWord(EEPROM_START_ADDR+(addr * 4), data);
000010  00a1              LSLS     r1,r4,#2
000012  4a05              LDR      r2,|L13.40|
000014  1888              ADDS     r0,r1,r2
000016  4629              MOV      r1,r5
000018  f7fffffe          BL       FLASH_ProgramWord
00001c  4606              MOV      r6,r0
;;;101    	FLASH_Lock();
00001e  f7fffffe          BL       FLASH_Lock
;;;102    	return status;
000022  4630              MOV      r0,r6
;;;103    }
000024  bd70              POP      {r4-r6,pc}
;;;104    
                          ENDP

000026  0000              DCW      0x0000
                  |L13.40|
                          DCD      0x0800b000

;*** Start embedded assembler ***

#line 1 "..\\user\\virtual_eeprom.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_virtual_eeprom_c_4605a928____REV16|
#line 129 "..\\FTLib\\CMSIS\\inc\\core_cmInstr.h"
|__asm___16_virtual_eeprom_c_4605a928____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_virtual_eeprom_c_4605a928____REVSH|
#line 144
|__asm___16_virtual_eeprom_c_4605a928____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
