; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\flash.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\flash.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\FTLib\CMSIS\inc -I..\FTLib\Inc -I..\FTLib\Lib -I..\usb\inc -I..\user -I..\RTT -IC:\Users\Tom\AppData\Local\Arm\Packs\FMD\FT32F0xx_DFP\1.0.2\Drivers\CMSIS\FT32F0xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=533 -DFT32F072x8 -DFT32F072x8 --omf_browse=.\objects\flash.crf ..\user\flash.c]
                          THUMB

                          AREA ||i.erase_page||, CODE, READONLY, ALIGN=1

                  erase_page PROC
;;;59     
;;;60     void erase_page(uint32_t addr)
000000  b510              PUSH     {r4,lr}
;;;61     {
000002  4604              MOV      r4,r0
;;;62     	FLASH_Unlock();
000004  f7fffffe          BL       FLASH_Unlock
;;;63     	FLASH_ClearFlag(FLASH_FLAG_EOP | FLASH_FLAG_PGERR | FLASH_FLAG_WRPERR);
000008  2034              MOVS     r0,#0x34
00000a  f7fffffe          BL       FLASH_ClearFlag
;;;64     	while(FLASH_ErasePage(addr) != FLASH_COMPLETE);
00000e  bf00              NOP      
                  |L1.16|
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       FLASH_ErasePage
000016  2804              CMP      r0,#4
000018  d1fa              BNE      |L1.16|
;;;65     	FLASH_Lock();
00001a  f7fffffe          BL       FLASH_Lock
;;;66     }
00001e  bd10              POP      {r4,pc}
;;;67     
                          ENDP


                          AREA ||i.read_byte||, CODE, READONLY, ALIGN=2

                  read_byte PROC
;;;14     
;;;15     uint8_t read_byte(uint32_t addr)
000000  b530              PUSH     {r4,r5,lr}
;;;16     {
000002  4601              MOV      r1,r0
;;;17     
;;;18     	uint8_t byte = addr % 4;
000004  078a              LSLS     r2,r1,#30
000006  0f92              LSRS     r2,r2,#30
;;;19     	uint32_t byte4 = addr / 4;
000008  088b              LSRS     r3,r1,#2
;;;20     	
;;;21     	return ( *(uint32_t*)(USER_DATA_ADDR + (byte4 * 4 * 4)) & ( 0xFF << (byte * 8) ) ) >> ( byte * 8 );
00000a  0118              LSLS     r0,r3,#4
00000c  4c05              LDR      r4,|L2.36|
00000e  1900              ADDS     r0,r0,r4
000010  6800              LDR      r0,[r0,#0]
000012  00d5              LSLS     r5,r2,#3
000014  24ff              MOVS     r4,#0xff
000016  40ac              LSLS     r4,r4,r5
000018  4020              ANDS     r0,r0,r4
00001a  00d4              LSLS     r4,r2,#3
00001c  40e0              LSRS     r0,r0,r4
00001e  b2c0              UXTB     r0,r0
;;;22     }
000020  bd30              POP      {r4,r5,pc}
;;;23     
                          ENDP

000022  0000              DCW      0x0000
                  |L2.36|
                          DCD      0x0800b000

                          AREA ||i.read_bytes||, CODE, READONLY, ALIGN=1

                  read_bytes PROC
;;;26     
;;;27     uint8_t read_bytes(uint32_t addr, uint8_t* recv, uint8_t num)
000000  b5f8              PUSH     {r3-r7,lr}
;;;28     {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
;;;29     	uint8_t i;
;;;30     	uint8_t conut = 0;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;31     	
;;;32     	if(recv == NULL || addr + num > USER_DATA_MAX_LEN)
00000c  2e00              CMP      r6,#0
00000e  d004              BEQ      |L3.26|
000010  19e0              ADDS     r0,r4,r7
000012  2105              MOVS     r1,#5
000014  0309              LSLS     r1,r1,#12
000016  4288              CMP      r0,r1
000018  d901              BLS      |L3.30|
                  |L3.26|
;;;33     	{
;;;34     		return 0;
00001a  2000              MOVS     r0,#0
                  |L3.28|
;;;35     	}
;;;36     	
;;;37     	for(i = addr; i < addr + num; ++i)
;;;38     	{
;;;39     		recv[conut++] = read_byte(i);
;;;40     	}
;;;41     	return conut;
;;;42     }
00001c  bdf8              POP      {r3-r7,pc}
                  |L3.30|
00001e  b2e5              UXTB     r5,r4                 ;37
000020  e00a              B        |L3.56|
                  |L3.34|
000022  4628              MOV      r0,r5                 ;39
000024  f7fffffe          BL       read_byte
000028  4601              MOV      r1,r0                 ;39
00002a  9800              LDR      r0,[sp,#0]            ;39
00002c  1c42              ADDS     r2,r0,#1              ;39
00002e  b2d2              UXTB     r2,r2                 ;39
000030  9200              STR      r2,[sp,#0]            ;39
000032  5431              STRB     r1,[r6,r0]            ;39
000034  1c68              ADDS     r0,r5,#1              ;37
000036  b2c5              UXTB     r5,r0                 ;37
                  |L3.56|
000038  19e0              ADDS     r0,r4,r7              ;37
00003a  42a8              CMP      r0,r5                 ;37
00003c  d8f1              BHI      |L3.34|
00003e  9800              LDR      r0,[sp,#0]            ;41
000040  e7ec              B        |L3.28|
;;;43     
                          ENDP


                          AREA ||i.read_word||, CODE, READONLY, ALIGN=2

                  read_word PROC
;;;6      
;;;7      uint32_t read_word(uint32_t addr)
000000  4601              MOV      r1,r0
;;;8      {
;;;9      	return *(uint32_t*)(USER_DATA_ADDR + (addr * 4));
000002  0088              LSLS     r0,r1,#2
000004  4a01              LDR      r2,|L4.12|
000006  1880              ADDS     r0,r0,r2
000008  6800              LDR      r0,[r0,#0]
;;;10     }
00000a  4770              BX       lr
;;;11     
                          ENDP

                  |L4.12|
                          DCD      0x0800b000

                          AREA ||i.write_byte||, CODE, READONLY, ALIGN=1

                  write_byte PROC
;;;71     
;;;72     void write_byte(uint32_t addr, uint8_t data)
000000  b5f8              PUSH     {r3-r7,lr}
;;;73     {
000002  4603              MOV      r3,r0
000004  460f              MOV      r7,r1
;;;74     	uint32_t buff;
;;;75     	uint32_t byte4;
;;;76     	uint8_t byte;
;;;77     	uint8_t* p = (uint8_t*)&buff;
000006  466e              MOV      r6,sp
;;;78     	
;;;79     	byte4 = addr / 4;
000008  089c              LSRS     r4,r3,#2
;;;80     	byte = addr % 4;
00000a  079d              LSLS     r5,r3,#30
00000c  0fad              LSRS     r5,r5,#30
;;;81     	
;;;82     	buff = read_word(byte4);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       read_word
000014  9000              STR      r0,[sp,#0]
;;;83     	//SEGGER_RTT_printf(0, "%d  %d   %08x        ", byte4, byte, buff);		
;;;84     	//buff |= ( data << ( byte * 8 ) );
;;;85     	
;;;86     	//SEGGER_RTT_printf(0, "%08x  ", buff);	
;;;87     	//p[byte] = data;
;;;88     	//SEGGER_RTT_printf(0, "%08x  ", buff);	
;;;89     
;;;90     	
;;;91     	//write_word(byte4, buff);
;;;92     }
000016  bdf8              POP      {r3-r7,pc}
;;;93     
                          ENDP


                          AREA ||i.write_bytes||, CODE, READONLY, ALIGN=1

                  write_bytes PROC
;;;96     
;;;97     uint8_t write_bytes(uint32_t addr, const uint8_t* data, uint8_t num)
000000  4603              MOV      r3,r0
;;;98     {
;;;99     	return 0;
000002  2000              MOVS     r0,#0
;;;100    }	
000004  4770              BX       lr
;;;101    
                          ENDP


                          AREA ||i.write_word||, CODE, READONLY, ALIGN=2

                  write_word PROC
;;;46     
;;;47     FLASH_Status write_word(uint32_t addr, uint32_t data)
000000  b570              PUSH     {r4-r6,lr}
;;;48     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;49     	FLASH_Status status;
;;;50     	FLASH_Unlock();
000006  f7fffffe          BL       FLASH_Unlock
;;;51     	FLASH_ClearFlag(FLASH_FLAG_EOP | FLASH_FLAG_PGERR | FLASH_FLAG_WRPERR);
00000a  2034              MOVS     r0,#0x34
00000c  f7fffffe          BL       FLASH_ClearFlag
;;;52     	status = FLASH_ProgramWord(USER_DATA_ADDR+(addr * 4), data);
000010  00a1              LSLS     r1,r4,#2
000012  4a05              LDR      r2,|L7.40|
000014  1888              ADDS     r0,r1,r2
000016  4629              MOV      r1,r5
000018  f7fffffe          BL       FLASH_ProgramWord
00001c  4606              MOV      r6,r0
;;;53     	FLASH_Lock();
00001e  f7fffffe          BL       FLASH_Lock
;;;54     	return status;
000022  4630              MOV      r0,r6
;;;55     }
000024  bd70              POP      {r4-r6,pc}
;;;56     
                          ENDP

000026  0000              DCW      0x0000
                  |L7.40|
                          DCD      0x0800b000

;*** Start embedded assembler ***

#line 1 "..\\user\\flash.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_flash_c_4605a928____REV16|
#line 129 "..\\FTLib\\CMSIS\\inc\\core_cmInstr.h"
|__asm___7_flash_c_4605a928____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_flash_c_4605a928____REVSH|
#line 144
|__asm___7_flash_c_4605a928____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
