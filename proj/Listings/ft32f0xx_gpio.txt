; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\ft32f0xx_gpio.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\ft32f0xx_gpio.d --cpu=Cortex-M0 --apcs=interwork -O0 --diag_suppress=9931 -I..\FTLib\CMSIS\inc -I..\FTLib\Inc -I..\FTLib\Lib -I..\usb\inc -I..\user -I..\RTT -I..\iap2 -IC:\Users\dell1\AppData\Local\Arm\Packs\FMD\FT32F0xx_DFP\1.0.6\Drivers\CMSIS\FT32F0xx\Include -D__UVISION_VERSION=534 -DFT32F072x8 -DFT32F072x8 --omf_browse=.\objects\ft32f0xx_gpio.crf ..\FTLib\Src\ft32f0xx_gpio.c]
                          THUMB

                          AREA ||i.GPIO_DeInit||, CODE, READONLY, ALIGN=2

                  GPIO_DeInit PROC
;;;25       */
;;;26     void GPIO_DeInit(GPIO_TypeDef* GPIOx)
000000  b510              PUSH     {r4,lr}
;;;27     {
000002  4604              MOV      r4,r0
;;;28       /* Check the parameters */
;;;29       assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;30     
;;;31       if(GPIOx == GPIOA)
000004  2009              MOVS     r0,#9
000006  06c0              LSLS     r0,r0,#27
000008  4284              CMP      r4,r0
00000a  d109              BNE      |L1.32|
;;;32       {
;;;33         RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOA, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  0448              LSLS     r0,r1,#17
000010  f7fffffe          BL       RCC_AHBPeriphResetCmd
;;;34         RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOA, DISABLE);
000014  2100              MOVS     r1,#0
000016  2001              MOVS     r0,#1
000018  0440              LSLS     r0,r0,#17
00001a  f7fffffe          BL       RCC_AHBPeriphResetCmd
00001e  e030              B        |L1.130|
                  |L1.32|
;;;35       }
;;;36       else if(GPIOx == GPIOB)
000020  4818              LDR      r0,|L1.132|
000022  4284              CMP      r4,r0
000024  d108              BNE      |L1.56|
;;;37       {
;;;38         RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOB, ENABLE);
000026  2101              MOVS     r1,#1
000028  0200              LSLS     r0,r0,#8
00002a  f7fffffe          BL       RCC_AHBPeriphResetCmd
;;;39         RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOB, DISABLE);
00002e  2100              MOVS     r1,#0
000030  0220              LSLS     r0,r4,#8
000032  f7fffffe          BL       RCC_AHBPeriphResetCmd
000036  e024              B        |L1.130|
                  |L1.56|
;;;40       }
;;;41       else if(GPIOx == GPIOC)
000038  4813              LDR      r0,|L1.136|
00003a  4284              CMP      r4,r0
00003c  d108              BNE      |L1.80|
;;;42       {
;;;43         RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOC, ENABLE);
00003e  2101              MOVS     r1,#1
000040  0200              LSLS     r0,r0,#8
000042  f7fffffe          BL       RCC_AHBPeriphResetCmd
;;;44         RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOC, DISABLE);
000046  2100              MOVS     r1,#0
000048  0220              LSLS     r0,r4,#8
00004a  f7fffffe          BL       RCC_AHBPeriphResetCmd
00004e  e018              B        |L1.130|
                  |L1.80|
;;;45       }
;;;46       else if(GPIOx == GPIOD)
000050  480e              LDR      r0,|L1.140|
000052  4284              CMP      r4,r0
000054  d109              BNE      |L1.106|
;;;47       {
;;;48         RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOD, ENABLE);
000056  2101              MOVS     r1,#1
000058  0508              LSLS     r0,r1,#20
00005a  f7fffffe          BL       RCC_AHBPeriphResetCmd
;;;49         RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOD, DISABLE);
00005e  2100              MOVS     r1,#0
000060  2001              MOVS     r0,#1
000062  0500              LSLS     r0,r0,#20
000064  f7fffffe          BL       RCC_AHBPeriphResetCmd
000068  e00b              B        |L1.130|
                  |L1.106|
;;;50       }
;;;51     //  else if(GPIOx == GPIOE)
;;;52     //  {
;;;53     //    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOE, ENABLE);
;;;54     //    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOE, DISABLE);
;;;55     //  }
;;;56       else
;;;57       {
;;;58         if(GPIOx == GPIOF)
00006a  4809              LDR      r0,|L1.144|
00006c  4284              CMP      r4,r0
00006e  d108              BNE      |L1.130|
;;;59         {
;;;60           RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOF, ENABLE);
000070  2101              MOVS     r1,#1
000072  0588              LSLS     r0,r1,#22
000074  f7fffffe          BL       RCC_AHBPeriphResetCmd
;;;61           RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOF, DISABLE);
000078  2100              MOVS     r1,#0
00007a  2001              MOVS     r0,#1
00007c  0580              LSLS     r0,r0,#22
00007e  f7fffffe          BL       RCC_AHBPeriphResetCmd
                  |L1.130|
;;;62         }
;;;63       }
;;;64     }
000082  bd10              POP      {r4,pc}
;;;65     
                          ENDP

                  |L1.132|
                          DCD      0x48000400
                  |L1.136|
                          DCD      0x48000800
                  |L1.140|
                          DCD      0x48000c00
                  |L1.144|
                          DCD      0x48001400

                          AREA ||i.GPIO_Init||, CODE, READONLY, ALIGN=1

                  GPIO_Init PROC
;;;73       */
;;;74     void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
000000  b5f0              PUSH     {r4-r7,lr}
;;;75     {
000002  460a              MOV      r2,r1
;;;76       uint32_t pinpos = 0x00, pos = 0x00 , currentpin = 0x00;
000004  2100              MOVS     r1,#0
000006  2300              MOVS     r3,#0
000008  2400              MOVS     r4,#0
;;;77     
;;;78       /* Check the parameters */
;;;79       assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;80       assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));
;;;81       assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
;;;82       assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));
;;;83     
;;;84       /*-------------------------- Configure the port pins -----------------------*/
;;;85       /*-- GPIO Mode Configuration --*/
;;;86       for (pinpos = 0x00; pinpos < 0x10; pinpos++)
00000a  bf00              NOP      
00000c  e03d              B        |L2.138|
                  |L2.14|
;;;87       {
;;;88         pos = ((uint32_t)0x01) << pinpos;
00000e  2501              MOVS     r5,#1
000010  408d              LSLS     r5,r5,r1
000012  462b              MOV      r3,r5
;;;89     
;;;90         /* Get the port pins position */
;;;91         currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
000014  6815              LDR      r5,[r2,#0]
000016  401d              ANDS     r5,r5,r3
000018  462c              MOV      r4,r5
;;;92     
;;;93         if (currentpin == pos)
00001a  429c              CMP      r4,r3
00001c  d134              BNE      |L2.136|
;;;94         {
;;;95           if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
00001e  7915              LDRB     r5,[r2,#4]
000020  2d01              CMP      r5,#1
000022  d002              BEQ      |L2.42|
000024  7915              LDRB     r5,[r2,#4]
000026  2d02              CMP      r5,#2
000028  d116              BNE      |L2.88|
                  |L2.42|
;;;96           {
;;;97             /* Check Speed mode parameters */
;;;98             assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
;;;99     
;;;100            /* Speed mode configuration */
;;;101            GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
00002a  6885              LDR      r5,[r0,#8]
00002c  004f              LSLS     r7,r1,#1
00002e  2603              MOVS     r6,#3
000030  40be              LSLS     r6,r6,r7
000032  43b5              BICS     r5,r5,r6
000034  6085              STR      r5,[r0,#8]
;;;102            GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
000036  7955              LDRB     r5,[r2,#5]
000038  004e              LSLS     r6,r1,#1
00003a  40b5              LSLS     r5,r5,r6
00003c  6886              LDR      r6,[r0,#8]
00003e  4335              ORRS     r5,r5,r6
000040  6085              STR      r5,[r0,#8]
;;;103    
;;;104            /* Check Output mode parameters */
;;;105            assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));
;;;106    
;;;107            /* Output mode configuration */
;;;108            GPIOx->OTYPER &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos));
000042  8885              LDRH     r5,[r0,#4]
000044  2601              MOVS     r6,#1
000046  408e              LSLS     r6,r6,r1
000048  43b5              BICS     r5,r5,r6
00004a  8085              STRH     r5,[r0,#4]
;;;109            GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
00004c  8885              LDRH     r5,[r0,#4]
00004e  7996              LDRB     r6,[r2,#6]
000050  408e              LSLS     r6,r6,r1
000052  b2b6              UXTH     r6,r6
000054  4335              ORRS     r5,r5,r6
000056  8085              STRH     r5,[r0,#4]
                  |L2.88|
;;;110          }
;;;111    
;;;112          GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
000058  6805              LDR      r5,[r0,#0]
00005a  004f              LSLS     r7,r1,#1
00005c  2603              MOVS     r6,#3
00005e  40be              LSLS     r6,r6,r7
000060  43b5              BICS     r5,r5,r6
000062  6005              STR      r5,[r0,#0]
;;;113    
;;;114          GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
000064  7915              LDRB     r5,[r2,#4]
000066  004e              LSLS     r6,r1,#1
000068  40b5              LSLS     r5,r5,r6
00006a  6806              LDR      r6,[r0,#0]
00006c  4335              ORRS     r5,r5,r6
00006e  6005              STR      r5,[r0,#0]
;;;115    
;;;116          /* Pull-up Pull down resistor configuration */
;;;117          GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
000070  68c5              LDR      r5,[r0,#0xc]
000072  004f              LSLS     r7,r1,#1
000074  2603              MOVS     r6,#3
000076  40be              LSLS     r6,r6,r7
000078  43b5              BICS     r5,r5,r6
00007a  60c5              STR      r5,[r0,#0xc]
;;;118          GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
00007c  79d5              LDRB     r5,[r2,#7]
00007e  004e              LSLS     r6,r1,#1
000080  40b5              LSLS     r5,r5,r6
000082  68c6              LDR      r6,[r0,#0xc]
000084  4335              ORRS     r5,r5,r6
000086  60c5              STR      r5,[r0,#0xc]
                  |L2.136|
000088  1c49              ADDS     r1,r1,#1              ;86
                  |L2.138|
00008a  2910              CMP      r1,#0x10              ;86
00008c  d3bf              BCC      |L2.14|
;;;119        }
;;;120      }
;;;121    }
00008e  bdf0              POP      {r4-r7,pc}
;;;122    
                          ENDP


                          AREA ||i.GPIO_LedmConfig||, CODE, READONLY, ALIGN=1

                  GPIO_LedmConfig PROC
;;;398    	*/
;;;399    void GPIO_LedmConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_LEDMx)
000000  6b02              LDR      r2,[r0,#0x30]
;;;400    {
;;;401      /* Check the parameters */
;;;402      assert_param(IS_GPIO_LIST_PERIPH(GPIOx));
;;;403    	assert_param(IS_GPIO_LEDM(GPIO_LEDMx));
;;;404    	
;;;405    	GPIOx->LEDM |= (uint16_t)GPIO_LEDMx;
000002  430a              ORRS     r2,r2,r1
000004  6302              STR      r2,[r0,#0x30]
;;;406    }
000006  4770              BX       lr
;;;407    /**
                          ENDP


                          AREA ||i.GPIO_PinAFConfig||, CODE, READONLY, ALIGN=1

                  GPIO_PinAFConfig PROC
;;;365      */
;;;366    void GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF)
000000  b5f0              PUSH     {r4-r7,lr}
;;;367    {
;;;368      uint32_t temp = 0x00;
000002  2300              MOVS     r3,#0
;;;369      uint32_t temp_2 = 0x00;
000004  2400              MOVS     r4,#0
;;;370    
;;;371      /* Check the parameters */
;;;372      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;373      assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
;;;374      assert_param(IS_GPIO_AF(GPIO_AF));
;;;375    
;;;376      temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4));
000006  074d              LSLS     r5,r1,#29
000008  0eee              LSRS     r6,r5,#27
00000a  4615              MOV      r5,r2
00000c  40b5              LSLS     r5,r5,r6
00000e  462b              MOV      r3,r5
;;;377      GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4));
000010  10cd              ASRS     r5,r1,#3
000012  00ae              LSLS     r6,r5,#2
000014  4605              MOV      r5,r0
000016  3520              ADDS     r5,r5,#0x20
000018  59ad              LDR      r5,[r5,r6]
00001a  074e              LSLS     r6,r1,#29
00001c  0ef7              LSRS     r7,r6,#27
00001e  260f              MOVS     r6,#0xf
000020  40be              LSLS     r6,r6,r7
000022  43b5              BICS     r5,r5,r6
000024  10ce              ASRS     r6,r1,#3
000026  00b6              LSLS     r6,r6,#2
000028  4607              MOV      r7,r0
00002a  3720              ADDS     r7,r7,#0x20
00002c  51bd              STR      r5,[r7,r6]
;;;378      temp_2 = GPIOx->AFR[GPIO_PinSource >> 0x03] | temp;
00002e  10cd              ASRS     r5,r1,#3
000030  00ae              LSLS     r6,r5,#2
000032  463d              MOV      r5,r7
000034  59ad              LDR      r5,[r5,r6]
000036  431d              ORRS     r5,r5,r3
000038  462c              MOV      r4,r5
;;;379      GPIOx->AFR[GPIO_PinSource >> 0x03] = temp_2;
00003a  10cd              ASRS     r5,r1,#3
00003c  00ad              LSLS     r5,r5,#2
00003e  463e              MOV      r6,r7
000040  5174              STR      r4,[r6,r5]
;;;380    }
000042  bdf0              POP      {r4-r7,pc}
;;;381    
                          ENDP


                          AREA ||i.GPIO_PinLockConfig||, CODE, READONLY, ALIGN=1

                  GPIO_PinLockConfig PROC
;;;149      */
;;;150    void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  b508              PUSH     {r3,lr}
;;;151    {
;;;152      __IO uint32_t tmp = 0x00010000;
000002  2201              MOVS     r2,#1
000004  0412              LSLS     r2,r2,#16
000006  9200              STR      r2,[sp,#0]
;;;153    
;;;154      /* Check the parameters */
;;;155      assert_param(IS_GPIO_LIST_PERIPH(GPIOx));
;;;156      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;157    
;;;158      tmp |= GPIO_Pin;
000008  9a00              LDR      r2,[sp,#0]
00000a  430a              ORRS     r2,r2,r1
00000c  9200              STR      r2,[sp,#0]
;;;159      /* Set LCKK bit */
;;;160      GPIOx->LCKR = tmp;
00000e  9a00              LDR      r2,[sp,#0]
000010  61c2              STR      r2,[r0,#0x1c]
;;;161      /* Reset LCKK bit */
;;;162      GPIOx->LCKR =  GPIO_Pin;
000012  61c1              STR      r1,[r0,#0x1c]
;;;163      /* Set LCKK bit */
;;;164      GPIOx->LCKR = tmp;
000014  9a00              LDR      r2,[sp,#0]
000016  61c2              STR      r2,[r0,#0x1c]
;;;165      /* Read LCKK bit */
;;;166      tmp = GPIOx->LCKR;
000018  69c2              LDR      r2,[r0,#0x1c]
00001a  9200              STR      r2,[sp,#0]
;;;167      /* Read LCKK bit */
;;;168      tmp = GPIOx->LCKR;
00001c  69c2              LDR      r2,[r0,#0x1c]
00001e  9200              STR      r2,[sp,#0]
;;;169    }
000020  bd08              POP      {r3,pc}
;;;170    
                          ENDP


                          AREA ||i.GPIO_ReadInputData||, CODE, READONLY, ALIGN=1

                  GPIO_ReadInputData PROC
;;;207      */
;;;208    uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
000000  4601              MOV      r1,r0
;;;209    {
;;;210      /* Check the parameters */
;;;211      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;212    
;;;213      return ((uint16_t)GPIOx->IDR);
000002  8a08              LDRH     r0,[r1,#0x10]
;;;214    }
000004  4770              BX       lr
;;;215    
                          ENDP


                          AREA ||i.GPIO_ReadInputDataBit||, CODE, READONLY, ALIGN=1

                  GPIO_ReadInputDataBit PROC
;;;183      */
;;;184    uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  4602              MOV      r2,r0
;;;185    {
;;;186      uint8_t bitstatus = 0x00;
000002  2000              MOVS     r0,#0
;;;187    
;;;188      /* Check the parameters */
;;;189      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;190      assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
;;;191    
;;;192      if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)Bit_RESET)
000004  8a13              LDRH     r3,[r2,#0x10]
000006  400b              ANDS     r3,r3,r1
000008  2b00              CMP      r3,#0
00000a  d001              BEQ      |L7.16|
;;;193      {
;;;194        bitstatus = (uint8_t)Bit_SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L7.18|
                  |L7.16|
;;;195      }
;;;196      else
;;;197      {
;;;198        bitstatus = (uint8_t)Bit_RESET;
000010  2000              MOVS     r0,#0
                  |L7.18|
;;;199      }
;;;200      return bitstatus;
;;;201    }
000012  4770              BX       lr
;;;202    
                          ENDP


                          AREA ||i.GPIO_ReadOutputData||, CODE, READONLY, ALIGN=1

                  GPIO_ReadOutputData PROC
;;;247      */
;;;248    uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
000000  4601              MOV      r1,r0
;;;249    {
;;;250      /* Check the parameters */
;;;251      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;252    
;;;253      return ((uint16_t)GPIOx->ODR);
000002  8a88              LDRH     r0,[r1,#0x14]
;;;254    }
000004  4770              BX       lr
;;;255    
                          ENDP


                          AREA ||i.GPIO_ReadOutputDataBit||, CODE, READONLY, ALIGN=1

                  GPIO_ReadOutputDataBit PROC
;;;223      */
;;;224    uint8_t GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  4602              MOV      r2,r0
;;;225    {
;;;226      uint8_t bitstatus = 0x00;
000002  2000              MOVS     r0,#0
;;;227    
;;;228      /* Check the parameters */
;;;229      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;230      assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
;;;231    
;;;232      if ((GPIOx->ODR & GPIO_Pin) != (uint32_t)Bit_RESET)
000004  8a93              LDRH     r3,[r2,#0x14]
000006  400b              ANDS     r3,r3,r1
000008  2b00              CMP      r3,#0
00000a  d001              BEQ      |L9.16|
;;;233      {
;;;234        bitstatus = (uint8_t)Bit_SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L9.18|
                  |L9.16|
;;;235      }
;;;236      else
;;;237      {
;;;238        bitstatus = (uint8_t)Bit_RESET;
000010  2000              MOVS     r0,#0
                  |L9.18|
;;;239      }
;;;240      return bitstatus;
;;;241    }
000012  4770              BX       lr
;;;242    
                          ENDP


                          AREA ||i.GPIO_ResetBits||, CODE, READONLY, ALIGN=1

                  GPIO_ResetBits PROC
;;;280      */
;;;281    void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  8501              STRH     r1,[r0,#0x28]
;;;282    {
;;;283      /* Check the parameters */
;;;284      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;285      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;286    
;;;287      GPIOx->BRR = GPIO_Pin;
;;;288    }
000002  4770              BX       lr
;;;289    
                          ENDP


                          AREA ||i.GPIO_SetBits||, CODE, READONLY, ALIGN=1

                  GPIO_SetBits PROC
;;;263      */
;;;264    void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  6181              STR      r1,[r0,#0x18]
;;;265    {
;;;266      /* Check the parameters */
;;;267      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;268      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;269    
;;;270      GPIOx->BSRR = GPIO_Pin;
;;;271    }
000002  4770              BX       lr
;;;272    
                          ENDP


                          AREA ||i.GPIO_StructInit||, CODE, READONLY, ALIGN=2

                  GPIO_StructInit PROC
;;;128      */
;;;129    void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
000000  4904              LDR      r1,|L12.20|
;;;130    {
;;;131      /* Reset GPIO init structure parameters values */
;;;132      GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
000002  6001              STR      r1,[r0,#0]
;;;133      GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN;
000004  2100              MOVS     r1,#0
000006  7101              STRB     r1,[r0,#4]
;;;134      GPIO_InitStruct->GPIO_Speed = GPIO_Speed_Level_2;
000008  2101              MOVS     r1,#1
00000a  7141              STRB     r1,[r0,#5]
;;;135      GPIO_InitStruct->GPIO_OType = GPIO_OType_PP;
00000c  2100              MOVS     r1,#0
00000e  7181              STRB     r1,[r0,#6]
;;;136      GPIO_InitStruct->GPIO_PuPd = GPIO_PuPd_NOPULL;
000010  71c1              STRB     r1,[r0,#7]
;;;137    }
000012  4770              BX       lr
;;;138    
                          ENDP

                  |L12.20|
                          DCD      0x0000ffff

                          AREA ||i.GPIO_Write||, CODE, READONLY, ALIGN=1

                  GPIO_Write PROC
;;;324      */
;;;325    void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal)
000000  8281              STRH     r1,[r0,#0x14]
;;;326    {
;;;327      /* Check the parameters */
;;;328      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;329    
;;;330      GPIOx->ODR = PortVal;
;;;331    }
000002  4770              BX       lr
;;;332    
                          ENDP


                          AREA ||i.GPIO_WriteBit||, CODE, READONLY, ALIGN=1

                  GPIO_WriteBit PROC
;;;301      */
;;;302    void GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal)
000000  2a00              CMP      r2,#0
;;;303    {
;;;304      /* Check the parameters */
;;;305      assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;306      assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
;;;307      assert_param(IS_GPIO_BIT_ACTION(BitVal));
;;;308    
;;;309      if (BitVal != Bit_RESET)
000002  d001              BEQ      |L14.8|
;;;310      {
;;;311        GPIOx->BSRR = GPIO_Pin;
000004  6181              STR      r1,[r0,#0x18]
000006  e000              B        |L14.10|
                  |L14.8|
;;;312      }
;;;313      else
;;;314      {
;;;315        GPIOx->BRR = GPIO_Pin ;
000008  8501              STRH     r1,[r0,#0x28]
                  |L14.10|
;;;316      }
;;;317    }
00000a  4770              BX       lr
;;;318    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\FTLib\\Src\\ft32f0xx_gpio.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_ft32f0xx_gpio_c_f8e8e39a____REV16|
#line 129 "..\\FTLib\\CMSIS\\inc\\core_cmInstr.h"
|__asm___15_ft32f0xx_gpio_c_f8e8e39a____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_ft32f0xx_gpio_c_f8e8e39a____REVSH|
#line 144
|__asm___15_ft32f0xx_gpio_c_f8e8e39a____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
